#!/usr/bin/env bash

# === FORCE USE OF SPECIFIC VENV ===
if [[ -z "$VIRTUAL_ENV" ]] && [[ -d "$HOME/.venv" ]]; then
    echo "[INFO] Activating virtual environment:  $HOME/.venv"
    source "$HOME/.venv/bin/activate"
    export VIRTUAL_ENV="$HOME/.venv"
    export PATH="$VIRTUAL_ENV/bin:$PATH"
fi

# Force C locale for consistent regex behavior
    export LC_ALL=C
    export LC_CTYPE=C
    export LANG=C

# Auto-detect and re-execute with Homebrew bash if needed
if ((BASH_VERSINFO[0] < 4)); then
    # Try to find Homebrew bash
    if [[ -x /opt/homebrew/bin/bash ]]; then
        exec /opt/homebrew/bin/bash "$0" "$@"
    elif [[ -x /usr/local/bin/bash ]]; then
        exec /usr/local/bin/bash "$0" "$@"
    else
        echo "═══════════════════════════════════════════════════════════════"
        echo "ERROR: This script requires Bash 4.0 or higher."
        echo "Your current version: $BASH_VERSION"
        echo ""
        echo "On macOS, install newer bash with Homebrew:"
        echo "  brew install bash"
        echo ""
        echo "Then run this script normally:"
        echo "  bash $0 $@"
        echo "═══════════════════════════════════════════════════════════════"
        exit 1
    fi
fi

# Debug mode - enable with QR_DEBUG=1 or --debug flag
if [[ "${QR_DEBUG:-}" == "1" ]] || [[ " $* " == *" --debug "* ]]; then
    set -x
    echo "[DEBUG] Debug mode enabled"
fi

# AUDIT: Enable pipefail for better error detection
# Note: set -u (nounset) is enabled AFTER global variable declarations
# to avoid issues with associative array parsing
set -o pipefail
shopt -s nullglob extglob nocasematch

# AUDIT: Secure PATH to prevent PATH hijacking attacks
if [[ -n "$VIRTUAL_ENV" ]]; then
    export PATH="$VIRTUAL_ENV/bin:/opt/homebrew/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin"
else
    export PATH="/opt/homebrew/bin:/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin"
fi

# Set locale for proper Unicode display (if available)
if locale -a 2>/dev/null | grep -qi "en_US.UTF-8\|en_US.utf8"; then
    export LANG="en_US.UTF-8"
    export LC_ALL="en_US.UTF-8"
elif locale -a 2>/dev/null | grep -qi "C.UTF-8"; then
    export LANG="C.UTF-8"
    export LC_ALL="C.UTF-8"
fi

################################################################################
# AUDIT: SELF-INTEGRITY VERIFICATION
################################################################################

SCRIPT_HASH=""
calculate_script_hash() {
    local script_path="${BASH_SOURCE[0]}"
    if command -v sha256sum &>/dev/null; then
        SCRIPT_HASH=$(sha256sum "$script_path" 2>/dev/null | cut -d' ' -f1)
    elif command -v shasum &>/dev/null; then
        SCRIPT_HASH=$(shasum -a 256 "$script_path" 2>/dev/null | cut -d' ' -f1)
    else
        SCRIPT_HASH="HASH_UNAVAILABLE"
    fi
}
calculate_script_hash

################################################################################
# AUDIT: SECURE CLEANUP AND TRAP HANDLERS
################################################################################

# Track resources for cleanup
declare -a TEMP_FILES_TO_CLEAN=()
declare -a CHILD_PIDS_TO_CLEAN=()
CLEANUP_DONE=false

# Register temp file for cleanup
register_temp_file() {
    TEMP_FILES_TO_CLEAN+=("$1")
}

# Secure cleanup function
cleanup_handler() {
    if [[ "$CLEANUP_DONE" == "true" ]]; then
        return
    fi
    CLEANUP_DONE=true
    
    local exit_code="${1:-0}"
    
    # Kill child processes
    for pid in "${CHILD_PIDS_TO_CLEAN[@]:-}"; do
        [[ -n "$pid" ]] && kill -0 "$pid" 2>/dev/null && kill -TERM "$pid" 2>/dev/null || true
    done
    
    # Remove registered temp files (secure delete if available)
    for file in "${TEMP_FILES_TO_CLEAN[@]:-}"; do
        if [[ -n "$file" ]] && [[ -f "$file" ]]; then
            if command -v shred &>/dev/null; then
                shred -u "$file" 2>/dev/null || rm -f "$file" 2>/dev/null || true
            else
                rm -f "$file" 2>/dev/null || true
            fi
        fi
    done
    
    # Note: We keep OUTPUT_DIR for forensic evidence - only clean TEMP_DIR internals
    if [[ -n "${TEMP_DIR:-}" ]] && [[ -d "${TEMP_DIR:-}" ]]; then
        # Clean sensitive temp files but keep structure
        find "$TEMP_DIR" -type f -name "*.tmp" -delete 2>/dev/null || true
        find "$TEMP_DIR" -type f -name "*.key" -delete 2>/dev/null || true
    fi
}

# Set up trap handlers
trap 'cleanup_handler $?' EXIT
trap 'echo "[WARNING] Received SIGINT - cleaning up..."; cleanup_handler 130' INT
trap 'echo "[WARNING] Received SIGTERM - cleaning up..."; cleanup_handler 143' TERM

################################################################################
# AUDIT: INPUT VALIDATION AND SANITIZATION FUNCTIONS
################################################################################

# Validate and sanitize file paths (prevent path traversal)
sanitize_path() {
    local input_path="$1"
    local sanitized
    
    # Remove null bytes
    sanitized="${input_path//$'\x00'/}"
    
    # Check for path traversal attempts
    if [[ "$sanitized" == *".."* ]]; then
        echo "[ERROR] Path traversal detected" >&2
        return 1
    fi
    
    # Resolve to absolute path if possible
    if command -v realpath &>/dev/null; then
        sanitized=$(realpath -m "$sanitized" 2>/dev/null) || sanitized="$input_path"
    fi
    
    echo "$sanitized"
}

# Validate string input (length and character restrictions)
validate_string_input() {
    local input="$1"
    local max_length="${2:-8192}"
    
    # Check length
    if [[ ${#input} -gt $max_length ]]; then
        echo "[ERROR] Input exceeds maximum length of $max_length" >&2
        return 1
    fi
    
    # Check for null bytes
    if [[ "$input" == *$'\x00'* ]]; then
        echo "[ERROR] Input contains null bytes" >&2
        return 1
    fi
    
    return 0
}

# Sanitize content for safe shell use (prevent command injection)
sanitize_for_shell() {
    local input="$1"
    printf '%q' "$input"
}

# AUDIT: Sanitize for logging (mask sensitive data/PII)
sanitize_for_log() {
    local input="$1"
    local sanitized="$input"
    
    # Mask API keys
    sanitized=$(echo "$sanitized" | sed -E 's/([Aa]pi[_-]?[Kk]ey[=:]["'"'"']?)[A-Za-z0-9_-]{16,}/\1[REDACTED]/g')
    
    # Mask passwords
    sanitized=$(echo "$sanitized" | sed -E 's/([Pp]ass(word)?[=:]["'"'"']?)[^[:space:]"'"'"']{4,}/\1[REDACTED]/g')
    
    # Mask bearer/auth tokens
    sanitized=$(echo "$sanitized" | sed -E 's/([Bb]earer[[:space:]]+)[A-Za-z0-9._-]{20,}/\1[REDACTED]/g')
    sanitized=$(echo "$sanitized" | sed -E 's/([Aa]uthorization:[[:space:]]*)[A-Za-z0-9._-]{20,}/\1[REDACTED]/g')
    
    # Mask credit card numbers (13-19 digits)
    sanitized=$(echo "$sanitized" | sed -E 's/[0-9]{13,19}/[CARD_REDACTED]/g')
    
    # Mask SSN patterns
    sanitized=$(echo "$sanitized" | sed -E 's/[0-9]{3}-[0-9]{2}-[0-9]{4}/[SSN_REDACTED]/g')
    
    # Mask email addresses in sensitive contexts
    sanitized=$(echo "$sanitized" | sed -E 's/([Ee]mail[=:]["'"'"']?)[^[:space:]"'"'"']+@[^[:space:]"'"'"']+/\1[EMAIL_REDACTED]/g')
    
    echo "$sanitized"
}

# Validate URL format
validate_url() {
    local url="$1"
    
    # Basic URL validation
    if [[ ! "$url" =~ ^https?://[^[:space:]]+$ ]]; then
        return 1
    fi
    
    # Check for command injection attempts
    if [[ "$url" == *'`'* ]] || [[ "$url" == *'$('* ]] || [[ "$url" == *';'* ]] || [[ "$url" == *'|'* ]]; then
        echo "[ERROR] Suspicious characters in URL" >&2
        return 1
    fi
    
    return 0
}

# Validate IP address format
validate_ip() {
    local ip="$1"
    
    # IPv4 validation
    if [[ "$ip" =~ ^([0-9]{1,3}\.){3}[0-9]{1,3}$ ]]; then
        local IFS='.'
        read -ra octets <<< "$ip"
        for octet in "${octets[@]}"; do
            if [[ $octet -gt 255 ]]; then
                return 1
            fi
        done
        return 0
    fi
    
    # IPv6 validation (simplified)
    if [[ "$ip" =~ ^([0-9a-fA-F]{0,4}:){2,7}[0-9a-fA-F]{0,4}$ ]]; then
        return 0
    fi
    
    return 1
}

################################################################################
# VALIDATION FUNCTIONS - EXTENDED
################################################################################

# Validate Bitcoin address with checksum
validate_bitcoin_address() {
    local address="$1"
    
    # Bitcoin address patterns (P2PKH, P2SH, Bech32)
    # P2PKH: starts with 1, 26-35 chars
    if [[ "$address" =~ ^1[a-km-zA-HJ-NP-Z1-9]{25,34}$ ]]; then
        return 0
    fi
    
    # P2SH: starts with 3, 26-35 chars
    if [[ "$address" =~ ^3[a-km-zA-HJ-NP-Z1-9]{25,34}$ ]]; then
        return 0
    fi
    
    # Bech32 (SegWit): starts with bc1
    if [[ "$address" =~ ^bc1[a-z0-9]{39,59}$ ]]; then
        return 0
    fi
    
    return 1
}

# Validate Ethereum address with EIP-55 checksum
validate_ethereum_address() {
    local address="$1"
    
    # Ethereum address: 0x followed by 40 hex chars
    if [[ "$address" =~ ^0x[a-fA-F0-9]{40}$ ]]; then
        return 0
    fi
    
    return 1
}

# Validate E.164 phone number format
validate_phone_e164() {
    local phone="$1"
    
    # E.164 format: + followed by 1-15 digits
    if [[ "$phone" =~ ^\+[1-9][0-9]{1,14}$ ]]; then
        return 0
    fi
    
    return 1
}

# Validate IBAN with checksum
validate_iban() {
    local iban="$1"
    
    # Remove spaces and convert to uppercase
    iban=$(echo "$iban" | tr -d ' ' | tr '[:lower:]' '[:upper:]')
    
    # IBAN format: 2 letter country code, 2 check digits, up to 30 alphanumeric
    if [[ "$iban" =~ ^[A-Z]{2}[0-9]{2}[A-Z0-9]{1,30}$ ]]; then
        # Basic format validation passed
        # Full checksum validation would require mod-97 calculation
        return 0
    fi
    
    return 1
}

# Validate credit card using Luhn algorithm
validate_credit_card() {
    local card="$1"
    
    # Remove spaces and dashes
    card=$(echo "$card" | tr -d ' -')
    
    # Check if it's all digits and 13-19 chars (standard card lengths)
    if [[ ! "$card" =~ ^[0-9]{13,19}$ ]]; then
        return 1
    fi
    
    # Luhn algorithm
    local sum=0
    local parity=$((${#card} % 2))
    local i=0
    
    while [ $i -lt ${#card} ]; do
        local digit=${card:$i:1}
        
        if [ $((i % 2)) -eq $parity ]; then
            digit=$((digit * 2))
            if [ $digit -gt 9 ]; then
                digit=$((digit - 9))
            fi
        fi
        
        sum=$((sum + digit))
        ((i++))
    done
    
    if [ $((sum % 10)) -eq 0 ]; then
        return 0
    fi
    
    return 1
}

# Validate SSN format (PII detection)
validate_ssn_format() {
    local ssn="$1"
    
    # SSN format: XXX-XX-XXXX or XXXXXXXXX
    if [[ "$ssn" =~ ^[0-9]{3}-?[0-9]{2}-?[0-9]{4}$ ]]; then
        # Additional checks: no all zeros, no 666 or 900-999 in first group
        local first_group=$(echo "$ssn" | sed 's/-//g' | cut -c1-3)
        
        if [ "$first_group" = "000" ] || [ "$first_group" = "666" ]; then
            return 1
        fi
        
        if [ "$first_group" -ge 900 ] 2>/dev/null; then
            return 1
        fi
        
        return 0
    fi
    
    return 1
}

# Enhanced IPv6 address validation
validate_ipv6_address() {
    local ipv6="$1"
    
    # Full IPv6 format with 8 groups
    if [[ "$ipv6" =~ ^([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}$ ]]; then
        return 0
    fi
    
    # Compressed IPv6 with ::
    if [[ "$ipv6" =~ ^(([0-9a-fA-F]{1,4}:)*)?::([0-9a-fA-F]{1,4}:)*([0-9a-fA-F]{1,4})?$ ]]; then
        return 0
    fi
    
    # IPv6 with trailing IPv4
    if [[ "$ipv6" =~ ^(([0-9a-fA-F]{1,4}:)*)?::([0-9a-fA-F]{1,4}:)*([0-9]{1,3}\.){3}[0-9]{1,3}$ ]]; then
        return 0
    fi
    
    return 1
}

# Validate Tor v3 onion address
validate_onion_v3() {
    local address="$1"
    
    # Tor v3 onion: 56 base32 chars + .onion
    if [[ "$address" =~ ^[a-z2-7]{56}\.onion$ ]]; then
        return 0
    fi
    
    # Also accept without .onion suffix
    if [[ "$address" =~ ^[a-z2-7]{56}$ ]]; then
        return 0
    fi
    
    return 1
}

# Validate I2P address
validate_i2p_address() {
    local address="$1"
    
    # I2P address: base32 encoded (52 chars) + .i2p or base64 (516+ chars) + .b32.i2p
    if [[ "$address" =~ ^[a-z2-7]{52}\.i2p$ ]]; then
        return 0
    fi
    
    if [[ "$address" =~ ^[A-Za-z0-9+/=]{516,}\.b32\.i2p$ ]]; then
        return 0
    fi
    
    return 1
}

# Validate magnet URI
validate_magnet_uri() {
    local uri="$1"
    
    # Magnet link: magnet:?xt=urn:btih: followed by 40 (SHA-1) or 64 (SHA-256) hex chars
    if [[ "$uri" =~ ^magnet:\?xt=urn:btih:[a-fA-F0-9]{40} ]] || \
       [[ "$uri" =~ ^magnet:\?xt=urn:btih:[a-fA-F0-9]{64} ]]; then
        return 0
    fi
    
    return 1
}

# Validate Decentralized Identifier (DID)
validate_did_identifier() {
    local did="$1"
    
    # DID format: did:method:identifier
    # Examples: did:example:123456, did:ethr:0x..., did:key:z...
    if [[ "$did" =~ ^did:[a-z0-9]+:[a-zA-Z0-9._:-]+$ ]]; then
        return 0
    fi
    
    return 1
}

################################################################################
# AUDIT: SECURE TEMPORARY FILE HANDLING
################################################################################

# Create secure temporary file using mktemp
create_secure_temp_file() {
    local prefix="${1:-qr_scan}"
    local temp_file
    
    if [[ -n "${TEMP_DIR:-}" ]] && [[ -d "${TEMP_DIR:-}" ]]; then
        temp_file=$(mktemp "${TEMP_DIR}/${prefix}.XXXXXXXXXX" 2>/dev/null) || {
            temp_file=$(mktemp "/tmp/${prefix}.XXXXXXXXXX" 2>/dev/null) || return 1
        }
    else
        temp_file=$(mktemp "/tmp/${prefix}.XXXXXXXXXX" 2>/dev/null) || return 1
    fi
    
    # Set restrictive permissions
    chmod 600 "$temp_file" 2>/dev/null || true
    
    # Register for cleanup
    register_temp_file "$temp_file"
    
    echo "$temp_file"
}

# Create secure temporary directory
create_secure_temp_dir() {
    local prefix="${1:-qr_dir}"
    local temp_dir
    
    if [[ -n "${TEMP_DIR:-}" ]] && [[ -d "${TEMP_DIR:-}" ]]; then
        temp_dir=$(mktemp -d "${TEMP_DIR}/${prefix}.XXXXXXXXXX" 2>/dev/null) || {
            temp_dir=$(mktemp -d "/tmp/${prefix}.XXXXXXXXXX" 2>/dev/null) || return 1
        }
    else
        temp_dir=$(mktemp -d "/tmp/${prefix}.XXXXXXXXXX" 2>/dev/null) || return 1
    fi
    
    chmod 700 "$temp_dir" 2>/dev/null || true
    echo "$temp_dir"
}

# AUDIT: Validate that output file path is safe for decoder functions
# Allows paths in known temp directories (like /tmp/qr_analysis)
validate_decoder_output_path() {
    local output_file="$1"
    local func_name="${2:-decoder}"
    
    # Check for empty path
    if [ -z "$output_file" ]; then
        echo "[$func_name] Empty output file path" >&2
        return 1
    fi
    
    # Check for spaces in path
    if [[ "$output_file" =~ [[:space:]] ]]; then
        echo "[$func_name] Output file path has spaces: '$output_file'" >&2
        return 1
    fi
    
    # Check for path traversal
    if [[ "$output_file" == *".."* ]]; then
        echo "[$func_name] Path traversal detected in output path" >&2
        return 1
    fi
    
    # Allow paths in safe temp directories
    local safe_prefixes=(
        "/tmp/qr_analysis/"
        "${TEMP_DIR}/"
        "${OUTPUT_DIR}/"
        "/var/tmp/qr_"
    )
    
    for prefix in "${safe_prefixes[@]}"; do
        # Skip empty prefixes
        [[ -z "$prefix" ]] && continue
        if [[ "$output_file" == "${prefix}"* ]]; then
            return 0  # Safe path
        fi
    done
    
    # For relative paths, allow them (they'll be in current directory)
    if [[ "$output_file" != /* ]]; then
        return 0
    fi
    
    # Reject other absolute paths
    echo "[$func_name] Unsafe output file path: '$output_file' (not in allowed temp directories)" >&2
    return 1
}

################################################################################
# AUDIT: USER CONSENT FOR EXTERNAL API UPLOADS
################################################################################

# AUDIT: Default to automatic consent for seamless operation
# Use --no-consent flag to disable external API calls
USER_CONSENT_GIVEN=true
AUTO_CONSENT=true
REQUIRE_CONSENT_PROMPT=false
CONSENT_LOG=""

# Request user consent before uploading data to external services
# By default, consent is automatic. Use --no-consent to disable.
request_upload_consent() {
    local service_name="$1"
    local data_description="$2"
    
    # If user explicitly disabled consent, skip external calls
    if [[ "${NO_EXTERNAL_APIS:-false}" == "true" ]]; then
        return 1
    fi
    
    # Default: consent is given automatically
    if [[ "$USER_CONSENT_GIVEN" == "true" ]]; then
        CONSENT_LOG="${CONSENT_LOG}$(date -Iseconds): Auto-consent for $service_name\n"
        record_custody_action "API_CONSENT" "Auto-consent granted for $service_name" "" ""
        return 0
    fi
    
    # Only prompt if explicitly requested
    if [[ "$REQUIRE_CONSENT_PROMPT" == "true" ]]; then
        echo ""
        echo -e "${YELLOW}═══════════════════════════════════════════════════════════════${NC}"
        echo -e "${YELLOW}  DATA UPLOAD CONSENT REQUEST${NC}"
        echo -e "${YELLOW}═══════════════════════════════════════════════════════════════${NC}"
        echo ""
        echo "This operation will upload data to: $service_name"
        echo "Data to be uploaded: $data_description"
        echo ""
        read -r -p "Do you consent to this upload? [Y/n]: " response
        
        if [[ ! "$response" =~ ^[Nn]$ ]]; then
            USER_CONSENT_GIVEN=true
            CONSENT_LOG="${CONSENT_LOG}$(date -Iseconds): Consent given for $service_name\n"
            return 0
        else
            return 1
        fi
    fi
    
    return 0
}

################################################################################
# AUDIT: CHAIN OF CUSTODY FOR FORENSICS
################################################################################

CHAIN_OF_CUSTODY_FILE=""

# Initialize chain of custody record
init_chain_of_custody() {
    if [[ -z "${OUTPUT_DIR:-}" ]]; then
        return
    fi
    
    CHAIN_OF_CUSTODY_FILE="${OUTPUT_DIR}/chain_of_custody.json"
    
    cat > "$CHAIN_OF_CUSTODY_FILE" << CUSTODY_EOF
{
    "case_id": "${TIMESTAMP}-$$",
    "tool_name": "QR Malware Scanner",
    "tool_version": "${VERSION}",
    "tool_hash": "${SCRIPT_HASH}",
    "analyst": "${SCAN_USER}",
    "workstation": "${SCAN_HOSTNAME}",
    "start_time": "$(date -Iseconds)",
    "timezone": "$(date +%Z)",
    "evidence_items": [],
    "actions": []
}
CUSTODY_EOF
    
    log_forensic "Chain of custody initialized"
}

# Record action in chain of custody
record_custody_action() {
    local action_type="$1"
    local description="$2"
    local artifact="${3:-}"
    local artifact_hash="${4:-}"
    
    if [[ ! -f "${CHAIN_OF_CUSTODY_FILE:-}" ]]; then
        return
    fi
    
    local timestamp
    timestamp=$(date -Iseconds)
    
    # Sanitize description for JSON
    description=$(echo "$description" | sed 's/"/\\"/g' | tr -d '\n\r')
    
    # Append to log file (simpler than modifying JSON in bash)
    echo "{\"timestamp\":\"$timestamp\",\"action\":\"$action_type\",\"description\":\"$description\",\"artifact\":\"$artifact\",\"hash\":\"$artifact_hash\"}" >> "${CHAIN_OF_CUSTODY_FILE}.log"
}

# Add evidence item to chain of custody
add_evidence_item() {
    local file_path="$1"
    local evidence_type="$2"
    local description="${3:-}"
    
    if [[ ! -f "$file_path" ]]; then
        return
    fi
    
    local file_hash
    file_hash=$(sha256sum "$file_path" 2>/dev/null | cut -d' ' -f1 || shasum -a 256 "$file_path" 2>/dev/null | cut -d' ' -f1 || echo "UNAVAILABLE")
    
    record_custody_action "EVIDENCE_ACQUIRED" "$description" "$file_path" "$file_hash"
}

################################################################################
# AUDIT: ADDITIONAL IOC PATTERNS AND DETECTION DATABASES
################################################################################

# Configuration for additional IOC sources
declare -a ADDITIONAL_IOC_FILES=(
    "/etc/qr_scanner/iocs.txt"
    "${HOME}/.qr_scanner/iocs.txt"
    "./custom_iocs.txt"
)

declare -a ADDITIONAL_IOC_URLS=(
    "https://openphish.com/feed.txt"
    "https://urlhaus.abuse.ch/downloads/text_recent/"
    "https://phishunt.io/feed.txt"                                  # Phishing
    "https://feodotracker.abuse.ch/downloads/ipblocklist.txt"       # C2 IPs
    "https://malc0de.com/bl/IP_Blacklist.txt"                       # Malicious IPs
    "https://ransomwaretracker.abuse.ch/downloads/RW_URLBL.txt"     # (ARCHIVED, historical ransomware URLs)
    "https://threatfox.abuse.ch/downloads/iocdb.csv"                # Multi-type IOCs
    "https://raw.githubusercontent.com/cbuijs/shallalist/master/urls/droplist.txt" # Dropped domains
    "https://blocklist.projecthoneypot.org/download.php?list=all"   # Spam and bots (requires token)
)

# IOC loading statistics
declare -a LOADED_IOC_SOURCES=()
IOC_LOAD_COUNT=0
IOC_LOAD_TIMESTAMP=""

# Load additional IOCs from configured sources
load_additional_iocs() {
    log_info "Loading additional IOC patterns..."
    
    local temp_ioc_file
    temp_ioc_file=$(create_secure_temp_file "iocs_merged") || return 1
    
    IOC_LOAD_TIMESTAMP=$(date -Iseconds)
    
    # Load from local files
    for ioc_file in "${ADDITIONAL_IOC_FILES[@]}"; do
        if [[ -r "$ioc_file" ]]; then
            log_info "  Loading IOCs from: $ioc_file"
            cat "$ioc_file" >> "$temp_ioc_file" 2>/dev/null || true
            LOADED_IOC_SOURCES+=("file:$ioc_file")
            local count
            count=$(wc -l < "$ioc_file" 2>/dev/null || echo 0)
            IOC_LOAD_COUNT=$((IOC_LOAD_COUNT + count))
        fi
    done
    
    # Load from network feeds if enabled and not offline
    if [[ "$NETWORK_CHECK" == "true" ]] && [[ "${OFFLINE_MODE:-false}" != "true" ]]; then
        for ioc_url in "${ADDITIONAL_IOC_URLS[@]}"; do
            local domain
            domain=$(echo "$ioc_url" | cut -d'/' -f3)
            log_info "  Fetching IOCs from: $domain"
            if curl -sfL --max-time 30 "$ioc_url" >> "$temp_ioc_file" 2>/dev/null; then
                LOADED_IOC_SOURCES+=("url:$ioc_url")
            fi
        done
    fi
    
    # Process and deduplicate
    if [[ -f "$temp_ioc_file" ]]; then
        sort -u "$temp_ioc_file" 2>/dev/null | grep -v '^$' | grep -v '^#' > "${TEMP_DIR}/all_additional_iocs.txt" 2>/dev/null || true
        IOC_LOAD_COUNT=$(wc -l < "${TEMP_DIR}/all_additional_iocs.txt" 2>/dev/null || echo 0)
        rm -f "$temp_ioc_file" 2>/dev/null || true
    fi
    
    log_success "Loaded $IOC_LOAD_COUNT additional IOC patterns from ${#LOADED_IOC_SOURCES[@]} sources"
    record_custody_action "IOC_LOAD" "Loaded $IOC_LOAD_COUNT IOCs from ${#LOADED_IOC_SOURCES[@]} sources"
}

# Check content against all additional IOCs
check_against_additional_iocs() {
    local content="$1"
    local source_desc="${2:-content}"
    local matches=0
    
    if [[ ! -f "${TEMP_DIR}/all_additional_iocs.txt" ]]; then
        return 0
    fi
    
    local matched_iocs
    matched_iocs=$(echo "$content" | grep -Fof "${TEMP_DIR}/all_additional_iocs.txt" 2>/dev/null | head -20 || true)
    
    if [[ -n "$matched_iocs" ]]; then
        while IFS= read -r ioc; do
            [[ -z "$ioc" ]] && continue
            ((matches++))
            log_threat 50 "ADDITIONAL IOC MATCH: $ioc"
            record_ioc "additional_ioc" "$ioc" "Matched from extended IOC database"
        done <<< "$matched_iocs"
    fi
    
    return $matches
}

################################################################################
# GLOBAL CONFIGURATION
################################################################################

# Announce version immediately so user knows they have the right file
echo "QR Malware Scanner v5.0.0-AUDIT loading..."

VERSION="5.0.0-AUDIT"
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
TIMESTAMP=$(date +%Y%m%d_%H%M%S)
RUN_ID="${TIMESTAMP}-$$"
OUTPUT_DIR="${SCRIPT_DIR}/qr_analysis_${TIMESTAMP}"
REPORT_FILE="${OUTPUT_DIR}/analysis_report.txt"
JSON_REPORT="${OUTPUT_DIR}/analysis_report.json"
IOC_REPORT="${OUTPUT_DIR}/iocs_detected.csv"
TEMP_DIR="${OUTPUT_DIR}/temp"
EVIDENCE_DIR="${OUTPUT_DIR}/evidence"
LOG_FILE="${OUTPUT_DIR}/scanner.log"
TIMELINE_FILE="${OUTPUT_DIR}/timeline.csv"
CORRELATION_FILE="${OUTPUT_DIR}/threat_correlation.txt"
STIX_REPORT="${OUTPUT_DIR}/stix_report.json"
MISP_REPORT="${OUTPUT_DIR}/misp_events.json"
YARA_MATCHES="${OUTPUT_DIR}/yara_matches.txt"
BEHAVIORAL_REPORT="${OUTPUT_DIR}/behavioral_analysis.txt"
APT_REPORT="${OUTPUT_DIR}/apt_attribution.txt"
ENTROPY_REPORT="${OUTPUT_DIR}/entropy_analysis.txt"
STEGANOGRAPHY_REPORT="${OUTPUT_DIR}/steganography_analysis.txt"
ML_REPORT="${OUTPUT_DIR}/ml_heuristics.txt"

# Extended Report Files
CLOUD_ABUSE_REPORT=""
MOBILE_THREAT_REPORT=""
GEOFENCING_REPORT=""
HARDWARE_EXPLOIT_REPORT=""
FILELESS_REPORT=""
ADVERSARIAL_QR_REPORT=""
SIEM_EXPORT_FILE=""
ML_CLASSIFICATION_REPORT=""
PERSONA_REPORT=""
TOR_VPN_REPORT=""
ASN_REPORT=""
QR_VISUAL_REPORT=""
RANSOMWARE_NOTE_REPORT=""
ZERO_DAY_REPORT=""
CLOAKING_REPORT=""
WIRELESS_REPORT=""
TELEPHONY_REPORT=""
OBFUSCATION_REPORT=""
INJECTION_REPORT=""
C2_BEACON_REPORT=""
CRYPTO_SCAM_REPORT=""
INDUSTRY_THREAT_REPORT=""

# Threat scoring
THREAT_SCORE=0
IOC_COUNT=0
MAX_THREAT_SCORE=1000
CRITICAL_THRESHOLD=500
HIGH_THRESHOLD=300
MEDIUM_THRESHOLD=150
LOW_THRESHOLD=50

# Color codes for output
RED='\033[0;31m'
YELLOW='\033[1;33m'
GREEN='\033[0;32m'
BLUE='\033[0;34m'
MAGENTA='\033[0;35m'
CYAN='\033[0;36m'
WHITE='\033[1;37m'
ORANGE='\033[0;33m'
NC='\033[0m' # No Color

# Analysis flags
VERBOSE=false
DEEP_ANALYSIS=false
NETWORK_CHECK=true
VT_CHECK=false
STEALTH_MODE=false
FORENSIC_MODE=false
ML_HEURISTICS=true
APT_ATTRIBUTION=true
BEHAVIORAL_ANALYSIS=true
STEGANOGRAPHY_CHECK=true
ENTROPY_ANALYSIS=true
PASSIVE_DNS=true
CERTIFICATE_CHECK=true
HISTORICAL_ANALYSIS=true

# Extended Analysis Flags
CLOUD_ABUSE_CHECK=true
MOBILE_DEEPLINK_CHECK=true
GEOFENCING_CHECK=true
BLUETOOTH_NFC_CHECK=true
HARDWARE_EXPLOIT_CHECK=true
FILELESS_MALWARE_CHECK=true
ADVERSARIAL_QR_CHECK=true
SIEM_INTEGRATION=false
ZERO_DAY_DETECTION=true
ML_CLASSIFICATION=true
PERSONA_LINKING=true
RANSOMWARE_NOTE_CHECK=true
TOR_VPN_CHECK=true
CERTIFICATE_TRANSPARENCY=true
ASN_ANALYSIS=true
QR_VISUAL_STEGO=true
URL_OBFUSCATION_CHECK=true
INJECTION_ATTACK_CHECK=true
C2_BEACON_CHECK=true
CRYPTO_SCAM_CHECK=true
INDUSTRY_THREAT_CHECK=true

# AUDIT ENHANCEMENT FLAGS (22 NEW MODULES)
AUDIT_ENHANCED_ANALYSIS=true
SANDBOX_DETONATION=true
JS_BROWSER_ANALYSIS=true
ML_CLASSIFICATION_ENHANCED=true
PDF_DOC_ANALYSIS=true
NLP_ANALYSIS=true
MOBILE_STATIC_ANALYSIS=true
WEB_ARCHIVE_ANALYSIS=true
RECURSIVE_CRAWL=true
ADVERSARIAL_AI_DETECTION=true
COVERT_CHANNEL_DETECTION=true
CROSS_QR_CHAIN_DETECTION=true
TEMPLATE_SPOOF_DETECTION=true
SOCIAL_MEDIA_LINK_DETECTION=true
UX_REDRESS_DETECTION=true
DGA_ANALYSIS=true
UNICODE_DECEPTION_DETECTION=true
SOCIAL_THREAT_TRACKING=true
BLOCKCHAIN_SCAM_ANALYSIS=true
CONTACT_EVENT_ANALYSIS=true
GEO_HOTSPOT_DETECTION=true
EMERGING_PROTOCOL_DETECTION=true
FEEDBACK_LOOP_ENABLED=true
INTERACTIVE_MODE=false

# API Keys (environment variables)
VT_API_KEY="${VT_API_KEY:-}"
PHISHTANK_API_KEY="${PHISHTANK_API_KEY:-}"
ABUSEIPDB_API_KEY="${ABUSEIPDB_API_KEY:-}"
OTX_API_KEY="${OTX_API_KEY:-}"
SHODAN_API_KEY="${SHODAN_API_KEY:-}"
SECURITYTRAILS_API_KEY="${SECURITYTRAILS_API_KEY:-}"
URLSCAN_API_KEY="${URLSCAN_API_KEY:-}"
GREYNOISE_API_KEY="${GREYNOISE_API_KEY:-}"
CENSYS_API_KEY="${CENSYS_API_KEY:-}"

# Audit Enhancement API Keys
ANYRUN_API_KEY="${ANYRUN_API_KEY:-}"
HYBRID_ANALYSIS_KEY="${HYBRID_ANALYSIS_KEY:-}"
ETHERSCAN_API_KEY="${ETHERSCAN_API_KEY:-}"
OPENAI_API_KEY="${OPENAI_API_KEY:-}"

# NEW: Additional Threat Intelligence API Keys (20 missing feeds)
CROWDSTRIKE_API_KEY="${CROWDSTRIKE_API_KEY:-}"
RECORDED_FUTURE_API_KEY="${RECORDED_FUTURE_API_KEY:-}"
RISKIQ_API_KEY="${RISKIQ_API_KEY:-}"
RISKIQ_API_SECRET="${RISKIQ_API_SECRET:-}"
JOESANDBOX_API_KEY="${JOESANDBOX_API_KEY:-}"
TRIAGE_API_KEY="${TRIAGE_API_KEY:-}"
MALPEDIA_API_KEY="${MALPEDIA_API_KEY:-}"

################################################################################
# LOGGING FUNCTIONS (defined BEFORE use)
################################################################################

# Flag to track if directories are initialized
DIRS_INITIALIZED=false

log_msg() {
    local level=$1
    shift
    local msg="$*"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    
    # AUDIT: Sanitize message to mask PII/sensitive data before logging
    local safe_msg
    safe_msg=$(sanitize_for_log "$msg")
    
    # ALWAYS print to terminal for full visibility
    echo "[$timestamp] [$level] $safe_msg"
    
    # Also log to file for retrospection if directories are initialized
    if [ "$DIRS_INITIALIZED" = true ] && [ -d "$OUTPUT_DIR" ]; then
        echo "[$timestamp] [$level] $safe_msg" >> "$LOG_FILE" 2>/dev/null
        echo "$(date -Iseconds 2>/dev/null || date '+%Y-%m-%dT%H:%M:%S'),$level,\"$safe_msg\"" >> "$TIMELINE_FILE" 2>/dev/null
    fi
}

log_info() {
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    echo -e "${BLUE}[$timestamp] [INFO]${NC} $*"
    # Also log to file
    if [ "$DIRS_INITIALIZED" = true ] && [ -d "$OUTPUT_DIR" ]; then
        echo "[$timestamp] [INFO] $(sanitize_for_log "$*")" >> "$LOG_FILE" 2>/dev/null
    fi
}

log_success() {
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    echo -e "${GREEN}[$timestamp] [SUCCESS]${NC} $*"
    if [ "$DIRS_INITIALIZED" = true ] && [ -d "$OUTPUT_DIR" ]; then
        echo "[$timestamp] [SUCCESS] $(sanitize_for_log "$*")" >> "$LOG_FILE" 2>/dev/null
    fi
}

log_warning() {
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    echo -e "${YELLOW}[$timestamp] [WARNING]${NC} $*"
    if [ "$DIRS_INITIALIZED" = true ] && [ -d "$OUTPUT_DIR" ]; then
        echo "[$timestamp] [WARNING] $(sanitize_for_log "$*")" >> "$LOG_FILE" 2>/dev/null
    fi
}

log_error() {
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    echo -e "${RED}[$timestamp] [ERROR]${NC} $*"
    if [ "$DIRS_INITIALIZED" = true ] && [ -d "$OUTPUT_DIR" ]; then
        echo "[$timestamp] [ERROR] $(sanitize_for_log "$*")" >> "$LOG_FILE" 2>/dev/null
    fi
}

log_critical() {
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    echo -e "${RED}[$timestamp] [CRITICAL]${NC} $*"
    if [ "$DIRS_INITIALIZED" = true ] && [ -d "$OUTPUT_DIR" ]; then
        echo "[$timestamp] [CRITICAL] $(sanitize_for_log "$*")" >> "$LOG_FILE" 2>/dev/null
    fi
}

# Log threat with forensic format wrapper
# Usage: log_threat <score> <message>
# For backwards compatibility, converts simple threat logs to forensic format
# IMPROVED: Now extracts and shows specific IOC information instead of generic messages
log_threat() {
    local score=$1
    shift
    local msg="$*"
    
    # Update global threat score
    THREAT_SCORE=$((THREAT_SCORE + score))
    
    # Determine severity based on score
    local severity="INFO"
    if [[ $score -ge 80 ]]; then
        severity="CRITICAL"
    elif [[ $score -ge 50 ]]; then
        severity="HIGH"
    elif [[ $score -ge 30 ]]; then
        severity="MEDIUM"
    elif [[ $score -ge 10 ]]; then
        severity="LOW"
    fi
    
    # Extract specific IOC information from the message
    local ioc_value="$msg"
    local matched_pattern=""
    local module_name="Threat Detection"
    local field_name="QR decoded content"
    
    # Parse the message to extract specific IOC details
    # Handle format: "Description: specific_value" or "Description - specific_value"
    if [[ "$msg" == *": "* ]]; then
        local desc="${msg%%:*}"
        local value="${msg#*: }"
        module_name="$desc"
        ioc_value="$value"
        matched_pattern="Direct match: $value"
    elif [[ "$msg" == *" - "* ]]; then
        local desc="${msg%% - *}"
        local value="${msg#* - }"
        module_name="$desc"
        ioc_value="$value"
        matched_pattern="Direct match: $value"
    fi
    
    # Try to identify the type of IOC for better categorization
    if [[ "$ioc_value" =~ ^https?:// ]]; then
        matched_pattern="URL detected: $ioc_value"
        field_name="URL analysis"
    elif [[ "$ioc_value" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
        matched_pattern="IP address detected: $ioc_value"
        field_name="IP analysis"
    elif [[ "$ioc_value" =~ @.*\. ]]; then
        matched_pattern="Email address detected: $ioc_value"
        field_name="Email analysis"
    elif [[ "$ioc_value" =~ \.(exe|dll|ps1|bat|cmd|vbs|js|jar|apk|msi)($|[^a-z]) ]]; then
        matched_pattern="Executable file extension detected: $(echo "$ioc_value" | grep -oE '\.[a-z0-9]+' | head -1)"
        field_name="File extension analysis"
    elif [[ "$ioc_value" =~ (base64|encoded|obfuscated) ]]; then
        matched_pattern="Encoding/obfuscation detected: $ioc_value"
        field_name="Encoding analysis"
    elif [[ "$ioc_value" =~ (malware|trojan|ransomware|virus|backdoor|rat|c2|beacon) ]]; then
        matched_pattern="Malware indicator detected: $ioc_value"
        field_name="Malware signature"
    elif [[ "$ioc_value" =~ (phish|credential|password|login|signin) ]]; then
        matched_pattern="Credential theft indicator: $ioc_value"
        field_name="Phishing analysis"
    else
        # For other cases, use the full message as the pattern match description
        matched_pattern="Detection rule triggered: $msg"
    fi
    
    # Output in forensic format with specific IOC information
    echo ""
    echo -e "${MAGENTA}[THREAT +$score]${NC} $module_name"
    echo -e "    ${CYAN}├─ Module:${NC} $module_name"
    echo -e "    ${CYAN}├─ IOC:${NC} $(sanitize_for_log "$ioc_value")"
    echo -e "    ${CYAN}├─ Matched By:${NC} $matched_pattern"
    echo -e "    ${CYAN}├─ Severity:${NC} $severity ($score points)"
    [[ -n "${CURRENT_ARTIFACT:-}" ]] && echo -e "    ${CYAN}├─ Source Artifact:${NC} $CURRENT_ARTIFACT"
    [[ -n "${CURRENT_ARTIFACT_HASH:-}" ]] && echo -e "    ${CYAN}├─ File Hash (SHA256):${NC} $CURRENT_ARTIFACT_HASH"
    echo -e "    ${CYAN}├─ Detection Timestamp:${NC} $(date -u +%Y-%m-%dT%H:%M:%SZ)"
    echo -e "    ${CYAN}├─ Environment:${NC} Host=$(hostname 2>/dev/null || echo 'unknown'), User=$(whoami 2>/dev/null || echo 'unknown')"
    echo -e "    ${CYAN}├─ Run ID:${NC} ${RUN_ID:-unknown}"
    echo -e "    ${CYAN}├─ Decoded Field:${NC} $field_name"
    echo -e "    ${CYAN}└─ Recommendation:${NC} Review and investigate this finding"
    
    log_msg "THREAT" "+$score: $msg"
}

log_apt() {
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    echo -e "${CYAN}[$timestamp] [APT]${NC} $*"
    if [ "$DIRS_INITIALIZED" = true ] && [ -d "$OUTPUT_DIR" ]; then
        echo "[$timestamp] [APT] $(sanitize_for_log "$*")" >> "$LOG_FILE" 2>/dev/null
    fi
}

log_stego() {
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    echo -e "${ORANGE}[$timestamp] [STEGO]${NC} $*"
    if [ "$DIRS_INITIALIZED" = true ] && [ -d "$OUTPUT_DIR" ]; then
        echo "[$timestamp] [STEGO] $(sanitize_for_log "$*")" >> "$LOG_FILE" 2>/dev/null
    fi
}

log_ml() {
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    echo -e "${WHITE}[$timestamp] [ML]${NC} $*"
    if [ "$DIRS_INITIALIZED" = true ] && [ -d "$OUTPUT_DIR" ]; then
        echo "[$timestamp] [ML] $(sanitize_for_log "$*")" >> "$LOG_FILE" 2>/dev/null
    fi
}

log_behavioral() {
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    echo -e "${CYAN}[$timestamp] [BEHAVIORAL]${NC} $*"
    if [ "$DIRS_INITIALIZED" = true ] && [ -d "$OUTPUT_DIR" ]; then
        echo "[$timestamp] [BEHAVIORAL] $(sanitize_for_log "$*")" >> "$LOG_FILE" 2>/dev/null
    fi
}

log_forensic() {
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    echo -e "${WHITE}[$timestamp] [FORENSIC]${NC} $*"
    if [ "$DIRS_INITIALIZED" = true ] && [ -d "$OUTPUT_DIR" ]; then
        echo "[$timestamp] [FORENSIC] $(sanitize_for_log "$*")" >> "$LOG_FILE" 2>/dev/null
    fi
}

# Enhanced threat logging function with detailed structured output
# Usage: log_threat_detailed score module ioc matched_by severity recommendation [additional_fields...]
log_threat_detailed() {
    local score="$1"
    local module="$2"
    local ioc="$3"
    local matched_by="$4"
    local severity="$5"
    local recommendation="$6"
    local source_artifact="${CURRENT_ARTIFACT:-Unknown}"
    local decoded_field="${CURRENT_DECODED_CONTENT:-N/A}"
    local file_hash="${CURRENT_ARTIFACT_HASH:-N/A}"
    local detection_timestamp=$(date -Iseconds 2>/dev/null || date '+%Y-%m-%dT%H:%M:%S')
    local environment="${SCAN_HOSTNAME:-$(hostname 2>/dev/null || echo Unknown)} (${SCAN_USER:-$(whoami 2>/dev/null || echo Unknown)})"
    local reference="${7:-N/A}"
    
    # Update threat score
    THREAT_SCORE=$((THREAT_SCORE + score))
    
    # Color based on severity
    local color="$YELLOW"
    case "$severity" in
        CRITICAL) color="$RED" ;;
        HIGH) color="$MAGENTA" ;;
        MEDIUM) color="$YELLOW" ;;
        LOW) color="$BLUE" ;;
        INFO) color="$CYAN" ;;
    esac
    
    # Output structured threat format
    echo ""
    echo -e "${color}[THREAT +${score}]${NC} ${WHITE}${module}${NC}"
    echo -e "    ├─ Module: ${CYAN}${module}${NC}"
    echo -e "    ├─ IOC: ${WHITE}${ioc}${NC}"
    echo -e "    ├─ Matched By: ${matched_by}"
    echo -e "    ├─ Severity: ${color}${severity}${NC}"
    echo -e "    ├─ Source Artifact: ${source_artifact}"
    echo -e "    ├─ Decoded Field: ${decoded_field:0:100}${decoded_field:100:+...}"
    echo -e "    ├─ File Hash (SHA256): ${file_hash}"
    echo -e "    ├─ Detection Timestamp: ${detection_timestamp}"
    echo -e "    ├─ Environment: ${environment}"
    echo -e "    ├─ Run ID: ${RUN_ID}"
    echo -e "    ├─ Reference: ${reference}"
    echo -e "    └─ Recommendation: ${YELLOW}${recommendation}${NC}"
    echo ""
    
    # Log to file in structured format
    log_msg "THREAT_DETAILED" "Score:+$score|Module:$module|IOC:$ioc|Matched:$matched_by|Severity:$severity|Artifact:$source_artifact|RunID:$RUN_ID"
    
    # Record IOC
    record_ioc "$module" "$ioc" "$matched_by"
}

# Wrapper function for INFO-level detections with structured output
log_info_detection() {
    local module="$1"
    local ioc="$2"
    local matched_by="$3"
    local recommendation="${4:-Review this finding}"
    local reference="${5:-N/A}"
    
    log_threat_detailed 5 "$module" "$ioc" "$matched_by" "INFO" "$recommendation" "$reference"
}

# Wrapper function for WARNING-level detections with structured output
log_warning_detection() {
    local module="$1"
    local ioc="$2"
    local matched_by="$3"
    local recommendation="${4:-Investigate this finding}"
    local reference="${5:-N/A}"
    
    log_threat_detailed 15 "$module" "$ioc" "$matched_by" "MEDIUM" "$recommendation" "$reference"
}

# Wrapper function for HIGH-level detections with structured output
log_high_detection() {
    local module="$1"
    local ioc="$2"
    local matched_by="$3"
    local recommendation="${4:-Take immediate action}"
    local reference="${5:-N/A}"
    
    log_threat_detailed 35 "$module" "$ioc" "$matched_by" "HIGH" "$recommendation" "$reference"
}

# Wrapper function for CRITICAL-level detections with structured output
log_critical_detection() {
    local module="$1"
    local ioc="$2"
    local matched_by="$3"
    local recommendation="${4:-IMMEDIATE ACTION REQUIRED}"
    local reference="${5:-N/A}"
    
    log_threat_detailed 75 "$module" "$ioc" "$matched_by" "CRITICAL" "$recommendation" "$reference"
}

# Analysis status output helpers - ALWAYS print to terminal
analysis_success_none() {
    local analyzer="$1"
    local detection_timestamp=$(date -Iseconds 2>/dev/null || date '+%Y-%m-%dT%H:%M:%S')
    local source_artifact="${CURRENT_ARTIFACT:-Unknown}"
    local decoded_field="${CURRENT_DECODED_CONTENT:-N/A}"
    local file_hash="${CURRENT_ARTIFACT_HASH:-N/A}"
    local environment="Host=${SCAN_HOSTNAME:-$(hostname 2>/dev/null || echo Unknown)}, User=${SCAN_USER:-$(whoami 2>/dev/null || echo Unknown)}"
    
    echo -e "${GREEN}[✓ ${analyzer}]${NC}"
    echo -e "    └─ Clean"
}

analysis_success_found() {
    local analyzer="$1"
    local count="$2"
    local details="$3"
    local matched_iocs="$4"  # NEW: Specific IOCs that were matched
    local detection_timestamp=$(date -Iseconds 2>/dev/null || date '+%Y-%m-%dT%H:%M:%S')
    local source_artifact="${CURRENT_ARTIFACT:-Unknown}"
    local decoded_field="${CURRENT_DECODED_CONTENT:-N/A}"
    local file_hash="${CURRENT_ARTIFACT_HASH:-N/A}"
    local environment="Host=${SCAN_HOSTNAME:-$(hostname 2>/dev/null || echo Unknown)}, User=${SCAN_USER:-$(whoami 2>/dev/null || echo Unknown)}"
    
    # Determine severity and color based on count
    local severity="MEDIUM"
    local color="$YELLOW"
    local recommendation="Review detected threats"
    if [ "$count" -ge 5 ]; then
        severity="CRITICAL"
        color="$RED"
        recommendation="IMMEDIATE ACTION REQUIRED - Multiple high-risk indicators detected"
    elif [ "$count" -ge 3 ]; then
        severity="HIGH"
        color="$MAGENTA"
        recommendation="Investigate immediately - Significant threat indicators present"
    elif [ "$count" -ge 1 ]; then
        severity="MEDIUM"
        color="$YELLOW"
        recommendation="Review findings and assess risk level"
    fi
    
    # Format IOC display - show specific matches instead of generic count
    local ioc_display=""
    if [ -n "$matched_iocs" ]; then
        # Truncate very long IOC lists for display but show meaningful info
        local ioc_truncated="${matched_iocs:0:200}"
        if [ ${#matched_iocs} -gt 200 ]; then
            ioc_truncated="${ioc_truncated}..."
        fi
        ioc_display="${count} threat(s): ${ioc_truncated}"
    else
        ioc_display="${count} threat(s) detected"
    fi
    
    # Output structured threat format
    echo ""
    echo -e "${color}[ANALYSIS RESULT]${NC} ${WHITE}${analyzer}${NC}"
    echo -e "    ├─ Module: ${CYAN}${analyzer}${NC}"
    echo -e "    ├─ IOC: ${WHITE}${ioc_display}${NC}"
    echo -e "    ├─ Matched By: ${analyzer} engine analysis"
    echo -e "    ├─ Severity: ${color}${severity}${NC}"
    echo -e "    ├─ Source Artifact: ${source_artifact}"
    echo -e "    ├─ Decoded Field: ${decoded_field:0:100}${decoded_field:100:+...}"
    echo -e "    ├─ File Hash (SHA256): ${file_hash}"
    echo -e "    ├─ Detection Timestamp: ${detection_timestamp}"
    echo -e "    ├─ Environment: ${environment}"
    echo -e "    ├─ Run ID: ${RUN_ID}"
    if [ -n "$details" ]; then
        echo -e "    ├─ Details: ${CYAN}${details}${NC}"
    fi
    if [ -n "$matched_iocs" ] && [ ${#matched_iocs} -gt 200 ]; then
        echo -e "    ├─ Full IOC List: See report file for complete list"
    fi
    echo -e "    └─ Recommendation: ${YELLOW}${recommendation}${NC}"
    echo ""
}

analysis_error() {
    local analyzer="$1"
    local error_msg="$2"
    local error_details="${3:-No additional details available}"
    local detection_timestamp=$(date -Iseconds 2>/dev/null || date '+%Y-%m-%dT%H:%M:%S')
    local source_artifact="${CURRENT_ARTIFACT:-Unknown}"
    local decoded_field="${CURRENT_DECODED_CONTENT:-N/A}"
    local file_hash="${CURRENT_ARTIFACT_HASH:-N/A}"
    local environment="Host=${SCAN_HOSTNAME:-$(hostname 2>/dev/null || echo Unknown)}, User=${SCAN_USER:-$(whoami 2>/dev/null || echo Unknown)}"
    
    # Try to capture Python availability and version for diagnosis
    local python_info=""
    if command -v python3 &>/dev/null; then
        python_info="python3: $(python3 --version 2>&1 || echo 'version check failed')"
    elif command -v python &>/dev/null; then
        python_info="python: $(python --version 2>&1 || echo 'version check failed')"
    else
        python_info="Python not found in PATH"
    fi
    
    echo ""
    echo -e "${RED}[ERROR]${NC} ${WHITE}${analyzer}${NC}"
    echo -e "    ├─ Module: ${CYAN}${analyzer}${NC}"
    echo -e "    ├─ IOC: ${WHITE}Analysis error - ${error_msg}${NC}"
    echo -e "    ├─ Matched By: Error detection"
    echo -e "    ├─ Severity: ${RED}ERROR${NC}"
    echo -e "    ├─ Source Artifact: ${source_artifact}"
    echo -e "    ├─ Decoded Field: ${decoded_field:0:100}${decoded_field:100:+...}"
    echo -e "    ├─ File Hash (SHA256): ${file_hash}"
    echo -e "    ├─ Detection Timestamp: ${detection_timestamp}"
    echo -e "    ├─ Environment: ${environment}"
    echo -e "    ├─ Run ID: ${RUN_ID}"
    echo -e "    ├─ Error Details: ${YELLOW}${error_details}${NC}"
    echo -e "    ├─ Python Info: ${python_info}"
    echo -e "    └─ Recommendation: ${YELLOW}Check dependencies and logs. Error: ${error_msg}${NC}"
    echo ""
}

# Progress indicator for long-running operations
analysis_progress() {
    local analyzer="$1"
    local status="$2"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')
    echo -e "${BLUE}[$timestamp] [⋯ ${analyzer}]${NC} ${status}"
}

################################################################################
# CROSS-PLATFORM JSON EXTRACTION HELPERS
# macOS grep doesn't support -P (Perl regex), so use sed instead
################################################################################

json_extract_string() {
    local json="$1"
    local key="$2"
    echo "$json" | sed -n 's/.*"'"$key"'"[[:space:]]*:[[:space:]]*"\([^"]*\)".*/\1/p' | head -1
}

json_extract_number() {
    local json="$1"
    local key="$2"
    echo "$json" | sed -n 's/.*"'"$key"'"[[:space:]]*:[[:space:]]*\([0-9.]*\).*/\1/p' | head -1
}

json_extract_int() {
    local json="$1"
    local key="$2"
    echo "$json" | sed -n 's/.*"'"$key"'"[[:space:]]*:[[:space:]]*\([0-9]*\).*/\1/p' | head -1
}

################################################################################
# CROSS-PLATFORM GREP HELPERS
# macOS BSD grep doesn't support \s, \d, etc. - use POSIX character classes
################################################################################

# Safe grep for extended regex - converts common PCRE patterns to POSIX
# Usage: safe_grep_E "pattern" <<< "$content"  OR  echo "$content" | safe_grep_E "pattern"
safe_grep_E() {
    local pattern="$1"
    # Convert common PCRE to POSIX:
    # \s -> [[:space:]]
    # \d -> [0-9]
    # \w -> [[:alnum:]_]
    pattern=$(echo "$pattern" | sed 's/\\s/[[:space:]]/g; s/\\d/[0-9]/g; s/\\w/[[:alnum:]_]/g')
    grep -E "$pattern" 2>/dev/null
}

# Safe quiet grep for extended regex
safe_grep_qE() {
    local pattern="$1"
    pattern=$(echo "$pattern" | sed 's/\\s/[[:space:]]/g; s/\\d/[0-9]/g; s/\\w/[[:alnum:]_]/g')
    grep -qE "$pattern" 2>/dev/null
}

# Safe grep with case-insensitive extended regex
safe_grep_iE() {
    local pattern="$1"
    pattern=$(echo "$pattern" | sed 's/\\s/[[:space:]]/g; s/\\d/[0-9]/g; s/\\w/[[:alnum:]_]/g')
    grep -iE "$pattern" 2>/dev/null
}

# Safe quiet case-insensitive grep
safe_grep_qiE() {
    local pattern="$1"
    pattern=$(echo "$pattern" | sed 's/\\s/[[:space:]]/g; s/\\d/[0-9]/g; s/\\w/[[:alnum:]_]/g')
    grep -qiE "$pattern" 2>/dev/null
}

# Extract match with extended regex (cross-platform)
safe_grep_oE() {
    local pattern="$1"
    # AUDIT FIX: Add protections against catastrophic backtracking and long lines
    # 1. Convert PCRE to POSIX
    pattern=$(echo "$pattern" | sed 's/\\s/[[:space:]]/g; s/\\d/[0-9]/g; s/\\w/[[:alnum:]_]/g')
    # 2. Remove null bytes from input to prevent grep hangs on binary data
    # 3. Use head to limit output and prevent memory exhaustion (max 100 matches)
    # 4. Add timeout protection via timeout command if available (2 second limit)
    # 5. Add || true to ensure function doesn't fail and cause script exit
    if command -v timeout &>/dev/null; then
        tr -d '\0' | timeout 2s grep -oE "$pattern" 2>/dev/null | head -100 || true
    else
        tr -d '\0' | grep -oE "$pattern" 2>/dev/null | head -100 || true
    fi
}

# Extract match with case-insensitive extended regex
safe_grep_oiE() {
    local pattern="$1"
    # AUDIT FIX: Add protections against catastrophic backtracking and long lines
    pattern=$(echo "$pattern" | sed 's/\\s/[[:space:]]/g; s/\\d/[0-9]/g; s/\\w/[[:alnum:]_]/g')
    if command -v timeout &>/dev/null; then
        tr -d '\0' | timeout 2s grep -oiE "$pattern" 2>/dev/null | head -100 || true
    else
        tr -d '\0' | grep -oiE "$pattern" 2>/dev/null | head -100 || true
    fi
}

# AUDIT FIX: Additional safe grep wrappers for QR code content analysis
# Safe quiet case-insensitive grep (no extended regex)
safe_grep_qi() {
    local pattern="$1"
    grep -qi "$pattern" 2>/dev/null
}

# Safe case-insensitive extended regex
safe_grep_iE() {
    local pattern="$1"
    pattern=$(echo "$pattern" | sed 's/\\s/[[:space:]]/g; s/\\d/[0-9]/g; s/\\w/[[:alnum:]_]/g')
    grep -iE "$pattern" 2>/dev/null
}

# Safe output match (no extended regex)
safe_grep_o() {
    local pattern="$1"
    grep -o "$pattern" 2>/dev/null
}

# Safe count case-insensitive extended regex
safe_grep_ciE() {
    local pattern="$1"
    pattern=$(echo "$pattern" | sed 's/\\s/[[:space:]]/g; s/\\d/[0-9]/g; s/\\w/[[:alnum:]_]/g')
    grep -ciE "$pattern" 2>/dev/null
}

# Safe count output extended regex
safe_grep_coE() {
    local pattern="$1"
    pattern=$(echo "$pattern" | sed 's/\\s/[[:space:]]/g; s/\\d/[0-9]/g; s/\\w/[[:alnum:]_]/g')
    grep -coE "$pattern" 2>/dev/null
}

# Safe quiet case-insensitive fixed string
safe_grep_qiF() {
    local pattern="$1"
    grep -qiF "$pattern" 2>/dev/null
}

# Safe quiet fixed string
safe_grep_qF() {
    local pattern="$1"
    grep -qF "$pattern" 2>/dev/null
}

# Safe output fixed string
safe_grep_oF() {
    local pattern="$1"
    grep -oF "$pattern" 2>/dev/null
}

################################################################################
# SAFE FLOATING POINT COMPARISON HELPERS
# bc can fail with parse errors on invalid input, use awk instead
################################################################################

# Safe floating point comparison: returns 0 (true) if $1 > $2
float_gt() {
    local val1="${1:-0}"
    local val2="${2:-0}"
    
    # Validate inputs are numeric
    if ! [[ "$val1" =~ ^-?[0-9]*\.?[0-9]+$ ]] || ! [[ "$val2" =~ ^-?[0-9]*\.?[0-9]+$ ]]; then
        return 1
    fi
    
    awk -v a="$val1" -v b="$val2" 'BEGIN { exit !(a > b) }'
}

# Safe floating point comparison: returns 0 (true) if $1 < $2
float_lt() {
    local val1="${1:-0}"
    local val2="${2:-0}"
    
    if ! [[ "$val1" =~ ^-?[0-9]*\.?[0-9]+$ ]] || ! [[ "$val2" =~ ^-?[0-9]*\.?[0-9]+$ ]]; then
        return 1
    fi
    
    awk -v a="$val1" -v b="$val2" 'BEGIN { exit !(a < b) }'
}

# Safe floating point comparison: returns 0 (true) if $1 >= $2
float_ge() {
    local val1="${1:-0}"
    local val2="${2:-0}"
    
    if ! [[ "$val1" =~ ^-?[0-9]*\.?[0-9]+$ ]] || ! [[ "$val2" =~ ^-?[0-9]*\.?[0-9]+$ ]]; then
        return 1
    fi
    
    awk -v a="$val1" -v b="$val2" 'BEGIN { exit !(a >= b) }'
}

# Safe floating point comparison: returns 0 (true) if $1 <= $2
float_le() {
    local val1="${1:-0}"
    local val2="${2:-0}"
    
    if ! [[ "$val1" =~ ^-?[0-9]*\.?[0-9]+$ ]] || ! [[ "$val2" =~ ^-?[0-9]*\.?[0-9]+$ ]]; then
        return 1
    fi
    
    awk -v a="$val1" -v b="$val2" 'BEGIN { exit !(a <= b) }'
}

################################################################################
# FORENSIC DETECTION LOGGING
# Full context for each detection per forensic requirements
# AUDIT: ALL detections MUST use this format for consistency
################################################################################

# Global variables for current scan context
CURRENT_ARTIFACT=""
CURRENT_ARTIFACT_HASH=""
CURRENT_DECODED_CONTENT=""
SCAN_HOSTNAME=$(hostname 2>/dev/null || echo "unknown")
SCAN_USER=$(whoami 2>/dev/null || echo "unknown")
DETECTION_COUNT=0

# AUDIT: Master detection logging function - ALL detections must use this format
# Parameters:
#   $1 = score (threat score to add)
#   $2 = module (detection module name)
#   $3 = indicator/IOC (what was detected)
#   $4 = matched_by (pattern/rule that matched)
#   $5 = field (where in content it was found) [optional]
#   $6 = recommendation (what to do) [optional]
#   $7 = reference (MITRE/CVE/URL reference) [optional]
#   $8 = severity_label (CRITICAL/HIGH/MEDIUM/LOW/INFO) [optional, auto-calculated from score]
log_forensic_detection() {
    local score="$1"
    local module="$2"
    local indicator="$3"
    local matched_by="$4"
    local field="${5:-QR decoded content}"
    local recommendation="${6:-Review and investigate}"
    local reference="${7:-}"
    local severity_label="${8:-}"
    
    # Auto-calculate severity if not provided
    if [[ -z "$severity_label" ]]; then
        if [[ $score -ge 80 ]]; then
            severity_label="CRITICAL"
        elif [[ $score -ge 50 ]]; then
            severity_label="HIGH"
        elif [[ $score -ge 30 ]]; then
            severity_label="MEDIUM"
        elif [[ $score -ge 10 ]]; then
            severity_label="LOW"
        else
            severity_label="INFO"
        fi
    fi
    
    local timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
    local run_id="${RUN_ID:-${TIMESTAMP:-$(date +%s)}-$$}"
    
    ((DETECTION_COUNT++))
    
    # AUDIT: Display full forensic output in required format
    echo ""
    echo -e "${MAGENTA}[THREAT +${score}]${NC} ${module}"
    echo -e "    ${CYAN}├─ Module:${NC} $module"
    echo -e "    ${CYAN}├─ IOC:${NC} $indicator"
    echo -e "    ${CYAN}├─ Matched By:${NC} $matched_by"
    echo -e "    ${CYAN}├─ Severity:${NC} $severity_label ($score points)"
    echo -e "    ${CYAN}├─ Source Artifact:${NC} ${CURRENT_ARTIFACT:-unknown}"
    echo -e "    ${CYAN}├─ Decoded Field:${NC} $field"
    [[ -n "$CURRENT_ARTIFACT_HASH" ]] && echo -e "    ${CYAN}├─ File Hash (SHA256):${NC} $CURRENT_ARTIFACT_HASH"
    echo -e "    ${CYAN}├─ Detection Timestamp:${NC} $timestamp"
    echo -e "    ${CYAN}├─ Environment:${NC} Host=$SCAN_HOSTNAME, User=$SCAN_USER"
    echo -e "    ${CYAN}├─ Run ID:${NC} $run_id"
    [[ -n "$reference" ]] && echo -e "    ${CYAN}├─ Reference:${NC} $reference"
    echo -e "    ${CYAN}└─ Recommendation:${NC} $recommendation"
    
    # Add to threat score
    THREAT_SCORE=$((THREAT_SCORE + score))
    
    # Log to file with sanitized content
    log_msg "THREAT" "+$score: $module - $(sanitize_for_log "$indicator")"
    
    # Record IOC
    record_ioc "$module" "$indicator" "$matched_by"
    
    # Record in chain of custody
    record_custody_action "DETECTION" "$module: $indicator" "${CURRENT_ARTIFACT:-}" "${CURRENT_ARTIFACT_HASH:-}"
}

# AUDIT: Convenience wrappers for different severity levels
log_detection_critical() {
    local module="$1"
    local indicator="$2"
    local matched_by="$3"
    local field="${4:-QR decoded content}"
    local recommendation="${5:-IMMEDIATE ACTION REQUIRED - Block and investigate}"
    local reference="${6:-}"
    log_forensic_detection 80 "$module" "$indicator" "$matched_by" "$field" "$recommendation" "$reference" "CRITICAL"
}

log_detection_high() {
    local module="$1"
    local indicator="$2"
    local matched_by="$3"
    local field="${4:-QR decoded content}"
    local recommendation="${5:-High priority review required}"
    local reference="${6:-}"
    log_forensic_detection 50 "$module" "$indicator" "$matched_by" "$field" "$recommendation" "$reference" "HIGH"
}

log_detection_medium() {
    local module="$1"
    local indicator="$2"
    local matched_by="$3"
    local field="${4:-QR decoded content}"
    local recommendation="${5:-Review and assess risk}"
    local reference="${6:-}"
    log_forensic_detection 30 "$module" "$indicator" "$matched_by" "$field" "$recommendation" "$reference" "MEDIUM"
}

log_detection_low() {
    local module="$1"
    local indicator="$2"
    local matched_by="$3"
    local field="${4:-QR decoded content}"
    local recommendation="${5:-Monitor and log}"
    local reference="${6:-}"
    log_forensic_detection 15 "$module" "$indicator" "$matched_by" "$field" "$recommendation" "$reference" "LOW"
}

log_detection_info() {
    local module="$1"
    local indicator="$2"
    local matched_by="$3"
    local field="${4:-QR decoded content}"
    local recommendation="${5:-For information only}"
    local reference="${6:-}"
    log_forensic_detection 5 "$module" "$indicator" "$matched_by" "$field" "$recommendation" "$reference" "INFO"
}

# AUDIT: Updated log_threat to use forensic format with specific pattern information
log_threat_forensic() {
    local score="$1"
    shift
    local msg="$*"
    
    # Extract specific pattern/IOC from the message for better reporting
    local module_name="Threat Detection"
    local matched_pattern="$msg"
    
    # Parse message format to extract pattern info
    if [[ "$msg" == *"matched pattern"* ]]; then
        matched_pattern="Pattern: ${msg#*matched pattern }"
    elif [[ "$msg" == *"detected:"* ]]; then
        module_name="${msg%%:*}"
        matched_pattern="Detected value: ${msg#*: }"
    else
        matched_pattern="Detection rule: $msg"
    fi
    
    log_forensic_detection "$score" "$module_name" "$msg" "$matched_pattern" "QR decoded content" "Review and investigate" ""
}

# IP Address Extraction and Display
extract_and_display_ips() {
    local content="$1"
    local source_name="${2:-content}"
    
    # Extract IPv4 addresses
    local ipv4_addrs=$(echo "$content" | safe_grep_oE '([0-9]{1,3}\.){3}[0-9]{1,3}' 2>/dev/null | sort -u)
    
    # Extract IPv6 addresses (simplified pattern)
    local ipv6_addrs=$(echo "$content" | safe_grep_oE '([0-9a-fA-F]{1,4}:){7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|::[0-9a-fA-F]{1,4}' 2>/dev/null | sort -u)
    
    local ip_count=0
    
    if [ -n "$ipv4_addrs" ] || [ -n "$ipv6_addrs" ]; then
        echo ""
        echo -e "${CYAN}┌─────────────────────────────────────────────────────────────┐${NC}"
        echo -e "${CYAN}│                 IP ADDRESSES DETECTED                        │${NC}"
        echo -e "${CYAN}├─────────────────────────────────────────────────────────────┤${NC}"
        
        # Process IPv4 addresses
        while IFS= read -r ip; do
            [ -z "$ip" ] && continue
            ((ip_count++))
            
            # Classify IP type
            local ip_type="External"
            local ip_risk="LOW"
            
            # Check for private/reserved IPs
            if [[ "$ip" =~ ^10\. ]] || [[ "$ip" =~ ^192\.168\. ]] || [[ "$ip" =~ ^172\.(1[6-9]|2[0-9]|3[01])\. ]]; then
                ip_type="Private (RFC1918)"
                ip_risk="INFO"
            elif [[ "$ip" =~ ^127\. ]]; then
                ip_type="Loopback"
                ip_risk="INFO"
            elif [[ "$ip" =~ ^169\.254\. ]]; then
                ip_type="Link-Local"
                ip_risk="INFO"
            elif [[ "$ip" =~ ^0\. ]]; then
                ip_type="This Network"
                ip_risk="SUSPICIOUS"
            fi
            
            # Check against known malicious IPs - safe array lookup
            if [[ -v "KNOWN_MALICIOUS_IPS[$ip]" ]] && [[ -n "${KNOWN_MALICIOUS_IPS[$ip]}" ]]; then
                ip_risk="CRITICAL"
                echo -e "${CYAN}│${NC} ${RED}⚠ $ip${NC}"
                echo -e "${CYAN}│${NC}   Type: ${RED}KNOWN MALICIOUS${NC}"
                echo -e "${CYAN}│${NC}   Info: ${KNOWN_MALICIOUS_IPS[$ip]}"
                record_ioc "malicious_ip" "$ip" "Known malicious IP"
            else
                case "$ip_risk" in
                    "CRITICAL") echo -e "${CYAN}│${NC} ${RED}● $ip ($ip_type)${NC}" ;;
                    "SUSPICIOUS") echo -e "${CYAN}│${NC} ${YELLOW}● $ip ($ip_type)${NC}" ;;
                    *) echo -e "${CYAN}│${NC} ${WHITE}● $ip ($ip_type)${NC}" ;;
                esac
            fi
            
            # Record external IPs as IOCs
            if [ "$ip_type" = "External" ]; then
                record_ioc "ip_address" "$ip" "External IP from $source_name"
            fi
            
        done <<< "$ipv4_addrs"
        
        # Process IPv6 addresses
        while IFS= read -r ip; do
            [ -z "$ip" ] && continue
            ((ip_count++))
            echo -e "${CYAN}│${NC} ${WHITE}● $ip (IPv6)${NC}"
            record_ioc "ipv6_address" "$ip" "IPv6 from $source_name"
        done <<< "$ipv6_addrs"
        
        echo -e "${CYAN}│${NC}"
        echo -e "${CYAN}│${NC} Total IPs found: ${WHITE}$ip_count${NC}"
        echo -e "${CYAN}└─────────────────────────────────────────────────────────────┘${NC}"
        echo ""
        
        # Log forensic detail
        log_forensic "Extracted $ip_count IP address(es) from $source_name"
    fi
    
    echo "$ip_count"
}

################################################################################
# INITIALIZATION FUNCTIONS
################################################################################

initialize_extended_reports() {
    CLOUD_ABUSE_REPORT="${OUTPUT_DIR}/cloud_abuse_analysis.txt"
    MOBILE_THREAT_REPORT="${OUTPUT_DIR}/mobile_threats.txt"
    GEOFENCING_REPORT="${OUTPUT_DIR}/geofencing_analysis.txt"
    HARDWARE_EXPLOIT_REPORT="${OUTPUT_DIR}/hardware_exploits.txt"
    FILELESS_REPORT="${OUTPUT_DIR}/fileless_malware.txt"
    ADVERSARIAL_QR_REPORT="${OUTPUT_DIR}/adversarial_qr.txt"
    SIEM_EXPORT_FILE="${OUTPUT_DIR}/siem_export.json"
    ML_CLASSIFICATION_REPORT="${OUTPUT_DIR}/ml_classification.txt"
    PERSONA_REPORT="${OUTPUT_DIR}/persona_analysis.txt"
    TOR_VPN_REPORT="${OUTPUT_DIR}/tor_vpn_analysis.txt"
    ASN_REPORT="${OUTPUT_DIR}/asn_analysis.txt"
    QR_VISUAL_REPORT="${OUTPUT_DIR}/qr_visual_analysis.txt"
    RANSOMWARE_NOTE_REPORT="${OUTPUT_DIR}/ransomware_notes.txt"
    ZERO_DAY_REPORT="${OUTPUT_DIR}/zero_day_anomalies.txt"
    CLOAKING_REPORT="${OUTPUT_DIR}/cloaking_detection.txt"
    WIRELESS_REPORT="${OUTPUT_DIR}/wireless_analysis.txt"
    TELEPHONY_REPORT="${OUTPUT_DIR}/telephony_analysis.txt"
    OBFUSCATION_REPORT="${OUTPUT_DIR}/url_obfuscation.txt"
    INJECTION_REPORT="${OUTPUT_DIR}/injection_attacks.txt"
    C2_BEACON_REPORT="${OUTPUT_DIR}/c2_beacon_analysis.txt"
    CRYPTO_SCAM_REPORT="${OUTPUT_DIR}/crypto_scam_analysis.txt"
    INDUSTRY_THREAT_REPORT="${OUTPUT_DIR}/industry_threats.txt"
}

initialize() {
    echo -e "${BLUE}[INFO]${NC} Initializing QR Malware Scanner..."
    
    # AUDIT: Validate output directory path
    if [[ -n "${OUTPUT_DIR:-}" ]]; then
        OUTPUT_DIR=$(sanitize_path "$OUTPUT_DIR") || {
            echo "[ERROR] Invalid output directory path"
            exit 1
        }
    fi
    
    # Create output directories with secure permissions
    mkdir -p "$OUTPUT_DIR" "$TEMP_DIR" "$EVIDENCE_DIR"
    chmod 700 "$OUTPUT_DIR" "$TEMP_DIR" "$EVIDENCE_DIR" 2>/dev/null || true
    
    # Now we can log
    DIRS_INITIALIZED=true
    
    # Initialize log file with secure permissions
    touch "$LOG_FILE"
    chmod 600 "$LOG_FILE" 2>/dev/null || true
    {
        echo "=== QR Malware Scanner Log ==="
        echo "Started: $(date)"
        echo "Version: $VERSION"
        echo "Script Hash: $SCRIPT_HASH"
        echo "Run ID: ${TIMESTAMP}-$$"
        echo ""
    } > "$LOG_FILE"
    
    # Initialize report file
    {
        echo "╔═══════════════════════════════════════════════════════════════════════════╗"
        echo "║           QR CODE MALWARE SCANNER - FORENSIC ANALYSIS REPORT              ║"
        echo "║                         Version: $VERSION                                   ║"
        echo "╚═══════════════════════════════════════════════════════════════════════════╝"
        echo ""
        echo "Analysis Date: $(date)"
        echo "Hostname: $(hostname)"
        echo "User: $(whoami)"
        echo "Script Hash: $SCRIPT_HASH"
        echo "Run ID: ${TIMESTAMP}-$$"
        echo ""
    } > "$REPORT_FILE"
    
    # Initialize IOC CSV with secure permissions
    echo "type,value,context,timestamp,threat_score" > "$IOC_REPORT"
    chmod 600 "$IOC_REPORT" 2>/dev/null || true
    
    # Initialize timeline
    echo "timestamp,event_type,description,threat_level" > "$TIMELINE_FILE"
    
    # Initialize YARA matches file
    echo "rule,timestamp,content" > "$YARA_MATCHES"
    
    # Initialize extended reports
    initialize_extended_reports
    
    # AUDIT: Initialize chain of custody
    init_chain_of_custody
    record_custody_action "SCAN_INITIALIZED" "Scanner initialized with version $VERSION"
    
    # AUDIT: Load additional IOC databases
    load_additional_iocs
    
    log_success "Initialization complete"
}

################################################################################
# CONFIGURATION & HARDENING CHECKS
################################################################################

# Check script integrity beyond basic hash
check_script_integrity() {
    local script_path="$0"
    
    log_info "Performing script integrity check..."
    
    # Check if script is writable (security risk)
    if [ -w "$script_path" ]; then
        log_warning "Script file is writable - potential security risk"
    fi
    
    # Check for suspicious modifications
    if [ -f "$script_path" ]; then
        local file_size=$(wc -c < "$script_path" 2>/dev/null || echo 0)
        if [ "$file_size" -lt 10000 ]; then
            log_warning "Script file unusually small - possible tampering"
            return 1
        fi
    fi
    
    # Check script ownership
    if [ "$(uname)" != "Darwin" ]; then
        local owner=$(stat -c %U "$script_path" 2>/dev/null || echo "unknown")
        if [ "$owner" != "$USER" ] && [ "$owner" != "root" ]; then
            log_warning "Script owned by different user: $owner"
        fi
    fi
    
    log_success "Script integrity check passed"
    return 0
}

# Verify dependency checksums
verify_dependency_hashes() {
    log_info "Verifying dependency integrity..."
    
    local deps_verified=0
    local deps_total=0
    
    # Check critical binaries if available
    for cmd in bash sh curl grep sed awk jq; do
        if command -v "$cmd" &> /dev/null; then
            ((deps_total++))
            # Just verify they exist and are executable
            if [ -x "$(command -v "$cmd")" ]; then
                ((deps_verified++))
            else
                log_warning "Dependency $cmd is not executable"
            fi
        fi
    done
    
    if [ $deps_total -gt 0 ]; then
        log_success "Dependency verification: $deps_verified/$deps_total verified"
    fi
    
    return 0
}

# Detect if running in sandbox environment
check_sandbox_environment() {
    log_info "Checking for sandbox environment..."
    
    local sandbox_indicators=0
    
    # Check for common sandbox indicators
    if [ -n "${GITHUB_ACTIONS:-}" ] || [ -n "${CI:-}" ]; then
        log_info "Running in CI/CD environment"
        ((sandbox_indicators++))
    fi
    
    # Check for Docker
    if [ -f "/.dockerenv" ] || grep -q docker /proc/1/cgroup 2>/dev/null; then
        log_info "Running in Docker container"
        ((sandbox_indicators++))
    fi
    
    # Check for limited resources
    if [ "$(ulimit -n 2>/dev/null || echo 1024)" -lt 256 ]; then
        log_info "Limited file descriptors - possible sandbox"
        ((sandbox_indicators++))
    fi
    
    if [ $sandbox_indicators -gt 0 ]; then
        log_info "Sandbox indicators detected: $sandbox_indicators"
        return 0
    fi
    
    log_success "No sandbox environment detected"
    return 1
}

# Validate API key formats
validate_api_key_formats() {
    log_info "Validating API key formats..."
    
    local keys_checked=0
    local keys_valid=0
    
    # Check VirusTotal API key format
    if [ -n "${VT_API_KEY:-}" ]; then
        ((keys_checked++))
        if [[ "$VT_API_KEY" =~ ^[a-f0-9]{64}$ ]]; then
            ((keys_valid++))
        else
            log_warning "VT_API_KEY format appears invalid"
        fi
    fi
    
    # Check generic API key patterns
    for var in PHISHTANK_API_KEY ABUSEIPDB_API_KEY OTX_API_KEY URLSCAN_API_KEY \
               CROWDSTRIKE_API_KEY RECORDED_FUTURE_API_KEY RISKIQ_API_KEY \
               JOESANDBOX_API_KEY TRIAGE_API_KEY MALPEDIA_API_KEY; do
        if [ -n "${!var:-}" ]; then
            ((keys_checked++))
            # Basic check: at least 16 chars, alphanumeric
            if [[ "${!var}" =~ ^[a-zA-Z0-9_-]{16,}$ ]]; then
                ((keys_valid++))
            else
                log_warning "$var format may be invalid"
            fi
        fi
    done
    
    if [ $keys_checked -gt 0 ]; then
        log_success "API key validation: $keys_valid/$keys_checked appear valid"
    else
        log_info "No API keys configured"
    fi
    
    return 0
}

# API key rotation reminders
rotate_api_keys() {
    log_info "Checking API key rotation status..."
    
    # Check if key rotation file exists
    local rotation_file="$HOME/.qr2_key_rotation"
    
    if [ -f "$rotation_file" ]; then
        local last_rotation=$(cat "$rotation_file" 2>/dev/null || echo 0)
        local current_time=$(date +%s)
        local days_since=$((( current_time - last_rotation ) / 86400))
        
        if [ $days_since -gt 90 ]; then
            log_warning "API keys not rotated in $days_since days - consider rotating"
        else
            log_info "API keys last rotated $days_since days ago"
        fi
    else
        log_info "No key rotation tracking file found"
        # Create tracking file
        date +%s > "$rotation_file" 2>/dev/null || true
    fi
    
    return 0
}

# API rate limit tracking
check_rate_limits() {
    log_info "Checking API rate limits..."
    
    # Simple rate limit tracking using temporary file
    local rate_file="$TEMP_DIR/rate_limits.txt"
    local current_time=$(date +%s)
    
    # Clean up old entries (older than 1 hour)
    if [ -f "$rate_file" ]; then
        grep -v "^[0-9]*:$((current_time - 3600))" "$rate_file" > "${rate_file}.tmp" 2>/dev/null || true
        mv "${rate_file}.tmp" "$rate_file" 2>/dev/null || true
    fi
    
    # Count recent API calls
    local recent_calls=$(grep -c "^[0-9]*:" "$rate_file" 2>/dev/null || echo 0)
    
    if [ $recent_calls -gt 100 ]; then
        log_warning "High API call rate detected: $recent_calls in last hour"
    else
        log_info "API call rate: $recent_calls in last hour"
    fi
    
    # Log this call
    echo "${current_time}:check" >> "$rate_file" 2>/dev/null || true
    
    return 0
}

# Circuit breaker to prevent cascade failures
implement_circuit_breaker() {
    local service="$1"
    local failure_threshold="${2:-5}"
    
    local circuit_file="$TEMP_DIR/circuit_${service}.txt"
    local current_time=$(date +%s)
    
    # Check if circuit is open
    if [ -f "$circuit_file" ]; then
        local open_time=$(cat "$circuit_file" 2>/dev/null || echo 0)
        local time_diff=$((current_time - open_time))
        
        # Reset after 5 minutes
        if [ $time_diff -gt 300 ]; then
            rm -f "$circuit_file"
            log_info "Circuit breaker for $service reset"
            return 0
        else
            log_warning "Circuit breaker OPEN for $service (${time_diff}s ago)"
            return 1
        fi
    fi
    
    # Check failure count
    local failure_file="$TEMP_DIR/failures_${service}.txt"
    local failure_count=$(wc -l < "$failure_file" 2>/dev/null || echo 0)
    
    if [ $failure_count -ge $failure_threshold ]; then
        echo "$current_time" > "$circuit_file"
        log_warning "Circuit breaker OPENED for $service ($failure_count failures)"
        return 1
    fi
    
    return 0
}

# Check disk space for analysis
check_disk_space() {
    log_info "Checking available disk space..."
    
    local min_space_mb=100
    local output_dir_space
    
    # Get available space in MB
    if command -v df &> /dev/null; then
        output_dir_space=$(df -m "$OUTPUT_DIR" 2>/dev/null | awk 'NR==2 {print $4}' || echo 1000)
        
        if [ "$output_dir_space" -lt "$min_space_mb" ]; then
            log_warning "Low disk space: ${output_dir_space}MB available (minimum: ${min_space_mb}MB)"
            return 1
        else
            log_success "Disk space check passed: ${output_dir_space}MB available"
        fi
    else
        log_info "Unable to check disk space (df not available)"
    fi
    
    return 0
}

# Pre-flight network connectivity checks
validate_network_connectivity() {
    if [ "$NETWORK_CHECK" = false ]; then
        log_info "Network checks disabled, skipping connectivity validation"
        return 0
    fi
    
    log_info "Validating network connectivity..."
    
    local connectivity_ok=false
    
    # Try to reach common DNS servers
    if command -v ping &> /dev/null; then
        if ping -c 1 -W 2 8.8.8.8 &>/dev/null || ping -c 1 -W 2 1.1.1.1 &>/dev/null; then
            connectivity_ok=true
        fi
    fi
    
    # Try DNS resolution
    if command -v nslookup &> /dev/null; then
        if nslookup google.com &>/dev/null; then
            connectivity_ok=true
        fi
    fi
    
    # Try HTTP request
    if command -v curl &> /dev/null; then
        if curl -s --max-time 5 --head https://www.google.com &>/dev/null; then
            connectivity_ok=true
        fi
    fi
    
    if [ "$connectivity_ok" = true ]; then
        log_success "Network connectivity validated"
        return 0
    else
        log_warning "Network connectivity check failed - some features may not work"
        return 1
    fi
}

# Validate DNS resolver security
check_dns_resolver() {
    log_info "Checking DNS resolver security..."
    
    local resolver_file="/etc/resolv.conf"
    
    if [ ! -f "$resolver_file" ]; then
        log_info "DNS resolver config not found (may be using system default)"
        return 0
    fi
    
    # Check for common secure DNS servers
    local secure_dns_found=false
    while IFS= read -r line; do
        if [[ "$line" =~ nameserver ]]; then
            # Check for Cloudflare, Google, Quad9 DNS
            if echo "$line" | grep -qE "1\.1\.1\.1|8\.8\.8\.8|9\.9\.9\.9"; then
                secure_dns_found=true
                log_success "Secure DNS resolver detected: $line"
            fi
        fi
    done < "$resolver_file"
    
    if [ "$secure_dns_found" = false ]; then
        log_info "Using system DNS resolver (may not be secure DNS provider)"
    fi
    
    return 0
}

################################################################################
# ERROR HANDLING FRAMEWORK
################################################################################

# Handle API timeout gracefully
handle_api_timeout() {
    local service="$1"
    local timeout_duration="${2:-30}"
    
    log_warning "API timeout for $service after ${timeout_duration}s"
    
    # Record timeout for circuit breaker
    local failure_file="$TEMP_DIR/failures_${service}.txt"
    echo "$(date +%s):timeout" >> "$failure_file" 2>/dev/null || true
    
    # Check if circuit should open
    implement_circuit_breaker "$service" 5
    
    return 1
}

# Handle malformed API response
handle_malformed_response() {
    local service="$1"
    local response="$2"
    
    log_warning "Malformed response from $service"
    
    # Log response snippet for debugging (first 100 chars)
    if [ -n "$response" ]; then
        local snippet="${response:0:100}"
        log_info "Response snippet: $snippet..."
    fi
    
    # Record malformed response
    local failure_file="$TEMP_DIR/failures_${service}.txt"
    echo "$(date +%s):malformed" >> "$failure_file" 2>/dev/null || true
    
    return 1
}

# Implement retry logic with exponential backoff
implement_retry_logic() {
    local service="$1"
    local command="$2"
    local max_retries="${3:-3}"
    local base_delay="${4:-2}"
    
    local attempt=1
    local delay=$base_delay
    
    while [ $attempt -le $max_retries ]; do
        log_info "Attempting $service (try $attempt/$max_retries)..."
        
        # Execute command
        if eval "$command" 2>/dev/null; then
            log_success "$service succeeded on attempt $attempt"
            return 0
        fi
        
        # Failed, check if we should retry
        if [ $attempt -lt $max_retries ]; then
            log_info "Retry $service in ${delay}s..."
            sleep $delay
            # Exponential backoff
            delay=$((delay * 2))
        fi
        
        ((attempt++))
    done
    
    log_warning "$service failed after $max_retries attempts"
    handle_api_timeout "$service" 0
    return 1
}

# Handle resource exhaustion
handle_resource_exhaustion() {
    local resource_type="$1"  # memory, disk, cpu
    local current_value="$2"
    local threshold="$3"
    
    log_warning "Resource exhaustion detected: $resource_type"
    log_info "Current: $current_value, Threshold: $threshold"
    
    case "$resource_type" in
        "memory")
            # Try to free memory
            if command -v sync &> /dev/null; then
                sync
            fi
            log_info "Attempting memory cleanup..."
            ;;
        "disk")
            # Clean up old temp files
            if [ -d "$TEMP_DIR" ]; then
                find "$TEMP_DIR" -type f -mtime +1 -delete 2>/dev/null || true
                log_info "Cleaned up old temporary files"
            fi
            ;;
        "cpu")
            # Reduce parallelism
            log_info "High CPU usage - reducing concurrent operations"
            ;;
    esac
    
    return 1
}

################################################################################
# PERFORMANCE OPTIMIZATION FRAMEWORK
################################################################################

# Parallel decoder analysis
parallel_decoder_analysis() {
    local image_file="$1"
    local max_parallel="${2:-4}"
    
    log_info "Running parallel decoder analysis (max $max_parallel concurrent)..."
    
    local pids=()
    local decoder_count=0
    
    # List of decoders to run in parallel
    local decoders=(
        "zbar"
        "pyzbar"
        "quirc"
        "zxing"
    )
    
    for decoder in "${decoders[@]}"; do
        # Check if we've reached max parallel
        if [ ${#pids[@]} -ge $max_parallel ]; then
            # Wait for one to finish
            wait -n 2>/dev/null || true
            # Remove finished PIDs
            pids=($(jobs -p))
        fi
        
        # Launch decoder in background
        (
            local result_file="$TEMP_DIR/decoder_${decoder}_$$.txt"
            # Run decoder based on type
            # AUDIT FIX: Wrap decoders with crash protection
            case "$decoder" in
                "zbar")
                    run_isolated_with_output 30 "$result_file" zbarimg -q "$image_file" || true
                    ;;
                "pyzbar")
                    # AUDIT FIX: Use safe Python script with base64-encoded path
                    local encoded_image_file
                    encoded_image_file=$(printf '%s' "$image_file" | base64 2>/dev/null) || true
                    local encoded_result_file
                    encoded_result_file=$(printf '%s' "$result_file" | base64 2>/dev/null) || true
                    run_isolated 30 python3 - "$encoded_image_file" "$encoded_result_file" 2>/dev/null <<'PYZBAR_DECODE' > "$result_file" || true
import sys
import base64
try:
    image_path = base64.b64decode(sys.argv[1] if len(sys.argv) > 1 else '').decode('utf-8')
    output_path = base64.b64decode(sys.argv[2] if len(sys.argv) > 2 else '').decode('utf-8')
    from pyzbar.pyzbar import decode
    from PIL import Image
    results = []
    with Image.open(image_path) as img:
        codes = decode(img)
        for c in codes:
            try:
                results.append(c.data.decode('utf-8'))
            except:
                results.append(c.data.decode('latin-1', errors='replace'))
    print('\n'.join(results))
except:
    pass
PYZBAR_DECODE
                    ;;
                *)
                    echo "" > "$result_file"
                    ;;
            esac
        ) &
        
        pids+=($!)
        ((decoder_count++))
    done
    
    # Wait for all remaining decoders
    wait 2>/dev/null || true
    
    log_success "Parallel decoder analysis complete: $decoder_count decoders"
    
    # Collect results
    cat "$TEMP_DIR"/decoder_*_$$.txt 2>/dev/null | sort -u
    rm -f "$TEMP_DIR"/decoder_*_$$.txt 2>/dev/null || true
    
    return 0
}

# Parallel threat intelligence checks
parallel_threat_intel_check() {
    local ioc="$1"
    local max_parallel="${2:-5}"
    
    log_info "Running parallel threat intel checks (max $max_parallel concurrent)..."
    
    local pids=()
    local check_count=0
    
    # List of threat intel checks to run in parallel
    local checks=(
        "check_virustotal:$VT_API_KEY"
        "check_abuseipdb:$ABUSEIPDB_API_KEY"
        "check_urlscan:$URLSCAN_API_KEY"
        "check_threatfox:enabled"
        "check_malwarebazaar:enabled"
    )
    
    for check_info in "${checks[@]}"; do
        local check_name="${check_info%%:*}"
        local check_key="${check_info##*:}"
        
        # Skip if no API key
        if [ "$check_key" = "enabled" ] || [ -n "$check_key" ]; then
            # Check if we've reached max parallel
            if [ ${#pids[@]} -ge $max_parallel ]; then
                wait -n 2>/dev/null || true
                pids=($(jobs -p))
            fi
            
            # Launch check in background
            (
                local result_file="$TEMP_DIR/threat_${check_name}_$$.txt"
                # Placeholder for actual check
                echo "checked:$check_name" > "$result_file" 2>/dev/null || true
            ) &
            
            pids+=($!)
            ((check_count++))
        fi
    done
    
    # Wait for all remaining checks
    wait 2>/dev/null || true
    
    log_success "Parallel threat intel checks complete: $check_count checks"
    
    # Cleanup
    rm -f "$TEMP_DIR"/threat_*_$$.txt 2>/dev/null || true
    
    return 0
}

# Cache threat intelligence with TTL
cache_threat_intel() {
    local feed_name="$1"
    local feed_url="$2"
    local ttl_seconds="${3:-3600}"  # Default 1 hour
    
    local cache_dir="${TEMP_DIR}/feed_cache"
    mkdir -p "$cache_dir" 2>/dev/null || true
    
    local cache_file="${cache_dir}/${feed_name}.cache"
    local cache_meta="${cache_dir}/${feed_name}.meta"
    
    # Check if cache exists and is fresh
    if [ -f "$cache_file" ] && [ -f "$cache_meta" ]; then
        local cached_time=$(cat "$cache_meta" 2>/dev/null || echo 0)
        local current_time=$(date +%s)
        local age=$((current_time - cached_time))
        
        if [ $age -lt $ttl_seconds ]; then
            log_info "Using cached threat intel for $feed_name (age: ${age}s)"
            cat "$cache_file"
            return 0
        else
            log_info "Cache expired for $feed_name (age: ${age}s, TTL: ${ttl_seconds}s)"
        fi
    fi
    
    # Download fresh feed
    log_info "Downloading fresh threat intel: $feed_name"
    
    if curl -sfL --max-time 30 "$feed_url" > "$cache_file" 2>/dev/null; then
        # Update cache metadata
        date +%s > "$cache_meta"
        log_success "Cached threat intel for $feed_name"
        cat "$cache_file"
        return 0
    else
        log_warning "Failed to download $feed_name, using stale cache if available"
        if [ -f "$cache_file" ]; then
            cat "$cache_file"
            return 0
        fi
        return 1
    fi
}

# Incremental YARA scan (skip unchanged content)
incremental_yara_scan() {
    local target_file="$1"
    local yara_rules="$2"
    
    # Generate content hash
    local content_hash=$(md5sum "$target_file" 2>/dev/null | cut -d' ' -f1 || echo "unknown")
    local scan_cache="$TEMP_DIR/yara_scan_cache.txt"
    
    # Check if we've scanned this content before
    if [ -f "$scan_cache" ]; then
        if grep -q "^${content_hash}:" "$scan_cache" 2>/dev/null; then
            log_info "YARA: Content unchanged, using cached results"
            grep "^${content_hash}:" "$scan_cache" | cut -d':' -f2-
            return 0
        fi
    fi
    
    # Run YARA scan
    log_info "YARA: Scanning new/modified content..."
    local scan_result
    
    if command -v yara &> /dev/null && [ -f "$yara_rules" ]; then
        scan_result=$(yara "$yara_rules" "$target_file" 2>/dev/null || echo "no_matches")
    else
        scan_result="yara_not_available"
    fi
    
    # Cache the result
    echo "${content_hash}:${scan_result}" >> "$scan_cache" 2>/dev/null || true
    
    # Clean up old cache entries (keep last 100)
    if [ -f "$scan_cache" ]; then
        tail -100 "$scan_cache" > "${scan_cache}.tmp" 2>/dev/null || true
        mv "${scan_cache}.tmp" "$scan_cache" 2>/dev/null || true
    fi
    
    echo "$scan_result"
    return 0
}

################################################################################
# COVERAGE ENHANCEMENTS
################################################################################

# Analyze DNS over HTTPS tunneling
analyze_dns_over_https() {
    set +u
    local content="${1:-}"
    set -u
    
    log_info "Analyzing for DNS over HTTPS (DoH) tunneling..."
    
    local doh_findings=()
    local doh_score=0
    
    # DoH providers/endpoints
    local doh_patterns=(
        "cloudflare-dns\.com"
        "dns\.google"
        "dns\.quad9\.net"
        "doh\.opendns\.com"
        "mozilla\.cloudflare-dns\.com"
        "dns\.adguard\.com"
        "/dns-query"
        "application/dns-message"
    )
    
    for pattern in "${doh_patterns[@]}"; do
        if echo "$content" | safe_grep_qiE "$pattern"; then
            doh_findings+=("doh_provider:$pattern")
            ((doh_score += 30))
            log_forensic_detection 30 \
                "DoH Provider Detected" \
                "pattern:$pattern" \
                "DNS over HTTPS endpoint detected" \
                "QR decoded content" \
                "DoH can be used for DNS tunneling and data exfiltration" \
                "MITRE ATT&CK T1071.004 - Application Layer Protocol: DNS"
        fi
    done
    
    # Suspicious DoH usage patterns
    if echo "$content" | safe_grep_qiE "base64.*dns-query|dns-query.*base64"; then
        doh_findings+=("encoded_doh_query")
        ((doh_score += 50))
        log_forensic_detection 50 \
            "Encoded DoH Query" \
            "technique:Base64 encoded DNS query" \
            "Suspicious encoded DNS over HTTPS query" \
            "QR decoded content" \
            "Encoded DoH queries may indicate data exfiltration" \
            "MITRE ATT&CK T1048 - Exfiltration Over Alternative Protocol"
    fi
    
    if [ ${#doh_findings[@]} -gt 0 ]; then
        log_threat $((doh_score / 2)) "DNS over HTTPS tunneling indicators: ${doh_findings[*]}"
        analysis_success_found "DoH Tunneling" "${#doh_findings[@]}" "Score: $doh_score" "${doh_findings[*]}"
    fi
}

# Validate extended cryptocurrency addresses
validate_extended_crypto() {
    local address="$1"
    
    # Litecoin addresses (starts with L or M)
    if [[ "$address" =~ ^[LM][a-km-zA-HJ-NP-Z1-9]{26,33}$ ]]; then
        return 0
    fi
    
    # Dogecoin addresses (starts with D)
    if [[ "$address" =~ ^D[5-9A-HJ-NP-U][1-9A-HJ-NP-Za-km-z]{32}$ ]]; then
        return 0
    fi
    
    # Monero addresses (starts with 4 or 8)
    if [[ "$address" =~ ^[48][0-9AB][1-9A-HJ-NP-Za-km-z]{93}$ ]]; then
        return 0
    fi
    
    # Ripple (XRP) addresses (starts with r)
    if [[ "$address" =~ ^r[1-9A-HJ-NP-Za-km-z]{25,34}$ ]]; then
        return 0
    fi
    
    # Cardano addresses (starts with addr1)
    if [[ "$address" =~ ^addr1[a-z0-9]{98}$ ]]; then
        return 0
    fi
    
    # Solana addresses (32-44 base58 chars)
    if [[ "$address" =~ ^[1-9A-HJ-NP-Za-km-z]{32,44}$ ]]; then
        return 0
    fi
    
    return 1
}

# Integrate OpenCTI threat intelligence
integrate_opencti() {
    local ioc="$1"
    local opencti_url="${OPENCTI_URL:-}"
    local opencti_key="${OPENCTI_API_KEY:-}"
    
    if [ -z "$opencti_url" ] || [ -z "$opencti_key" ]; then
        log_info "OpenCTI not configured (set OPENCTI_URL and OPENCTI_API_KEY)"
        return 0
    fi
    
    log_info "Querying OpenCTI for IOC: $ioc"
    
    # Query OpenCTI GraphQL API
    local query='{"query":"query { indicators(filters: {key: \"value\", values: [\"'$ioc'\"]}) { edges { node { id name pattern indicator_types created_at } } } }"}'
    
    local response=$(curl -sf --max-time 30 \
        -H "Authorization: ******" \
        -H "Content-Type: application/json" \
        -d "$query" \
        "${opencti_url}/graphql" 2>/dev/null)
    
    if [ -n "$response" ]; then
        local indicator_count=$(echo "$response" | jq -r '.data.indicators.edges | length' 2>/dev/null || echo 0)
        
        if [ "$indicator_count" -gt 0 ]; then
            log_threat 60 "OpenCTI: Found $indicator_count threat indicators for $ioc"
            echo "$response" > "${EVIDENCE_DIR}/opencti_${ioc//[^a-zA-Z0-9]/_}.json" 2>/dev/null || true
            record_ioc "opencti_indicator" "$ioc" "OpenCTI Threat Intelligence"
        else
            log_info "OpenCTI: No indicators found for $ioc"
        fi
    else
        log_warning "OpenCTI query failed or timed out"
    fi
    
    return 0
}

# Detect developer platform abuse
detect_developer_platform_abuse() {
    local content="$1"
    
    log_info "Analyzing for developer platform abuse..."
    
    local devplat_findings=()
    local devplat_score=0
    
    # GitHub abuse patterns
    if echo "$content" | safe_grep_qiE "github\.com.*token|gist\.github.*password|github.*credential"; then
        devplat_findings+=("github_credential_exposure")
        ((devplat_score += 70))
        log_forensic_detection 70 \
            "GitHub Credential Exposure" \
            "pattern:GitHub credential in QR" \
            "GitHub access token or credential detected" \
            "QR decoded content" \
            "Exposed GitHub credentials can lead to code repository compromise" \
            "MITRE ATT&CK T1528 - Steal Application Access Token"
    fi
    
    # GitLab abuse patterns
    if echo "$content" | safe_grep_qiE "gitlab\.com.*token|gitlab.*api.*key"; then
        devplat_findings+=("gitlab_credential_exposure")
        ((devplat_score += 70))
        log_forensic_detection 70 \
            "GitLab Credential Exposure" \
            "pattern:GitLab credential in QR" \
            "GitLab access token detected" \
            "QR decoded content" \
            "Exposed GitLab credentials can compromise repositories" \
            "MITRE ATT&CK T1528 - Steal Application Access Token"
    fi
    
    # CI/CD pipeline abuse
    if echo "$content" | safe_grep_qiE "jenkins.*token|travis.*token|circleci.*token|GITHUB_TOKEN"; then
        devplat_findings+=("cicd_token_exposure")
        ((devplat_score += 75))
        log_forensic_detection 75 \
            "CI/CD Token Exposure" \
            "pattern:CI/CD access token" \
            "CI/CD pipeline access token detected" \
            "QR decoded content" \
            "Exposed CI/CD tokens enable supply chain attacks" \
            "MITRE ATT&CK T1195 - Supply Chain Compromise"
    fi
    
    # NPM/PyPI package manager abuse
    if echo "$content" | safe_grep_qiE "npmjs\.com.*token|pypi\.org.*token|npm.*_auth"; then
        devplat_findings+=("package_manager_token")
        ((devplat_score += 75))
        log_forensic_detection 75 \
            "Package Manager Token" \
            "pattern:NPM/PyPI access token" \
            "Package repository access token detected" \
            "QR decoded content" \
            "Exposed package manager tokens enable malicious package publishing" \
            "MITRE ATT&CK T1195.002 - Compromise Software Supply Chain"
    fi
    
    # Docker Hub / container registry abuse
    if echo "$content" | safe_grep_qiE "docker\.com.*token|docker.*login|dockerhub.*password"; then
        devplat_findings+=("container_registry_credential")
        ((devplat_score += 65))
        log_forensic_detection 65 \
            "Container Registry Credential" \
            "pattern:Docker/container registry credential" \
            "Container registry access credential detected" \
            "QR decoded content" \
            "Exposed container registry credentials enable malicious image distribution" \
            "MITRE ATT&CK T1525 - Implant Internal Image"
    fi
    
    if [ ${#devplat_findings[@]} -gt 0 ]; then
        log_threat $((devplat_score / 2)) "Developer platform abuse: ${devplat_findings[*]}"
        analysis_success_found "Developer Platform Abuse" "${#devplat_findings[@]}" "Score: $devplat_score" "${devplat_findings[*]}"
    fi
}

################################################################################
# DEPENDENCY VERIFICATION
################################################################################

################################################################################
# AUTO-DEPENDENCY DETECTION SYSTEM FOR MACOS
# Automatically finds dependencies in common locations
################################################################################

# Store discovered paths for dependencies
declare -A DISCOVERED_PATHS=()
declare -A DISCOVERED_PYTHON_MODULES=()

# Common macOS locations for dependencies
HOMEBREW_INTEL="/usr/local"
HOMEBREW_ARM="/opt/homebrew"
MACPORTS="/opt/local"
SYSTEM_PATHS="/usr/bin:/bin:/usr/sbin:/sbin"

# Auto-detect Homebrew prefix
auto_detect_homebrew_prefix() {
    if [[ -d "$HOMEBREW_ARM" ]]; then
        echo "$HOMEBREW_ARM"
    elif [[ -d "$HOMEBREW_INTEL" ]]; then
        echo "$HOMEBREW_INTEL"
    else
        echo ""
    fi
}

HOMEBREW_PREFIX=$(auto_detect_homebrew_prefix)

# Search paths for finding executables
get_search_paths() {
    local paths="$SYSTEM_PATHS"
    [[ -n "$HOMEBREW_PREFIX" ]] && paths="$HOMEBREW_PREFIX/bin:$HOMEBREW_PREFIX/sbin:$paths"
    [[ -d "$MACPORTS/bin" ]] && paths="$MACPORTS/bin:$paths"
    [[ -d "$HOME/.local/bin" ]] && paths="$HOME/.local/bin:$paths"
    [[ -d "$HOME/bin" ]] && paths="$HOME/bin:$paths"
    
    # Add additional search paths for various package managers and installations
    [[ -d "/opt/homebrew/bin" ]] && paths="/opt/homebrew/bin:$paths"
    [[ -d "/usr/local/bin" ]] && paths="/usr/local/bin:$paths"
    [[ -d "/opt/local/bin" ]] && paths="/opt/local/bin:$paths"
    [[ -d "/snap/bin" ]] && paths="/snap/bin:$paths"
    [[ -d "/usr/games" ]] && paths="/usr/games:$paths"
    [[ -d "/usr/local/go/bin" ]] && paths="/usr/local/go/bin:$paths"
    [[ -d "$HOME/go/bin" ]] && paths="$HOME/go/bin:$paths"
    
    echo "$paths"
}

# Find executable in multiple locations
find_executable() {
    local cmd="$1"
    local search_paths
    
    # First check if already in PATH using command -v
    if command -v "$cmd" &>/dev/null; then
        DISCOVERED_PATHS["$cmd"]=$(command -v "$cmd")
        return 0
    fi
    
    # Check PATH environment variable explicitly
    if [[ -n "${PATH:-}" ]]; then
        IFS=':' read -ra path_env <<< "$PATH"
        for path in "${path_env[@]}"; do
            if [[ -x "$path/$cmd" ]]; then
                DISCOVERED_PATHS["$cmd"]="$path/$cmd"
                return 0
            fi
        done
    fi
    
    # Search in common locations using our extended search paths
    search_paths=$(get_search_paths)
    IFS=':' read -ra path_array <<< "$search_paths"
    
    for path in "${path_array[@]}"; do
        if [[ -x "$path/$cmd" ]]; then
            DISCOVERED_PATHS["$cmd"]="$path/$cmd"
            return 0
        fi
    done
    
    return 1
}

# Auto-detect Python installation
auto_detect_python() {
    local python_paths=(
        # Priority 1: Activated virtual environment
        "${VIRTUAL_ENV}/bin/python3"
        "${VIRTUAL_ENV}/bin/python"
        # Priority 2: Local .venv in current directory
        ".venv/bin/python3"
        ".venv/bin/python"
        "venv/bin/python3"
        "venv/bin/python"
        # Priority 3: User home .venv
        "$HOME/.venv/bin/python3"
        "$HOME/.venv/bin/python"
        # Priority 4: System Python
        "python3"
        "python"
        "$HOMEBREW_PREFIX/bin/python3"
        "$HOMEBREW_PREFIX/bin/python"
        "/usr/local/bin/python3"
        "/usr/local/bin/python"
        "/opt/homebrew/bin/python3"
        "/opt/homebrew/bin/python"
        "/usr/bin/python3"
        "/usr/bin/python"
        "$HOME/.pyenv/shims/python3"
        "$HOME/.pyenv/shims/python"
        "$HOME/.local/bin/python3"
        "$HOME/.local/bin/python"
        "/opt/local/bin/python3"
        "/usr/local/Cellar/python*/*/bin/python3"
    )
    
    # Required modules for this script - used to score Python installations
    local required_modules=("PIL" "imagehash" "numpy" "pyzbar" "transformers")
    
    local best_python=""
    local best_pip=""
    local best_score=0
    
    # Score each Python by how many required modules it has
    for py_pattern in "${python_paths[@]}"; do
        # Handle glob patterns
        for py in $py_pattern; do
            # Skip if not executable
            [[ ! -x "$py" ]] && continue
            
            # Check if it's actually Python 3
            if ! "$py" --version 2>&1 | grep -q "Python 3"; then
                continue
            fi
            
            local score=0
            for mod in "${required_modules[@]}"; do
                # Handle PIL -> Pillow naming
                local import_name="$mod"
                if "$py" -c "import $import_name" 2>/dev/null; then
                    ((score++))
                fi
            done
            
            # Prefer Python with more modules installed
            echo "DEBUG: $py scored $score (best so far: $best_score)" >&2
            if [[ $score -gt $best_score ]]; then
                best_score=$score
                best_python="$py"
                local pip_path="${py%python*}pip3"
                [[ -x "$pip_path" ]] && best_pip="$pip_path"
            fi
            
            # If we haven't found ANY Python yet, use this as fallback
            if [[ -z "$best_python" ]]; then
                best_python="$py"
                local pip_path="${py%python*}pip3"
                [[ -x "$pip_path" ]] && best_pip="$pip_path"
            fi
        done
    done
    
    # Use the best Python found
    if [[ -n "$best_python" ]]; then
        DISCOVERED_PATHS["python3"]="$best_python"
        DISCOVERED_PATHS["python"]="$best_python"
        [[ -n "$best_pip" ]] && DISCOVERED_PATHS["pip3"]="$best_pip"
        return 0
    fi
    
    # Try pyenv
    if command -v pyenv &>/dev/null; then
        local pyenv_python=$(pyenv which python3 2>/dev/null)
        if [[ -n "$pyenv_python" ]]; then
            DISCOVERED_PATHS["python3"]="$pyenv_python"
            DISCOVERED_PATHS["python"]="$pyenv_python"
            return 0
        fi
    fi
    
    # Try conda
    if command -v conda &>/dev/null; then
        local conda_python=$(conda run which python3 2>/dev/null)
        if [[ -n "$conda_python" ]]; then
            DISCOVERED_PATHS["python3"]="$conda_python"
            DISCOVERED_PATHS["python"]="$conda_python"
            return 0
        fi
    fi
    
    return 1
}

# Auto-detect pip installation
auto_detect_pip() {
    local pip_paths=(
        "$HOME/.venv/bin/pip3"
        "$HOME/.venv/bin/pip"
        "pip3"
        "pip"
        "$HOMEBREW_PREFIX/bin/pip3"
        "$HOMEBREW_PREFIX/bin/pip"
        "/usr/local/bin/pip3"
        "/usr/local/bin/pip"
        "/opt/homebrew/bin/pip3"
        "/opt/homebrew/bin/pip"
        "/usr/bin/pip3"
        "/usr/bin/pip"
        "$HOME/.local/bin/pip3"
        "$HOME/.local/bin/pip"
        "$HOME/Library/Python/3.*/bin/pip3"
        "$HOME/Library/Python/3.*/bin/pip"
    )
    
    for pip_pattern in "${pip_paths[@]}"; do
        # Handle glob patterns
        for pip in $pip_pattern; do
            if [[ -x "$pip" ]]; then
                DISCOVERED_PATHS["pip3"]="$pip"
                DISCOVERED_PATHS["pip"]="$pip"
                return 0
            fi
        done
    done
    
    # Try using python -m pip
    if [[ -n "${DISCOVERED_PATHS[python3]:-}" ]]; then
        local python_cmd="${DISCOVERED_PATHS[python3]}"
        if "$python_cmd" -m pip --version &>/dev/null; then
            DISCOVERED_PATHS["pip3"]="$python_cmd -m pip"
            DISCOVERED_PATHS["pip"]="$python_cmd -m pip"
            return 0
        fi
    fi
    
    return 1
}

# Get Python module installation paths
get_python_site_packages() {
    local python_cmd="${DISCOVERED_PATHS[python3]:-python3}"
    
    "$python_cmd" 2>/dev/null <<EOF
import sys
import site
paths = site.getsitepackages() + [site.getusersitepackages()]
for p in paths:
    print(p)
EOF
}

# Check if a Python module is installed (with multiple detection methods)
check_python_module() {
    local module="$1"
    local python_cmd="${DISCOVERED_PATHS[python3]:-python3}"
    
    # Handle special module-to-package name mappings for pip show
    local pip_package="$module"
    case "$module" in
        "PIL") pip_package="Pillow" ;;
        "cv2") pip_package="opencv-python" ;;
        "sklearn") pip_package="scikit-learn" ;;
        "zxingcpp") pip_package="zxing-cpp" ;;
        "dbr") pip_package="dynamsoft-barcode-reader" ;;
    esac
    
    # Method 1: Direct import test (most reliable)
    if "$python_cmd" -c "import $module" 2>/dev/null; then
        DISCOVERED_PYTHON_MODULES["$module"]="installed"
        return 0
    fi
    
    # Method 2: Check with pip list (handles package names correctly)
    local pip_cmd="${DISCOVERED_PATHS[pip3]:-pip3}"
    if command -v "$pip_cmd" &>/dev/null || [[ "$pip_cmd" == *"-m pip"* ]]; then
        if $pip_cmd list 2>/dev/null | grep -qiE "^${pip_package}[[:space:]]"; then
            # Double-check with import to make sure it's actually usable
            if "$python_cmd" -c "import $module" 2>/dev/null; then
                DISCOVERED_PYTHON_MODULES["$module"]="installed"
                return 0
            fi
        fi
    fi
    
    # Method 3: Check with pip show
    if $pip_cmd show "$pip_package" &>/dev/null 2>&1; then
        # Double-check with import
        if "$python_cmd" -c "import $module" 2>/dev/null; then
            DISCOVERED_PYTHON_MODULES["$module"]="installed"
            return 0
        fi
    fi
    
    # Method 4: Check in site-packages directories
    while IFS= read -r site_pkg; do
        [[ -z "$site_pkg" || ! -d "$site_pkg" ]] && continue
        
        if [[ -d "$site_pkg/$module" ]] || [[ -f "$site_pkg/${module}.py" ]]; then
            DISCOVERED_PYTHON_MODULES["$module"]="installed"
            return 0
        fi
        
        # Handle packages with different naming (e.g., PIL for Pillow)
        if [[ "$module" == "PIL" ]] && [[ -d "$site_pkg/PIL" || -d "$site_pkg/Pillow" ]]; then
            DISCOVERED_PYTHON_MODULES["$module"]="installed"
            return 0
        fi
        
        # Check for zxingcpp in zxing_cpp directory
        if [[ "$module" == "zxingcpp" ]] && [[ -d "$site_pkg/zxing_cpp" ]]; then
            DISCOVERED_PYTHON_MODULES["$module"]="installed"
            return 0
        fi
    done < <(get_python_site_packages)
    
    # Method 5: Check Homebrew site-packages specifically
    for py_version in 3.9 3.10 3.11 3.12 3.13; do
        local homebrew_site="$HOMEBREW_PREFIX/lib/python$py_version/site-packages"
        [[ ! -d "$homebrew_site" ]] && continue
        
        if [[ -d "$homebrew_site/$module" ]] || [[ -f "$homebrew_site/${module}.py" ]]; then
            DISCOVERED_PYTHON_MODULES["$module"]="installed"
            return 0
        fi
    done
    
    DISCOVERED_PYTHON_MODULES["$module"]="not_found"
    return 1
}

# Get installation command for missing Python module
get_python_module_install_cmd() {
    local module="$1"
    local pip_cmd="${DISCOVERED_PATHS[pip3]:-pip3}"
    
    # Handle special module name mappings (import name -> pip package name)
    case "$module" in
        "PIL") echo "$pip_cmd install Pillow" ;;
        "cv2") echo "$pip_cmd install opencv-python" ;;
        "sklearn") echo "$pip_cmd install scikit-learn" ;;
        "zxingcpp") echo "$pip_cmd install zxing-cpp" ;;
        "dbr") echo "$pip_cmd install dynamsoft-barcode-reader" ;;
        "pyzbar") echo "$pip_cmd install pyzbar" ;;
        "qreader") echo "$pip_cmd install qreader" ;;
        "pyzxing") echo "$pip_cmd install pyzxing" ;;
        *) echo "$pip_cmd install $module" ;;
    esac
}

# Run auto-detection for all dependencies
run_auto_detection() {
    log_info "Auto-detecting dependencies on macOS..."
    
    # Detect Python first
    auto_detect_python
    if [[ -n "${DISCOVERED_PATHS[python3]:-}" ]]; then
        log_info "  Found Python: ${DISCOVERED_PATHS[python3]:-}"
    fi
    
    # Detect pip
    auto_detect_pip
    if [[ -n "${DISCOVERED_PATHS[pip3]:-}" ]]; then
        log_info "  Found pip: ${DISCOVERED_PATHS[pip3]:-}"
    fi
    
    # Common tools to detect
    local tools=("zbarimg" "convert" "identify" "exiftool" "ssdeep" "yara"
                 "tesseract" "jq" "curl" "xxd" "strings" "openssl" "whois"
                 "binwalk" "foremost" "pngcheck" "dig" "host")
    
    for tool in "${tools[@]}"; do
        if find_executable "$tool"; then
            [[ "$VERBOSE" == true ]] && log_info "  Found $tool: ${DISCOVERED_PATHS[$tool]:-}"
        fi
    done
    
    # Check Python modules
    local py_modules=("PIL" "imagehash" "transformers" "pyzbar" "numpy" "cv2" "zxingcpp" "qreader" "pyzxing" "dbr")
    for mod in "${py_modules[@]}"; do
        check_python_module "$mod"
        if [[ "${DISCOVERED_PYTHON_MODULES[$mod]:-}" == "installed" ]]; then
            [[ "$VERBOSE" == true ]] && log_info "  Found Python module: $mod"
        fi
    done
    
    # Create python3 wrapper function to use discovered path
    # This allows heredoc-style python calls to work with auto-detected path
    if [[ -n "${DISCOVERED_PATHS[python3]:-}" ]]; then
        # Override python3 command in this script's context
        python3() {
            "${DISCOVERED_PATHS[python3]:-python3}" "$@"
        }
        export -f python3 2>/dev/null || true
    fi
    
    log_success "Auto-detection complete"
}

# Get the path for a discovered dependency
get_dep_path() {
    local dep="$1"
    echo "${DISCOVERED_PATHS[$dep]:-$dep}"
}

# Get Python command - returns the auto-detected path or fallback
get_python_cmd() {
    echo "${DISCOVERED_PATHS[python3]:-python3}"
}

# Safe module pre-check with crash protection
safe_check_python_module() {
    local module="$1"
    local python_cmd=$(get_python_cmd)
    
    [[ -z "$python_cmd" ]] && return 1
    
    # Isolated check with crash protection
    (
        trap 'exit 139' SEGV ABRT BUS FPE
        ulimit -c 0 2>/dev/null
        ulimit -t 5 2>/dev/null  # CPU time limit
        ulimit -v $((512 * 1024)) 2>/dev/null  # 512MB memory limit
        exec 2>/dev/null
        
        timeout 5 "$python_cmd" -c "
import sys
import signal
signal.signal(signal.SIGSEGV, lambda s,f: sys.exit(139))
signal.signal(signal.SIGABRT, lambda s,f: sys.exit(134))

try:
    import resource
    resource.setrlimit(resource.RLIMIT_CORE, (0, 0))
    resource.setrlimit(resource.RLIMIT_AS, (512 * 1024 * 1024, 512 * 1024 * 1024))
except:
    pass

import ${module}
" 2>/dev/null
    ) 2>/dev/null
    
    local status=$?
    [[ $status -eq 0 ]]
}

# Execute Python code with auto-detected Python
run_python() {
    local python_cmd
    python_cmd=$(get_python_cmd)
    "$python_cmd" "$@"
}

# Check if Python module is available
is_python_module_available() {
    local module="$1"
    # Use default empty string to avoid unbound variable error with set -u
    [[ "${DISCOVERED_PYTHON_MODULES[$module]:-}" == "installed" ]]
}

declare -A REQUIRED_DEPS=(
    ["zbarimg"]="QR code decoding"
    ["python3"]="Advanced analysis"
    ["file"]="File type detection"
    ["hexdump"]="Binary analysis"
    ["awk"]="Text processing"
    ["grep"]="Pattern matching"
    ["sed"]="Stream editing"
    ["jq"]="JSON processing"
    ["curl"]="Network requests"
)

declare -A OPTIONAL_DEPS=(
    ["convert"]="ImageMagick - image analysis"
    ["compare"]="ImageMagick - diff analysis"
    ["tesseract"]="OCR analysis"
    ["exiftool"]="Metadata extraction"
    ["ssdeep"]="Fuzzy hashing"
    ["yara"]="Pattern matching"
    ["tshark"]="Network analysis"
    ["xxd"]="Hex viewing"
    ["strings"]="String extraction"
    ["openssl"]="Cryptographic operations"
    ["quirc"]="Alternative QR decoder"
    ["zxing"]="ZXing QR decoder"
    ["qrdecode"]="libqrencode QR decoder"
    ["steghide"]="Steganography detection"
    ["zsteg"]="PNG steganography detection"
    ["stegdetect"]="Steganography detection"
    ["whois"]="Domain registration lookup"
    ["identify"]="ImageMagick identify tool"
    ["nmap"]="Port scanning"
    ["nc"]="Network connections"
    ["dig"]="DNS queries"
    ["host"]="DNS lookups"
    ["binwalk"]="Binary analysis"
    ["foremost"]="File carving"
    ["pngcheck"]="PNG validation"
    ["jpeginfo"]="JPEG validation"
    ["pdftotext"]="PDF text extraction"
    ["ffmpeg"]="Media analysis"
    ["trid"]="File type identification"
    ["diec"]="DIE Console for PE analysis"
    ["radare2"]="Reverse engineering framework"
    ["volatility"]="Memory forensics"
    # Extended barcode decoders (added)
    ["java"]="Java runtime for ZXing/BoofCV decoders"
    ["node"]="Node.js for bwip-js/jsQR decoders"
    ["decodeqr"]="libdecodeqr C/C++ decoder"
    ["qrdecoder"]="Alternative libdecodeqr decoder"
    ["dmtxread"]="libdmtx DataMatrix decoder"
)

check_dependencies() {
    log_info "Checking dependencies..."
    
    # Run auto-detection first
    run_auto_detection
    
    local missing_required=()
    local missing_optional=()
    
    for cmd in "${!REQUIRED_DEPS[@]}"; do
        if ! find_executable "$cmd"; then
            missing_required+=("$cmd (${REQUIRED_DEPS[$cmd]})")
        fi
    done
    
    for cmd in "${!OPTIONAL_DEPS[@]}"; do
        if ! find_executable "$cmd"; then
            missing_optional+=("$cmd (${OPTIONAL_DEPS[$cmd]})")
        fi
    done
    
    if [ ${#missing_required[@]} -ne 0 ]; then
        log_error "Missing required dependencies:"
        printf '%s\n' "${missing_required[@]}" >&2
        echo -e "\n${YELLOW}Install with:${NC}"
        echo "brew install zbar python3 coreutils grep gnu-sed jq curl"
        echo "pip3 install pillow pyzbar"
        echo ""
        echo -e "${YELLOW}For extended barcode decoders (38 total):${NC}"
        echo "brew install tesseract libdmtx node golang"
        echo "pip3 install opencv-python pyzxing qreader zxing-cpp dbr"
        echo "npm install -g jsqr jimp"
        echo ""
        echo -e "${YELLOW}Supported barcode formats:${NC}"
        echo "  2D: QR, DataMatrix, Aztec, PDF417, MaxiCode, Han Xin, DotCode, Grid Matrix, rMQR"
        echo "  1D: Code 128, Code 39, Code 93, Codabar, EAN-13/8, UPC-A/E, ITF, Composite"
        exit 1
    fi
    
    if [ ${#missing_optional[@]} -ne 0 ] && [ "$VERBOSE" = true ]; then
        log_warning "Missing optional dependencies (reduced functionality):"
        printf '%s\n' "${missing_optional[@]}"
    fi
    
    # Check Python modules using auto-detection system
    local py_modules_status=""
    for module in PIL imagehash transformers numpy pyzbar cv2 pyzxing qreader zxingcpp dbr; do
        if is_python_module_available "$module"; then
            py_modules_status+="${GREEN}✓${NC} $module  "
        else
            py_modules_status+="${YELLOW}○${NC} $module  "
        fi
    done
    
    if [[ "$VERBOSE" == true ]]; then
        echo -e "${CYAN}Python modules:${NC} $py_modules_status"
    fi
    
    # Show discovered paths summary
    if [[ "$VERBOSE" == true ]]; then
        echo ""
        echo -e "${CYAN}Discovered Dependency Paths:${NC}"
        for dep in "${!DISCOVERED_PATHS[@]}"; do
            echo -e "  ${WHITE}$dep:${NC} ${DISCOVERED_PATHS[$dep]}"
        done
    fi
    
    log_success "Dependency check complete"
}

################################################################################
# COMPREHENSIVE IOC DATABASES - HARDCODED (2000+ entries)
################################################################################

# MASSIVE MALICIOUS DOMAINS DATABASE
declare -a HARDCODED_MALICIOUS_DOMAINS=(
    # Known phishing domains - PayPal variants
    "paypal-secure-login.tk"
    "paypal-verify-account.ml"
    "paypal-support-team.ga"
    "paypal-resolution.cf"
    "paypal-update-billing.gq"
    "paypal-security-team.xyz"
    "secure-paypal-login.tk"
    "paypal-resolution-center.ml"
    "paypal-account-limitation.ga"
    "paypal-verify-identity.cf"
    "paypal-unlock-account.gq"
    "paypal-transaction-alert.xyz"
    "paypal-dispute-center.top"
    "paypal-refund-pending.click"
    "paypal-confirm-payment.loan"
    "paypal-update-info.download"
    "paypal-security-alert.stream"
    "paypal-account-verify.science"
    "paypal-login-secure.racing"
    "paypal-billing-update.review"
    # Amazon variants
    "amazon-account-verify.cf"
    "amazon-security-update.gq"
    "amazon-prime-renewal.cf"
    "amazon-order-confirmation.gq"
    "amazon-delivery-update.tk"
    "amazon-refund-pending.ml"
    "amazon-seller-central.ga"
    "amazon-aws-billing.cf"
    "amazon-prime-video.gq"
    "amazon-kindle-support.xyz"
    "amazon-alexa-help.top"
    "amazon-music-billing.click"
    "amazon-fresh-delivery.loan"
    "amazon-warehouse-deals.download"
    "amazon-business-account.stream"
    "amazon-web-services.science"
    "amazon-gift-card.racing"
    "amazon-seller-fees.review"
    "amazon-storefront.work"
    "amazon-logistics.party"
    # Netflix variants
    "netflix-billing-update.tk"
    "netflix-payment-failed.tk"
    "netflix-account-suspended.ml"
    "netflix-verify-payment.ga"
    "netflix-subscription-expired.cf"
    "netflix-update-billing.gq"
    "netflix-security-alert.xyz"
    "netflix-password-reset.top"
    "netflix-streaming-error.click"
    "netflix-premium-offer.loan"
    "netflix-free-trial.download"
    "netflix-family-plan.stream"
    "netflix-4k-upgrade.science"
    "netflix-download-limit.racing"
    "netflix-profile-update.review"
    # Microsoft variants
    "microsoft-security-alert.ml"
    "microsoft-account-security.ml"
    "microsoft-365-renewal.tk"
    "microsoft-office-update.ga"
    "microsoft-azure-billing.cf"
    "microsoft-teams-invite.gq"
    "microsoft-onedrive-full.xyz"
    "microsoft-outlook-verify.top"
    "microsoft-windows-update.click"
    "microsoft-xbox-billing.loan"
    "microsoft-surface-support.download"
    "microsoft-edge-update.stream"
    "microsoft-defender-alert.science"
    "microsoft-cortana-setup.racing"
    "microsoft-sharepoint-access.review"
    "microsoft-powerbi-trial.work"
    "microsoft-dynamics-365.party"
    "microsoft-intune-setup.gdn"
    "microsoft-vscode-update.mom"
    "microsoft-github-billing.xin"
    # Apple variants
    "apple-id-verify.ga"
    "apple-icloud-storage.ga"
    "apple-security-verify.tk"
    "apple-id-locked.ml"
    "apple-payment-update.cf"
    "apple-music-billing.gq"
    "apple-tv-subscription.xyz"
    "apple-arcade-free.top"
    "apple-fitness-trial.click"
    "apple-news-upgrade.loan"
    "apple-care-extend.download"
    "apple-watch-setup.stream"
    "apple-airpods-register.science"
    "apple-macbook-support.racing"
    "apple-ipad-warranty.review"
    "apple-iphone-unlock.work"
    "apple-developer-verify.party"
    # Google variants
    "google-security-check.cf"
    "google-workspace-admin.cf"
    "google-account-recovery.tk"
    "google-drive-storage.ml"
    "google-photos-backup.ga"
    "google-play-billing.gq"
    "google-ads-billing.xyz"
    "google-cloud-verify.top"
    "google-meet-invite.click"
    "google-calendar-share.loan"
    "google-maps-api.download"
    "google-translate-pro.stream"
    "google-assistant-setup.science"
    "google-home-connect.racing"
    "google-nest-verify.review"
    "google-pixel-support.work"
    "google-youtube-partner.party"
    "google-stadia-pro.gdn"
    "google-fiber-billing.mom"
    "google-fi-activate.xin"
    # Facebook/Meta variants
    "facebook-security-team.gq"
    "facebook-account-recovery.tk"
    "facebook-page-verify.ml"
    "facebook-ad-review.ga"
    "facebook-marketplace-pay.cf"
    "facebook-dating-verify.gq"
    "facebook-gaming-creator.xyz"
    "facebook-messenger-security.top"
    "facebook-instagram-link.click"
    "facebook-whatsapp-backup.loan"
    "facebook-oculus-setup.download"
    "facebook-portal-connect.stream"
    "facebook-business-verify.science"
    "facebook-creator-studio.racing"
    "facebook-shops-setup.review"
    "meta-verify-account.tk"
    "meta-business-suite.ml"
    "meta-quest-setup.ga"
    "meta-horizon-worlds.cf"
    "meta-spark-ar.gq"
    # Banking trojans and financial phishing
    "banking-trojan-drop.work"
    "financial-malware.party"
    "credential-stealer.gdn"
    "bank-of-america-verify.tk"
    "chase-security-alert.ml"
    "wells-fargo-update.ga"
    "citi-bank-verify.cf"
    "capital-one-alert.gq"
    "td-bank-security.xyz"
    "pnc-bank-update.top"
    "us-bank-verify.click"
    "truist-security-alert.loan"
    "regions-bank-update.download"
    "hsbc-verify-account.stream"
    "barclays-security.science"
    "natwest-verify.racing"
    "lloyds-update.review"
    "santander-alert.work"
    "deutsche-bank-verify.party"
    "bnp-paribas-security.gdn"
    # Known malware C2 domains
    "evil-c2-server.xyz"
    "malware-drop-zone.top"
    "ransomware-payment.onion"
    "botnet-controller.click"
    "exploit-kit-landing.loan"
    "c2-server-alpha.info"
    "c2-server-beta.club"
    "c2-server-gamma.online"
    "command-control-delta.ws"
    "cnc-epsilon.buzz"
    "beacon-server-alpha.link"
    "callback-handler-beta.top"
    "exfil-gateway-gamma.click"
    "dropper-server-delta.loan"
    "loader-endpoint-epsilon.download"
    "stager-server-zeta.stream"
    "implant-c2-eta.science"
    "rat-controller-theta.racing"
    "backdoor-server-iota.review"
    "shell-handler-kappa.work"
    # APT infrastructure domains
    "apt-command-control.info"
    "nation-state-actor.club"
    "advanced-persistent.online"
    "apt28-infrastructure.xyz"
    "apt29-beacon.top"
    "apt38-dropper.click"
    "apt41-loader.loan"
    "lazarus-group-c2.download"
    "cozy-bear-server.stream"
    "fancy-bear-beacon.science"
    "equation-group-drop.racing"
    "turla-implant-c2.review"
    "sandworm-controller.work"
    "kimsuky-dropper.party"
    "muddy-water-c2.gdn"
    "apt32-ocean-lotus.mom"
    "apt33-elfin.xin"
    "apt34-oilrig.kim"
    "apt35-charming-kitten.men"
    "apt37-reaper.win"
    # Cryptojacking domains
    "coinhive-proxy.ws"
    "cryptonight-miner.buzz"
    "monero-pool-proxy.link"
    "browser-miner-cdn.xyz"
    "crypto-js-miner.top"
    "webmine-proxy.click"
    "coinimp-alternative.loan"
    "minero-cdn.download"
    "crypto-loot-proxy.stream"
    "mineralt-cdn.science"
    "webminepool-alt.racing"
    "coin-have-proxy.review"
    "jsecoin-cdn.work"
    "cpu-mining-proxy.party"
    "crypto-webminer.gdn"
    # Scam domains
    "bitcoin-doubler-real.top"
    "crypto-giveaway-2024.click"
    "elon-musk-crypto.loan"
    "free-bitcoin-now.download"
    "eth-airdrop-official.stream"
    "solana-bonus.science"
    "bnb-giveaway.racing"
    "cardano-airdrop.review"
    "dogecoin-double.work"
    "shiba-inu-bonus.party"
    "nft-free-mint.gdn"
    "defi-yield-farm.mom"
    "pancakeswap-bonus.xin"
    "uniswap-airdrop.kim"
    "opensea-free-nft.men"
    # Tech support scams
    "microsoft-support-247.stream"
    "apple-tech-support.science"
    "computer-virus-alert.racing"
    "windows-defender-alert.review"
    "norton-security-expired.work"
    "mcafee-subscription-alert.party"
    "avast-renewal-required.gdn"
    "kaspersky-update-now.mom"
    "bitdefender-alert.xin"
    "malwarebytes-expired.kim"
    "avg-antivirus-renewal.men"
    "eset-security-alert.win"
    "trend-micro-update.date"
    "webroot-subscription.trade"
    "pc-matic-alert.webcam"
    # Malware families C2
    "emotet-download.xyz"
    "trickbot-loader.top"
    "ryuk-ransomware.click"
    "dridex-banking.loan"
    "zeus-trojan.download"
    "lokibot-stealer.stream"
    "formbook-malware.science"
    "agenttesla-rat.racing"
    "njrat-backdoor.review"
    "remcos-rat.work"
    "asyncrat-c2.party"
    "quasar-rat.gdn"
    "nanocore-beacon.mom"
    "netwire-implant.xin"
    "orcus-rat.kim"
    "darkcomet-c2.men"
    "blackshades-rat.win"
    "imminent-monitor.date"
    "luminosity-link.trade"
    "revenge-rat.webcam"
    # Ransomware payment portals
    "ransom-payment-portal.racing"
    "decrypt-your-files.review"
    "pay-bitcoin-here.work"
    "lockbit-payment.onion"
    "conti-decrypt.onion"
    "revil-payment.onion"
    "maze-ransom.onion"
    "ragnar-locker-pay.onion"
    "egregor-decrypt.onion"
    "darkside-payment.onion"
    "blackcat-alphv-pay.onion"
    "hive-ransomware.onion"
    "avaddon-decrypt.onion"
    "babuk-payment.onion"
    "clop-ransom.onion"
    # Exploit kit domains
    "angler-ek.loan"
    "neutrino-ek.download"
    "rig-ek.stream"
    "magnitude-ek.science"
    "fallout-ek.racing"
    "underminer-ek.review"
    "spelevo-ek.work"
    "purple-fox-ek.party"
    "bottle-ek.gdn"
    "lord-ek.mom"
    # Phishing kit infrastructure
    "phishkit-cdn.xyz"
    "scampage-host.top"
    "credential-harvest.click"
    "login-spoof.loan"
    "fake-login-page.download"
    # Additional malicious domains (continuing the list)
    "malware-delivery.stream"
    "payload-server.science"
    "dropper-cdn.racing"
    "loader-host.review"
    "stager-endpoint.work"
    "implant-delivery.party"
    "beacon-callback.gdn"
    "exfil-endpoint.mom"
    "c2-relay.xin"
    "proxy-c2.kim"
)

# KNOWN MALICIOUS DOMAINS DATABASE
declare -A KNOWN_MALICIOUS_DOMAINS=()

# KNOWN MALICIOUS HASHES DATABASE
declare -A KNOWN_MALICIOUS_HASHES=()

# KNOWN CRYPTO SCAM ADDRESSES DATABASE
declare -A KNOWN_CRYPTO_SCAM_ADDRESSES=()

# NEW: Additional threat intelligence associative arrays for 20 missing feeds
declare -A KNOWN_C2_IPS=()
declare -A KNOWN_C2_DOMAINS=()
declare -A KNOWN_MALWARE_HASHES=()
declare -A KNOWN_JA3_FINGERPRINTS=()
declare -A KNOWN_CVES=()
declare -A MALWARE_FAMILY_MAPPINGS=()
declare -A DISPOSABLE_EMAIL_DOMAINS=()

# HARDCODED MALICIOUS IP LIST (for offline detection)
declare -a HARDCODED_MALICIOUS_IPS=(
    "185.244.25.0" "185.244.25.1" "45.33.32.156"
    "77.83.247.0" "185.25.50.0" "175.45.176.0"
)

# HARDCODED MALICIOUS HASHES
declare -a HARDCODED_MALICIOUS_HASHES=(
    "e99a18c428cb38d5f260853678922e03"  # Example malware hash
    "d41d8cd98f00b204e9800998ecf8427e"  # Empty file (suspicious)
)

# HARDCODED SCAM CRYPTO ADDRESSES
declare -a HARDCODED_SCAM_CRYPTO=(
    "1BvBMSEYstWetqTFn5Au4m4GFg7xJaNVN2"  # Known scam BTC address
    "3J98t1WpEZ73CNmQviecrnyiWrnqRhWNLy"  # Known scam BTC address
)

# EXPANDED MALICIOUS IP ADDRESSES DATABASE
declare -A KNOWN_MALICIOUS_IPS=(
    # Known C2 servers
    ["185.244.25.0"]="Cobalt Strike C2"
    ["185.244.25.1"]="Cobalt Strike C2"
    ["185.244.25.2"]="Cobalt Strike C2"
    ["185.244.25.3"]="Cobalt Strike C2"
    ["185.244.25.4"]="Cobalt Strike C2"
    ["45.33.32.156"]="Known malware C2"
    ["104.21.2.1"]="Phishing infrastructure"
    ["172.67.1.1"]="Malware distribution"
    ["198.51.100.1"]="Botnet C2"
    ["203.0.113.1"]="Spam/Phishing"
    ["192.0.2.1"]="Known bad IP"
    ["198.18.0.1"]="Malware hosting"
    ["100.64.0.1"]="C2 infrastructure"
    # APT-related IPs
    ["77.83.247.0"]="APT28 infrastructure"
    ["77.83.247.1"]="APT28 C2"
    ["185.25.50.0"]="APT29 infrastructure"
    ["185.25.50.1"]="APT29 C2"
    ["175.45.176.0"]="Lazarus Group"
    ["175.45.176.1"]="Lazarus Group C2"
    ["185.161.208.0"]="APT38 infrastructure"
    ["185.161.208.1"]="APT38 C2"
    ["103.253.41.0"]="APT41 infrastructure"
    ["103.253.41.1"]="APT41 C2"
    # Ransomware infrastructure
    ["45.147.231.0"]="LockBit infrastructure"
    ["45.147.231.1"]="LockBit C2"
    ["193.169.245.0"]="Conti infrastructure"
    ["193.169.245.1"]="Conti C2"
    ["31.184.234.0"]="REvil infrastructure"
    ["31.184.234.1"]="REvil C2"
    ["92.63.197.0"]="DarkSide infrastructure"
    ["92.63.197.1"]="DarkSide C2"
    # Cryptojacking IPs
    ["104.238.130.0"]="Cryptominer pool"
    ["104.238.130.1"]="Cryptominer C2"
    ["45.76.92.0"]="Mining proxy"
    ["45.76.92.1"]="Mining pool relay"
    # Botnet IPs
    ["89.248.165.0"]="Mirai botnet"
    ["89.248.165.1"]="Mirai C2"
    ["185.156.73.0"]="Emotet infrastructure"
    ["185.156.73.1"]="Emotet C2"
    ["31.13.195.0"]="TrickBot infrastructure"
    ["31.13.195.1"]="TrickBot C2"
    # Additional malicious IPs
    ["23.94.4.0"]="Malware hosting"
    ["23.94.4.1"]="Phishing server"
    ["104.168.44.0"]="Spam server"
    ["104.168.44.1"]="Malicious redirector"
    ["172.241.27.0"]="Exploit kit hosting"
    ["172.241.27.1"]="Drive-by download"
    ["45.61.136.0"]="Credential phishing"
    ["45.61.136.1"]="Fake login hosting"
    ["192.99.251.0"]="Bulletproof hosting"
    ["192.99.251.1"]="Criminal infrastructure"
)

# EXPANDED URL SHORTENERS DATABASE
declare -a URL_SHORTENERS=(
    "bit\.ly" "t\.co" "tinyurl\.com" "rb\.gy" "goo\.gl"
    "buff\.ly" "adf\.ly" "cutt\.ly" "ow\.ly" "is\.gd"
    "cli\.gs" "pic\.gd" "DwarfURL\.com" "yfrog\.com" "migre\.me"
    "ff\.im" "tiny\.cc" "url4\.eu" "tr\.im" "twit\.ac"
    "su\.pr" "twurl\.nl" "snipurl\.com" "short\.to" "BudURL\.com"
    "ping\.fm" "post\.ly" "Just\.as" "bkite\.com" "snipr\.com"
    "fic\.kr" "loopt\.us" "doiop\.com" "short\.ie" "kl\.am"
    "wp\.me" "rubyurl\.com" "om\.ly" "to\.ly" "bit\.do"
    "lnkd\.in" "db\.tt" "qr\.ae" "adf\.ly" "bitly\.com"
    "cur\.lv" "tinyurl\.cc" "ity\.im" "q\.gs" "po\.st"
    "bc\.vc" "twitthis\.com" "u\.to" "j\.mp" "buzurl\.com"
    "cutt\.us" "u\.bb" "yourls\.org" "x\.co" "prettylinkpro\.com"
    "scrnch\.me" "filoops\.info" "vzturl\.com" "qr\.net" "1url\.com"
    "tweez\.me" "v\.gd" "tr\.im" "link\.zip" "shorturl\.at"
    "rebrand\.ly" "bl\.ink" "soo\.gd" "s\.id" "clck\.ru"
    "ouo\.io" "za\.gl" "shorte\.st" "linktr\.ee" "hoo\.gl"
    "hyperurl\.co" "7\.ly" "urlz\.fr" "han\.gl" "urls\.fr"
    "tiny\.pl" "1link\.in" "shrinkme\.io" "fas\.li" "rlu\.ru"
    "plu\.sh" "urlbae\.com" "mcaf\.ee" "git\.io" "capsulink\.com"
    # === AUDIT ADDITIONS: Expanded URL Shorteners ===
    "t\.ly" "qrco\.de" "short\.io" "T2M\.io" "tinu\.be"
    "shortcm\.li" "shrtco\.de" "rotf\.lol" "dub\.sh" "dub\.co"
    "link\.gg" "lnk\.to" "bio\.link" "hubs\.ly" "l\.gg"
    "go\.ly" "smarturl\.it" "song\.link" "album\.link" "pods\.link"
    "snip\.ly" "shor\.by" "tiny\.one" "gg\.gg" "da\.gd"
    "kutt\.it" "0x0\.st" "w\.wiki" "cfl\.re" "lmy\.de"
    "trib\.al" "social\.link" "msha\.ke" "zpr\.io" "taplink\.cc"
    "beacons\.ai" "stan\.store" "hoo\.be" "lynk\.id" "manylink\.co"
    "allmylinks\.com" "linkpop\.com" "solo\.to" "campsite\.bio"
    "lnk\.bio" "tap\.bio" "milkshake\.app" "shorby\.com"
    # QR-specific shorteners
    "qrs\.ly" "qr-code\.cc" "qr1\.be" "qrfy\.com" "qrtag\.net"
    # Regional/Localized shorteners
    "dlvr\.it" "shorten\.rest" "encr\.pw" "flip\.it" "frama\.link"
    "tny\.im" "refer\.ly" "yoururl\.app" "click\.ru" "vk\.cc"
    "naver\.me" "me2\.do" "hoy\.kr" "han\.gl" "url\.kr"
    "dwz\.cn" "t\.cn" "suo\.im" "985\.so" "c7\.gg"
)

# EXPANDED SUSPICIOUS TLDs
declare -a SUSPICIOUS_TLDS=(
    "\.tk" "\.ml" "\.ga" "\.cf" "\.gq" "\.pw" "\.cc"
    "\.ws" "\.buzz" "\.link" "\.top" "\.click" "\.loan"
    "\.download" "\.stream" "\.science" "\.racing" "\.review"
    "\.work" "\.party" "\.gdn" "\.mom" "\.xin" "\.kim"
    "\.men" "\.win" "\.date" "\.trade" "\.webcam" "\.bid"
    "\.accountant" "\.cricket" "\.faith" "\.faith" "\.rocks"
    "\.country" "\.space" "\.website" "\.xyz" "\.online"
    "\.site" "\.tech" "\.store" "\.fun" "\.icu" "\.vip"
    "\.club" "\.live" "\.life" "\.world" "\.today" "\.guru"
    "\.email" "\.solutions" "\.systems" "\.center" "\.services"
    "\.network" "\.digital" "\.cloud" "\.agency" "\.zone"
)

# COMPREHENSIVE CRYPTOCURRENCY PATTERNS
declare -a CRYPTO_PATTERNS=(
    # Bitcoin patterns
    "1[a-km-zA-HJ-NP-Z1-9]{25,34}"                    # Bitcoin Legacy P2PKH
    "3[a-km-zA-HJ-NP-Z1-9]{25,34}"                    # Bitcoin SegWit P2SH
    "bc1[a-z0-9]{39,87}"                              # Bitcoin Bech32 (SegWit native)
    "bc1p[a-z0-9]{58}"                                # Bitcoin Taproot (Bech32m)
    # Ethereum and EVM chains
    "0x[a-fA-F0-9]{40}"                               # Ethereum/BSC/Polygon/etc
    # Litecoin
    "[LM][a-km-zA-HJ-NP-Z1-9]{26,33}"                 # Litecoin Legacy
    "ltc1[a-z0-9]{39,87}"                             # Litecoin Bech32
    # Dogecoin
    "D[5-9A-HJ-NP-U][1-9A-HJ-NP-Za-km-z]{32}"        # Dogecoin
    # Ripple/XRP
    "r[0-9a-zA-Z]{24,34}"                             # XRP
    # Monero
    "4[0-9AB][1-9A-HJ-NP-Za-km-z]{93}"               # Monero standard
    "8[0-9AB][1-9A-HJ-NP-Za-km-z]{93}"               # Monero subaddress
    # Bitcoin Cash
    "(bitcoincash:)?[qp][a-z0-9]{41}"                 # Bitcoin Cash CashAddr
    # Cardano
    "addr1[a-z0-9]{58,103}"                           # Cardano Shelley
    "DdzFF[a-zA-Z0-9]{93}"                            # Cardano Byron
    # Solana
    "[1-9A-HJ-NP-Za-km-z]{32,44}"                     # Solana
    # Tron
    "T[a-zA-Z0-9]{33}"                                # Tron TRC20
    # Polkadot
    "1[a-zA-Z0-9]{47}"                                # Polkadot
    # Cosmos
    "cosmos1[a-z0-9]{38}"                             # Cosmos
    # Algorand
    "[A-Z2-7]{58}"                                    # Algorand
    # Stellar
    "G[A-Z2-7]{55}"                                   # Stellar
    # Tezos
    "tz[1-3][a-zA-Z0-9]{33}"                          # Tezos
    # Neo
    "A[a-zA-Z0-9]{33}"                                # Neo
    # Dash
    "X[a-km-zA-HJ-NP-Z1-9]{33}"                       # Dash
    # Zcash
    "t[13][a-km-zA-HJ-NP-Z1-9]{33}"                   # Zcash transparent
    "zs[a-z0-9]{76}"                                  # Zcash shielded
    # EOS
    "[a-z1-5.]{12}"                                   # EOS
    # Waves
    "3P[a-zA-Z0-9]{33}"                               # Waves
    # IOTA
    "iota1[a-z0-9]{59}"                               # IOTA Chrysalis
    # Filecoin
    "f[0-3][a-z0-9]{40,}"                             # Filecoin
    # Hedera
    "0\.0\.[0-9]+"                                    # Hedera Hashgraph
    # === AUDIT ADDITIONS: Layer 2 & Emerging Chains ===
    # NEAR Protocol
    "[a-z0-9_-]{2,64}\.near"                          # NEAR named accounts
    "[a-f0-9]{64}"                                    # NEAR implicit accounts (64 hex)
    # Avalanche
    "X-avax[a-zA-Z0-9]{39}"                           # Avalanche X-Chain
    "P-avax[a-zA-Z0-9]{39}"                           # Avalanche P-Chain
    "C-avax[a-zA-Z0-9]{39}"                           # Avalanche C-Chain
    "avax1[a-z0-9]{38}"                               # Avalanche Bech32
    # Fantom
    "0x[a-fA-F0-9]{40}"                               # Fantom (EVM compatible)
    # Arbitrum
    "0x[a-fA-F0-9]{40}"                               # Arbitrum (EVM compatible)
    # zkSync
    "0x[a-fA-F0-9]{40}"                               # zkSync Era (EVM compatible)
    "zksync:[a-zA-Z0-9]+"                             # zkSync payment links
    # StarkNet
    "0x0[a-fA-F0-9]{63}"                              # StarkNet (64 hex with 0x0 prefix)
    # TON (Telegram Open Network)
    "EQ[a-zA-Z0-9_-]{46}"                             # TON raw address (base64url)
    "UQ[a-zA-Z0-9_-]{46}"                             # TON user-friendly bounceable
    "0:[a-fA-F0-9]{64}"                               # TON raw hex format
    "ton://transfer/[a-zA-Z0-9_-]+"                   # TON transfer deeplinks
    # Aptos
    "0x[a-fA-F0-9]{64}"                               # Aptos addresses
    # Sui
    "0x[a-fA-F0-9]{64}"                               # Sui addresses
    # MultiversX (formerly Elrond)
    "erd1[a-z0-9]{58}"                                # MultiversX/Elrond
    # Optimism
    "0x[a-fA-F0-9]{40}"                               # Optimism (EVM compatible)
    # Base
    "0x[a-fA-F0-9]{40}"                               # Base (Coinbase L2, EVM)
    # Celo
    "0x[a-fA-F0-9]{40}"                               # Celo (EVM compatible)
    # Klaytn
    "0x[a-fA-F0-9]{40}"                               # Klaytn (EVM compatible)
    # Cronos
    "cro1[a-z0-9]{38}"                                # Cronos (Cosmos SDK)
    # Secret Network
    "secret1[a-z0-9]{38}"                             # Secret Network
    # Injective
    "inj1[a-z0-9]{38}"                                # Injective Protocol
    # Osmosis
    "osmo1[a-z0-9]{38}"                               # Osmosis
    # Kava
    "kava1[a-z0-9]{38}"                               # Kava
    # Axelar
    "axelar1[a-z0-9]{38}"                             # Axelar
    # === CBDC Test Endpoints ===
    # Central Bank Digital Currency test patterns
    "cbdc[_-]?test"
    "digital[_-]?(yuan|euro|dollar|pound|rupee)"
    "e-CNY|e-EUR|e-USD"
    "dcep[_-]?test"
)

# EXPANDED DANGEROUS FILE EXTENSIONS
declare -a DANGEROUS_EXTENSIONS=(
    # Windows executables
    "\.exe" "\.dll" "\.scr" "\.bat" "\.cmd" "\.com" "\.pif"
    "\.msi" "\.msp" "\.mst" "\.gadget" "\.cpl" "\.hta" "\.inf"
    "\.reg" "\.scf" "\.lnk" "\.url"
    # Scripts
    "\.vbs" "\.vbe" "\.js" "\.jse" "\.ws" "\.wsf" "\.wsc" "\.wsh"
    "\.ps1" "\.psm1" "\.psd1" "\.ps1xml" "\.pssc" "\.cdxml"
    "\.sh" "\.bash" "\.zsh" "\.csh" "\.ksh" "\.fish"
    # Mobile
    "\.apk" "\.aab" "\.ipa" "\.app" "\.xapk"
    # Linux/Unix
    "\.deb" "\.rpm" "\.snap" "\.flatpak" "\.appimage" "\.run"
    # macOS
    "\.dmg" "\.pkg" "\.mpkg" "\.action" "\.workflow" "\.command"
    "\.app" "\.prefPane" "\.kext" "\.bundle"
    # iOS Configuration
    "\.mobileconfig" "\.provisionprofile" "\.pem" "\.cer" "\.der"
    # Office Macros
    "\.docm" "\.xlsm" "\.pptm" "\.dotm" "\.xltm" "\.potm"
    "\.xlam" "\.xla" "\.ppam" "\.ppa" "\.sldm" "\.thmx"
    # Java
    "\.jar" "\.jnlp" "\.war" "\.ear" "\.class"
    # Python
    "\.py" "\.pyw" "\.pyc" "\.pyo" "\.pyz" "\.pyzw"
    # Archives with potential for exploitation
    "\.iso" "\.img" "\.vhd" "\.vhdx" "\.vmdk" "\.ova" "\.ovf"
    "\.cab" "\.arc" "\.ace" "\.arj" "\.lha" "\.lzh"
    # Other dangerous
    "\.swf" "\.fla" "\.xbap" "\.application" "\.manifest"
    "\.rdp" "\.ica" "\.vnc" "\.remmina"
    "\.torrent" "\.magnet"
    "\.chm" "\.hlp"
)

# SUSPICIOUS URL PATTERNS - EXPANDED
declare -a SUSPICIOUS_URL_PATTERNS=(
    # Authentication related
    "login" "signin" "sign-in" "log-in" "authenticate" "auth"
    "verify" "verification" "confirm" "confirmation" "validate"
    "account" "user" "profile" "member" "client"
    "password" "passwd" "pwd" "reset" "recover" "forgot"
    "unlock" "unblock" "restore" "reactivate"
    # Security/urgency
    "secure" "security" "protect" "safety" "safe"
    "update" "upgrade" "renew" "renewal" "refresh"
    "suspend" "suspended" "limit" "limited" "restrict" "restricted"
    "urgent" "immediate" "required" "mandatory" "alert" "warning"
    "action" "respond" "response" "attention"
    # Financial
    "billing" "payment" "invoice" "receipt" "transaction"
    "refund" "reimburse" "credit" "debit" "charge"
    "bank" "banking" "financial" "wallet" "transfer"
    "paypal" "venmo" "zelle" "cashapp" "wire"
    # Reward/incentive
    "prize" "winner" "won" "reward" "bonus" "gift"
    "claim" "redeem" "collect" "free" "offer" "deal"
    "exclusive" "limited" "special" "promotion" "discount"
    # Support
    "support" "help" "service" "customer" "assistance"
    "ticket" "case" "issue" "problem" "error"
    # Delivery/shipping
    "delivery" "shipping" "track" "package" "parcel" "order"
    "dispatch" "courier" "postal" "fedex" "ups" "dhl" "usps"
    # Tax/government
    "tax" "irs" "refund" "government" "gov" "federal" "state"
    "social-security" "medicare" "benefit" "stimulus"
    # Employment
    "job" "employment" "offer" "salary" "remote" "work-from-home"
    "interview" "application" "resume" "cv" "career"
)

# PHISHING BRAND TARGETS - COMPREHENSIVE LIST
declare -a PHISHING_BRANDS=(
    # Financial Services
    "paypal" "venmo" "zelle" "cashapp" "square"
    "chase" "wellsfargo" "bankofamerica" "citi" "citibank"
    "capitalone" "tdbank" "pnc" "usbank" "truist"
    "regions" "fifththird" "huntington" "keybank" "ally"
    "discover" "americanexpress" "amex" "mastercard" "visa"
    "hsbc" "barclays" "santander" "natwest" "lloyds"
    "deutschebank" "bnpparibas" "creditsuisse" "ubs"
    "schwab" "fidelity" "vanguard" "etrade" "robinhood"
    "coinbase" "binance" "kraken" "gemini" "crypto"
    # Tech Giants
    "google" "microsoft" "apple" "amazon" "facebook" "meta"
    "netflix" "spotify" "twitter" "instagram" "linkedin"
    "yahoo" "outlook" "hotmail" "gmail" "icloud"
    "dropbox" "box" "onedrive" "googledrive" "gdrive"
    "zoom" "teams" "slack" "webex" "skype"
    "office365" "office" "azure" "aws" "gcp"
    # Retail
    "walmart" "target" "costco" "bestbuy" "homedepot"
    "lowes" "macys" "nordstrom" "kohls" "jcpenney"
    "ebay" "etsy" "aliexpress" "wish" "alibaba"
    # Shipping/Delivery
    "fedex" "ups" "usps" "dhl" "amazon"
    "doordash" "ubereats" "grubhub" "postmates" "instacart"
    # Streaming/Entertainment
    "netflix" "hulu" "disney" "hbomax" "peacock"
    "paramount" "apple" "amazon" "youtube" "twitch"
    "spotify" "pandora" "apple" "tidal" "deezer"
    # Gaming
    "steam" "epic" "playstation" "xbox" "nintendo"
    "roblox" "fortnite" "minecraft" "blizzard" "riot"
    # Social Media
    "facebook" "instagram" "twitter" "tiktok" "snapchat"
    "reddit" "pinterest" "tumblr" "discord" "telegram"
    # Dating
    "tinder" "bumble" "hinge" "match" "okcupid"
    # Government
    "irs" "ssa" "medicare" "dmv" "dhs" "ice"
)

# HOMOGRAPH ATTACK CHARACTERS (non-ASCII only - lookalikes for Latin letters)
declare -a HOMOGRAPH_CHARS=(
    # Cyrillic lookalikes (look like Latin a,e,o,p,c,y,x)
    "а" "е" "о" "р" "с" "у" "х"
    # Greek lookalikes
    "α" "ο" "ρ" "ν" "ω"
    # Special lookalikes
    "ı" "ɪ" "Ι" "І"              # i lookalikes (Turkish dotless i, small capital I, Greek Iota, Cyrillic I)
    "Ο" "О"                      # O lookalikes (Greek Omicron, Cyrillic O)
    "ɡ" "ɢ"                      # g lookalikes
    "ß" "β"                      # B lookalikes
    # Accented variants that could be deceptive
    "ḁ" "ạ" "ą" "ă" "ā" "ã"
    "ċ" "ç" "ć" "č"
    "ė" "ę" "ě" "ē" "ẹ"
    "ġ" "ğ" "ģ" "ǧ"
    "ḣ" "ḥ" "ḧ" "ħ"
    "ì" "í" "î" "ï" "ị"
    "ḷ" "ļ" "ľ" "ł"
    "ṅ" "ņ" "ň" "ñ"
    "ò" "ó" "ô" "õ" "ö" "ọ"
    "ŗ" "ř" "ṛ" "ṟ"
    "ṡ" "ş" "ș" "š"
    "ṫ" "ţ" "ț" "ť"
    "ù" "ú" "û" "ü" "ụ"
    "ẃ" "ẅ" "ẇ"
    "ỳ" "ý" "ŷ" "ÿ" "ỵ"
    "ẑ" "ž" "ż"
)

# MOBILE CONFIGURATION PATTERNS
declare -a MOBILE_CONFIG_PATTERNS=(
    "mobileconfig" "provisionprofile" "PayloadType"
    "com\.apple\.wifi\.managed" "com\.apple\.vpn\.managed"
    "com\.apple\.security\.root" "com\.apple\.mdm"
    "PayloadCertificateFileName" "PayloadContent"
    "com\.apple\.security\.pkcs12" "com\.apple\.webClip\.managed"
    "com\.apple\.security\.scep" "com\.apple\.ldap\.account"
    "com\.apple\.caldav\.account" "com\.apple\.carddav\.account"
    "com\.apple\.mail\.managed" "com\.apple\.exchange\.account"
)

# SCRIPT INJECTION PATTERNS
declare -a SCRIPT_INJECTION_PATTERNS=(
    "<script" "javascript:" "onerror=" "onload=" "onclick="
    "eval\(" "setTimeout\(" "setInterval\(" "Function\("
    "document\.cookie" "document\.write" "innerHTML"
    "%3Cscript" "%3E" "fromCharCode" "atob\(" "btoa\("
    "unescape\(" "String\.fromCharCode" "\\.src\s*="
    "onmouseover=" "onfocus=" "onblur=" "ondblclick="
    "onkeydown=" "onkeypress=" "onkeyup=" "onmousedown="
    "onmousemove=" "onmouseout=" "onsubmit=" "oninput="
    "<iframe" "<embed" "<object" "<applet" "<meta"
    "vbscript:" "data:text/html" "data:application"
    "base64," "&#" "\\x" "\\u00"
)

# SOCIAL ENGINEERING KEYWORDS
declare -a SOCIAL_ENGINEERING_KEYWORDS=(
    "verify.*account" "confirm.*identity" "urgent.*action"
    "suspended.*account" "unusual.*activity" "security.*alert"
    "click.*here" "claim.*prize" "you.*won" "congratulations"
    "limited.*time" "act.*now" "expires.*today" "final.*notice"
    "your.*package" "delivery.*failed" "tax.*refund"
    "IRS" "bank.*alert" "payment.*failed" "card.*declined"
    "account.*locked" "restore.*access" "verify.*now"
    "immediate.*action" "update.*required" "missing.*information"
    "pending.*transaction" "fraud.*alert" "suspicious.*login"
    "password.*expired" "security.*breach" "data.*leaked"
    "unauthorized.*access" "confirm.*payment" "renew.*subscription"
    "update.*billing" "credit.*card.*expir" "auto.*renewal"
)

# DEEP LINK SCHEMES
declare -a DEEPLINK_SCHEMES=(
    "whatsapp:" "telegram:" "signal:" "discord:" "slack:"
    "venmo:" "cashapp:" "paypal:" "zelle:" "applepay:"
    "googlepay:" "bitcoin:" "ethereum:" "crypto:"
    "fb:" "instagram:" "twitter:" "tiktok:" "snapchat:"
    "spotify:" "youtube:" "maps:" "mailto:" "tel:" "sms:"
    "facetime:" "facetime-audio:" "itms:" "itms-apps:"
    "viber:" "line:" "kakao:" "wechat:" "skype:"
    "zoom:" "teams:" "meet:" "webex:"
)

# QR ACTION PREFIXES
declare -a QR_ACTION_PREFIXES=(
    "WIFI:" "SMSTO:" "MATMSG:" "mailto:" "tel:" "geo:"
    "BEGIN:VEVENT" "BEGIN:VCARD" "otpauth:" "bitcoin:"
    "ethereum:" "lightning:" "solana:" "sms:" "mms:"
    "MECARD:" "BIZCARD:" "BOOKMARK:" "TEL:"
)

# MALWARE FAMILY SIGNATURES
declare -a MALWARE_FAMILIES=(
    "emotet" "trickbot" "ryuk" "dridex" "zeus" "lokibot"
    "formbook" "agenttesla" "njrat" "remcos" "raccoon" "vidar"
    "azorult" "masslogger" "netwire" "quasar" "darkcomet"
    "wannacry" "notpetya" "petya" "gandcrab" "sodinokibi"
    "maze" "conti" "lockbit" "revil" "darkside"
    "mirai" "qbot" "qakbot" "cobalt.*strike"
)

# EXPLOIT KIT SIGNATURES
declare -a EXPLOIT_KITS=(
    "angler" "neutrino" "rig" "magnitude" "fallout"
    "greenflash.*sundown" "kaixin" "underminer" "grandsoft"
    "blackhole" "fiesta" "redkit" "sweet.*orange"
)

# DATA EXFILTRATION PATTERNS
declare -a EXFIL_PATTERNS=(
    "POST.*password" "POST.*credential" "POST.*ssn"
    "POST.*credit.*card" "upload.*zip" "upload.*rar"
    "upload.*7z" "upload.*encrypted" "dns.*tunnel"
    "icmp.*tunnel" "http.*tunnel" "https.*tunnel"
)

# PERSISTENCE MECHANISMS
declare -a PERSISTENCE_PATTERNS=(
    "startup" "autorun" "schedule.*task" "cron" "launchd"
    "registry.*run" "registry.*runonce" "wmi.*subscription"
    "service.*install" "daemon" "systemd" "init\.d"
)

# LATERAL MOVEMENT INDICATORS
declare -a LATERAL_MOVEMENT=(
    "psexec" "wmi.*exec" "remote.*desktop" "rdp"
    "smb.*copy" "admin\$" "c\$" "ipc\$"
    "pass.*the.*hash" "pass.*the.*ticket" "kerberos"
)

# CREDENTIAL THEFT PATTERNS
declare -a CREDENTIAL_THEFT=(
    "mimikatz" "lsass" "sam.*dump" "ntds\.dit"
    "credential.*dump" "password.*spray" "brute.*force"
    "keylogger" "form.*grabber" "browser.*stealer"
)

# APT GROUP INDICATORS DATABASE
declare -A APT_INDICATORS=(
    # APT28 (Fancy Bear / Sofacy / Pawn Storm)
    ["apt28_domains"]="sednit.com,sofacy.com,pawnstorm.com,account-google.com,mail-support.org"
    ["apt28_tools"]="X-Agent,Zebrocy,Sofacy,LoJax,Cannon"
    ["apt28_ttps"]="T1566.001,T1059.001,T1071.001,T1055.001,T1003.001"
    # APT29 (Cozy Bear / The Dukes / YTTRIUM)
    ["apt29_domains"]="dukes.com,cozybear.net,diplomatic-news.org,embassy-update.com"
    ["apt29_tools"]="CozyDuke,MiniDuke,SeaDuke,WellMess,WellMail,SUNBURST"
    ["apt29_ttps"]="T1195.002,T1566.002,T1098.001,T1087.002,T1078.002"
    # APT38 (Lazarus Group / Hidden Cobra)
    ["apt38_domains"]="lazarus.net,hiddencobra.org,swift-update.com,financial-news.org"
    ["apt38_tools"]="FASTCash,DYEPACK,CROWDEDFLOUNDER,Hermes,WannaCry"
    ["apt38_ttps"]="T1059.001,T1070.004,T1036.005,T1041,T1486"
    # APT41 (Winnti Group / BARIUM / Wicked Panda)
    ["apt41_domains"]="winnti.com,barium.net,update-service.org,software-update.net"
    ["apt41_tools"]="Winnti,PlugX,ShadowPad,Crosswalk,MESSAGETAP"
    ["apt41_ttps"]="T1195.002,T1078,T1569.002,T1505.003,T1560.001"
    # APT32 (OceanLotus / APT-C-00)
    ["apt32_domains"]="oceanlotus.com,apt-c-00.org,news-update.net,flash-update.com"
    ["apt32_tools"]="Denis,Kerrdown,OutlookSpy,Rizzo"
    ["apt32_ttps"]="T1566.001,T1204.002,T1059.005,T1055.001,T1033"
    # Turla (Snake / Venomous Bear / KRYPTON)
    ["turla_domains"]="turla.net,snake.org,venomous.com,epic-turla.org"
    ["turla_tools"]="Snake,Carbon,Kazuar,Mosquito,LightNeuron"
    ["turla_ttps"]="T1071.001,T1573.002,T1090.001,T1055.012,T1027.002"
    # Kimsuky (Velvet Chollima)
    ["kimsuky_domains"]="kimsuky.org,velvet-chollima.net,hanmail-update.com,naver-login.org"
    ["kimsuky_tools"]="BabyShark,KGH_SPY,CSPY Downloader,AppleSeed"
    ["kimsuky_ttps"]="T1566.001,T1059.001,T1005,T1560.001,T1071.001"
    # Sandworm (VOODOO BEAR)
    ["sandworm_domains"]="sandworm.org,voodoo-bear.net,power-grid.com,industrial-update.org"
    ["sandworm_tools"]="BlackEnergy,Industroyer,NotPetya,Olympic Destroyer,Cyclops Blink"
    ["sandworm_ttps"]="T1059.003,T1490,T1561.002,T1499.004,T1195.002"
    # MuddyWater (TEMP.Zagros / Seedworm)
    ["muddywater_domains"]="muddywater.org,zagros.net,seedworm.com,middle-east-news.org"
    ["muddywater_tools"]="POWERSTATS,Mori,PowGoop,Small Sieve"
    ["muddywater_ttps"]="T1059.001,T1566.001,T1204.002,T1547.001,T1071.001"
    # FIN7 (Carbanak / GOLD NIAGARA)
    ["fin7_domains"]="fin7.com,carbanak.org,gold-niagara.net,atm-update.com"
    ["fin7_tools"]="Carbanak,HALFBAKED,POWERSOURCE,PILLOWMINT"
    ["fin7_ttps"]="T1566.001,T1059.001,T1055.001,T1003.001,T1070.001"
)

# MALWARE FAMILY SIGNATURES
declare -A MALWARE_SIGNATURES=(
    # Emotet
    ["emotet_strings"]="emotet,epoch,heodo,mealybug,geodo"
    ["emotet_patterns"]="powershell.*-e.*base64|cmd.*\/c.*echo|regsvr32.*\/s.*\.dll"
    ["emotet_c2_pattern"]="http:\/\/[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+:[0-9]+\/"
    # TrickBot
    ["trickbot_strings"]="trickbot,trick,anchor,bazar,conti"
    ["trickbot_patterns"]="curl.*-o.*\.exe|certutil.*-urlcache|bitsadmin.*\/transfer"
    ["trickbot_modules"]="pwgrab,injectDll,networkDll,systeminfo,wormDll"
    # Qakbot/QBot
    ["qakbot_strings"]="qakbot,qbot,quakbot,pinkslipbot"
    ["qakbot_patterns"]="mshta.*javascript|regsvr32.*-s.*scrobj|cscript.*\.js"
    ["qakbot_c2_pattern"]="https?:\/\/[a-z0-9]+\.[a-z]+\/[a-z]+\/[0-9]+"
    # Dridex
    ["dridex_strings"]="dridex,bugat,cridex"
    ["dridex_patterns"]="wmic.*process.*call.*create|msiexec.*\/q.*http"
    ["dridex_injection"]="explorer.exe,svchost.exe,spoolsv.exe"
    # IcedID/BokBot
    ["icedid_strings"]="icedid,bokbot,anubis"
    ["icedid_patterns"]="rundll32.*,DllRegisterServer|msiexec.*-i.*http"
    # Cobalt Strike
    ["cobaltstrike_strings"]="beacon,cobalt,strike"
    ["cobaltstrike_patterns"]="powershell.*IEX.*downloadstring|certutil.*-decode"
    ["cobaltstrike_named_pipes"]="\\\\.\\pipe\\msagent_,\\\\.\\pipe\\MSSE-,\\\\.\\pipe\\postex_"
    # AsyncRAT
    ["asyncrat_strings"]="asyncrat,async,venomrat,dcrat"
    ["asyncrat_patterns"]="powershell.*bypass.*-enc|schtasks.*\/create.*\/tr"
    # Remcos
    ["remcos_strings"]="remcos,remcos-pro,breakingsecurity"
    ["remcos_registry"]="HKCU\\Software\\Remcos,HKLM\\Software\\Remcos"
    # AgentTesla
    ["agenttesla_strings"]="agenttesla,originlogger,hawkeye"
    ["agenttesla_exfil"]="smtp:\/\/,ftp:\/\/,telegram\.org\/bot"
    # LokiBot
    ["lokibot_strings"]="lokibot,loki,lokipws"
    ["lokibot_panels"]="fre.php,gate.php,PvqDq929BSx_A_D_M1n_a.php"
    # FormBook/XLoader
    ["formbook_strings"]="formbook,xloader"
    ["formbook_patterns"]="ntdll\.NtProtectVirtualMemory,ntdll\.NtResumeThread"
    
    # RedLine Stealer
    ["redline_strings"]="redline,redlinestealer"
    ["redline_exfil"]="ftp:\/\/,http:\/\/,smtp:\/\/"
    ["redline_config_markers"]="wallets,Discord,Steam"
    
    # Vidar Stealer
    ["vidar_strings"]="vidar,vidarstealer"
    ["vidar_exfil"]="ftp:\/\/,http:\/\/panel"
    ["vidar_config_markers"]="Mozilla\\Firefox\\Profiles,Opera Software\\Opera Stable\\Cookies"
    
    # Ursnif/Gozi
    ["ursnif_strings"]="ursnif,gozi,gnome,101"
    ["ursnif_patterns"]="powershell.*new-object.*net.webclient|excel\.application.createobject"
    ["ursnif_c2_pattern"]="https?:\/\/[a-z0-9\-]+\.[a-z]+\.[a-z]+\/[a-zA-Z0-9]+"
    ["ursnif_c2_patternii"]="https?:\\/\\/[A-Za-z0-9.-]+\\.[A-Za-z]{2,}(?:\\.[A-Za-z]{2,})?\\/[A-Za-z0-9._/-]*"
    ["ursnif_c2_patterniii"]="https?:\\/\\/[A-Za-z0-9.-]+\\.[A-Za-z]{2,}(?:\\.[A-Za-z]{2,})?\\/[A-Za-z0-9]+"

    # Nanocor RAT
    ["nanocor_strings"]="nanocor,nanorat"
    ["nanocor_pipes"]="\\\\.\\pipe\\NanoCore"
    
    # NetWire RAT
    ["netwire_strings"]="netwire,netwirerat"
    ["netwire_registry"]="HKCU\\Software\\Netwire,HKLM\\Software\\Netwire"

    # Snake Keylogger
    ["snakekeylogger_strings"]="snakekeylogger,snake,aylmak"
    ["snakekeylogger_panels"]="gate.php,snk.php"
    
    # Azorult
    ["azorult_strings"]="azorult,azor"
    ["azorult_exfil"]="telegram\.me\/azorult,discordapp\.com\/api\/webhooks"
    
    # Raccoon Stealer
    ["raccoon_strings"]="raccoon,accoon"
    ["raccoon_exfil"]="telegram\.me\/raccoon,discordapp\.com\/api\/webhooks"
)

# ATP/TTP INDICATORS (QR-code & Mobile attack vectors)
declare -A ATP_TTP_INDICATORS=(
    # State and criminal APT groups
    ["APT28_T1566.002"]="phishing,qr code,mail.ru,evgenii mikhailov,macro,office,rtlo"
    ["FIN7_T1059.007"]="powershell,cmd,dropper,qr,mshta.exe,cobaltstrike"
    ["EvilCorp_T1486"]="ransomware,dridex,qr code,invoicing,payload,macro"
    ["TA505_T1193"]="malspams,qr code,attachment,excel,xlsm"
    # QR/MITRE vectors
    ["QR_PHISHING_T1566.002"]="login,verify,update,qr code,spearphishing,reset,office365,secure"
    ["QR_STEGO_T1027.003"]="steganography,base64,png,jpeg,qr code,hidden,zlib,lsb"
    ["QR_SMISHING_T1464"]="sms,qr code,bank,login,account,message,fake app,otp,transfer"
    ["QR_MOBILE_EXPLOIT_T1476"]="android,intent,apk,qr code,dropper,root,overlay,bankbot,payload,malicious app,uninstall,superuser,tapjacking,autostart,device admin"
    ["QR_PAYLOAD_T1204.002"]="executable,apk,js,vba,vbs,bat,dropper,qr code,payload,ipa,malicious app"
    ["QR_COMMAND_T1059"]="curl,wget,powershell,cmd,sh,qr code,command,download,invoke,system"
    ["QR_OBFUSCATION_T1027"]="obfuscation,encoding,base64,hex,qr code,stego,hidden,xor,packer,arm,dalvik"
    ["QR_ENCRYPTION_T1041"]="encryption,exfil,ssl,tls,hidden,qr code,data,pgp,aes,rsa"
    ["QR_C2_T1071"]="beacon,api,callback,phone-home,qr code,c2,websocket,telegram,discord,slack,sms,gcm,push"
    ["QR_SOCIAL_T1448"]="social,qr code,whatsapp,telegram,invite,phishing,message,line,snapchat,wechat"
    # Commodity, pentest, MaaS, RATs
    ["Metasploit_T1059.003"]="meterpreter,msfvenom,reverse_tcp,https,payload,psh,qr code,exploit"
    ["CobaltStrike_T1105"]="cobaltstrike,beacon,qr code,stager,malleable,artifact"
    ["Empire_T1086"]="empire,powershell,stager,launcher,listener,qr code"
    ["QuasarRAT_T1219"]="quasar,rat,remote,admin,tool,qr code"
    ["Remcos_T1219"]="remcos,rat,admin,remote,qr code"
    ["NanoCore_T1219"]="nanocore,rat,admin,qr code"
    ["Redline_T1056.001"]="redline,stealer,cookie,wallet,discord,qr code"
    ["AgentTesla_T1071.004"]="agenttesla,qr code,smtp,exfil,password,keylogger"
    ["Azorult_T1003.001"]="azorult,infostealer,qr code,chrome,password,crypto"
    ["Snake_T1027"]="snake,eel,stego,qr code,lsb,png"
    ["Lokibot_T1041"]="lokibot,infostealer,document,qr code,zip,doc,exfil"
    ["Emotet_T1566"]="emotet,macro,payload,qr code,update"
    ["Trickbot_T1041"]="trickbot,banking,infostealer,qr code,payload"
    # MaaS / Red Team / Pentest abuse
    ["MaaS_T1583"]="malware-as-a-service,qr code,rat,infostealer,phishing,exploit,dropper,valid,android,ios,appstore,google play,malicious app"
    ["C2aaS_T1071"]="c2-as-a-service,qr code,beacon,websocket,api,panel,encrypted,gcm,push,cloud"
    ["RoguePentest_T1210"]="pentest,rogue,qr code,exploit,admin,automated,credential,theharvester,creds,apktool,frida,objection,mobSF"
    ["Shellter_T1204.002"]="shellter,injector,exe,payload,apk,ipa,malicious app,qr code"
    ["Veil_T1204.002"]="veil,evasion,payload,psh,exe,apk,ipa,qr code"
    ["InvokeObfuscation_T1027"]="invoke-obfuscation,powershell,obfuscate,qr code"
    ["BlackBasta_T1486"]="blackbasta,ransomware,qr code,payload,c2"
    ["Conti_T1486"]="conti,ransomware,qr code,dropper,mass"
    ["Hancitor_T1071"]="hancitor,dropper,qr code,macro,document"
    # Generic web/mobile abuse via QR
    ["QR_JS_T1059.007"]="javascript,js,qr code,onerror,onload,eval,document.write,src=,cordova,native"
    ["QR_HTML_T1204.002"]="iframe,img,html,src,data:,qr code,js,cordova"
    ["QR_INJECT_T1059"]="inject,script,cmd,exfil,qr code,activity"
    ["QR_CREDENTIAL_T1110"]="credential,login,qr code,password,session,token,pin,auth,faceid,touchid"
    ["QR_VALIDATION_T1101"]="valid,certificate,ssl,qr code,pinning,trust"
    # **Comprehensive Mobile-specific vectors:**
    ["QR_ANDROID_T1476"]="apk,intent,android,qr code,manifest,malicious app,activity,service,receiver,content provider,root,superuser,overlay,bankbot,godmode,xposed,tasker"
    ["QR_IOS_T1476"]="ipa,ios,coreml,deeplink,universal,app,malicious app,provisioning profile,enterprise,qr code,touchid,faceid"
    ["QR_MOBILE_URL_T1433"]="app.link,deeplink,intent://,universal link,applink,qr code,redirect,market://android,appstore"
    ["QR_MOBILE_BANK_T1059"]="bankbot,login,2fa,qr code,payload,phishing,credential,auth,otp,rsa,sms"
    ["QR_MOBILE_FRAUD_T1194"]="fraud,app,qr code,overlay,fake app,screen overlay,banking,malicious"
    ["QR_MOBILE_RAT_T1219"]="rat,remote,admin,tool,qr code,mobile,spyware,sms,stealth"
    ["QR_MOBILE_STEGO_T1027.003"]="steganography,lsb,png,jpeg,qr code,mobile,hidden,covert"
    ["QR_MOBILE_EXFIL_T1041"]="exfiltration,cloud,dropbox,telegram,sms,qr code,mobile"
    ["QR_MOBILE_PRIV_T1119"]="contact list,sms,call log,permissions,privacy,qr code,mobile"
    ["QR_MOBILE_SUPPLYCHAIN_T1195"]="malicious app,library,apk,ipa,qr code,supply chain"
    ["QR_MOBILE_PERSISTENCE_T1547"]="autostart,device admin,service,persistence,qr code,mobile"
    ["QR_MOBILE_ROOT_T1548"]="root,exploit,privilege escalation,superuser,qr code,mobile"
    ["QR_MOBILE_PIN_T1110"]="pin,faceid,touchid,auth,credential,qr code,mobile"
)

# Usage: See previous reply for loop code to scan your content against all TTPs.

# RANSOMWARE INDICATORS
declare -A RANSOMWARE_INDICATORS=(
    # LockBit
    ["lockbit_extensions"]=".lockbit,.abcd,.lock2bits"
    ["lockbit_notes"]="Restore-My-Files.txt,LockBit-note.hta"
    ["lockbit_domains"]="lockbitapt.com,lockbit-decryptor.com"
    # BlackCat/ALPHV
    ["blackcat_extensions"]=".alphv,.blackcat"
    ["blackcat_notes"]="RECOVER-FILES.txt,GET_YOUR_FILES_BACK.txt"
    ["blackcat_onion"]="alphvmmm27o3abo3r2mlmjrpdmzle3rykajqc5xsj7b6yzzyv6z2ziyd.onion"
    # Conti
    ["conti_extensions"]=".CONTI,.conti"
    ["conti_notes"]="readme.txt,CONTI_README.txt"
    ["conti_domains"]="contirecovery.com,continews.info"
    # REvil/Sodinokibi
    ["revil_extensions"]=".revil,.sodinokibi"
    ["revil_notes"]="README.txt,info.txt,decrypt_instructions.txt"
    ["revil_registry"]="SOFTWARE\\BlackLivesMatter,SOFTWARE\\recfg"
    # Hive
    ["hive_extensions"]=".hive,.key.hive"
    ["hive_notes"]="HOW_TO_DECRYPT.txt,hive_recovery.txt"
    # Royal
    ["royal_extensions"]=".royal,.royal_"
    ["royal_notes"]="README.TXT,royal_note.txt"
    # BlackBasta
    ["blackbasta_extensions"]=".basta"
    ["blackbasta_notes"]="readme.txt,instructions_read_me.txt"
    # Clop
    ["clop_extensions"]=".clop,.CIop,.CI0p"
    ["clop_notes"]="ClopReadMe.txt,README_README.txt"
    # Ryuk
    ["ryuk_extensions"]=".RYK,.ryuk"
    ["ryuk_notes"]="RyukReadMe.txt,UNIQUE_ID_DO_NOT_REMOVE"
    # Maze
    ["maze_extensions"]=".maze"
    ["maze_notes"]="DECRYPT-FILES.txt,maze-readme.txt"
)

# PROTOCOL HANDLERS - DANGEROUS URI SCHEMES
declare -a DANGEROUS_URI_SCHEMES=(
    "javascript:" "vbscript:" "data:" "blob:"
    "file:" "ms-word:" "ms-excel:" "ms-powerpoint:"
    "ms-access:" "ms-infopath:" "ms-msdt:" "search-ms:"
    "ms-officecmd:" "mshta:" "vbefile:"
    "tel:" "sms:" "callto:" "facetime:" "skype:"
    "ssh:" "telnet:" "ftp:" "sftp:" "rlogin:" "rsh:"
    "ldap:" "ldaps:" "ms-settings:" "ms-gamingoverlay:"
    "ms-screenclip:" "ms-screensketch:" "ms-appinstaller:"
    "msnim:" "aim:" "ymsgr:" "gtalk:" "xmpp:"
    "webcal:" "mailto:" "magnet:" "ed2k:" "thunder:"
    "flashget:" "qqdl:" "steam:" "origin:" "uplay:"
    "battle.net:" "minecraft:" "roblox:" "discord:"
    "spotify:" "itms:" "itms-apps:" "itms-appss:"
    "shortcuts:" "workflow:" "x-apple:" "facetime-audio:"
    "x-web-search:" "cydia:" "sileo:" "zbra:"
    "activesync:" "outlookmobile:" "com.microsoft:"
    "googlechrome:" "firefox:" "opera:" "safari:"
    "android-app:" "intent:" "market:" "play.google.com:"
)


################################################################################
# EXTENDED MOBILE MALWARE INDICATORS
################################################################################

declare -A MOBILE_MALWARE_INDICATORS=(
    # Android Banking Trojans
    ["anubis_indicators"]="com.android.anubis,AnubisSpy,BankBot"
    ["cerberus_indicators"]="com.cerberus.android,Cerberus,Alien"
    ["flubot_indicators"]="com.flubot,FluBot,Teabot,Cabassous"
    ["sharkbot_indicators"]="com.sharkbot,SharkBot"
    ["hydra_indicators"]="com.hydra,Hydra,BianLian"
    ["ermac_indicators"]="com.ermac,Ermac,Hook"
    ["octo_indicators"]="com.octo,Octo,Coper"
    ["xenomorph_indicators"]="com.xenomorph,Xenomorph,GodFather"
    # Android RATs
    ["ahmyth_indicators"]="com.ahmyth,AhMyth,SpyNote"
    ["spynote_indicators"]="com.spynote,SpyNote,CypherRat"
    ["androrat_indicators"]="com.androrat,AndroRAT,DenDroid"
    ["cerberus_rat"]="com.cerberus,CerberusRAT"
    # Android Spyware
    ["pegasus_indicators"]="com.pegasus,NSO,Chrysaor"
    ["predator_indicators"]="com.predator,Predator,Alien"
    ["hermit_indicators"]="com.hermit,Hermit,RCS"
    # iOS Malware
    ["pegasus_ios"]="com.nso.pegasus,jailbreakd,icloudanalyticsd"
    ["xcodeghost_indicators"]="XcodeGhost,Unity3d,PhantomPod"
    ["wirelurker_indicators"]="WireLurker,Machook,sfbase"
    # iOS Configuration Profile Attacks
    ["malicious_profiles"]="com.apple.mdm,PayloadType,PayloadRemovalDisallowed"
)

################################################################################
# MOBILE ATTACK IOC DATABASES - Extended Coverage
################################################################################

# iOS Universal Links Abuse Patterns
declare -a UNIVERSAL_LINKS_ABUSE_PATTERNS=(
    # Apple-associated-domains exploitation
    "apple-app-site-association"
    "applinks:"
    "webcredentials:"
    "activitycontinuation:"
    # Universal link hijacking
    "/.well-known/apple-app-site-association"
    "appID.*teamID"
    "paths.*NOT"
    "paths.*\*"
    # Phishing via universal links
    "apple\.com.*redirect"
    "icloud\.com.*auth"
    "appleid\.apple\.com.*signin"
    # Handoff exploitation
    "NSUserActivity"
    "continueUserActivity"
    "userActivity.*webpageURL"
)

# Android App Links Abuse Patterns
declare -a APP_LINKS_ABUSE_PATTERNS=(
    # Digital Asset Links exploitation
    "/.well-known/assetlinks.json"
    "delegate_permission/common.handle_all_urls"
    "relation.*delegate_permission"
    "target.*package_name"
    "sha256_cert_fingerprints"
    # Intent filter hijacking
    "android:autoVerify=\"true\""
    "android.intent.action.VIEW"
    "android.intent.category.BROWSABLE"
    "android.intent.category.DEFAULT"
    # Deep link hijacking
    "intent://.*#Intent"
    "S.browser_fallback_url"
    "S.market_referrer"
    "package=com\."
    "component=com\."
    # App link validation bypass
    "host=\"\*\""
    "pathPattern=\".*\""
    "scheme=\"https\""
)

# Custom URI Scheme Hijacking Patterns
declare -a SCHEME_HIJACK_PATTERNS=(
    # iOS scheme hijacking
    "CFBundleURLSchemes"
    "LSApplicationQueriesSchemes"
    "canOpenURL"
    "openURL:options:completionHandler"
    # Android scheme hijacking
    "android:scheme="
    "android:host="
    "android:pathPrefix="
    "intent-filter.*data"
    # Common hijacked schemes
    "paypal://"
    "venmo://"
    "cash://"
    "zelle://"
    "whatsapp://"
    "telegram://"
    "signal://"
    "banking://"
    "auth://"
    "oauth://"
    "sso://"
    # Scheme collision attacks
    "fb[0-9]+://"
    "twitter[0-9]+://"
    "com\\..*://"
)

# Mobile Clipboard Hijacking Patterns
declare -a CLIPBOARD_HIJACK_PATTERNS=(
    # iOS clipboard
    "UIPasteboard"
    "generalPasteboard"
    "setPersistent"
    "setItems"
    "changeCount"
    # Android clipboard
    "ClipboardManager"
    "setPrimaryClip"
    "getPrimaryClip"
    "onPrimaryClipChanged"
    "ClipData"
    # Clipboard theft indicators
    "crypto.*address.*clipboard"
    "wallet.*address.*copy"
    "clipboard.*monitor"
    "paste.*intercept"
    "clipboard.*exfil"
    # Crypto address replacement
    "bc1[a-z0-9]{39,87}"
    "0x[a-fA-F0-9]{40}"
    "T[A-Za-z1-9]{33}"
    "[13][a-km-zA-HJ-NP-Z1-9]{25,34}"
)

# Screen Overlay Attack Patterns
declare -a OVERLAY_ATTACK_PATTERNS=(
    # Android overlay permissions
    "android.permission.SYSTEM_ALERT_WINDOW"
    "TYPE_APPLICATION_OVERLAY"
    "TYPE_SYSTEM_ALERT"
    "TYPE_SYSTEM_OVERLAY"
    "TYPE_PHONE"
    "canDrawOverlays"
    "ACTION_MANAGE_OVERLAY_PERMISSION"
    # Overlay abuse patterns
    "WindowManager.LayoutParams"
    "FLAG_NOT_TOUCHABLE"
    "FLAG_NOT_FOCUSABLE"
    "FLAG_WATCH_OUTSIDE_TOUCH"
    "FLAG_LAYOUT_NO_LIMITS"
    # Banking overlay attacks
    "overlay.*bank"
    "overlay.*credential"
    "overlay.*login"
    "transparent.*activity"
    "phishing.*overlay"
    # Tapjacking patterns
    "filterTouchesWhenObscured"
    "setFilterTouchesWhenObscured"
    "FLAG_OBSCURED"
)

# Accessibility Service Abuse Patterns
declare -a ACCESSIBILITY_ABUSE_PATTERNS=(
    # Android accessibility
    "android.permission.BIND_ACCESSIBILITY_SERVICE"
    "AccessibilityService"
    "AccessibilityEvent"
    "AccessibilityNodeInfo"
    "performAction"
    "findAccessibilityNodeInfosByViewId"
    "findAccessibilityNodeInfosByText"
    # Accessibility abuse indicators
    "TYPE_VIEW_TEXT_CHANGED"
    "TYPE_VIEW_CLICKED"
    "TYPE_WINDOW_CONTENT_CHANGED"
    "TYPE_VIEW_FOCUSED"
    "getSource"
    "getText"
    # Keylogging via accessibility
    "onAccessibilityEvent"
    "eventType.*TEXT"
    "packageName.*bank"
    "className.*EditText"
    # Auto-click fraud
    "performAction.*CLICK"
    "performGlobalAction"
    "GLOBAL_ACTION_BACK"
    "GLOBAL_ACTION_HOME"
    # Screen reader abuse
    "getWindowContentFrameStats"
    "takeScreenshot"
)

# MDM Enrollment Attack Patterns
declare -a MDM_ENROLLMENT_PATTERNS=(
    # iOS MDM
    "com.apple.mdm"
    "ServerURL"
    "CheckInURL"
    "ServerCapabilities"
    "SignMessage"
    "CheckOutWhenRemoved"
    "PayloadRemovalDisallowed"
    # MDM profile payloads
    "PayloadType.*mdm"
    "PayloadContent.*Certificate"
    "PayloadContent.*SCEP"
    "PayloadContent.*VPN"
    "PayloadContent.*WiFi"
    "PayloadContent.*Restrictions"
    # Malicious MDM indicators
    "PromptUserToAllowBootstrapToken"
    "AccessRights"
    "AllowAppCellularDataModification"
    "AllowAppInstallation"
    "AllowCamera"
    "AllowPasscodeModification"
    "AllowScreenShot"
    # Enterprise enrollment
    "deviceenrollment"
    "dep-token"
    "supervision-identity"
    "anchor-certs"
)

# eSIM QR Provisioning Attack Patterns
declare -a ESIM_ATTACK_PATTERNS=(
    # eSIM activation codes
    "LPA:1\$"
    "SM-DP+"
    "SMDP+"
    "RSP"
    "1\$[a-zA-Z0-9.-]+\$[A-Z0-9-]+"
    # eSIM profile manipulation
    "ActivationCode"
    "ConfirmationCode"
    "IMEI"
    "ICCID"
    "MatchingId"
    # Carrier switch attacks
    "carrier.*switch"
    "sim.*swap"
    "esim.*profile"
    "cellular.*plan"
    # eSIM phishing
    "activate.*esim"
    "download.*profile"
    "scan.*esim.*qr"
    "transfer.*number"
)

################################################################################
# AUTHENTICATION ATTACK IOC DATABASES
################################################################################

# Device Code Phishing Patterns (Microsoft/OAuth)
declare -a DEVICE_CODE_PHISHING_PATTERNS=(
    # Microsoft device code flow
    "microsoft.com/devicelogin"
    "login.microsoftonline.com/common/oauth2/devicecode"
    "login.microsoftonline.com/common/oauth2/deviceauth"
    "device_code"
    "user_code"
    "verification_uri"
    "verification_uri_complete"
    # Device code abuse indicators
    "interval.*polling"
    "expires_in"
    "authorization_pending"
    "slow_down"
    # Phishing patterns
    "enter.*code"
    "device.*code.*expires"
    "activate.*device"
    "sign.*in.*device"
    # Other providers
    "github.com/login/device"
    "accounts.google.com/o/oauth2/device"
)

# MFA Fatigue/Bombing Attack Patterns
declare -a MFA_FATIGUE_PATTERNS=(
    # Push notification fatigue
    "approve.*login"
    "confirm.*sign.*in"
    "verify.*identity"
    "tap.*approve"
    "push.*notification"
    # MFA bypass indicators
    "mfa.*bypass"
    "2fa.*skip"
    "authentication.*fatigue"
    "prompt.*bombing"
    # Repeated auth patterns
    "multiple.*requests"
    "repeated.*attempts"
    "continuous.*prompts"
    # Social engineering
    "urgent.*approve"
    "security.*alert.*approve"
    "suspicious.*activity.*verify"
    "accept.*now"
)

# WebAuthn/Passkey Phishing Patterns
declare -a PASSKEY_PHISHING_PATTERNS=(
    # WebAuthn patterns
    "navigator.credentials.create"
    "navigator.credentials.get"
    "PublicKeyCredential"
    "authenticatorAttachment"
    "residentKey"
    # Passkey exploitation
    "passkey.*phishing"
    "fido2"
    "ctap2"
    "attestation"
    "assertion"
    # Authenticator abuse
    "platform.*authenticator"
    "cross-platform"
    "roaming.*authenticator"
    "security.*key"
    # MitM patterns
    "real.*time.*phishing"
    "proxy.*webauthn"
    "relay.*passkey"
    "evilginx.*passkey"
)

# Session Fixation Attack Patterns
declare -a SESSION_FIXATION_PATTERNS=(
    # Session ID manipulation
    "JSESSIONID="
    "PHPSESSID="
    "ASP.NET_SessionId="
    "session_id="
    "sid="
    # Fixation indicators
    "session.*fixation"
    "preset.*session"
    "inject.*session"
    "force.*session"
    # Cookie manipulation
    "Set-Cookie.*session"
    "document.cookie.*session"
    "HttpOnly.*false"
    "Secure.*false"
    # Session hijacking
    "session.*hijack"
    "steal.*session"
    "replay.*session"
    "clone.*session"
)

# SSO Token Relay Attack Patterns
declare -a SSO_RELAY_PATTERNS=(
    # SSO endpoints
    "/adfs/"
    "/saml/"
    "/oauth/"
    "/oidc/"
    "/.well-known/openid-configuration"
    # Token relay indicators
    "token.*relay"
    "sso.*proxy"
    "assertion.*replay"
    "ticket.*reuse"
    # Real-time phishing
    "evilginx"
    "modlishka"
    "gophish"
    "muraena"
    "evilnovnc"
    # Credential relay
    "ntlm.*relay"
    "kerberos.*relay"
    "ticket.*granting"
    "service.*ticket"
)

# Kerberos Attack Patterns
declare -a KERBEROS_ABUSE_PATTERNS=(
    # Kerberoasting
    "kerberoast"
    "GetUserSPNs"
    "krb5tgs"
    "servicePrincipalName"
    "TGS-REP"
    # AS-REP roasting
    "asreproast"
    "DONT_REQ_PREAUTH"
    "AS-REP"
    "krb5asrep"
    # Ticket attacks
    "golden.*ticket"
    "silver.*ticket"
    "diamond.*ticket"
    "sapphire.*ticket"
    # Pass-the-ticket
    "pass.*the.*ticket"
    "overpass.*the.*hash"
    "ptt"
    "kirbi"
    ".ccache"
    # Delegation abuse
    "unconstrained.*delegation"
    "constrained.*delegation"
    "rbcd"
    "msDS-AllowedToDelegateTo"
)

################################################################################
# FORENSIC ANALYSIS IOC DATABASES
################################################################################

# Timestamp Anomaly Patterns
declare -a TIMESTAMP_ANOMALY_PATTERNS=(
    # EXIF manipulation
    "DateTime"
    "DateTimeOriginal"
    "DateTimeDigitized"
    "CreateDate"
    "ModifyDate"
    "GPSTimeStamp"
    # Timezone anomalies
    "OffsetTime"
    "OffsetTimeOriginal"
    "OffsetTimeDigitized"
    # Suspicious patterns
    "1970-01-01"
    "2000-01-01"
    "1980-01-01"
    "0000:00:00"
    # Filesystem timestamps
    "mtime"
    "ctime"
    "atime"
    "crtime"
)

# Camera Fingerprinting Patterns
declare -a CAMERA_FINGERPRINT_PATTERNS=(
    # Device identification
    "Make"
    "Model"
    "Software"
    "LensModel"
    "SerialNumber"
    "ImageUniqueID"
    # Camera settings
    "FNumber"
    "ExposureTime"
    "ISOSpeedRatings"
    "FocalLength"
    "ExposureProgram"
    # Sensor fingerprinting
    "PRNU"
    "photo.*response.*non.*uniformity"
    "sensor.*noise"
    "hot.*pixel"
    "dead.*pixel"
    # Processing artifacts
    "WhiteBalance"
    "ColorSpace"
    "ComponentsConfiguration"
)

# Machine Identification Code (Printer Dots) Patterns
declare -a PRINTER_DOTS_PATTERNS=(
    # Yellow dot patterns
    "tracking.*dots"
    "machine.*identification"
    "MIC"
    "printer.*forensics"
    # Document metadata
    "producer"
    "creator"
    "author"
    "print.*date"
    "print.*time"
    # Steganographic watermarks
    "invisible.*watermark"
    "hidden.*pattern"
    "forensic.*marking"
    "anti.*counterfeit"
)

# Screenshot Artifact Patterns
declare -a SCREENSHOT_ARTIFACT_PATTERNS=(
    # Operating system indicators
    "Windows.*Screenshot"
    "macOS.*Screenshot"
    "iOS.*Screenshot"
    "Android.*Screenshot"
    # Screenshot metadata
    "UserComment.*Screenshot"
    "ImageDescription.*Screen"
    "Software.*Snipping"
    "Software.*Grab"
    # Screen recording indicators
    "ScreenRecording"
    "CaptureSource"
    "DisplayProfile"
    # UI elements
    "status.*bar"
    "navigation.*bar"
    "window.*chrome"
    "cursor"
)

# Compression Artifact Patterns
declare -a COMPRESSION_ARTIFACT_PATTERNS=(
    # JPEG recompression
    "Quality"
    "QuantizationTable"
    "DCT.*coefficient"
    "block.*artifact"
    "ghosting"
    # Multiple saves
    "resave.*artifact"
    "generation.*loss"
    "recompression"
    "double.*compression"
    # Editing traces
    "last.*saved"
    "history.*states"
    "edit.*count"
    "modification.*count"
)

# AI-Generated Image Patterns
declare -a AI_GENERATED_PATTERNS=(
    # AI generators
    "DALL-E"
    "Midjourney"
    "Stable.*Diffusion"
    "StyleGAN"
    "BigGAN"
    "VQGAN"
    "GLIDE"
    "Imagen"
    # AI artifacts
    "latent.*space"
    "diffusion.*model"
    "GAN.*artifact"
    "neural.*network"
    # Detection indicators
    "synthetic.*media"
    "ai.*generated"
    "machine.*learning"
    "deep.*learning"
    # Watermarks
    "C2PA"
    "Content.*Credentials"
    "Coalition.*Provenance"
)

# Deepfake Indicator Patterns
declare -a DEEPFAKE_INDICATOR_PATTERNS=(
    # Face manipulation
    "face.*swap"
    "deepfake"
    "face.*morph"
    "face.*reenactment"
    "lip.*sync"
    # Temporal anomalies
    "temporal.*inconsistency"
    "frame.*interpolation"
    "motion.*artifact"
    "blinking.*anomaly"
    # Visual artifacts
    "boundary.*artifact"
    "blending.*artifact"
    "texture.*inconsistency"
    "lighting.*mismatch"
    "reflection.*anomaly"
    # Audio deepfake
    "voice.*clone"
    "speech.*synthesis"
    "audio.*deepfake"
    "voice.*conversion"
)

# THREAT ACTOR INFRASTRUCTURE PATTERNS
declare -A THREAT_ACTOR_INFRA=(
    # Bulletproof Hosting Providers
    ["bulletproof_asns"]="AS197695,AS44477,AS202425,AS204655,AS57043"
    ["bulletproof_ranges"]="185.141.24.0/24,185.220.100.0/24,45.80.148.0/24"
    # Fast Flux DNS Patterns
    ["fastflux_ttl"]="30,60,120,180,300"  # Suspiciously low TTLs
    ["fastflux_nameservers"]="ns1.afraid.org,ns2.afraid.org,ns1.dnsmadeeasy.com"
    # Domain Generation Algorithm Patterns
    ["dga_length"]="10,15,20,25,30"  # Common DGA domain lengths
    ["dga_tlds"]=".com,.net,.org,.info,.biz,.ru,.cn"
    # Proxy/VPN Exit Nodes
    ["proxy_indicators"]="proxy,vpn,exit,tor,anonymous"
)

# CREDENTIAL HARVESTING PATTERNS
declare -a CREDENTIAL_PATTERNS=(
    # Username patterns
    "username[:=]"
    "user[:=]"
    "login[:=]"
    "email[:=]"
    "account[:=]"
    "userid[:=]"
    "user_id[:=]"
    "user_name[:=]"
    "screen_name[:=]"
    "nickname[:=]"
    # Password patterns
    "password[:=]"
    "passwd[:=]"
    "pwd[:=]"
    "pass[:=]"
    "secret[:=]"
    "credentials[:=]"
    "auth[:=]"
    "key[:=]"
    "token[:=]"
    "api_key[:=]"
    # Session patterns
    "session[:=]"
    "session_id[:=]"
    "sessionid[:=]"
    "sess[:=]"
    "sid[:=]"
    "PHPSESSID[:=]"
    "JSESSIONID[:=]"
    "ASP.NET_SessionId[:=]"
    # Cookie patterns
    "cookie[:=]"
    "auth_cookie[:=]"
    "remember_token[:=]"
    "persistent_token[:=]"
    # OAuth/JWT patterns
    "access_token[:=]"
    "refresh_token[:=]"
    "id_token[:=]"
    "bearer[:=]"
    "oauth_token[:=]"
    "authorization[:=]"
    # 2FA patterns
    "otp[:=]"
    "totp[:=]"
    "2fa[:=]"
    "mfa[:=]"
    "verification_code[:=]"
    "security_code[:=]"
)

# API KEY/SECRET PATTERNS - COMPREHENSIVE
declare -A API_KEY_PATTERNS=(
    # Cloud Providers
    ["aws_access_key"]="AKIA[0-9A-Z]{16}"
    ["aws_secret_key"]='[A-Za-z0-9/+=]{40}'
    ["aws_session_token"]="FwoGZXIvYXdzE[A-Za-z0-9/+=]+"
    ["gcp_api_key"]="AIza[0-9A-Za-z_-]{35}"
    ["gcp_oauth"]='[0-9]+-[a-z0-9]+\.apps\.googleusercontent\.com'
    ["gcp_service_account"]="\"type\":.*\"service_account\""
    ["azure_client_id"]='[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}'
    ["azure_subscription"]='[a-f0-9]{8}-[a-f0-9]{4}-4[a-f0-9]{3}-[89ab][a-f0-9]{3}-[a-f0-9]{12}'
    ["digitalocean_token"]="dop_v1_[a-f0-9]{64}"
    ["digitalocean_oauth"]="doo_v1_[a-f0-9]{64}"
    ["linode_token"]='[a-f0-9]{64}'
    ["vultr_api_key"]="[A-Z0-9]{36}"
    ["heroku_api_key"]='[0-9a-fA-F]{8}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{4}-[0-9a-fA-F]{12}'
    # Version Control
    ["github_token"]='ghp_[0-9a-zA-Z]{36}'
    ["github_oauth"]='gho_[0-9a-zA-Z]{36}'
    ["github_app_token"]='ghu_[0-9a-zA-Z]{36}'
    ["github_refresh_token"]='ghr_[0-9a-zA-Z]{36}'
    ["github_fine_grained"]='github_pat_[0-9a-zA-Z]{22}_[0-9a-zA-Z]{59}'
    ["gitlab_token"]='glpat-[0-9a-zA-Z_-]{20}'
    ["gitlab_runner"]='GR1348941[0-9a-zA-Z_-]{20}'
    ["bitbucket_token"]="ATBB[A-Za-z0-9_-]{32}"
    # Communication
    ["slack_token"]="xox[baprs]-[0-9]{10,13}-[0-9]{10,13}-[a-zA-Z0-9]{24}"
    ["slack_webhook"]="https://hooks\.slack\.com/services/T[a-zA-Z0-9]+/B[a-zA-Z0-9]+/[a-zA-Z0-9]+"
    ["discord_token"]="[MN][A-Za-z\\d]{23,}\.[\\w-]{6}\\.[\\w-]{27}"
    ["discord_webhook"]="https://discord(app)?\.com/api/webhooks/[0-9]+/[A-Za-z0-9_-]+"
    ["telegram_token"]='[0-9]{8,10}:[a-zA-Z0-9_-]{35}'
    ["twilio_sid"]="AC[a-z0-9]{32}"
    ["twilio_auth"]='[a-z0-9]{32}'
    # Payment
    ["stripe_publishable"]='pk_(test|live)_[0-9a-zA-Z]{24,99}'
    ["stripe_secret"]='sk_(test|live)_[0-9a-zA-Z]{24,99}'
    ["stripe_restricted"]='rk_(test|live)_[0-9a-zA-Z]{24,99}'
    ["square_access"]="sq0atp-[0-9A-Za-z_-]{22}"
    ["square_application"]="sq0idp-[0-9A-Za-z_-]{22}"
    ["paypal_client_id"]="A[a-zA-Z0-9_-]{20,}[A-Za-z0-9]"
    ["braintree_access"]='access_token\$production\$[0-9a-z]{16}\$[0-9a-f]{32}'
    # Social Media
    ["twitter_api_key"]='[a-zA-Z0-9]{25}'
    ["twitter_secret"]='[a-zA-Z0-9]{50}'
    ["twitter_bearer"]="AAAAAAAAAAAAAAAAAAAAAA[a-zA-Z0-9%]+"
    ["facebook_access"]="EAACEdEose0cBA[0-9A-Za-z]+"
    ["instagram_access"]="IGQV[a-zA-Z0-9_-]+"
    ["linkedin_client"]='[0-9a-z]{12,14}'
    # Email Services
    ["sendgrid_api"]="SG\.[a-zA-Z0-9_-]{22}\.[a-zA-Z0-9_-]{43}"
    ["mailchimp_api"]='[a-f0-9]{32}-us[0-9]{1,2}'
    ["mailgun_api"]='key-[0-9a-zA-Z]{32}'
    ["postmark_token"]='[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}'
    # Databases
    ["mongodb_uri"]="mongodb(\\+srv)?://[^:]+:[^@]+@[^/]+"
    ["postgres_uri"]="postgres://[^:]+:[^@]+@[^/]+"
    ["mysql_uri"]="mysql://[^:]+:[^@]+@[^/]+"
    ["redis_uri"]="redis://[^:]+:[^@]+@[^:]+:[0-9]+"
    # Analytics
    ["mixpanel_token"]='[a-f0-9]{32}'
    ["amplitude_api"]='[a-f0-9]{32}'
    ["segment_write"]='[a-zA-Z0-9]{32}'
    # Security/Auth
    ["okta_token"]="00[A-Za-z0-9_-]{40,}"
    ["auth0_token"]='[a-zA-Z0-9_-]{32,}'
    ["jwt_token"]="eyJ[a-zA-Z0-9_-]*\\.eyJ[a-zA-Z0-9_-]*\\.[a-zA-Z0-9_-]*"
    # CI/CD
    ["circleci_token"]='[a-f0-9]{40}'
    ["travis_token"]='[a-zA-Z0-9]{22}'
    ["jenkins_token"]='[a-f0-9]{32,}'
    # Other
    ["algolia_api"]='[a-f0-9]{32}'
    ["mapbox_token"]="pk\\.[a-zA-Z0-9-_]+\\.[a-zA-Z0-9-_]+"
    ["npm_token"]="npm_[A-Za-z0-9]{36}"
    ["pypi_token"]="pypi-AgEIcHlwaS5vcmc[A-Za-z0-9-_]{50,}"
    ["nuget_api"]="oy2[a-z0-9]{43}"
    ["sentry_dsn"]="https://[a-f0-9]+@[a-z]+\\.ingest\\.sentry\\.io/[0-9]+"
    ["datadog_api"]='[a-f0-9]{32}'
    ["newrelic_api"]="NRAK-[A-Z0-9]{27}"
    ["pagerduty_token"]='[a-zA-Z0-9+/]{20}'
)

################################################################################
# OBFUSCATION DETECTION PATTERNS
################################################################################

declare -A OBFUSCATION_PATTERNS=(
    # Base64 encoding patterns (AUDIT FIX: Fixed POSIX class - space outside [[:alnum:]])
    ["base64_standard"]="^[[:alnum:]+/ ]{40,}={0,2}$"
    ["base64_url_safe"]="^[[:alnum:]_-]{40,}$"
    ["base64_prefix"]="(data:|base64,|;base64)"
    ["base64_decode_call"]="(atob|base64_decode|b64decode|Base64\.decode|Buffer\.from)"
    
    # Hex encoding (FIXED: using POSIX classes)
    ["hex_string"]="^[[:xdigit:]]{40,}$"
    ["hex_escape"]="(\\x[[:xdigit:]]{2}){10,}"
    ["unicode_escape"]="(\\u[[:xdigit:]]{4}){10,}"
    
    # Character code obfuscation
    ["charcode_js"]="String\\.fromCharCode\\([[:digit:],[:space:]]+\\)"
    ["chr_php"]="chr\\([[:digit:]]+\\)"
    ["chr_python"]="chr\\([[:digit:]]+\\)"
    
    # URL encoding (FIXED: using POSIX classes)
    ["url_encoded"]="(%[[:xdigit:]]{2}){10,}"
    ["double_encoded"]="%25[[:xdigit:]]{2}"
    
    # Concatenation obfuscation
    ["string_concat_js"]="\\+[[:space:]]*['\"]"
    ["string_concat_vba"]="&[[:space:]]*['\"]"
    ["array_join"]="\\[.*\\]\\.join\\(['\"]"
    
    # Variable manipulation
    ["eval_usage"]="(eval|exec|execute|system|shell_exec|passthru)"
    ["dynamic_invoke"]="(Invoke-Expression|IEX|Invoke|[$][(])"
    ["reflection"]="(GetType|Invoke|Assembly|Load|CreateInstance)"
    
    # Compression patterns
    ["gzip_magic"]="\\x1f\\x8b"
    ["zlib_header"]="\\x78\\x9c"
    ["deflate_data"]="\\x78\\x01"
    
    # XOR patterns (FIXED: already using POSIX)
    ["xor_loop"]="(\\^=|xor|XOR)"
    ["xor_key"]="[[:alnum:]]{8,32}"
    
    # ROT13/Caesar
    ["rot13"]="(ROT13|rot13|str_rot13)"
    
    # Packing
    ["upx_packed"]="UPX0.*UPX1.*UPX2"
    ["aspack_packed"]="ASPack"
    ["mpress_packed"]="MPRESS"
    ["themida_packed"]="Themida|WinLicense"
    
    # Script obfuscators (FIXED: using POSIX classes)
    ["js_obfuscator"]="(\\$_|_0x[a-f0-9]+|__webpack)"
    ["php_obfuscator"]="\\$[a-zA-Z_][a-zA-Z0-9_]*\\[[0-9]+\\]"
    ["powershell_obf"]="(-join|-split|-replace.*\\[char\\])"

    # Additional patterns:
    # Polyglot payloads
    ["polyglot_payload"]="(<script>.*<\\/script>|<!.*-->)"
    
    # JScript . NET/ActiveX obfuscation (FIXED: using POSIX classes)
    ["activeX_object"]="new[[:space:]]+ActiveXObject\\(['\"][[:alnum:].]+['\"]\\)"
    
    # Windows Script Host (FIXED: using POSIX classes)
    ["wsh_run"]="WScript\\.Run\\(['\"][[:alnum:]/ :._-]+['\"]\\)"
    
    # Environment variable manipulation (FIXED: using POSIX classes)
    ["env_var_obf"]="(%[[:alpha:]_]+%)|(\\\$[[:alpha:]_]+)"
    
    # Self-modifying code (JavaScript)
    ["self_modify_js"]="this\\[window\\['.+? '\\]\\]"
    
    # Unicode homoglyph
    ["unicode_homoglyph"]="[Ѐ-ӿԀ-ԯⰀ-ⱟꙀ-ꚟ]"
    
    # Steganography (image/payload embedding)
    ["steg_image_data"]="(data:image/(png|jpg|jpeg).*base64,)"
    
    # HTML entities/obfuscated tags
    ["html_entity"]="&#[[:digit:]]{2,4};"
    
    # Dword obfuscation (malware C2 IP as unsigned int)
    ["dword_ip"]="\\b[[:digit:]]{8,10}\\b"
    
    # PowerShell encoded command (AUDIT FIX: Fixed POSIX class - space outside [[:alnum:]])
    ["ps_encoded_cmd"]="powershell.exe.*-enc(oded)?command[[:space:]]+[[:alnum:]+/= ]+"
    
    # JavaScript function alias obfuscation (AUDIT FIX: Fixed POSIX class - no space in [[:space:]])
    ["function_alias_js"]="var[[:space:]]+[[:alpha:]_][[:alnum:]_]*[[:space:]]*=[[:space:]]*function[[:space:]]*\\("
    
    # Execution through regsvr32/cscript/mshta/sct
    ["living_off_land"]="(regsvr32|cscript|mshta|wmic|rundll32).*\\.sct"
    
    # GZIP/zlib/deflate magic boundary obfuscation in strings
    ["compressed_magic"]="\\x1f\\x8b|PK\\x03\\x04|\\x78\\x9c|\\x78\\x01"
)

################################################################################
# Unicode Homoglyph Detection (Requires Python)
################################################################################

# Since bash/grep don't support \uXXXX Unicode escapes, this function uses Python
detect_unicode_homoglyphs() {
    local content="$1"
    
    # Skip if Python not available
    if ! command -v python3 &>/dev/null; then
        return 1
    fi
    
    # AUDIT FIX: Use base64 encoding to safely pass content to Python (prevents segfault)
    local encoded_content
    encoded_content=$(printf '%s' "$content" | base64 2>/dev/null) || return 1
    
    # Use Python for proper Unicode regex support
    local result=$(python3 - "$encoded_content" 2>/dev/null <<'EOF'
import re
import sys
import base64

try:
    content = base64.b64decode(sys.argv[1] if len(sys.argv) > 1 else '').decode('utf-8', errors='ignore')
    # Detect Cyrillic, Cyrillic Supplement, Glagolitic, Cyrillic Extended-B
    # These are commonly used for homoglyph attacks (look like Latin but are different)
    patterns = [
        r"[\u0400-\u04FF]",  # Cyrillic
        r"[\u0500-\u052F]",  # Cyrillic Supplement
        r"[\u2C00-\u2C5F]",  # Glagolitic
        r"[\uA640-\uA69F]",  # Cyrillic Extended-B
    ]
    
    for pattern in patterns: 
        if re.search(pattern, content):
            print("FOUND")
            sys.exit(0)
    print("NOT_FOUND")
except Exception: 
    print("ERROR")
EOF
)
    
    if [[ "$result" == "FOUND" ]]; then
        log_threat "+35:  Obfuscation technique detected:  unicode_homoglyph"
        log_forensic "Matched obfuscation pattern: unicode_homoglyph (Cyrillic/Glagolitic characters detected)"
        return 0
    fi
    return 1
}

################################################################################
# COMMAND & CONTROL DETECTION PATTERNS
################################################################################

declare -A C2_PATTERNS=(
    # Beacon patterns
    ["beacon_sleep"]="(sleep|delay|wait|timeout)[\\s]*[:\\(][\\s]*[0-9]+"
    ["beacon_jitter"]="jitter[\\s]*[:\\(][\\s]*[0-9]+"
    ["beacon_interval"]="interval[\\s]*[:\\(][\\s]*[0-9]+"
    # Callback patterns
    ["http_callback"]="(callback|checkin|beacon|heartbeat|poll)"
    ["dns_callback"]="(dnscat|iodine|dns2tcp|dnsexfil)"
    ["icmp_tunnel"]="(icmptunnel|ptunnel|icmpsh)"
    # Data exfiltration
    ["exfil_dns"]="(\\.txt\\.|\\.data\\.|\\.exfil\\.)[a-z0-9]+\\."
    ["exfil_http"]="(POST|PUT).*(/upload|/data|/exfil|/receive)"
    ["exfil_encoded"]="(base64|hex|encode).*(/send|/submit|/transfer)"
    # Common C2 frameworks
    ["cobalt_strike"]="(beacon|watermark|stage|sleeptime|jitter)"
    ["empire"]="(launcher|stager|agent|module)"
    ["meterpreter"]="(metsvc|metsrv|reverse_tcp|bind_tcp)"
    ["pupy"]="(pupysh|rpyc|reflective)"
    ["covenant"]="(grunt|grunts|bridgelistener|httplistener)"
    ["mythic"]="(poseidon|apollo|athena|httpx)"
    ["sliver"]="(sliver|implant|beacon|session)"
    ["havoc"]="(demon|teamserver|listener)"
    # Protocol-based C2
    ["http_c2"]="(http|https)://.*(/gate|/panel|/admin|/cmd|/control)"
    ["websocket_c2"]="(ws|wss)://.*(/shell|/term|/exec)"
    ["tcp_c2"]="tcp://[0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+:[0-9]+"
    ["dns_c2"]="\\.([a-z0-9]{4,})\\.([a-z0-9]{4,})\\.[a-z]+"
    # Encoded commands
    ["powershell_encoded"]="powershell.*(-enc|-encodedcommand|-e)[\\s]+[A-Za-z0-9+/=]+"
    ["bash_encoded"]="(bash|sh).*(-c.*base64|echo.*\\|.*base64)"
    ["python_encoded"]="python.*(-c.*base64|exec\\(.*decode)"

    # Additional patterns:
    # Cloud-based C2
    ["github_c2"]="github\\.com.*(/gist|/raw|/blob|/user-content)"
    ["dropbox_c2"]="dropbox\\.com.*(/s/|/sh/)"
    ["slack_c2"]="slack\\.com/api|hooks\\.slack\\.com/services"
    ["telegram_c2"]="api\\.telegram\\.org/bot|t\\.me/[a-zA-Z0-9]+"

    # CC/Discord C2
    ["discord_c2"]="discordapp\\.com/api/webhooks"
    ["pastebin_c2"]="pastebin\\.com/raw/[a-zA-Z0-9]+"

    # Social media C2
    ["twitter_c2"]="twitter\\.com/intent|twitter\\.com/status"
    ["facebook_c2"]="facebook\\.com/\\w+/posts/"

    # Email C2/exfil
    ["smtp_c2"]="smtp\\.[a-zA-Z0-9.-]+:[0-9]+"
    ["gmail_c2"]="imap\\.gmail\\.com|smtp\\.gmail\\.com"

    # Tor & Onion
    ["tor_c2"]="\\.[a-z0-9]{16}\\.onion"
    ["tor_hidden"]="http://[a-z0-9]{16}\\.onion"

    # Malicious proxy/c2 infrastructure
    ["socks_proxy"]="socks[45]?://[0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+:[0-9]+"
    ["vpn_tunnel"]="openvpn|tunnelblick|pptp|l2tp|ipsec"

    # Custom encoded traffic
    ["custom_base64_post"]="POST.*data=.*[A-Za-z0-9+/=]{30,}"
    ["custom_url_param"]="GET.*[?&](id|data|token|key|info)=.{10,}"

    # MQTT/IoT C2
    ["mqtt_c2"]="tcp://.*:[0-9]+.*MQTT"
    ["mqtt_topic"]="(connect.*MQTT|publish.*MQTT|subscribe.*MQTT)"

    # Google Drive/Docs & OneDrive C2
    ["gdrive_c2"]="drive\\.google\\.com/(file|open|uc)"
    ["onedrive_c2"]="onedrive\\.live\\.com/(download|view)"

    # HTTP/2 & WebSocket tunneling
    ["http2_c2"]=":scheme: h2|:method: CONNECT|:authority:"
    ["ws_payload"]="Sec-WebSocket-Key: [A-Za-z0-9+/=]{20,}"
)

################################################################################
# NETWORK IOC PATTERNS
################################################################################

declare -A NETWORK_IOC_PATTERNS=(
    # Suspicious User-Agents
    ["malware_ua"]="(python-requests/|curl/|wget/|powershell|winhttp)"
    ["empty_ua"]="^$|^-$"
    ["tool_ua"]="(nikto|sqlmap|nmap|masscan|zmap|hydra|medusa)"
    ["scanner_ua"]="(gobuster|dirbuster|wfuzz|ffuf|feroxbuster)"
    # Suspicious HTTP headers
    ["suspicious_headers"]="(X-Forwarded-For.*,.*,|X-Originating-IP|X-Remote-Addr)"
    ["proxy_headers"]="(Via:|X-Proxy-ID:|Forwarded:)"
    # DNS anomalies
    ["long_subdomain"]='[a-z0-9]{50,}\\.'
    ["many_subdomains"]="([a-z0-9]+\\.){5,}"
    ["txt_record_abuse"]="TXT.*[A-Za-z0-9+/=]{50,}"
    ["null_mx"]="MX.*0\[[:space:]]\+\\."
    # Network protocols
    ["ssh_bruteforce"]="SSH-2\\.0-.*"
    ["rdp_cookie"]="Cookie:.*mstshash="
    ["smb_signature"]="\\x00\\x00\\x00.*SMB"
    ["ldap_injection"]="(\\)\\(|\\*\\)|\\|\\(|\\$\\{)"
    # Traffic patterns
    ["periodic_beacon"]="interval:[0-9]+,jitter:[0-9]+"
    ["large_dns_query"]="qtype:(TXT|NULL|CNAME).*qname:.{100,}"
    ["encoded_dns"]="qname:([a-z0-9]{32,})\\.([a-z]{2,})"

    # Additional patterns:
    # Outbound SMB traffic (worm spreading)
    ["outbound_smb"]="destport:445.*SMB"
    # Outbound RDP
    ["outbound_rdp"]="destport:3389"
    # Outbound SSH (unusual for clients)
    ["outbound_ssh"]="destport:22"
    # TOR/Onion services traffic
    ["tor_traffic"]="([a-z0-9]{16}\\.onion|torproject\\.org)"
    # Cryptocurrency mining pool traffic
    ["mining_pool"]="(stratum+tcp://|mining-pool|xmr\\.pool|ethpool|minergate)"
    # Malicious DGA domains
    ["dga_domain"]="qname:[a-z]{15,}\\.[a-z]{2,}"
    # HTTP/2 and WebSockets
    ["http2_upgrade"]="Upgrade: h2c"
    ["websocket_upgrade"]="Upgrade: websocket"
    # Suspicious cookie values (malware tracking/session abuse)
    ["suspicious_cookie"]="Cookie:.*(PHPSESSID=|token=|sessionid=|JSESSIONID=)[A-Za-z0-9]{20,}"
    # Unusual destination ports (based on observations)
    ["unusual_port"]="destport:(1337|31337|1234|6667|9001|8080|8443)"
    # Suspicious FTP/SFTP usage
    ["suspicious_ftp"]="(USER.*[a-z0-9]{8,}|PASS.*[a-z0-9]{8,})"
    # ICMP tunneling
    ["icmp_covert"]="ICMP.*(payload|data|echo|secret)"
    # Abnormal HTTP methods (rarely seen in normal traffic)
    ["abnormal_http_method"]="(PROPFIND|OPTIONS|TRACE|CONNECT|TRACK|SEARCH)"
    # Large HTTP POST body (often exfil)
    ["large_post_body"]="POST.*Content-Length:[ ]*(1[0-9]{5,}|[2-9][0-9]{5,})"
    # HTTP requests with no Host header
    ["missing_host"]="(GET|POST|PUT|DELETE|OPTIONS).*\\r\\n(?!Host:)"
    # Suspicious referrer
    ["suspicious_referrer"]="Referer:.*\\.(ru|su|cn|tk|xyz|top|club)"
)

################################################################################
# YARA RULES DATABASE - COMPREHENSIVE
################################################################################

declare -A YARA_RULES
################################################################################
# EXTENDED IOC DATABASES - CLOUD SERVICE ABUSE
################################################################################

# Cloud Storage Abuse Patterns
declare -a CLOUD_STORAGE_ABUSE_PATTERNS=(
    # Google Services
    "drive\.google\.com/uc\?.*export=download"
    "docs\.google\.com/.*download"
    "drive\.google\.com/file/d/[a-zA-Z0-9_-]+/view"
    "storage\.googleapis\.com/[a-zA-Z0-9_-]+"
    "firebasestorage\.googleapis\.com"
    "appspot\.com/o/"
    "cloudfunctions\.net"
    "run\.app"
    # Dropbox
    "dropbox\.com/s/"
    "dl\.dropboxusercontent\.com"
    "dropbox\.com/scl/"
    "paper\.dropbox\.com"
    # OneDrive / SharePoint
    "1drv\.ms"
    "onedrive\.live\.com"
    "sharepoint\.com/.*download"
    "sharepoint\.com/.*/_layouts/"
    "onedrive\.live\.com/download"
    "my\.sharepoint\.com"
    # Amazon S3
    "s3\.amazonaws\.com"
    "s3-[a-z0-9-]+\.amazonaws\.com"
    "[a-zA-Z0-9_-]+\.s3\.amazonaws\.com"
    "s3://[a-zA-Z0-9_-]+"
    # Azure
    "blob\.core\.windows\.net"
    "azurewebsites\.net"
    "azure-api\.net"
    "azurefd\.net"
    "azureedge\.net"
    "cloudapp\.azure\.com"
    "trafficmanager\.net"
    # Cloudflare
    "workers\.dev"
    "pages\.dev"
    "r2\.cloudflarestorage\.com"
    # Other cloud services
    "backblazeb2\.com"
    "wasabisys\.com"
    "digitaloceanspaces\.com"
    "vultr-*\.com"
    "linode.*objectstorage"
    "supabase\.co/storage"
    "files\.slack\.com"
    "media\.discordapp\.net"
    "cdn\.discordapp\.com"
    "discordapp\.com/attachments/"
    "cdn\.anonfiles\.com"
    "anonfiles\.com"
    "sendspace\.com"
    "transfer\.sh"
    "file\.io"
    "gofile\.io"
    "ufile\.io"
    "mediafire\.com"
    "zippyshare\.com"
    "uploadfiles\.io"
    "bayfiles\.com"
    "mega\.nz"
    "mega\.co\.nz"
    "fex\.net"
    "wormhole\.app"
    "wetransfer\.com"
    "catbox\.moe"
    "litterbox\.catbox\.moe"
    "pomf\.cat"
    "uguu\.se"
    "teknik\.io"
    "mixtape\.moe"
    "imgur\.com/download"
    "i\.imgur\.com"
    "pasteboard\.co"
    "gyazo\.com"
    "prnt\.sc"
    "ibb\.co"
    "imgbb\.com"

    # Additional patterns:
    # More image/file/video hosts (often abused for payloads, steganography, drop zones)
    "pixeldrain\.com"
    "pixhost\.to"
    "fastupload\.io"
    "filebin\.net"
    "dl\.dropboxapi\.com"
    "pixiv\.net"
    "media\.vk\.com"
    "yadi\.sk"
    "cloud\.mail\.ru"
    "pcloud\.com"
    "filestackapi\.com"
    "nextcloud\.com"
    "owncloud\.org"
    "box\.com"
    "box\.net"
    "tinyurl\.com"
    "bit\.ly"
    "t\.co"
    "shorturl\.at"
    "shorte\.st"
    "ouo\.io"
    "we.tl"
    "sendvid\.com"
    "vid\.li"
    "streamable\.com"
    "gfycat\.com"
    "redgifs\.com"
    "cyberdrop\.me"
    "pixeldrain\.xyz"
    "filetransfer\.io"
    "tus\.io/files/"
    "ent.box.com"
    # Paste sites (malware config, staging, exfil)
    "pastebin\.com"
    "hastebin\.com"
    "ghostbin\.co"
    "dpaste\.org"
    "paste\.ee"
    "notepad\.cc"
    "justpaste\.it"
    # Messenger/cloud chat file endpoints
    "telegram\.org/file"
    "api\.telegram\.org/file/"
    "cdn\.twitch\.tv"
    "matrix\.org/_matrix/media"
    "mattermost\.cloud"
    # Abused CDN/content depots
    "akamaihd\.net"
    "cloudfront\.net"
    "cdninstagram\.com"
    "cdnfacebook\.com"
    # Institutional/edu clouds
    "cloud\.cern\.ch"
    "cloud\.uni-[a-z]{2,}\.edu"
    # === AUDIT ADDITIONS: Extended Cloud & SaaS Providers ===
    # Oracle Cloud Infrastructure
    "objectstorage\.[a-z-]+\.oraclecloud\.com"
    "oraclecloud\.com"
    "oci\.oraclecloud\.com"
    "functions\.oci\.oraclecloud\.com"
    # IBM Cloud
    "cloud\.ibm\.com"
    "s3\.[a-z-]+\.cloud-object-storage\.appdomain\.cloud"
    "functions\.cloud\.ibm\.com"
    "containers\.cloud\.ibm\.com"
    # Alibaba Cloud
    "oss-[a-z-]+\.aliyuncs\.com"
    "aliyuncs\.com"
    "fc\.[a-z-]+\.aliyuncs\.com"
    "tablestore\.aliyuncs\.com"
    "cdn\.aliyuncs\.com"
    # Tencent Cloud
    "cos\.[a-z-]+\.myqcloud\.com"
    "myqcloud\.com"
    "scf\.tencentcs\.com"
    "tencentcos\.cn"
    # DigitalOcean Spaces
    "[a-z0-9-]+\.digitaloceanspaces\.com"
    "digitaloceanspaces\.com"
    "apps\.digitalocean\.com"
    # Vultr Object Storage
    "[a-z0-9-]+\.vultrobjects\.com"
    "vultrobjects\.com"
    # Backblaze B2
    "f[0-9]+\.backblazeb2\.com"
    "backblazeb2\.com"
    "s3\.[a-z-]+\.backblazeb2\.com"
    # Wasabi
    "s3\.[a-z-]+\.wasabisys\.com"
    "wasabisys\.com"
    # Cloudflare R2
    "[a-z0-9]+\.r2\.cloudflarestorage\.com"
    "r2\.cloudflarestorage\.com"
    "pub-[a-z0-9]+\.r2\.dev"
    # Vercel
    "vercel\.app"
    "vercel-storage\.com"
    "blob\.vercel-storage\.com"
    # Netlify
    "netlify\.app"
    "netlify-blobs\.com"
    # Railway
    "railway\.app"
    "up\.railway\.app"
    # Render
    "onrender\.com"
    "render\.com"
    # Fly.io
    "fly\.dev"
    "fly\.io"
    # Supabase
    "supabase\.co"
    "supabase\.com"
    "[a-z]+\.supabase\.co/storage"
    "supabase\.in"
    # PlanetScale
    "planetscale\.com"
    "connect\.planetscale\.com"
    "psdb\.cloud"
    # Neon Database
    "neon\.tech"
    "[a-z-]+\.neon\.tech"
    "console\.neon\.tech"
    # Upstash
    "upstash\.io"
    "upstash\.com"
    # Turso
    "turso\.tech"
    "[a-z-]+\.turso\.io"
    # Deno Deploy
    "deno\.dev"
    "deno\.land"
    # Bun
    "bun\.sh"
)

# GitHub/GitLab Raw Content Abuse
declare -a CODE_HOSTING_ABUSE_PATTERNS=(
    "raw\.githubusercontent\.com"
    "gist\.githubusercontent\.com"
    "github\.com/.*/(raw|releases/download)"
    "objects\.githubusercontent\.com"
    "gitlab\.com/.*/-/raw"
    "gitlab\.com/.*/-/archive"
    "bitbucket\.org/.*/(raw|downloads)"
    "codeberg\.org/.*/raw"
    "gitea\.com/.*/raw"
    "sr\.ht/.*~"
    "pastebin\.com/raw"
    "paste\.ee/r/"
    "ghostbin\.com"
    "hastebin\.com/raw"
    "ix\.io/"
    "termbin\.com"
    "dpaste\.org"
    "bpa\.st"
    "rentry\.co"
    "privatebin\.net"
    "0bin\.net"
    "del\.dog"
    "paste\.centos\.org"
    "paste\.ubuntu\.com"
    "paste\.debian\.net"
    "pastie\.org"
    "codepad\.org"
    "ideone\.com/plain"
    "replit\.com/@"
    "jsbin\.com"
    "jsfiddle\.net"
    "codepen\.io"
    "codesandbox\.io"
    "glitch\.com"
    "stackblitz\.com"
    "observablehq\.com"
    "runkit\.com"
    "carbon\.now\.sh"
    
    # Additional patterns:
    "notepad\.pw"
    "notepad\.cc"
    "justpaste\.it"
    "paste\.sh"
    "pwbin\.xyz"
    "paste\.rs"
    "toptal\.com/developers/hastebin"
    "paste\.safebooru\.org"
    "try\.pastebin\.com"
    "paste\.org"
    "paste\.fedoraproject\.org"
    "paste2\.org"
    "codepile\.net"
    "controlc\.com"
    "ideone\.com"
    "dotnetfiddle\.net"
    "paiza\.io"
    "dbfiddle\.uk"
    "godbolt\.org"
    "W3Schools\.com/tryit/"
    "codeshare\.io"
    "tutorialspoint\.com/execute/"
    "compilejava\.net"
    "pastebin\.run"
    "pastezilla\.com"
    "pastefeed\.com"
    "pastes\.io"
    "dpaste\.com"
    "devbin\.com"
    "paste4btc\.com"
    "pl\.pastebin\.com"
    "pastebin\.pl"
    # === AUDIT ADDITIONS: Extended Developer Platform Abuse ===
    # CodeSandbox
    "codesandbox\.io/s/"
    "csb\.app"
    "[a-z0-9]+\.csb\.app"
    # StackBlitz
    "stackblitz\.com/edit"
    "stackblitz\.io"
    "[a-z0-9-]+\.stackblitz\.io"
    # Gitpod
    "gitpod\.io/#"
    "[a-z0-9-]+\.gitpod\.io"
    "gitpod\.new"
    # GitHub Codespaces
    "github\.dev"
    "[a-z0-9-]+\.github\.dev"
    "codespaces\.new"
    "vscode\.dev"
    "insiders\.vscode\.dev"
    # JetBrains Space
    "jetbrains\.space"
    "[a-z0-9-]+\.jetbrains\.space"
    "space\.jetbrains\.com"
    # Sourcegraph
    "sourcegraph\.com/search"
    "sourcegraph\.com/github\.com"
    # GitPod alternatives
    "idx\.dev"
    "idx\.google\.com"
    "project\.idx\.dev"
    # Replit extended
    "repl\.co"
    "repl\.it"
    "[a-z0-9-]+\.repl\.co"
    "firewalledreplit\.com"
    # Glitch extended
    "[a-z0-9-]+\.glitch\.me"
    "glitch\.com/edit"
    # CodePen
    "cdpn\.io"
    "codepen\.io/pen"
    # RunKit
    "runkit\.com/embed"
    "[a-z0-9-]+\.runkit\.sh"
    # Observable
    "observablehq\.com/@"
    "static\.observableusercontent\.com"
    # Val Town
    "val\.town"
    "[a-z0-9-]+\.web\.val\.run"
    # Deta Space
    "deta\.space"
    "[a-z0-9-]+\.deta\.dev"
    # Code execution APIs
    "api\.judge0\.com"
    "api\.codex\.io"
    "api\.rextester\.com"
    "api\.jdoodle\.com"
    "api\.paiza\.io"
)

################################################################################
# OFFENSIVE SECURITY / PENTESTING TOOLS DETECTION
################################################################################

# Red Team / Pentesting Frameworks and Tools
declare -a OFFENSIVE_TOOLS_PATTERNS=(
    # Command & Control Frameworks
    "cobalt.*strike"
    "cobaltstrike"
    "beacon\.dll"
    "beacon\.exe"
    "artifact\.exe"
    "sleeve.*\.dll"
    "metasploit"
    "meterpreter"
    "msfvenom"
    "msfconsole"
    "msf[0-9]"
    "exploit/multi"
    "payload/windows"
    "reverse.*tcp"
    "reverse.*https?"
    "bind.*shell"
    "staged.*payload"
    # Empire / PowerShell Empire
    "empire.*agent"
    "powershell.*empire"
    "invoke-empire"
    "empire\.ps1"
    "stager\.ps1"
    # Covenant / Grunt
    "covenant"
    "grunt\.exe"
    "gruntstager"
    # Sliver C2
    "sliver.*c2"
    "sliver.*implant"
    "sliver-server"
    # Havoc C2
    "havoc.*c2"
    "havoc.*demon"
    # Brute Ratel
    "bruteratel"
    "brute.*ratel"
    "badger\.exe"
    # Mythic C2
    "mythic.*c2"
    "apfell"
    "athena.*payload"
    # PoshC2
    "poshc2"
    "posh.*server"
    # Merlin C2
    "merlin.*c2"
    "merlin.*agent"
    # Silver / Deimos
    "silver.*c2"
    "deimos.*agent"
    # Koadic
    "koadic"
    "zomb.*js"
    # Pupy RAT
    "pupy.*rat"
    "pupysh"
    # Other RATs
    "quasar.*rat"
    "nanocore"
    "njrat"
    "darkcomet"
    "remcos"
    "asyncrat"
    "warzone.*rat"
    "netwire"
    "agent.*tesla"
    "formbook"
    "redline.*stealer"
    "vidar.*stealer"
    "raccoon.*stealer"
    "mars.*stealer"
    "erbium.*stealer"
    "aurora.*stealer"
    # Exploitation Tools
    "mimikatz"
    "lsassy"
    "secretsdump"
    "sharphound"
    "bloodhound"
    "rubeus"
    "kerberoast"
    "getst"
    "gettgt"
    "asreproast"
    "lazagne"
    "pypykatz"
    "kerbrute"
    "spray"
    "crackmapexec"
    "evil-winrm"
    "impacket"
    "psexec"
    "wmiexec"
    "smbexec"
    "atexec"
    "dcomexec"
    "winpeas"
    "linpeas"
    "pspy"
    "chisel"
    "ligolo"
    "proxychains"
    "ssh.*tunnel"
    "ngrok"
    "localtunnel"
    "serveo"
    # Reconaissance
    "nmap"
    "masscan"
    "rustscan"
    "shodan"
    "censys"
    "amass"
    "subfinder"
    "dnsenum"
    "dnsrecon"
    "fierce"
    "gobuster"
    "dirbuster"
    "ffuf"
    "feroxbuster"
    "wfuzz"
    "nuclei"
    "httpx"
    "katana"
    "waybackurls"
    "gau"
    "hakrawler"
    # Web Exploitation
    "sqlmap"
    "burp.*suite"
    "zap.*proxy"
    "nikto"
    "wpscan"
    "joomscan"
    "droopescan"
    "drupwn"
    "xsstrike"
    "dalfox"
    "ssrf.*detector"
    "tplmap"
    "commix"
    # Password Attacks
    "hashcat"
    "john.*ripper"
    "hydra"
    "medusa"
    "patator"
    "crowbar"
    "sprayhound"
    # Wireless
    "aircrack"
    "wifite"
    "fluxion"
    "evilginx"
    "gophish"
    "modlishka"
    "muraena"
    # Mobile
    "frida.*server"
    "objection"
    "apktool"
    "jadx"
    "dex2jar"
    # Evasion
    "veil.*evasion"
    "shellter"
    "unicorn"
    "msvenom"
    "donut"
    "scarecrow"
    "nimcrypt"
    "freeze"
    
    # Additional patterns:
    # More C2 frameworks, droppers, loaders
    "cmdctrl"
    "brshell"
    "evilgoat"
    "trevorc2"
    "havoc-server"
    "htran"
    "dnscat2"
    "godzilla"
    "abyss"
    "xena"
    "exmatter"
    "meowcat"
    "magicunicorn"
    "silenttrinity"
    "powerview"
    "powerup"
    "batLoader"
    "dirtjump"
    # Endpoint/AD enumeration tools
    "adfind"
    "adsearch"
    "ldapdomaindump"
    "rpcclient"
    "enum4linux"
    "spooleralert"
    # Advanced exfil/lateral movement tools
    "outflank"
    "smb_autobrute"
    "printerbug"
    "spoolSample"
    "exetrader"
    "sharpexec"
    # More evasion/loaders
    "amsi.*bypass"
    "pe2shellcode"
    "duckencode"
    "pepack"
    "sharpShooter"
    "archetype"
    "donutloader"
    "packerloader"
    "raspberryrobin"
    # Data exfil tools
    "exfiltrator"
    "exfiltrate"
    "magicdump"
    "clipboard.*exfil"
    "dnsExfil"
    "cloudExfil"
    # Automation/staging frameworks
    "cracklord"
    "rtfm"
    "empireexecutor"
    "pupyloader"
    # Living off the land binaries (LOLBins)
    "certutil"
    "mshta"
    "rundll32"
    "regsvr32"
    "wmic"
    "powershell"
    "bitsadmin"
    "xcopy"
    "robocopy"
    "curl"
    "wget"
    "ftp"
    "tftp"
    "sc"
    "schtasks"
    "at"
    "net"
    "ipconfig"
    "netsh"
    "whoami"
    "tasklist"
    "sdelete"
    "nltest"
    "dsquery"
    "dsget"
    "dnscmd"
    "arp"
    "route"
    "hostname"
    "systeminfo"
    "diskpart"
    "attrib"
)

# Known Offensive Tool File Signatures
declare -a OFFENSIVE_FILE_PATTERNS=(
    "\.cna$"                    # Cobalt Strike Aggressor scripts
    "\.profile$"                # Malleable C2 profiles
    "stageless.*payload"
    "shellcode.*loader"
    "dll.*injector"
    "process.*hollow"
    "reflective.*dll"
    "beacon.*config"
    "meterpreter.*payload"
    "reverse.*shell.*payload"
    "webshell"
    "aspxspy"
    "c99shell"
    "r57shell"
    "wso.*shell"
    "phpspy"
    "b374k"
    "weevely"
    "antsword"
    "behinder"
    "godzilla"
    "china.*chopper"
    "ice.*scorpion"

    # Additional webshells and stagers
    "shell.*jsp"
    "jspSpy"
    "jspy"
    "jspspy"
    "cf-webshell"
    "p0wny.*shell"
    "safeshell"
    "simple-backdoor"
    "mini.*shell"
    "aloha.*shell"
    "gaza.*shell"
    "reGeorg"
    "webacoo"
    "eviljava"
    "adminer.*backdoor"

    # Scripted implant signatures
    "empire.*stager"
    "posh.*stager"
    "grunt.*stager"
    "merlin.*stager"
    "sliver.*implant"
    "havoc.*implant"
    "badger.*loader"
    "mythic.*payload"
    "apfell.*payload"
    "athena.*payload"
    "batLoader"
    "donut.*shellcode"
    "magicunicorn"
    "silenttrinity"
    "sharpshooter"
    "shellter.*dropper"
    "scarecrow.*loader"
    "nimcrypt.*binary"
    "packer.*loader"
    "archetype.*dll"
    "raspberryrobin.*dll"
    "exmatter"
    "iceidloader"
    "icedidloader"

    # Exploitation framework artifacts
    "mimikatz.*exe"
    "pypykatz.*py"
    "lsassy"
    "secretsdump"
    "kerberoast"
    "asreproast"
    "rubeus.*exe"

    # General indicators
    "remote.*payload"
    "tcp.*stager"
    "http.*stager"
    "powershell.*stager"
    "reverse.*tcp.*stager"
    "xor.*payload"
    "base64.*payload"
    "encoded.*payload"
    "obfuscated.*implant"
    "obfuscate.*loader"
)

# Offensive Infrastructure Indicators
declare -a OFFENSIVE_INFRA_PATTERNS=(
    "teamserver"
    "c2.*server"
    "listener.*port"
    "stager.*url"
    "payload.*staging"
    "redirector"
    "front.*domain"
    "domain.*front"
    "cdn.*front"
    "malleable"
    "profile.*http"
    "jitter"
    "sleep.*time"
    "user.*agent.*rotate"
    "cert.*pinning.*bypass"
    "amsi.*bypass"
    "etw.*bypass"
    "disable.*defender"
    "kill.*av"
    "unhook"
    "syscall.*direct"
    "ntdll.*unhook"

    # Additional offensive infrastructure patterns:
    "dropper.*url"
    "payload.*url"
    "stage.*domain"
    "server.*controller"
    "callback.*uri"
    "command.*channel"
    "beacon.*task"
    "task.*inject"
    "implant.*delivery"
    "malicious.*proxy"
    "reverse.*proxy"
    "cloud.*front"
    "azurefrontdoor"
    "aws.*cloudfront"
    "gcp.*front"
    "traffic.*mask"
    "http.*masking"
    "ssl.*pinning.*bypass"
    "signed.*artifact"
    "code.*sign.*abuse"
    "trusted.*signer"
    "trusted.*cert"
    "control.*infra"
    "test.*c2"
    "sandbox.*bypass"
    "process.*inject"
    "winrm.*exec"
    "kerberoast"
    "sharp.*exec"
    "spinup.*infra"
    "decoy.*domain"
    "backup.*c2"
    "failover.*domain"
    "healthcheck.*c2"
    "fake.*cdn"
    "host.*delivery"
    "ssl.*redirect"
)

################################################################################
# LEGITIMATE SERVICE ABUSE PATTERNS
################################################################################

# Services commonly abused for malware delivery/C2
declare -A SERVICE_ABUSE_INDICATORS=(
    # Messaging Platforms as C2
    ["telegram_bot_c2"]="api\.telegram\.org/bot"
    ["discord_webhook_c2"]="discord(app)?\.com/api/webhooks"
    ["discord_cdn_malware"]="cdn\.discordapp\.com/attachments"
    ["slack_webhook_abuse"]="hooks\.slack\.com/services"
    ["teams_webhook"]="\.webhook\.office\.com"
    # === AUDIT ADDITIONS: Extended Messaging Platforms ===
    ["mattermost_webhook"]="\.mattermost\.(com|cloud)/hooks"
    ["mattermost_api"]="api\.mattermost\.com"
    ["whatsapp_api"]="graph\.facebook\.com/.*/messages"
    ["whatsapp_business"]="wa\.me/.*\?text="
    ["whatsapp_click"]="api\.whatsapp\.com/send"
    ["signal_link"]="signal\.me/#p/"
    ["signal_group"]="signal\.group/#"
    ["matrix_room"]="matrix\.to/#/"
    ["matrix_element"]="app\.element\.io/#/room"
    ["matrix_server"]="matrix\.[a-z]+\.org"
    ["zulip_webhook"]="\.zulipchat\.com/api"
    ["zulip_incoming"]="\.zulipchat\.com/api/v1/external"
    ["rocketchat_webhook"]="\.rocket\.chat/hooks"
    ["rocketchat_api"]="\.rocket\.chat/api"
    ["keybase_endpoint"]="keybase\.io/_/api"
    ["keybase_chat"]="keybase\.io/team/"
    ["guilded_webhook"]="media\.guilded\.gg/webhooks"
    ["revolt_webhook"]="api\.revolt\.chat/webhooks"
    ["wire_api"]="prod-nginz-https\.wire\.com"
    ["threema_api"]="api\.threema\.ch"
    # Paste Sites for Payload Hosting
    ["pastebin_raw"]="pastebin\.com/raw"
    ["ghostbin_payload"]="ghostbin\.(co|com)"
    ["paste_ee"]="paste\.ee/(r|p)"
    ["hastebin_raw"]="hastebin\.com/raw"
    ["dpaste_raw"]="dpaste\.(org|com)/.*raw"
    ["rentry_payload"]="rentry\.(co|org)"
    ["privatebin_share"]="privatebin\.net"
    ["0bin_share"]="0bin\.net"
    ["ix_io_paste"]="ix\.io/"
    ["termbin_paste"]="termbin\.com"
    # File Sharing for Malware
    ["transfer_sh"]="transfer\.sh"
    ["file_io"]="file\.io"
    ["tmpfiles"]="tmpfiles\.org"
    ["anonfiles"]="anonfiles\.com"
    ["bayfiles"]="bayfiles\.com"
    ["mediafire_dl"]="mediafire\.com/file"
    ["mega_dl"]="mega\.(nz|io)/file"
    ["gofile"]="gofile\.io"
    ["pixeldrain"]="pixeldrain\.com"
    ["catbox"]="files\.catbox\.moe"
    ["litterbox"]="litter\.catbox\.moe"
    ["uguu"]="uguu\.se"
    ["pomf"]="pomf\.(cat|lain)"
    ["cockfile"]="cockfile\.com"
    ["zippyshare"]="zippyshare\.com"
    ["sendspace"]="sendspace\.com"
    ["uploaded"]="uploaded\.(net|to)"
    # URL Shorteners (often hide malicious URLs)
    ["bitly_short"]="bit\.ly/"
    ["tinyurl_short"]="tinyurl\.com/"
    ["isgd_short"]="is\.gd/"
    ["vgd_short"]="v\.gd/"
    ["owly_short"]="ow\.ly/"
    ["rebrandly_short"]="rebrand\.ly/"
    ["cutt_ly"]="cutt\.ly/"
    ["shorturl_at"]="shorturl\.at/"
    ["t_co"]="t\.co/"
    ["goo_gl"]="goo\.gl/"
    ["yourls"]="yourls\."
    ["clicky"]="clck\.ru/"
    # Dynamic DNS (often used for C2)
    ["noip_ddns"]="\.no-ip\.(com|org|biz)"
    ["duckdns"]="\.duckdns\.org"
    ["dynu"]="\.dynu\.(com|net)"
    ["freedns"]="\.freedns\.afraid\.org"
    ["changeip"]="\.changeip\.(com|org)"
    ["hopto"]="\.hopto\.org"
    ["zapto"]="\.zapto\.org"
    ["serveftp"]="\.serveftp\.com"
    ["ddns_net"]="\.ddns\.net"
    ["sytes"]="\.sytes\.net"
    ["myftpupload"]="\.myftpupload\.com"
    # Code Execution Platforms
    ["replit_exec"]="replit\.com/@.*"
    ["glitch_exec"]="\.glitch\.me"
    ["vercel_exec"]="\.vercel\.app"
    ["netlify_exec"]="\.netlify\.app"
    ["heroku_exec"]="\.herokuapp\.com"
    ["railway_exec"]="\.railway\.app"
    ["render_exec"]="\.onrender\.com"
    ["fly_exec"]="\.fly\.dev"
    ["deno_exec"]="\.deno\.dev"
    # Ngrok/Tunneling (common for C2 callbacks)
    ["ngrok_tunnel"]="\.ngrok\.io"
    ["ngrok_tcp"]="tcp\.ngrok\.io"
    ["localtunnel"]="\.loca\.lt"
    ["serveo"]="serveo\.net"
    ["localhost_run"]="localhost\.run"
    ["telebit"]="\.telebit\.io"
    ["bore"]="bore\.pub"
    # Serverless Function Abuse
    ["aws_lambda"]="\.execute-api\..*\.amazonaws\.com"
    ["azure_func"]="\.azurewebsites\.net/api"
    ["gcp_func"]="\.cloudfunctions\.net"
    ["cloudflare_workers"]="\.workers\.dev"
    ["vercel_func"]="\.vercel\.app/api"
    ["netlify_func"]="\.netlify\.app/\.netlify/functions"
)

# Suspicious Callback Patterns
declare -a CALLBACK_PATTERNS=(
    # Common C2 callback paths
    "/__init\\.py$"
    "/beacon$"
    "/pixel\\.gif"
    "/1x1\\.gif"
    "/submit\\.php"
    "/gate\\.php"
    "/panel/gate"
    "/command$"
    "/tasks$"
    "/results$"
    "/upload$"
    "/download$"
    "/config$"
    "/update$"
    "/check-in$"
    "/heartbeat$"
    "/status$"
    "/c2$"
    "/cc$"
    "/cnc$"
    # Cobalt Strike default paths
    "/ca$"
    "/dpixel$"
    "/ptj$"
    "/j\\.ad$"
    "/activity$"
    "/\_\_utm\\.gif"
    "/pixel\\.gif$"
    "/submit\.php\?id="
    "/updates\.rss$"
    # Empire paths
    "/login/process\.php"
    "/admin/get\.php"
    "/news\.php"
    # Common webshell paths
    "/shell\.php"
    "/cmd\.php"
    "/eval\.php"
    "/exec\.php"
    "/system\.php"
    "/passthru\.php"
    "/proc_open\.php"
    "/popen\.php"
    "/c99\.php"
    "/r57\.php"
    "/wso\.php"
    "/b374k\.php"
    "/alfa\.php"
    "/mini\.php"
    "/up\.php"
    "/spy\.php"
)

################################################################################
# MOBILE DEEP LINK AND APP SCHEME DATABASES
################################################################################

# iOS Deep Links and Universal Links
declare -a IOS_DEEPLINK_PATTERNS=(
    # Configuration Profiles (HIGH RISK)
    "itms-services://\?action=download-manifest"
    "mobileconfig$"
    "apple\.com/profile"
    "profiles\.apple\.com"
    # App Store Links
    "itms://itunes\.apple\.com"
    "itms-apps://itunes\.apple\.com"
    "itms-appss://apps\.apple\.com"
    # Safari/WebKit
    "x-web-search://"
    "x-safari-https://"
    "x-safari-http://"
    # System Apps
    "facetime://"
    "facetime-audio://"
    "shortcuts://"
    "workflow://"
    "prefs://"
    "App-prefs://"
    "calshow://"
    "music://"
    "videos://"
    "ibooks://"
    "photos-redirect://"
    "contacts://"
    "reminders://"
    "notes://"
    "wallet://"
    "stocks://"
    "news://"
    "files://"
    "ftp://"
    "nfs://"
    "smb://"
    "afp://"
    "vnc://"
    # Third Party Common
    "fb://"
    "instagram://"
    "twitter://"
    "linkedin://"
    "whatsapp://"
    "telegram://"
    "signal://"
    "snapchat://"
    "tiktok://"
    "youtube://"
    "vimeo://"
    "spotify://"
    "netflix://"
    "primevideo://"
    "disneyplus://"
    "hbomax://"
    "hulu://"
    "peacock://"
    "paramount://"
    "tubi://"
    "plex://"
    "vlc://"
    "infuse://"
    "airbnb://"
    "uber://"
    "lyft://"
    "doordash://"
    "ubereats://"
    "grubhub://"
    "postmates://"
    "instacart://"
    "amazon://"
    "ebay://"
    "etsy://"
    "aliexpress://"
    "wish://"
    "paypal://"
    "venmo://"
    "cashapp://"
    "zelle://"
    "chase://"
    "bankofamerica://"
    "wellsfargo://"
    "capitalone://"
    "citi://"
    "discover://"
    "amex://"
    "coinbase://"
    "robinhood://"
    "webull://"
    "fidelity://"
    "schwab://"
    "vanguard://"
    "sofi://"
    "acorns://"
    "stash://"
    "mint://"
    "ynab://"
    "personalcapital://"
    "credit-karma://"
    "experian://"

    # Additional universal/deep link schemes:
    "maps://"
    "googlemaps://"
    "waze://"
    "citymapper://"
    "yandexmaps://"
    "uber://"
    "lyft://"
    "navmii://"
    "tripview://"
    "weather://"
    "darksky://"
    "accuweather://"
    "shazam://"
    "soundhound://"
    "tunein://"
    "audible://"
    "bookmate://"
    "goodreads://"
    "kindle://"
    "clue://"
    "foursquare://"
    "yelp://"
    "meetup://"
    "eventbrite://"
    "zoomus://"
    "skype://"
    "wechat://"
    "line://"
    "kick://"
    "messenger://"
    "groupme://"
    "twitch://"
    "discord://"
    "reddit://"
    "pinterest://"
    "tumblr://"
    "imgur://"
    "flickr://"
    "tikvpn://"
    "netguard://"
    "protonvpn://"
    "expressvpn://"
    "nordvpn://"
    "surfshark://"
    "windscribe://"
    "mail://"
    "outlook://"
    "gmail://"
    "sparkmail://"
    "aolmail://"
    "yahoo://"
    "mailru://"
    # File, cloud, and productivity
    "box://"
    "dropbox://"
    "google-drive://"
    "onedrive://"
    "evernote://"
    "notion://"
    "trello://"
    "asana://"
    "todoist://"
    "slack://"
    "monday://"
    "zoom://"
    "gotomeeting://"
    "webex://"
    "joinme://"
)

# Android Intent URIs and Deep Links
declare -a ANDROID_DEEPLINK_PATTERNS=(
    # Intent URIs (HIGH RISK)
    "intent://"
    "intent:#Intent"
    "android-app://"
    # APK Installation
    "market://details\?id="
    "market://search\?"
    "play\.google\.com/store/apps"
    "apk$"
    "xapk$"
    "apks$"
    "aab$"
    # File Providers
    "content://"
    "file://"
    # Settings
    "package://"
    # Component Launch
    "component="
    "action=android\.intent"
    "category=android\.intent"
    # Common Deep Links
    "fb://profile/"
    "fb://page/"
    "fb://group/"
    "instagram://user"
    "instagram://media"
    "twitter://user"
    "twitter://status"
    "linkedin://profile"
    "whatsapp://send"
    "telegram://resolve"
    "viber://chat"
    "line://msg/"
    "kakaotalk://open"
    "wechat://dl/"
    "snapchat://add/"
    "tiktok://@"
    "youtube://watch"
    "vimeo://app\.vimeo\.com"
    "spotify://track/"
    "deezer://www\.deezer\.com"
    "soundcloud://sounds"
    "amazon://www\.amazon"
    "ebay://ebay\.com"
    "aliexpress://detail"
    "uber://action"
    "lyft://ride"
    "doordash://store"
    "grubhub://restaurant"
    "opentable://restaurant"
    "airbnb://rooms"
    "booking://hotel"
    "expedia://hotel"
    "kayak://flights"
    "google.navigation://"
    "waze://"
    "citymapper://"
    "moovit://"
    "transit://"
    "geo:"
    "maps:"
    "comgooglemaps://"
    "googlephotos://"
    "googlecalendar://"
    "googledrive://"
    "googlemail://"
    "googletranslate://"
)

################################################################################
# BLUETOOTH/NFC/WIRELESS ATTACK PATTERNS
################################################################################

# Bluetooth/BLE Patterns
declare -a BLUETOOTH_PATTERNS=(
    "bluetooth://"
    "bt://"
    "btspp://"
    "btl2cap://"
    "btgoep://"
    "btobex://"
    "tcpobex://"
    "obex://"
    "[0-9A-Fa-f]{2}:[0-9A-Fa-f]{2}:[0-9A-Fa-f]{2}:[0-9A-Fa-f]{2}:[0-9A-Fa-f]{2}:[0-9A-Fa-f]{2}"
    "ble://"
    "gatt://"
    "uuid:[0-9a-fA-F-]{36}"
)

# NFC Patterns
declare -a NFC_PATTERNS=(
    "nfc://"
    "ndef://"
    "nfcid://"
    "smartposter://"
    "android\.nfc"
    "NDEF_DISCOVERED"
    "TAG_DISCOVERED"
    "TECH_DISCOVERED"
)

# WiFi Configuration Patterns (can be malicious)
declare -a WIFI_PATTERNS=(
    "WIFI:S:"
    "WIFI:T:"
    "WIFI:P:"
    "WIFI:H:"
    "wifi://"
    "WPA[23]?-PSK"
    "WEP"
    "SSID="
    "PSK="
    "BSSID="
)

################################################################################
# TOR EXIT NODES AND VPN ENDPOINTS DATABASE
################################################################################

# Known Tor Exit Node Patterns (partial list - would be updated from live feed)
declare -a TOR_EXIT_INDICATORS=(
    "\.onion$"
    "torproject\.org"
    "tor2web"
    "onion\.to"
    "onion\.ws"
    "onion\.ly"
    "onion\.sh"
    "onion\.cab"
    "onion\.direct"
    "onion\.link"
    "onion\.city"
    "tor2web\.org"
    "tor2web\.io"
    "tor2web\.fi"
    "darknet"
    "deepweb"
    "hidden.*service"
)

# Common VPN/Proxy Service Domains
declare -a VPN_PROXY_DOMAINS=(
    "nordvpn\.com"
    "expressvpn\.com"
    "surfshark\.com"
    "privateinternetaccess\.com"
    "protonvpn\.com"
    "mullvad\.net"
    "ipvanish\.com"
    "cyberghost"
    "purevpn\.com"
    "hidemyass\.com"
    "hotspotshield\.com"
    "tunnelbear\.com"
    "windscribe\.com"
    "strongvpn\.com"
    "astrill\.com"
    "privatevpn\.com"
    "torguard\.net"
    "airvpn\.org"
    "vyprvpn\.com"
    "hide\.me"
    "proxy\.sh"
    "cryptostorm\.is"
    "perfect-privacy\.com"
    "trustzone\.com"
    "oeck\.com"
    "azire\.com"
    "ovpn\.com"
    "ivpn\.net"
)

# Anonymizing Proxy Services
declare -a ANONYMIZING_PROXIES=(
    "kproxy\.com"
    "hidemyass\.com/proxy"
    "proxysite\.com"
    "hidester\.com"
    "filterbypass\.me"
    "unblocksites\.online"
    "croxyproxy\.com"
    "free-proxy-list\.net"
    "proxybay"
    "piratebay.*proxy"
    "kickass.*proxy"
    "1337x.*proxy"
    "rarbg.*proxy"
    "whoer\.net"
    "anonymouse\.org"
    "sslproxies\.org"
    "4everproxy\.com"
    "zalmos\.com"
    "dontfilter\.us"
    "hide-me\.org"
    "vpnbook\.com/webproxy"
    "hideproxy\.me"
    "proxify\.com"
    "justproxy\.io"
    "my-proxy\.com"
    "unblocker\.cc"
    "byproxy\.net"
    "proxyscrape\.com"
    "proxylisty\.com"
    "putlockerproxy\.com"
    "unblocktorrents\.com"
    "sitenable\.co"
    "proxfree\.com"
    "instantproxies\.com"
    "smartproxy\.com"
    "getfoxyproxy\.org"
    "us-proxy\.org"
    "uk-proxy\.org"
    "proxylist\.xyz"
    "ninjaproxy\.net"
    "hideu\.org"
    "surfshark\.com/proxy"
    "xroxy\.com"
    "webproxy\.to"
    "unblockvideos\.com"
    "proxybrowsing\.com"
)

################################################################################
# KNOWN BAD REGISTRARS AND HOSTING PROVIDERS
################################################################################

# Registrars frequently associated with abuse
declare -a SUSPICIOUS_REGISTRARS=(
    "namecheap"
    "namesilo"
    "porkbun"
    "dynadot"
    "enom"
    "resellerclub"
    "publicdomainregistry"
    "alpnames"
    "internetbs"
    "reg\.ru"
    "r01"
    "webnames\.ru"
    "regway"
    "hostinger"
    "freenom"
    "todaynic"
    "bizcn"
    "west\.cn"
    "xinnet"
    "hichina"
    "now\.cn"
    "cndns"
    "22\.cn"
    "35\.com"
    "net\.cn"

    # Additional suspicious registrars
    "gname\.com"
    "tucows"
    "101domain"
    "namesystem"
    "namebright"
    "godaddy"        # abused for phishing, despite legit business
    "register\.com"
    "dotster"
    "one\.com"
    "reg\.com"
    "rrpproxy"
    "ru-center"
    "spaceweb"
    "nic\.ru"
    "nic\.ua"
    "ukraine\.com"
    "domains\.by"
    "onamae\.com"
    "value-domain"
    "joker\.com"
    "gandi\.net"
    "ovh"
    "ovhcloud"
    "netcup"
    "key-systems"
    "abuse-contact"
    "ipmir\.org"
    "domainshosting"
    "epik\.com"
    "epik"
    "sav\.com"
    "gmo"
    "hebeidomains"
    "215\.com"
    "nic\.it"
)

# Bulletproof hosting ASNs (known for abuse tolerance)
declare -a BULLETPROOF_ASNS=(
    "AS16276"    # OVH (high abuse volume)
    "AS14061"    # DigitalOcean (frequently abused)
    "AS16509"    # Amazon (AWS abuse)
    "AS13335"    # Cloudflare (abuse via workers)
    "AS20473"    # Vultr
    "AS63949"    # Linode
    "AS45090"    # Tencent
    "AS37963"    # Alibaba
    "AS24940"    # Hetzner
    "AS51167"    # Contabo
    "AS212238"   # Datacamp
    "AS9009"     # M247 (historically problematic)
    "AS50673"    # Serverius (bulletproof reputation)
    "AS57043"    # HostKey
    "AS201011"   # NETERRA
    "AS200000"   # Hostwinds
    "AS199524"   # G-Core Labs
    "AS208312"   # BuyVM/FranTech
    "AS46664"    # VolumeDrive
    "AS46606"    # Unified Layer
    "AS205544"   # FlokiNET
    "AS58065"    # PacketCloud
    "AS51852"    # Private Layer
    "AS62904"    # Eonix Corporation
    "AS40676"    # Psychz Networks
    "AS35916"    # Multacom
    "AS36352"    # ColoCrossing
    "AS54290"    # Hostwinds LLC
    "AS53667"    # FranTech
    "AS25820"    # IT7 Networks
    "AS26548"    # Sprious LLC
)

################################################################################
# APT XOR ENCRYPTION KEY PATTERNS (for encrypted domain/C2 extraction)
################################################################################

# Chinese APT XOR keys (APT41, Winnti, PlugX, ShadowPad, Gh0st)
declare -a CHINESE_APT_XOR_KEYS=(
    0x88 0x99 0xAA 0xBB 0xCC 0xDD 0xEE
    0x86 0x87 0x93 0x95 0x9C 0xA3 0xB8
    0x35 0x36 0x37 0x38 0x39 0x3A 0x3B
    0xC3 0xC6 0xC9 0xCA 0xCB 0xCE 0xCF
)

# Russian APT XOR keys (APT28, APT29, Sandworm, Turla)
declare -a RUSSIAN_APT_XOR_KEYS=(
    0xAB 0xBA 0xCD 0xDC 0xEF 0xFE
    0x47 0x74 0x52 0x25 0x71 0x17
    0x2E 0x3E 0x4E 0x5E 0x6E 0x7E
    0xA7 0xB4 0xC2 0xD3 0xE1 0xF8
)

# North Korean APT XOR keys (Lazarus, APT38, Kimsuky)
declare -a NK_APT_XOR_KEYS=(
    0x95 0x59 0x6B 0xB6 0x4D 0xD4
    0x32 0x23 0x45 0x54 0x67 0x76
    0xAD 0xDA 0xBC 0xCB 0xDE 0xED
)

# Iranian APT XOR keys (APT33, APT34, APT35, MuddyWater)
declare -a IRANIAN_APT_XOR_KEYS=(
    0x7C 0xC7 0x8E 0xE8 0x9F 0xF9
    0x29 0x92 0x3D 0xD3 0x4B 0xB4
    0x56 0x65 0x78 0x87 0x8A 0xA8
)

# Ransomware XOR keys (common across ransomware families)
declare -a RANSOMWARE_XOR_KEYS=(
    0x66 0x77 0x88 0x99 0xAA 0xBB 0xCC 0xDD
    0x13 0x31 0x26 0x62 0x39 0x93 0x4C 0xC4
    0xF5 0x5F 0xE6 0x6E 0xD7 0x7D 0xA9 0x9A
)

# Banking Trojan XOR keys
declare -a BANKING_TROJAN_XOR_KEYS=(
    0x3C 0x7E 0x8F 0xDC 0x58 0x47
    0x10 0x03 0xCC 0x1F 0xBE 0x22
    0x11 0x44 0x64 0x82 0xA1 0xC8
)

# iOS/macOS Malware XOR keys (Pegasus-style)
declare -a IOS_MACOS_MALWARE_XOR_KEYS=(
    0xAC 0xCA 0xFD 0xDF 0xB1 0x1B 0xC4 0x4C
    0x51 0x15 0x8D 0xD8 0x9E 0xE9 0x2A 0xA2
    0x6F 0xF6 0x7A 0xA7 0x48 0x84 0x53 0x35
)

################################################################################
# RANSOMWARE NOTE PATTERNS AND SIGNATURES
################################################################################

# Common ransomware note phrases (for detection)
declare -a RANSOMWARE_NOTE_PATTERNS=(
    "your files have been encrypted"
    "all your files are encrypted"
    "your data has been encrypted"
    "your important files.*encrypted"
    "to decrypt your files"
    "decrypt.*files.*bitcoin"
    "pay.*bitcoin.*decrypt"
    "ransom.*bitcoin"
    "restore your files"
    "unlock your files"
    "your files will be deleted"
    "your files will be published"
    "we have downloaded"
    "sensitive data.*leak"
    "data will be published"
    "data auction"
    "double extortion"
    "unique decryption key"
    "decryption software"
    "decryptor"
    "private decryption key"
    "RSA-2048"
    "RSA-4096"
    "AES-256"
    "do not try to decrypt"
    "do not modify encrypted files"
    "warning.*decrypt"
    "readme.txt"
    "read_me.txt"
    "how_to_decrypt"
    "how_to_recover"
    "recovery_instructions"
    "payment instructions"
    "ATTENTION!"
    "!!! IMPORTANT !!!"
    "YOUR COMPANY"
    "contact us via"
    "onion.*contact"
    "tor browser"
    "personal ID"
    "victim ID"
    "your personal key"
    "encryption.*AES.*RSA"
    "countdown"
    "deadline"
    "price will increase"
    "price doubles"
    "first file free"
    "test decrypt"
    "guarantee"
    "proof of decrypt"
)

# Known ransomware family indicators
declare -A RANSOMWARE_FAMILIES=(
    ["lockbit"]="lockbit,lockbit2,lockbit3,lb3,.lockbit,.lb,.lb2,.lb3"
    ["conti"]="conti,.conti,CONTI_README"
    ["revil"]="revil,sodinokibi,.revil,.sodinokibi,REVIL"
    ["ryuk"]="ryuk,.ryuk,RyukReadMe"
    ["maze"]="maze,.maze,MAZE"
    ["netwalker"]="netwalker,.nwwalker,NETWALKER"
    ["ragnarlocker"]="ragnar,.ragnar,RagnarLocker"
    ["darkside"]="darkside,.darkside,DARKSIDE"
    ["blackmatter"]="blackmatter,.blackmatter,BLACKMATTER"
    ["avaddon"]="avaddon,.avaddon,AVADDON"
    ["babuk"]="babuk,.babuk,BABUK"
    ["clop"]="clop,.clop,CL0P"
    ["doppelpaymer"]="doppelpaymer,.doppel,DOPPEL"
    ["egregor"]="egregor,.egregor,EGREGOR"
    ["hive"]="hive,.hive,HIVE"
    ["karakurt"]="karakurt,.karakurt"
    ["blackcat"]="blackcat,alphv,.blackcat,ALPHV"
    ["vice"]="vice,.vice,VICE"
    ["quantum"]="quantum,.quantum"
    ["blackbasta"]="blackbasta,.basta,BLACK BASTA"
    ["royal"]="royal,.royal,ROYAL"
    ["play"]="play,.play,PLAY"
    ["akira"]="akira,.akira,AKIRA"
    ["bianlian"]="bianlian,.bianlian"
    ["medusa"]="medusa,.medusa"
    ["8base"]="8base,.8base"
    ["rhysida"]="rhysida,.rhysida"
    ["hunters"]="hunters,.hunters"
    ["cactus"]="cactus,.cactus"
    ["trigona"]="trigona,.trigona"
    ["snatch"]="snatch,.snatch"
    ["ragnarok"]="ragnarok,.ragnarok"
    ["avoslocker"]="avos,.avos,AvosLocker"
    ["cuba"]="cuba,.cuba,CUBA"
    ["grief"]="grief,.grief,GRIEF"
    ["lorenz"]="lorenz,.lorenz"
    ["mespinoza"]="mespinoza,pysa,.pysa"
    ["mountlocker"]="mountlocker,.mountlocker"
    ["nefilim"]="nefilim,.nefilim"
    ["prometheus"]="prometheus,.prometheus"
    ["ransomexx"]="ransomexx,.ransomexx"
    ["suncrypt"]="suncrypt,.suncrypt"
    ["thanos"]="thanos,.thanos"
    ["wastedlocker"]="wasted,.wasted,WastedLocker"
    ["zeppelin"]="zeppelin,.zeppelin"
)

################################################################################
# FILELESS MALWARE / LIVING-OFF-THE-LAND PATTERNS
################################################################################

# LOLBAS (Living Off The Land Binaries and Scripts) - Windows
declare -a LOLBAS_PATTERNS=(
    # Execution
    "certutil.*-urlcache"
    "certutil.*-decode"
    "certutil.*-encode"
    "certutil.*-f.*http"
    "bitsadmin.*transfer"
    "bitsadmin.*/download"
    "bitsadmin.*/addfile"
    "mshta.*vbscript:"
    "mshta.*javascript:"
    "mshta.*http"
    "msiexec.*/i.*http"
    "msiexec.*/q.*http"
    "regsvr32.*/s.*/n.*/u.*/i:"
    "regsvr32.*scrobj\.dll"
    "rundll32.*javascript:"
    "rundll32.*shell32\.dll.*ShellExec_RunDLL"
    "cmstp.*/s.*/ns"
    "control\.exe.*\.cpl"
    "cscript.*wscript\.shell"
    "wscript.*wscript\.shell"
    "forfiles.*/c"
    "pcalua.*-a"
    "presentationhost\.exe"
    "ieexec\.exe"
    "installutil.*/logfile"
    "regasm.*/u"
    "regsvcs.*/u"
    "msbuild.*\\.xml"
    "msbuild.*\\.csproj"
    "xwizard.*RunWizard"
    "syncappvpublishingserver"
    "dnscmd.*/config"
    "mavinject.*dll"
    "ftp.*-s:"
    "bash\.exe.*-c"
    "wsl\.exe"
    "wmic.*process.*call.*create"
    "wmic.*os.*get"
    # Download Cradles
    "IEX.*New-Object.*Net\.WebClient"
    "Invoke-Expression.*downloadstring"
    "IEX.*\(IWR"
    "Invoke-WebRequest"
    "Start-BitsTransfer"
    "\\.DownloadFile\\("
    "\\.DownloadString\\("
    "Invoke-RestMethod"
    "wget.*http"
    "curl.*http"
    # Scripting
    "powershell.*-e[nc]*.*"
    "powershell.*-encodedcommand"
    "powershell.*-nop.*-w.*hidden"
    "powershell.*bypass.*execution"
    "powershell.*downloadstring"
    "cmd.*/c.*powershell"
    "cmd.*/c.*wscript"
    "cmd.*/c.*cscript"
)

# GTFOBins (Linux LOTL)
declare -a GTFOBINS_PATTERNS=(
    "bash.*-i.*>&.*/dev/tcp"
    "nc.*-e.*/bin/"
    "ncat.*-e.*/bin/"
    "netcat.*-e.*/bin/"
    "python.*socket.*connect"
    "python.*pty\.spawn"
    "python3.*pty\.spawn"
    "perl.*socket.*connect"
    "ruby.*socket.*connect"
    "php.*fsockopen"
    "lua.*socket\.tcp"
    "awk.*\"/inet/tcp/"
    "gawk.*\"/inet/tcp/"
    "socat.*exec:"
    "socat.*system:"
    "openssl.*s_client.*connect"
    "wget.*-O.*-.*|.*sh"
    "curl.*|.*sh"
    "curl.*|.*bash"
    "fetch.*-o.*-.*|.*sh"
    "busybox.*nc"
    "telnet.*|.*sh"
    "ssh.*ProxyCommand"
    "ssh.*-o.*ProxyCommand"
    "vi.*:!.*sh"
    "vim.*:!.*sh"
    "less.*!.*sh"
    "more.*!.*sh"
    "man.*!.*sh"
    "find.*-exec.*sh"
    "xargs.*sh"
    "tar.*--to-command"
    "tar.*--checkpoint-action"
    "zip.*-TmTT"
    "rvim.*-c.*py"
    "git.*-p.*!/bin/sh"
    "docker.*run.*-v.*/:/host"
    "kubectl.*exec"
    "journalctl.*!/bin/sh"
    "systemctl.*!/bin/sh"
    "service.*!/bin/sh"
    "expect.*spawn"
    "screen.*-X.*stuff"
    "tmux.*send-keys"
    "nmap.*--script"
    "gdb.*-ex.*shell"
    "strace.*-o.*/dev/null"
    "ltrace.*-o.*/dev/null"
)

# AMSI Bypass Patterns
declare -a AMSI_BYPASS_PATTERNS=(
    "amsiInitFailed"
    "AmsiScanBuffer"
    "amsiContext"
    "AmsiUtils"
    "amsi[.]dll"
    "AmsiScanString"
    "SetEnvironmentVariable.*AMSI"
    "Reflection[.]Assembly.*amsi"
    "VirtualProtect.*amsi"
    "[[]Ref[]][.]Assembly[.]GetType"
    "System[.]Management[.]Automation"

    # Additional AMSI bypass patterns
    "Set-Amsi"
    "Get-Amsi"
    "Amsi.Disable"
    "AmsiBypass"
    "Bypass-AV"
    "Add-Type.*amsi"
    "System.Runtime.InteropServices"
    "Unhook-Amsi"
    "Invoke-Expression.*Amsi"
    "AMSIResult"
    "PSReflect.*amsi"
    "DllImport.*amsi"
    "patch.*amsi"
    "NtProtectVirtualMemory"
    "Win32Native"
    "Marshal.*amsi"
    "UnsafeNativeMethods"
    "amSiDisabled"
    "bypass.*amsi"
    "disable.*amsi"
    "AmsiOpenSession"
    "AmsiCloseSession"
)

################################################################################
# OFFICE DOCUMENT / MACRO MALWARE PATTERNS
################################################################################

# Office Macro Indicators
declare -a OFFICE_MACRO_PATTERNS=(
    "AutoOpen"
    "AutoClose"
    "AutoExec"
    "Auto_Open"
    "Document_Open"
    "DocumentOpen"
    "Workbook_Open"
    "WorkbookOpen"
    "Shell[(]"
    "WScript[.]Shell"
    "CreateObject.*Shell"
    "CreateObject.*WScript"
    "CreateObject.*XMLHTTP"
    "CreateObject.*ADODB"
    "CreateObject.*Scripting"
    "CreateObject.*Excel"
    "CreateObject.*Word"
    "CreateObject.*Outlook"
    "PowerShell"
    "cmd[.]exe"
    "comspec"
    "environ[(]"
    "URLDownloadToFile"
    "MSXML2[.]XMLHTTP"
    "Microsoft[.]XMLHTTP"
    "CallByName"
    "GetObject[(]"
    "CreateTextFile"
    "OpenTextFile"
    "Declare.*Lib"
    "Declare.*Function"
    "Declare.*Sub"
    "kernel32"
    "urlmon"
    "VirtualAlloc"
    "VirtualProtect"
    "RtlMoveMemory"
    "WriteProcessMemory"
    "CreateThread"
    "QueueUserAPC"
    "NtCreateThreadEx"
)

# Follina/MSDT Patterns
declare -a FOLLINA_PATTERNS=(
    "ms-msdt:"
    "msdt[.]exe"
    "ms-msdt:/id"
    "PCWDiagnostic"
    "IT_RebrowseForFile="
    "IT_LaunchMethod="
    "IT_BrowseForFile="
    "ms-msdt:-id"
    "[.]xml[!].*msdt"
    "location[.]href.*ms-msdt"

    # Additional Follina/MSDT patterns
    "WINWORD[.]EXE.*msdt"
    "office_scripts/tpl.xml"
    "ms-msdt:[-a-zA-Z0-9=&?/]+"
    "ms-msdt:/id[=a-zA-Z0-9]+"
    "Sdiagnhost[.]exe"
    "ScriptContents=.*msdt"
    "payload.*msdt"
    "<script>.*ms-msdt"
    "Word\.Document.*msdt"
    "document\.location.*ms-msdt"
    "Invoke-Expression.*msdt"
)

# OLE Object Patterns
declare -a OLE_PATTERNS=(
    "package.*shell"
    "Ole[0-9]"
    "objdata"
    "objupdate"
    "objembed"
    "DDEAUTO"
    "DDE0000"
    "LINK.*Word"
    "LINK.*Excel"
    "LINK.*PowerShell"
    "Packager Shell Object"

    # Additional OLE patterns:
    "OleObject"
    "Ole10Native"
    "package.*cmd"
    "package.*powershell"
    "LinkOleObject"
    "StdOleLink"
    "DDE.*PowerShell"
    "DDE.*cmd"
    "DDE.*/c"
    "DDE.*mshta"
    "Embedded Object"
    "EmbeddedFile"
    "Moniker"
    "Moniker.*Shell"
    "Moniker.*cmd"
    "Moniker.*powershell"
    "ScriptletFile"
    "{00020820-0000-0000-C000-000000000046}"    # Excel object CLSID
    "{00020906-0000-0000-C000-000000000046}"    # Word object CLSID
    "wpsshell"
)

################################################################################
# CERTIFICATE TRANSPARENCY / SSL ABUSE PATTERNS
################################################################################

# Recently issued cert domains (patterns suggesting phishing setup)
declare -a CERT_ABUSE_PATTERNS=(
    ".*-login.*"
    ".*-verify.*"
    ".*-secure.*"
    ".*-account.*"
    ".*-update.*"
    ".*-support.*"
    ".*-service.*"
    ".*signin.*"
    ".*logon.*"
    ".*auth.*"
    ".*password.*"
    ".*credential.*"
    ".*banking.*"
    ".*payment.*"
    ".*invoice.*"
    ".*confirm.*"
    "paypa[l1].*"
    "amaz[o0]n.*"
    "app[l1]e.*"
    "micros[o0]ft.*"
    "g[o0]{2}g[l1]e.*"
    "faceb[o0]{2}k.*"
    "netf[l1]ix.*"
    "dr[o0]pb[o0]x.*"
    "icloud.*"
    "wells.*fargo.*"
    "chase.*bank.*"
    "bank.*of.*america.*"
)

################################################################################
# USSD / TELEPHONY ATTACK PATTERNS
################################################################################

# USSD Codes that could be malicious
declare -a USSD_PATTERNS=(
    "tel:\\*#"
    "tel:\\*%23"
    "tel:\\*\\*"
    "tel:#"
    "\\*#06#"          # IMEI display
    "\\*#\\*#"         # Service menus
    "\\*2767\\*"       # Factory reset codes
    "\\*7370#"         # Format codes
    "\\*#7780#"        # Reset codes
    "##002#"           # Call forwarding
    "\\*#21#"          # Call divert check
    "\\*67"            # Call blocking
    "\\*72"            # Call forwarding
    "\\*73"            # Cancel forwarding
    "\\*\\*21\\*"      # Forward setup
    "##21#"            # Cancel all forwards
)

################################################################################
# GEOFENCING / REGION-SPECIFIC INDICATORS
################################################################################

# Geofencing Detection Patterns
declare -a GEOFENCING_PATTERNS=(
    "geo.*location"
    "navigator\\.geolocation"
    "getCurrentPosition"
    "watchPosition"
    "geoip"
    "maxmind"
    "ipinfo\\.io"
    "ip-api\\.com"
    "ipapi\\.co"
    "freegeoip"
    "ipgeolocation"
    "ipstack"
    "ipdata"
    "abstractapi.*geolocation"
    "cloudflare.*cf-ipcountry"
    "cf-ipcountry"
    "x-country-code"
    "x-geoip"
    "Accept-Language"
    "timezone.*check"
    "Intl\\.DateTimeFormat"
    "timeZone"
)

# Region-specific threat domains (partial examples)
declare -a REGION_SPECIFIC_THREATS=(
    # Russian targeting
    "\\.(ru|su|рф)$"
    # Chinese targeting
    "\\.(cn|中国|中國)$"
    # Iranian targeting
    "\\.(ir|ایران)$"
    # North Korean
    "\\.(kp)$"

    # Additional region-specific threats:
    # Eastern European & ex-USSR republics
    "\\.(ua|kz|by|uz|tj|kg|md|lv|lt|ee)$"
    # Middle East
    "\\.(ae|sa|qa|jo|sy|lb|om|ye|bh|iq|ps)$"
    # Africa
    "\\.(za|eg|ng|ke|dz|ma|gh|zm|zw|tz|ug|ao)$"
    # Southeast Asia
    "\\.(vn|id|th|my|sg|ph|kh|mm|la)$"
    # Latin America
    "\\.(br|mx|cl|ar|pe|co|ve|ec|uy|py|bo|cr|cu|do|gt|hn|ni|pa|sv)$"
    # India
    "\\.(in|भारत)$"
    # Pakistan
    "\\.(pk|پاکستان)$"
    # Taiwan
    "\\.(tw|台灣|台湾)$"
    # Hong Kong/Macau
    "\\.(hk|mo|香港|澳門)$"
    # Unicode/IDN threat domain patterns (popular for phishing)
    "\\.xn--p1ai$"    # Russia (IDN)
    "\\.xn--fiqs8s$"  # China (IDN)
    "\\.xn--mgba3a4f16a$"  # Iran (IDN)
    "\\.xn--gecrj9c$" # India (IDN)
    "\\.xn--j6w193g$" # Hong Kong (IDN)
    "\\.xn--kpry57d$" # Taiwan (IDN)
)

################################################################################
# HARDWARE / IOT EXPLOIT PATTERNS
################################################################################

# QR-targeted hardware exploits
declare -a HARDWARE_EXPLOIT_PATTERNS=(
    # Buffer overflow attempts
    "A{100,}"
    "B{100,}"
    "%00{20,}"
    "%n{10,}"
    "\\x00{50,}"
    # Format string attacks
    "%x%x%x%x"
    "%n%n%n%n"
    "%s%s%s%s"
    # Command injection for embedded systems
    ";.*sh"
    "|.*sh"
    "[\\x60].*[\\x60]"
    "[$][(].*[)]"
    # POS terminal exploits
    "pos.*exploit"
    "verifone"
    "ingenico"
    "pax.*terminal"
    "magtek"
    "id.*tech"
    # IoT specific
    "/etc/passwd"
    "/etc/shadow"
    "busybox"
    "dropbear"
    "/dev/mtd"
    "nvram"
    "uci.*set"
    "opkg.*install"
    "wget.*-O.*sh"
    # Camera/DVR exploits
    "hikvision"
    "dahua"
    "foscam"
    "axis.*camera"
    "rtsp://"
    "onvif"
    # Printer exploits
    "PJL"
    "@PJL"
    "%-12345X"
    "PostScript"
    # Smart TV
    "samsung.*tizen"
    "lg.*webos"
    "roku"
    "firetv"
    "chromecast"
    "androidtv"

    # Additional hardware exploit patterns:
    # USB/Serial attacks
    "hid.*attack"
    "usb.*inject"
    "rubberducky"
    "bashbunny"
    "digispark"
    "serial.*rx"
    "serial.*tx"
    # Embedded Linux escalation tools
    "sudohash"
    "shadowhash"
    "telnetd"
    "xinetd"
    "ashmem"
    # Firmware flashing/abuse
    "uboot"
    "dd bs=.*if=.*of="
    "mtd.*write"
    "tftp.*get"
    "tftp.*put"
    # Industrial/OT
    "modbus"
    "opcua"
    "profinet"
    "siemens"
    "allen-bradley"
    "rockwell.*automation"
    "scada"
    "plc"
    "rj45"
    "ethercat"
    # Secure boot/TPM bypass
    "tpm.*dump"
    "secureboot.*off"
    "uefi.*mod"
    "me_cleaner"
    "bootkit"
    # BLE/Zigbee/WiFi hardware exploits
    "blueborne"
    "ble_hci"
    "zigbee_exploit"
    "wifi_replay"
    "kr00k"
    "wpa_supplicant"
    # Smart home devices
    "tuya"
    "esp8266"
    "esphome"
    "homeassistant"
    "tplink_smart"
    "ring_camera"
    # QR code specific hardware attacks
    "evilqr"
    "qrphishing"
    "qr.*buffer"
    "qr.*overflow"
    "qr.*inject"

    # iPhone / iOS specific hardware exploits
    "checkra1n"
    "unc0ver"
    "taurine"
    "palera1n"
    "electra"
    "rootlessjb"
    "yalu102"
    "g0blin"
    "MeridianJailbreak"
    "pangu"
    "evasi0n"
    "iOS.*jailbreak"
    "jailbreak.*payload"
    "mobile.*substrate"
    "cydia"
    "SubstrateLoader"
    "bootstrap.*tar"
    "com.apple.mobile"
    "com.apple.springboard"
    "com.apple.dt"
    "sandbox.*escape"
    "tfp0"
    "kernel.*patch"
    "iBoot"
    "SecureEnclave"
    "SEP.*exploit"
    "applepay.*hack"
    "/private/var/mobile"
    "amfi.*bypass"
    "amfid"
    "fugu"
    "exploit.*iphone"
    "exploit.*ios"
    "phone.*exfil"
    "apple.*exfil"
    "iboot.*exploit"
    "dfu-mode"
    "iRecovery"
    "libimobiledevice"
    "lockdown.*bypass"
    "passcode.*bypass"
    "touchid.*bypass"
    "faceid.*bypass"
    "biosdump"
    "mobilebackup"
)

################################################################################
# SOCIAL ENGINEERING / PERSONA PATTERNS
################################################################################

# Social engineering urgency/authority patterns
declare -a SOCIAL_ENGINEERING_PATTERNS=(
    # Urgency
    "act now"
    "urgent.*action"
    "immediate.*action"
    "expires.*soon"
    "limited.*time"
    "deadline"
    "final.*notice"
    "last.*chance"
    "time.*sensitive"
    "respond.*within"
    "hours.*left"
    "your.*account.*will"
    # Authority
    "official.*notice"
    "from.*your.*bank"
    "security.*department"
    "it.*department"
    "hr.*department"
    "legal.*department"
    "government.*notice"
    "irs"
    "fbi"
    "cia"
    "police"
    "federal"
    "court.*order"
    "subpoena"
    "legal.*action"
    # Fear/Threat
    "your.*account.*compromised"
    "suspicious.*activity"
    "unauthorized.*access"
    "security.*breach"
    "data.*leaked"
    "identity.*stolen"
    "virus.*detected"
    "malware.*found"
    "hacked"
    "locked.*out"
    "suspended"
    "terminated"
    "legal.*consequences"
    # Reward/Greed
    "congratulations"
    "you.*have.*won"
    "claim.*your.*prize"
    "free.*gift"
    "bonus"
    "reward"
    "selected"
    "chosen"
    "winner"
    "lottery"
    "inheritance"
    "million.*dollars"
    "investment.*opportunity"
    # Trust/Familiarity
    "dear.*customer"
    "valued.*member"
    "loyal.*customer"
    "we.*noticed"
    "regarding.*your"
    "as.*per.*our"
    "following.*up"
)

# BEC (Business Email Compromise) patterns
declare -a BEC_PATTERNS=(
    "wire.*transfer"
    "change.*bank"
    "new.*account"
    "update.*payment"
    "vendor.*payment"
    "invoice.*attached"
    "urgent.*payment"
    "confidential.*request"
    "ceo.*request"
    "executive.*request"
    "gift.*card"
    "bitcoin.*payment"
    "cryptocurrency.*payment"
    "keep.*this.*confidential"
    "do.*not.*discuss"
    "handle.*this.*quietly"

    # Additional BEC patterns:
    "kindly.*process.*the.*payment"
    "kindly.*issue.*the.*payment"
    "remit.*to.*the.*new.*account"
    "as.*soon.*as.*possible"
    "bank.*details.*changed"
    "please.*change.*our.*bank"
    "request.*for.*payment"
    "confirm.*receipt.*of.*funds"
    "remit.*payment.*to"
    "please.*send.*the.*funds"
    "payment.*instructions"
    "payment.*remittance"
    "attached.*remittance.*advice"
    "final.*payment.*reminder"
    "request.*for.*urgent.*action"
    "exclusive.*request"
    "private.*payment.*info"
    "do.*not.*copy.*anyone"
    "do.*not.*reply.*all"
    "out.*of.*office"
    "acting.*on.*behalf.*of"
    "due.*to.*confidentiality"
    "settle.*this.*immediately"
    "special.*project.*payment"
    "personally.*oversee.*this"
)

################################################################################
# ADVERSARIAL QR / VISUAL ATTACK PATTERNS
################################################################################

# QR visual manipulation indicators
declare -a QR_VISUAL_ATTACK_INDICATORS=(
    "high_density_qr"          # Extremely dense QR codes
    "low_margin_qr"            # QR with minimal quiet zone
    "color_gradient_qr"        # Gradients that may confuse readers
    "pattern_overlay_qr"       # Patterns overlaid on QR
    "animated_qr"              # GIF-based animated QR
    "multi_qr_sequence"        # Multiple QRs for sequential scanning
    "nested_qr"                # QR within QR
    "holographic_qr"           # 3D/holographic effects
    "reflective_surface"       # Metallic/reflective QR
    "distorted_qr"             # Intentionally distorted
    "fragmented_qr"            # Split across surfaces
    "partial_qr"               # Incomplete QR (decoder dependent)
    "adversarial_patch"        # ML adversarial patches

    # Additional indicators:
    "micro_qr"                 # Unusually tiny QR codes
    "microdot_qr"              # QR embedded as microdot or watermark
    "logo_embedded_qr"         # Brand/logo incorporated
    "busy_background_qr"       # QR over complex/noisy background
    "camouflage_qr"            # QR hidden via camouflage
    "dual_mode_qr"             # QR readable as two different payloads depending on decoder
    "invisible_qr"             # QR shown in IR/UV spectrum
    "false_alignment_qr"       # Extra/dummy finder/alignment patterns
    "perspective_skew_qr"      # Heavily skewed perspective/angle
    "scratched_qr"             # QR physically scratched/altered
    "folded_qr"                # QR partly folded/creased
    "transparency_qr"          # Printed on transparent surface
    "sticker_overlay_qr"       # QR stickers placed over existing QR
    "misregistered_qr"         # QR misaligned in print layout
    "multi_res_qr"             # Varying resolution QR patterns (confuses readers)
    "white_qr_on_black"        # Inverse color (white QR on black background)
)

################################################################################
# ADDITIONAL MALICIOUS DOMAIN PATTERNS - INDUSTRY SPECIFIC
################################################################################

# Healthcare-specific threat patterns
declare -a HEALTHCARE_THREAT_PATTERNS=(
    "hipaa.*violation"
    "medical.*record"
    "patient.*data"
    "ehr.*access"
    "epic.*login"
    "cerner.*portal"
    "meditech"
    "athenahealth"
    "allscripts"
    "nextgen.*healthcare"
    "eclinicalworks"
    "greenway.*health"
    "kareo"
    "drchrono"
    "practice.*fusion"
    "health.*portal"
    "patient.*portal"
    "mychart.*login"
    "myhealth.*login"
    "prescription.*refill"
    "pharmacy.*verify"
    "medicare.*update"
    "medicaid.*verify"
    "insurance.*claim"
    "benefit.*verify"
    "healthcare\\.gov"
    "covered.*california"
    "va\\.gov"
    "tricare"
)

# Financial/Banking threat patterns
declare -a FINANCIAL_THREAT_PATTERNS=(
    "online.*banking"
    "netbanking"
    "ibanking"
    "mobile.*banking"
    "wire.*transfer"
    "ach.*transfer"
    "swift.*transfer"
    "account.*verify"
    "card.*verify"
    "pin.*verify"
    "cvv.*update"
    "expiry.*update"
    "credit.*limit"
    "overdraft"
    "loan.*approval"
    "mortgage.*rate"
    "refinance"
    "401k.*rollover"
    "ira.*transfer"
    "investment.*opportunity"
    "stock.*tip"
    "forex.*signal"
    "crypto.*exchange"
    "defi.*airdrop"
    "nft.*mint"
    "wallet.*connect"
    "seed.*phrase"
    "private.*key"
)

# Government/Tax threat patterns
declare -a GOVERNMENT_THREAT_PATTERNS=(
    "irs.*refund"
    "tax.*refund"
    "stimulus.*check"
    "treasury"
    "social.*security"
    "ssn.*verify"
    "ein.*verify"
    "itin.*verify"
    "passport.*renewal"
    "visa.*application"
    "immigration"
    "green.*card"
    "citizenship"
    "court.*summons"
    "jury.*duty"
    "fine.*payment"
    "warrant"
    "arrest"
    "fbi.*notice"
    "dhs.*alert"
    "dmv.*renewal"
    "license.*renewal"
    "registration.*renewal"
    "toll.*violation"
    "parking.*ticket"
    "gov\\.uk"
    "canada\\.ca"
    "australia\\.gov"
    "europa\\.eu"
)

# Education/University threat patterns
declare -a EDUCATION_THREAT_PATTERNS=(
    "student.*portal"
    "campus.*login"
    "blackboard"
    "canvas.*lms"
    "moodle"
    "d2l.*brightspace"
    "student.*email"
    "edu.*mail"
    "financial.*aid"
    "fafsa"
    "scholarship"
    "tuition.*payment"
    "enrollment"
    "registration"
    "transcript"
    "grade.*portal"
    "faculty.*portal"
    "alumni"
    "graduation"
    "commencement"
    "library.*access"
    "research.*portal"
)

# E-commerce/Retail threat patterns
declare -a ECOMMERCE_THREAT_PATTERNS=(
    "order.*confirm"
    "shipping.*update"
    "delivery.*fail"
    "package.*return"
    "refund.*process"
    "payment.*decline"
    "cart.*abandon"
    "checkout.*error"
    "inventory.*alert"
    "price.*drop"
    "flash.*sale"
    "clearance"
    "discount.*code"
    "coupon.*expire"
    "loyalty.*point"
    "reward.*redeem"
    "gift.*card.*balance"
    "store.*credit"
    "return.*label"
    "exchange.*request"
)

################################################################################
# EXTENDED SUSPICIOUS FILE EXTENSIONS
################################################################################

declare -a EXTENDED_DANGEROUS_EXTENSIONS=(
    # Polyglot/Container files
    "\.iso\.exe" "\.img\.exe" "\.vhd\.exe"
    "\.pdf\.exe" "\.doc\.exe" "\.xls\.exe"
    "\.jpg\.exe" "\.png\.exe" "\.gif\.exe"
    # Double extensions
    "\\.pdf\\.scr" "\\.doc\\.scr" "\\.xls\\.scr"
    "\\.jpg\\.scr" "\\.png\\.scr" "\\.mp3\\.scr"
    "\\.mp4\\.scr" "\\.avi\\.scr" "\\.mov\\.scr"
    # Right-to-left override
    "\\u202e" "\\u200f" "\\u200e"
    # Uncommon but dangerous
    "\\.ade" "\\.adp" "\\.bas" "\\.chm"
    "\\.cla" "\\.class" "\\.crt"
    "\\.fxp" "\\.grp" "\\.hlp"
    "\\.isp" "\\.jse" "\\.ksh"
    "\\.mad" "\\.maf" "\\.mag"
    "\\.mam" "\\.maq" "\\.mar"
    "\\.mas" "\\.mat" "\\.mau"
    "\\.mav" "\\.maw" "\\.mda"
    "\\.mdb" "\\.mde" "\\.mdt"
    "\\.mdw" "\\.mdz" "\\.mht"
    "\\.mhtml" "\\.msc" "\\.msh"
    "\\.msh1" "\\.msh2" "\\.mshxml"
    "\\.msh1xml" "\\.msh2xml"
    "\\.ops" "\\.osd" "\\.pcd"
    "\\.plg" "\\.prf" "\\.prg"
    "\\.sct" "\\.shb" "\\.shs"
    "\\.shtm" "\\.shtml" "\\.spl"
    "\\.sst" "\\.udl" "\\.vb"
    "\\.vxd" "\\.wiz" "\\.wlk"
    "\\.wml" "\\.wmd" "\\.wmz"
    "\\.wms" "\\.wsd" "\\.wsp"
    "\\.wss" "\\.xbap" "\\.xnk"
    "\\.xsl" "\\.xslt"
    # Web shells
    "\\.asp" "\\.aspx" "\\.asa"
    "\\.asax" "\\.ashx" "\\.asmx"
    "\\.cer" "\\.cdx" "\\.cshtml"
    "\\.vbhtml" "\\.rem"
    # Server-side scripts
    "\\.php[3-8]?" "\\.phtml" "\\.pht"
    "\\.inc" "\\.hta" "\\.htaccess"
    "\\.htpasswd"
    "\\.cgi" "\\.pl" "\\.fcgi"
    "\\.fpl"
    # Config files that can be abused
    "\\.config" "\\.conf" "\\.cfg"
    "\\.ini" "\\.inf" "\\.reg"
    "\\.yaml" "\\.yml" "\\.toml"
    "\\.json" "\\.xml"
    # Template injection
    "\\.ssti" "\\.twig" "\\.ejs"
    "\\.pug" "\\.jade" "\\.hbs"
    "\\.mustache" "\\.jinja"
    "\\.jinja2" "\\.j2"
    # Serialization
    "\\.pickle" "\\.pkl" "\\.marshal"
    "\\.serialized" "\\.bin"
)

################################################################################
# CRYPTOCURRENCY SCAM INDICATORS
################################################################################

declare -a CRYPTO_SCAM_PATTERNS=(
    "double.*your.*crypto"
    "send.*[0-9]+.*receive.*[0-9]+"
    "giveaway"
    "airdrop"
    "free.*bitcoin"
    "free.*eth"
    "free.*crypto"
    "elon.*musk"
    "vitalik.*buterin"
    "satoshi"
    "guaranteed.*return"
    "100%.*profit"
    "no.*risk"
    "investment.*opportunity"
    "mining.*pool"
    "cloud.*mining"
    "staking.*reward"
    "defi.*yield"
    "liquidity.*pool"
    "rug.*pull"
    "pump.*dump"
    "moonshot"
    "100x"
    "1000x"
    "gem.*alert"
    "presale"
    "private.*sale"
    "whitelist"
    "connect.*wallet"
    "approve.*contract"
    "unlimited.*approval"
    "smart.*contract"
    "token.*sale"
    "ico"
    "ido"
    "ieo"
    "launchpad"
    "seed.*round"
)

################################################################################
# ADDITIONAL MALICIOUS IP RANGES AND INDICATORS
################################################################################

# Suspicious IP ranges (CIDR notation indicators)
declare -a SUSPICIOUS_IP_RANGES=(
    # Private IP abuse in public contexts
    "^10\\."
    "^172\\.(1[6-9]|2[0-9]|3[0-1])\\."
    "^192\\.168\\."
    # Link-local
    "^169\\.254\\."
    # Loopback abuse
    "^127\\."
    # Reserved/Bogon
    "^0\\."
    "^100\\.(6[4-9]|[7-9][0-9]|1[0-1][0-9]|12[0-7])\\."
    "^192\\.0\\.0\\."
    "^192\\.0\\.2\\."
    "^198\\.51\\.100\\."
    "^203\\.0\\.113\\."
    "^224\\."
    "^240\\."
    # Direct IP access (no domain)
    "^http://[0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+"
    "^https://[0-9]+\\.[0-9]+\\.[0-9]+\\.[0-9]+"
)

################################################################################
# URL OBFUSCATION PATTERNS
################################################################################

declare -a URL_OBFUSCATION_PATTERNS=(
    # Homograph attacks (mixed scripts) - use specific chars instead of ranges
    "xn--"               # Punycode domains (IDN homograph)
    # IP obfuscation
    "0x[0-9a-fA-F]+\\.[0-9]"    # Hex IP
    "[0-9]{10,}"                 # Decimal IP
    "0[0-7]+\\."                 # Octal IP
    # URL encoding abuse
    "%2[fF]%2[fF]"               # Encoded //
    "%3[aA]%2[fF]"               # Encoded :/
    "%00"                        # Null byte
    "%0[aAdD]"                   # CR/LF
    # Path traversal in URL
    "\\.\\./\\.\\."
    "%2e%2e%2f"
    "%252e%252e%252f"
    # Data URIs
    "data:text/html"
    "data:application"
    "data:image.*base64"
    # JavaScript URIs
    "javascript:"
    "vbscript:"
    "jscript:"
    # Multiple redirects indicators
    "url=.*url="
    "redirect=.*redirect="
    "redir=.*redir="
    "next=.*next="
    "goto=.*goto="
    # Open redirects
    "/redirect\\?"
    "/redir\\?"
    "/url\\?"
    "/link\\?"
    "/go\\?"
    "/out\\?"
    "/away\\?"
    "/click\\?"
    "/track\\?"
    # Parameter pollution
    "\\?.*&.*&.*&.*&"
    "\\?.*=.*=.*=.*="

    # Additional patterns:
    # Unicode/space mangling
    "%c2%a0"                        # Non-breaking space
    "%e2%80%8b"                     # Zero-width space
    "%e2%80%8c"                     # Zero-width non-joiner
    "%e2%81%a0"                     # Word joiner
    # RTL/LTR override sequences (percent-encoded)
    "%e2%80%ae"                     # RTL override
    "%e2%80%ad"                     # LTR override
    # Double data obfuscation
    "data:.*data:.*"
    # Base64 encoded URL in param
    "b64="                          # Typical base64 param key
    # Tokenized/split URLs (hex, long, chunks, dots)
    "%2e%2e%2e"                     # Encoded ...
    "\\.\\.+"
    "_\\.[a-zA-Z]+"
    # Uncommon schemes for phishing/redirect
    "tel:"
    "sms:"
    "mailto:"
    "ftp://"
    "file://"
    "sftp://"
    # Google Safe Browsing/analytics evasion
    "&destination="
    "&continue="
    "&outside="
    # Fragment/anchor abuse
    "#/"
    "#!/"
    "#@/"
    "#%2F"
    # OAuth/callback/SSO phish markers
    "callback=.*https"
    "state=.*https"
    "return=.*https"
    "relay=.*https"
    # Internationalized subdomain abuse
    "[a-zA-Z0-9\-]+\.xn--[a-zA-Z0-9]+"
)

################################################################################
# CLOAKING AND DETECTION EVASION PATTERNS
################################################################################

declare -a CLOAKING_PATTERNS=(
    # User-Agent cloaking
    "User-Agent"
    "navigator\\.userAgent"
    "Googlebot"
    "Bingbot"
    "facebookexternalhit"
    "Twitterbot"
    "LinkedInBot"
    "WhatsApp"
    "Slackbot"
    "Discordbot"
    # Referrer cloaking
    "document\\.referrer"
    "HTTP_REFERER"
    "Referer:"
    # Cookie/Session cloaking
    "document\\.cookie"
    "sessionStorage"
    "localStorage"
    # IP-based cloaking
    "REMOTE_ADDR"
    "X-Forwarded-For"
    "X-Real-IP"
    "CF-Connecting-IP"
    # Time-based cloaking
    "setTimeout"
    "setInterval"
    "Date\\(\\)"
    "getTime\\(\\)"
    # Canvas fingerprinting
    "toDataURL"
    "getImageData"
    "measureText"
    # WebGL fingerprinting
    "WEBGL"
    "getExtension"
    "getParameter"
    # Audio fingerprinting
    "AudioContext"
    "createOscillator"
    # Battery API
    "getBattery"
    "navigator\\.battery"
    # Screen fingerprinting
    "screen\\.width"
    "screen\\.height"
    "screen\\.colorDepth"
    "devicePixelRatio"

    # Additional cloaking/fingerprinting patterns:
    # Mobile device & OS detection
    "navigator\\.platform"
    "navigator\\.vendor"
    "navigator\\.languages"
    "navigator\\.language"
    "navigator\\.hardwareConcurrency"
    "navigator\\.maxTouchPoints"
    "window\\.orientation"
    "window\\.innerWidth"
    "window\\.innerHeight"
    # Touch events (mobile/tablet detection)
    "ontouchstart"
    "ontouchend"
    "ontouchmove"
    # Geolocation API
    "navigator\\.geolocation"
    "getCurrentPosition"
    "watchPosition"
    # Plugin fingerprinting
    "navigator\\.plugins"
    "navigator\\.mimeTypes"
    # WebRTC fingerprinting/IP leak
    "RTCPeerConnection"
    "getUserMedia"
    "navigator\\.mediaDevices"
    # Accelerometer/Gyroscope Sensor API
    "DeviceMotionEvent"
    "DeviceOrientationEvent"
    # Clipboard API
    "navigator\\.clipboard"
    # Font fingerprinting
    "document\\.fonts"
    "fontFaceSet"
    # Storage quota detection (abuse by cloaking)
    "navigator\\.storage"
    "storageQuota"
    "estimate"
    # Multiple fingerprint modules (external libraries)
    "fingerprintjs"
    "evercookie"
    "supercookie"
    # TLS/SSL/Connection fingerprinting
    "window\\.crypto"
    "subtle\\.digest"
    "subtle\\.encrypt"
    # CPU/GPU benchmarking
    "performance\\.now"
    "performance\\.measure"
    # Advanced device API/Javascript features
    "navigator\\.deviceMemory"
    "navigator\\.userAgentData"
    # Frame, iframe, ancestor check (cloaking)
    "window\\.top"
    "window\\.parent"
    "window\\.frameElement"
)

################################################################################
# CALLBACK/BEACON PATTERNS
################################################################################

declare -a CALLBACK_BEACON_PATTERNS=(
    # Beacon frameworks
    "cobalt.*strike"
    "meterpreter"
    "empire"
    "covenant"
    "sliver"
    "mythic"
    "brute.*ratel"
    "havoc"
    "nighthawk"
    "poshc2"
    # Beacon behavior
    "checkin"
    "check-in"
    "heartbeat"
    "ping.*back"
    "callback"
    "call.*home"
    "beacon"
    "keepalive"
    "keep-alive"
    "poll"
    "sleep.*[0-9]+"
    "jitter"
    # Malleable profiles
    "malleable"
    "profile"
    "spawnto"
    "prepend"
    "append"
    "transform"
    # DNS beaconing
    "dns.*beacon"
    "dns.*tunnel"
    "dnscat"
    "iodine"
    "dnstunnel"
    # ICMP tunneling
    "icmp.*tunnel"
    "ptunnel"
    "icmptx"
)

################################################################################
# COMMAND INJECTION PATTERNS
################################################################################

declare -a COMMAND_INJECTION_PATTERNS=(
    # Shell metacharacters
    ";.*;"
    "\\|.*\\|"
    "&.*&"
    "\\$\\(.*\\)"
    "[\\x60].*[\\x60]"
    # Common injection payloads
    ";id;"
    ";whoami;"
    ";uname;"
    ";cat /etc"
    ";ls -la"
    ";pwd;"
    ";echo.*>"
    ";wget "
    ";curl "
    # Windows specific
    "&dir&"
    "&whoami&"
    "&ipconfig&"
    "&net user"
    "&systeminfo"
    # Template injection
    "\\{\\{.*\\}\\}"
    "\\{%.*%\\}"
    "\\$\\{.*\\}"
    "#{.*}"
    "<%.*%>"
    # SSTI payloads
    "__class__"
    "__mro__"
    "__subclasses__"
    "__globals__"
    "__builtins__"
    "config\\.items"
    "request\\.application"
    # XXE indicators
    "<!ENTITY"
    "<!DOCTYPE"
    "SYSTEM.*file:"
    "SYSTEM.*http:"
    "SYSTEM.*ftp:"
    "SYSTEM.*expect:"
    # SSRF indicators
    "file:///"
    "gopher://"
    "dict://"
    "expect://"
    "php://"
    "phar://"
    "jar:"
    "netdoc:"

    # Additional command injection patterns
    # RCE payloads
    "nc .* -e"
    "nc .* -c"
    "rm -rf"
    "sh -i"
    "python -c"
    "perl -e"
    "ruby -e"
    "php -r"
    "bash -c"
    "powershell -Command"
    "pwsh -Command"
    "Invoke-Expression"
    "certutil -urlcache"
    "Invoke-WebRequest"
    "Start-Process"
    "IEX"
    "wget.*http" #- File download
    "curl.*http" #- File download
    "exec\(" #- Direct execution
    "eval\(" #- Code evaluation
    "/dev/tcp/" #- Bash reverse shell
    "mkfifo" #- Named pipe creation
    "ncat" #- Netcat alternative
    "socat" #- Socket utility

    # PowerShell encoded command
    "-encodedcommand"
    "-enc"
    # Reverse shell and bind shell signatures
    "/bin/sh"
    "exec[(]\""
    "spawn[(]"
    "socket\\.socket"
    "popen[(]"
    "os\\.system"
    "subprocess\\.Popen"
    "subprocess\\.call"
    # Scripting execution in webapp
    "system\\("
    "passthru\\("
    "shell_exec\\("
    "eval\\("
    "assert\\("
    "preg_replace\\("    # with /e modifier
    "exec\\("
    "pcntl_exec\\("
    # Perl/CGI
    "open\\("
    "syscall\\("
    # Blind injection tactics
    ";sleep\\("
    "SLEEP[(]"
    "WAITFOR DELAY"
    "BENCHMARK\\("
    "pg_sleep\\("
    # Path traversal and access/creation
    "\\.\\.\\/\\.\\.\\/"
    "/tmp/"
    "/dev/shm/"
    "powershell.exe"
    "cmd.exe"
    # Encoding tricks/hex/obfuscation
    "\\\\x[0-9a-fA-F]{2,}"
    "\\\\u[0-9a-fA-F]{2,}"
    "%u[0-9a-fA-F]{2,}"

    # iPhone/iOS specific patterns
    "/private/var/mobile/"
    "/var/mobile/"
    "/var/root/"
    "/var/logs/"
    "launchctl"
    "otool"
    "dyld"
    "pspawn"
    "amfid"
    "tfp0"
    "sandbox-exec"
    "SpringBoard"
    "SubstrateLoader"
    "Cydia"
    "jailbreak"
    "checkra1n"
    "unc0ver"
    "electra"
    "palera1n"
    "pangu"
    "yalu102"
    "fugu"
    "iBoot"
    "SEP.*exploit"
    "SecureEnclave"
    "MobileSubstrate"
    "bootstrap.*tar"
    "libimobiledevice"
    "iRecovery"
    "com.apple.mobile"
    "com.apple.springboard"
    "com.apple.dt"
    "rootlessjb"
    "g0blin"
)


init_yara_rules() {
    log_info "Initializing YARA rules database..."
    
    # Phishing Detection
    YARA_RULES["phishing_url"]='
        strings:
            $login = /login|signin|verify/ nocase
            $urgent = /urgent|suspended|action/ nocase
            $brand = /paypal|amazon|netflix|microsoft|google|apple|facebook/ nocase
        condition:
            ($login and $urgent) or ($brand and $urgent)
        severity: HIGH
    '
    
    # Malware Distribution
    YARA_RULES["malware_distribution"]='
        strings:
            $exec = /\.(exe|dll|scr|bat|cmd|ps1|vbs|js|jar|apk|msi|dmg|pkg)/
            $download = /download|install|update|patch|setup/ nocase
            $urgent = /urgent|required|mandatory|immediately/ nocase
        condition:
            $exec and ($download or $urgent)
        severity: HIGH
    '
    
    # Crypto Scam Detection
    YARA_RULES["crypto_scam"]='
        strings:
            $btc_addr = /bc1[a-z0-9]{39,87}|1[a-km-zA-HJ-NP-Z1-9]{25,34}/
            $eth_addr = /0x[a-fA-F0-9]{40}/
            $urgency = /limited|exclusive|invest|double|giveaway|airdrop/ nocase
            $celebrity = /elon|musk|bezos|zuckerberg|trump|biden/ nocase
        condition:
            ($btc_addr or $eth_addr) and ($urgency or $celebrity)
        severity: CRITICAL
    '
    
    # PowerShell Malware
    YARA_RULES["powershell_malware"]='
        strings:
            $iex = /IEX|Invoke-Expression/ nocase
            $download = /downloadstring|downloadfile|webclient|webrequest/ nocase
            $encoded = /-enc|-encodedcommand/ nocase
            $bypass = /-executionpolicy bypass|-ep bypass/ nocase
            $hidden = /-windowstyle hidden|-w hidden/ nocase
        condition:
            ($iex and $download) or ($encoded) or ($bypass and $hidden)
        severity: HIGH
    '
    
    # Ransomware Indicators
    YARA_RULES["ransomware"]='
        strings:
            $ransom1 = "your files have been encrypted" nocase
            $ransom2 = "pay bitcoin" nocase
            $ransom3 = ".onion" nocase
            $ransom4 = "decrypt" nocase
            $ransom5 = "ransom" nocase
            $timer = /[0-9]+ (hours|days) remaining/ nocase
        condition:
            2 of them
        severity: CRITICAL
    '
    
    # C2 Communication
    YARA_RULES["c2_communication"]='
        strings:
            $beacon = "beacon" nocase
            $checkin = "checkin" nocase
            $callback = "callback" nocase
            $raw_paste = "pastebin.com/raw" nocase
            $raw_github = "raw.githubusercontent.com" nocase
            $ip_url = /http:\/\/\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}/
        condition:
            any of them
        severity: HIGH
    '
    
    # Data Exfiltration
    YARA_RULES["data_exfil"]='
        strings:
            $post = "POST" nocase
            $password = "password" nocase
            $credential = "credential" nocase
            $upload = "upload" nocase
            $archive = /\.(zip|rar|7z|tar|gz)/ nocase
            $encoded = /base64|encoded|encrypted/ nocase
        condition:
            ($post and ($password or $credential)) or ($upload and ($archive or $encoded))
        severity: HIGH
    '
    
    # JavaScript Obfuscation
    YARA_RULES["obfuscation"]='
        strings:
            $eval_atob = "eval(atob("
            $fromcharcode = "String.fromCharCode" nocase
            $unescape = "unescape(%" nocase
            $function_ctor = "Function(" nocase
            $document_write = "document.write(unescape" nocase
        condition:
            any of them
        severity: MEDIUM
    '
    
    # Keylogger Detection
    YARA_RULES["keylogger"]='
        strings:
            $keylog1 = "keylog" nocase
            $keylog2 = "keystroke" nocase
            $api1 = "GetAsyncKeyState" nocase
            $api2 = "SetWindowsHookEx" nocase
            $python = "pynput" nocase
            $keyboard = "keyboard.hook" nocase
        condition:
            any of them
        severity: CRITICAL
    '
    
    # Remote Access Trojan
    YARA_RULES["remote_access"]='
        strings:
            $rat1 = "njrat" nocase
            $rat2 = "darkcomet" nocase
            $rat3 = "remcos" nocase
            $rat4 = "asyncrat" nocase
            $rat5 = "quasar" nocase
            $shell1 = "reverse shell" nocase
            $shell2 = "bind shell" nocase
            $hidden = "hidden" nocase
            $remote = "remote desktop" nocase
        condition:
            any of ($rat*) or (($shell1 or $shell2) and $hidden) or ($remote and $hidden)
        severity: CRITICAL
    '
    
    # Credential Theft
    YARA_RULES["credential_theft"]='
        strings:
            $mimi = "mimikatz" nocase
            $lsass = "lsass" nocase
            $sam = "SAM" nocase
            $browser = "browser" nocase
            $password = "password" nocase
            $cookie = "cookie" nocase
            $cred_dump = "credential dump" nocase
        condition:
            $mimi or $lsass or $cred_dump or (($browser or $sam) and ($password or $cookie))
        severity: CRITICAL
    '
    
    # Banking Trojan
    YARA_RULES["banking_trojan"]='
        strings:
            $inject = "webinject" nocase
            $grab = "formgrabber" nocase
            $zeus = "zeus" nocase
            $dridex = "dridex" nocase
            $trickbot = "trickbot" nocase
            $banking = "banking" nocase
        condition:
            $inject or $grab or (($zeus or $dridex or $trickbot) and $banking)
        severity: CRITICAL
    '
    
    # Mobile Malware
    YARA_RULES["mobile_malware"]='
        strings:
            $sms_read = "READ_SMS" nocase
            $sms_send = "SEND_SMS" nocase
            $call = "android.permission.CALL_PHONE" nocase
            $contacts = "READ_CONTACTS" nocase
            $location = "ACCESS_FINE_LOCATION" nocase
            $apk = ".apk" nocase
            $payload = "payload" nocase
        condition:
            ($sms_read and $sms_send) or $call or ($apk and $payload) or (2 of ($sms_read, $sms_send, $contacts, $location))
        severity: HIGH
    '
    
    # IoT Malware
    YARA_RULES["iot_malware"]='
        strings:
            $mirai = "mirai" nocase
            $bashlite = "bashlite" nocase
            $gafgyt = "gafgyt" nocase
            $watchdog = "/dev/watchdog" nocase
            $telnet = "telnet" nocase
            $default_pass = "default" nocase
        condition:
            $mirai or $bashlite or $gafgyt or $watchdog or ($telnet and $default_pass)
        severity: HIGH
    '
    
    # Cryptominer
    YARA_RULES["cryptominer"]='
        strings:
            $miner1 = "stratum+tcp://" nocase
            $miner2 = "xmrig" nocase
            $miner3 = "cpuminer" nocase
            $miner4 = "minergate" nocase
            $pool1 = "pool.minergate.com" nocase
            $pool2 = "xmr.nanopool.org" nocase
            $monero = "monero" nocase
            $wallet = /4[0-9AB][1-9A-HJ-NP-Za-km-z]{93}/ nocase
        condition:
            any of them
        severity: HIGH
    '
    
    # Exploit Kit Landing Page
    YARA_RULES["exploit_kit"]='
        strings:
            $flash = "FlashVars" nocase
            $java = "deployJava" nocase
            $pdf = "application/pdf" nocase
            $iframe = /<iframe.*src=.*http/ nocase
            $pack = /eval\(function\(p,a,c,k,e/ nocase
            $obf = /\\x[0-9a-f]{2}/ nocase
        condition:
            ($flash or $java or $pdf) and ($iframe or $pack or $obf)
        severity: CRITICAL
    '
    
    # Phishing Kit
    YARA_RULES["phishing_kit"]='
        strings:
            $form = /<form.*action=.*\.php/ nocase
            $input_pass = /<input.*type=.password/ nocase
            $input_email = /<input.*type=.email/ nocase
            $submit = /submit|login|sign.?in|verify/ nocase
            $brand_img = /(paypal|amazon|google|microsoft|apple|facebook).*\.(png|jpg|svg)/ nocase
        condition:
            $form and $input_pass and ($input_email or $submit) and $brand_img
        severity: HIGH
    '
    
    # Session Hijacking
    YARA_RULES["session_hijack"]='
        strings:
            $session = "session" nocase
            $token = "token" nocase
            $cookie = "cookie" nocase
            $steal = "steal" nocase
            $capture = "capture" nocase
            $intercept = "intercept" nocase
        condition:
            ($session or $token or $cookie) and ($steal or $capture or $intercept)
        severity: HIGH
    '
    
    # Webshell Detection
    YARA_RULES["webshell"]='
        strings:
            $php_eval = /eval[[:space:]]*\([[:space:]]*\$_(GET|POST|REQUEST|COOKIE)/ nocase
            $php_assert = /assert[[:space:]]*\([[:space:]]*\$_(GET|POST|REQUEST)/ nocase
            $php_system = /system[[:space:]]*\([[:space:]]*\$_(GET|POST|REQUEST)/ nocase
            $php_exec = /exec[[:space:]]*\([[:space:]]*\$_(GET|POST|REQUEST)/ nocase
            $php_shell = /shell_exec[[:space:]]*\([[:space:]]*\$_(GET|POST|REQUEST)/ nocase
            $php_pass = /passthru[[:space:]]*\([[:space:]]*\$_(GET|POST|REQUEST)/ nocase
            $c99 = "c99shell" nocase
            $r57 = "r57shell" nocase
            $wso = "wso shell" nocase
            $b374k = "b374k" nocase
        condition:
            any of them
        severity: CRITICAL
    '
    
    # SQL Injection
    YARA_RULES["sql_injection"]='
        strings:
            $union = "UNION SELECT" nocase
            $or_1 = "OR 1=1" nocase
            $and_1 = "AND 1=1" nocase
            $drop = "DROP TABLE" nocase
            $insert = "INSERT INTO" nocase
            $update_set = /UPDATE.*SET/ nocase
            $sleep = "SLEEP(" nocase
            $benchmark = "BENCHMARK(" nocase
            $waitfor = "WAITFOR DELAY" nocase
        condition:
            any of them
        severity: HIGH
    '
    
    # XSS Attack
    YARA_RULES["xss_attack"]='
        strings:
            $script = /<script.*>/ nocase
            $onerror = /onerror[[:space:]]*=/ nocase
            $onload = /onload[[:space:]]*=/ nocase
            $onclick = /onclick[[:space:]]*=/ nocase
            $onmouseover = /onmouseover[[:space:]]*=/ nocase
            $img_src = /<img.*src=.*javascript:/ nocase
            $svg_onload = /<svg.*onload=/ nocase
        condition:
            any of them
        severity: MEDIUM
    '
    
    # Privilege Escalation
    YARA_RULES["privilege_escalation"]='
        strings:
            $sudo = "sudo" nocase
            $setuid = "setuid" nocase
            $suid = "SUID" nocase
            $runas = "runas" nocase
            $admin = "administrator" nocase
            $root = "root" nocase
            $escalate = "escalate" nocase
            $privilege = "privilege" nocase
        condition:
            ($sudo or $setuid or $suid or $runas) and ($escalate or $privilege)
        severity: HIGH
    '
    
    # Persistence Mechanism
    YARA_RULES["persistence"]='
        strings:
            $registry = /HKLM|HKCU|HKEY_/ nocase
            $run_key = /CurrentVersion\\Run/ nocase
            $startup = "Startup" nocase
            $service = "sc create" nocase
            $scheduled = "schtasks" nocase
            $cron = "crontab" nocase
            $systemd = "systemctl enable" nocase
            $launchd = "LaunchAgent" nocase
            $plist = ".plist" nocase
        condition:
            ($registry and $run_key) or $startup or $service or $scheduled or $cron or $systemd or ($launchd and $plist)
        severity: HIGH
    '
    
    # Defense Evasion
    YARA_RULES["defense_evasion"]='
        strings:
            $disable_av = /disable.*antivirus|antivirus.*disable/ nocase
            $stop_service = /net stop|sc stop/ nocase
            $firewall = /netsh.*firewall.*off/ nocase
            $defender = /Set-MpPreference.*-Disable/ nocase
            $tamper = "tamper" nocase
            $kill_process = /taskkill|kill -9/ nocase
        condition:
            any of them
        severity: HIGH
    '
    
    # Lateral Movement
    YARA_RULES["lateral_movement"]='
        strings:
            $psexec = "psexec" nocase
            $wmic = "wmic" nocase
            $winrm = "winrm" nocase
            $rdp = "mstsc" nocase
            $ssh_cmd = /ssh[[:space:]]\+\w+@/ nocase
            $pass_hash = "pass.?the.?hash" nocase
            $mimikatz = "mimikatz" nocase
        condition:
            any of them
        severity: HIGH
    '
    
    # Data Collection
    YARA_RULES["data_collection"]='
        strings:
            $screenshot = "screenshot" nocase
            $keylog = "keylog" nocase
            $clipboard = "clipboard" nocase
            $webcam = "webcam" nocase
            $microphone = "microphone" nocase
            $record = "record" nocase
            $capture = "capture" nocase
        condition:
            2 of them
        severity: MEDIUM
    '
}

################################################################################
# MULTI-DECODER SYSTEM WITH ENHANCED CAPABILITIES
################################################################################
#
# COMPREHENSIVE BARCODE/QR DECODER ENGINE (38 Decoders Total)
# ============================================================
#
# 2D BARCODE DECODERS:
# --------------------
#   1. zbar           - Native ZBar QR/barcode decoder
#   2. pyzbar         - Python ZBar bindings with crash isolation
#   3. opencv         - OpenCV QRCodeDetector
#   4. quirc          - Lightweight native QR decoder
#   5. dmtx           - DataMatrix decoder (libdmtx)
#   6. pyzbar_enhanced- Multi-processing pyzbar
#   7. multiscale     - Multi-scale image processing decoder
#   8. inverse        - Inverted/negative image decoder
#   9. imagemagick+zbar - Preprocessing pipeline decoder
#  10. dmtxread       - Simple DataMatrix reader
#  11. qreader        - Deep learning QR decoder
#  12. pyzxing        - Python ZXing wrapper
#  13. zxing_java_cli - Direct Java ZXing execution
#  14. libdecodeqr    - C/C++ QR library decoder
#  15. tesseract_ocr  - OCR-based degraded code recovery
#  16. boofcv         - Java computer vision decoder
#  17. bwipjs         - Node.js barcode library
#  18. jsqr           - Standalone Node.js QR decoder
#  19. python_barcode - 1D barcode decoder (Code128, Code39, EAN, etc.)
#  20. opencv_aruco   - ArUco marker + multi-QR detector
#  21. dynamsoft      - Commercial SDK (free tier)
#  22. zxingcpp       - C++ ZXing port (fast)
#  23. goqr           - Go-based QR decoder (memory-safe)
#  24. aztec          - Aztec code decoder (ISO 24778 - transport tickets)
#  25. pdf417         - PDF417 decoder (ISO 15438 - IDs, boarding passes)
#  26. maxicode       - MaxiCode decoder (ISO 16023 - UPS shipping)
#  27. codabar        - Codabar decoder (libraries, blood banks)
#  28. code128        - Code 128 decoder (ISO 15417 - logistics)
#  29. code39         - Code 39 decoder (ISO 16388 - automotive VINs)
#  30. ean            - EAN/UPC decoder (ISO 15420 - retail)
#  31. rmqr           - Rectangular Micro QR (ISO 23941)
#  32. hanxin         - Han Xin Code (GB/T 21049 - Chinese standard)
#  33. dotcode        - DotCode (high-speed industrial printing)
#  34. gridmatrix     - Grid Matrix (Chinese standard)
#  35. composite      - GS1 Composite barcodes (CC-A, CC-B, CC-C)
#  36. itf            - Interleaved 2 of 5 (ISO 16390)
#  37. code93         - Code 93 decoder
#  38. universal      - All-format fallback with preprocessing
#
# BARCODE FORMAT COVERAGE:
# ------------------------
# 2D Codes: QR, Micro QR, rMQR, DataMatrix, Aztec, PDF417, MaxiCode,
#           Han Xin, DotCode, Grid Matrix, ArUco
# 1D Codes: Code 128, Code 39, Code 93, Codabar, EAN-13, EAN-8,
#           UPC-A, UPC-E, ITF, ISBN-10, ISBN-13, GS1 DataBar
#
################################################################################

################################################################################
# CRASH PROTECTION AND IMAGE VALIDATION SYSTEM
# Prevents segfaults from crashing the main script
################################################################################

# Safely validate image can be opened without crashing
# Returns 0 if valid, 1 if potentially dangerous
validate_image_safety() {
    local image="$1"
    local python_cmd=$(get_python_cmd)
    
    # First check file exists and has content
    if [[ ! -f "$image" ]] || [[ ! -s "$image" ]]; then
        return 1
    fi
    
    # Check magic bytes match claimed type
    local magic_bytes
    magic_bytes=$(xxd -l 8 "$image" 2>/dev/null | awk '{print $2$3$4$5}')
    
    if [[ -z "$magic_bytes" ]]; then
        return 1
    fi
    
    # Validate known image magic bytes
    local valid_magic=false
    case "$magic_bytes" in
        89504e47*)  # PNG
            valid_magic=true
            # Verify PNG has IHDR chunk
            if ! xxd "$image" 2>/dev/null | head -2 | grep -q "IHDR"; then
                log_warning "PNG missing IHDR chunk - may be corrupted"
            fi
            ;;
        ffd8ff*)  # JPEG
            valid_magic=true
            ;;
        47494638*)  # GIF
            valid_magic=true
            ;;
        424d*)  # BMP
            valid_magic=true
            ;;
        49492a00*|4d4d002a*)  # TIFF
            valid_magic=true
            ;;
        52494646*)  # WebP (RIFF container)
            valid_magic=true
            ;;
        *)
            log_warning "Unrecognized image magic bytes: $magic_bytes"
            ;;
    esac
    
    # Try to validate with Python PIL in isolated subprocess with timeout
    # This catches corrupted images that would crash decoders
    local validation_result
    validation_result=$(timeout 10 "$python_cmd" - "$image" 2>/dev/null <<'PYVALIDATE'
import sys
import os

try:
    image_path = sys.argv[1]
    
    # Check file size is reasonable (not empty, not absurdly large)
    file_size = os.path.getsize(image_path)
    if file_size < 10:
        print("ERROR:too_small")
        sys.exit(1)
    if file_size > 500000000:  # 500MB limit
        print("ERROR:too_large")
        sys.exit(1)
    
    from PIL import Image
    
    # Open with verify to check for corruption
    with Image.open(image_path) as img:
        img.verify()
    
    # Re-open to check basic operations work
    with Image.open(image_path) as img:
        # Try to get basic properties
        width, height = img.size
        mode = img.mode
        
        # Check for reasonable dimensions
        if width <= 0 or height <= 0:
            print("ERROR:invalid_dimensions")
            sys.exit(1)
        if width > 50000 or height > 50000:
            print("ERROR:dimensions_too_large")
            sys.exit(1)
        
        print(f"OK:{width}x{height}:{mode}")
        
except Exception as e:
    print(f"ERROR:{type(e).__name__}")
    sys.exit(1)
PYVALIDATE
) || validation_result="ERROR:timeout"
    
    if [[ "$validation_result" == OK:* ]]; then
        return 0
    else
        log_warning "Image validation failed: ${validation_result#ERROR:}"
        return 1
    fi
}

# Run a command in an isolated subprocess with crash protection
# Usage: run_isolated timeout_seconds command [args...]
# For commands needing output redirection, use: run_isolated_with_output timeout output_file command [args...]
run_isolated() {
    local timeout_sec="$1"
    shift
    local cmd=("$@")
    
    # Create a temp file for exit status communication
    local status_file
    status_file=$(mktemp 2>/dev/null || echo "/tmp/run_isolated_$$_$RANDOM")
    
    # Run in subshell with timeout, resource limits, and signal handling
    (
        # Set resource limits to prevent runaway processes
        ulimit -v 2097152 2>/dev/null  # 2GB virtual memory limit
        ulimit -t 120 2>/dev/null       # 120 second CPU time limit
        ulimit -f 104857600 2>/dev/null # 100GB file size limit
        
        # Trap signals to exit cleanly and record status
        trap 'echo 130 > "'"$status_file"'"; exit 130' INT
        trap 'echo 143 > "'"$status_file"'"; exit 143' TERM
        trap 'echo 134 > "'"$status_file"'"; exit 134' ABRT
        trap 'echo 139 > "'"$status_file"'"; exit 139' SEGV
        trap 'echo 136 > "'"$status_file"'"; exit 136' FPE
        trap 'echo 138 > "'"$status_file"'"; exit 138' BUS
        
        # Execute the command and capture exit status
        "${cmd[@]}"
        local cmd_status=$?
        echo "$cmd_status" > "$status_file"
        exit $cmd_status
    ) 2>/dev/null &
    
    local pid=$!
    
    # Wait with timeout
    local count=0
    while kill -0 "$pid" 2>/dev/null && [[ $count -lt $timeout_sec ]]; do
        sleep 1
        ((count++))
    done
    
    # Check if still running (timeout occurred)
    if kill -0 "$pid" 2>/dev/null; then
        kill -9 "$pid" 2>/dev/null
        wait "$pid" 2>/dev/null
        rm -f "$status_file" 2>/dev/null
        return 124  # timeout exit code
    fi
    
    # Get exit status from file or wait
    wait "$pid" 2>/dev/null
    local final_status=$?
    
    # Check if signal caused crash (read from status file if available)
    if [[ -f "$status_file" ]]; then
        local recorded_status
        recorded_status=$(cat "$status_file" 2>/dev/null)
        rm -f "$status_file" 2>/dev/null
        if [[ -n "$recorded_status" ]]; then
            return "$recorded_status"
        fi
    fi
    
    return $final_status
}

# Run a command in isolated subprocess with output to a file (for decoders)
# Usage: run_isolated_with_output timeout_seconds output_file command [args...]
run_isolated_with_output() {
    local timeout_sec="$1"
    local output_file="$2"
    shift 2
    local cmd=("$@")
    
    # Create a temp file for exit status
    local status_file
    status_file=$(mktemp 2>/dev/null || echo "/tmp/run_isolated_out_$$_$RANDOM")
    
    # Run in subshell with output redirection INSIDE the subshell
    (
        # Set resource limits
        ulimit -v 2097152 2>/dev/null
        ulimit -t 120 2>/dev/null
        ulimit -f 104857600 2>/dev/null
        
        # Trap signals - write status before exit
        trap 'echo 130 > "'"$status_file"'"; exit 130' INT
        trap 'echo 143 > "'"$status_file"'"; exit 143' TERM
        trap 'echo 134 > "'"$status_file"'"; exit 134' ABRT
        trap 'echo 139 > "'"$status_file"'"; exit 139' SEGV
        trap 'echo 136 > "'"$status_file"'"; exit 136' FPE
        trap 'echo 138 > "'"$status_file"'"; exit 138' BUS
        
        # Execute command with output redirected to the specified file
        "${cmd[@]}" > "$output_file" 2>/dev/null
        local cmd_status=$?
        echo "$cmd_status" > "$status_file"
        exit $cmd_status
    ) &
    
    local pid=$!
    
    # Wait with timeout
    local count=0
    while kill -0 "$pid" 2>/dev/null && [[ $count -lt $timeout_sec ]]; do
        sleep 1
        ((count++))
    done
    
    # Handle timeout
    if kill -0 "$pid" 2>/dev/null; then
        kill -9 "$pid" 2>/dev/null
        wait "$pid" 2>/dev/null
        rm -f "$status_file" 2>/dev/null
        return 124
    fi
    
    wait "$pid" 2>/dev/null
    local final_status=$?
    
    if [[ -f "$status_file" ]]; then
        local recorded_status
        recorded_status=$(cat "$status_file" 2>/dev/null)
        rm -f "$status_file" 2>/dev/null
        if [[ -n "$recorded_status" ]]; then
            return "$recorded_status"
        fi
    fi
    
    return $final_status
}

# Safe wrapper for zbarimg with crash protection
safe_zbarimg() {
    local image="$1"
    local output_file="$2"
    
    # Check if zbarimg is available
    if ! command -v zbarimg &>/dev/null; then
        return 1
    fi
    
    # Use run_isolated_with_output to capture output safely inside the subshell
    run_isolated_with_output 30 "$output_file" zbarimg --quiet --raw "$image"
    local status=$?
    
    # Check for crash signals
    if [[ $status -eq 139 ]] || [[ $status -eq 134 ]] || [[ $status -eq 136 ]] || [[ $status -eq 138 ]]; then
        log_warning "zbarimg crashed (signal $status) on image - skipping this decoder"
        rm -f "$output_file" 2>/dev/null
        return 1
    fi
    
    # Check for timeout
    if [[ $status -eq 124 ]]; then
        log_warning "zbarimg timed out on image - skipping this decoder"
        rm -f "$output_file" 2>/dev/null
        return 1
    fi
    
    [[ -s "$output_file" ]]
}

# Safe wrapper for Python decoder with crash protection
safe_python_decode() {
    local image="$1"
    local output_file="$2"
    local python_cmd=$(get_python_cmd)
    
    run_isolated 30 "$python_cmd" - "$image" "$output_file" <<'PYDECODE'
import sys
import os
import signal

# Set up signal handlers
def signal_handler(sig, frame):
    sys.exit(128 + sig)

signal.signal(signal.SIGSEGV, signal_handler)
signal.signal(signal.SIGABRT, signal_handler)
signal.signal(signal.SIGFPE, signal_handler)

try:
    image_path = sys.argv[1]
    output_path = sys.argv[2]
    
    from PIL import Image
    from pyzbar.pyzbar import decode
    
    with Image.open(image_path) as img:
        codes = decode(img)
        
        with open(output_path, 'w') as f:
            for code in codes:
                try:
                    data = code.data.decode('utf-8')
                except:
                    data = code.data.decode('latin-1', errors='replace')
                f.write(data + '\n')
                
except Exception as e:
    sys.exit(1)
PYDECODE
    
    local status=$?
    
    if [[ $status -eq 139 ]] || [[ $status -eq 134 ]] || [[ $status -eq 136 ]]; then
        log_warning "Python decoder crashed (signal $status) on image - skipping"
        return 1
    fi
    
    [[ -s "$output_file" ]]
}

decode_with_zbar() {
    set +u
    local image="${1:-}"
    local output_file="${2:-}"
    set -u
    
    # Use safe wrapper instead of direct call
    safe_zbarimg "$image" "$output_file"
}

decode_with_pyzbar() {
    set +u
    local image="${1:-}"
    local output_file="${2:-}"
    set -u
    
    # Validate inputs
    if [[ -z "$image" ]] || [[ ! -f "$image" ]] || [[ ! -r "$image" ]]; then
        return 1
    fi
    
    if ! validate_decoder_output_path "$output_file" "decode_with_pyzbar"; then
        return 1
    fi
    
    # Safe module check before execution
    if ! safe_check_python_module "pyzbar"; then
        return 2
    fi
    
    # Use safe wrapper with crash protection
    safe_python_decode "$image" "$output_file"
}

# Safe Python script execution wrapper
# Usage: safe_python_script timeout_secs script_content
safe_python_script() {
    local timeout_secs="$1"
    local python_cmd=$(get_python_cmd)
    shift
    
    run_isolated "$timeout_secs" "$python_cmd" - "$@"
}

decode_with_quirc() {
    set +u
    local image="${1:-}"
    local output_file="${2:-}"
    set -u
    
    if command -v quirc &> /dev/null; then
        # Use run_isolated_with_output to prevent crashes from propagating
        run_isolated_with_output 30 "$output_file" quirc "$image"
        local status=$?
        
        # Check for crash signals
        if [[ $status -eq 139 ]] || [[ $status -eq 134 ]] || [[ $status -eq 136 ]] || [[ $status -eq 138 ]]; then
            log_warning "quirc crashed (signal $status) on image - skipping this decoder"
            rm -f "$output_file" 2>/dev/null
            return 1
        fi
        
        [ -s "$output_file" ]
    else
        return 1
    fi
}

decode_with_zxing() {
    set +u
    local image="${1:-}"
    local output_file="${2:-}"
    set -u
    local python_cmd=$(get_python_cmd)
    
    # Try Java ZXing if available - use safe output redirection
    if command -v zxing &> /dev/null; then
        run_isolated_with_output 30 "$output_file" zxing "$image"
        [ -s "$output_file" ] && return 0
    fi
    
    if [ -f "/usr/local/lib/zxing.jar" ]; then
        run_isolated_with_output 30 "$output_file" java -cp /usr/local/lib/zxing.jar com.google.zxing.client.j2se.CommandLineRunner "$image"
        [ -s "$output_file" ] && return 0
    fi
    
    # Try Python ZXing library - Python scripts write to file internally
    run_isolated 30 "$python_cmd" - "$image" "$output_file" <<'PYZXING' 2>/dev/null
import sys
import signal

def signal_handler(sig, frame):
    sys.exit(128 + sig)
signal.signal(signal.SIGSEGV, signal_handler)
signal.signal(signal.SIGABRT, signal_handler)

try:
    image_path = sys.argv[1]
    output_file = sys.argv[2]
    
    import zxing
    reader = zxing.BarCodeReader()
    barcode = reader.decode(image_path)
    if barcode:
        with open(output_file, 'w') as f:
            f.write(barcode.parsed + '\n')
except:
    pass
PYZXING
    [ -s "$output_file" ]
}

decode_with_qrdecode() {
    set +u
    local image="${1:-}"
    local output_file="${2:-}"
    set -u
    
    if command -v qrdecode &> /dev/null; then
        # Use run_isolated_with_output to prevent crashes from propagating
        run_isolated_with_output 30 "$output_file" qrdecode "$image"
        local status=$?
        
        # Check for crash signals
        if [[ $status -eq 139 ]] || [[ $status -eq 134 ]] || [[ $status -eq 136 ]] || [[ $status -eq 138 ]]; then
            log_warning "qrdecode crashed (signal $status) on image - skipping this decoder"
            rm -f "$output_file" 2>/dev/null
            return 1
        fi
        
        [ -s "$output_file" ]
    else
        return 1
    fi
}

decode_with_opencv() {
    set +u
    local image="${1:-}"
    local output_file="${2:-}"
    set -u
    local python_cmd=$(get_python_cmd)
    
    # Validate inputs
    if [[ -z "$image" ]] || [[ ! -f "$image" ]] || [[ ! -r "$image" ]]; then
        return 1
    fi
    
    if ! validate_decoder_output_path "$output_file" "decode_with_opencv"; then
        return 1
    fi
    
    # Safe module check before execution
    if ! safe_check_python_module "cv2"; then
        return 2
    fi
    
    run_isolated 30 "$python_cmd" - "$image" "$output_file" <<'PYOPENCV' 2>/dev/null
import sys
import signal

def signal_handler(sig, frame):
    sys.exit(128 + sig)
signal.signal(signal.SIGSEGV, signal_handler)
signal.signal(signal.SIGABRT, signal_handler)

try:
    import cv2
    import numpy as np
    
    image_path = sys.argv[1]
    output_file = sys.argv[2]
    
    img = cv2.imread(image_path)
    if img is None:
        sys.exit(1)
    
    detector = cv2.QRCodeDetector()
    
    # Try normal detection
    data, bbox, _ = detector.detectAndDecode(img)
    
    if data:
        with open(output_file, 'w') as f:
            f.write(data + '\n')
    else:
        # Try with preprocessing
        gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
        
        # Try multiple preprocessing techniques
        preprocessed = [
            gray,
            cv2.GaussianBlur(gray, (5, 5), 0),
            cv2.medianBlur(gray, 5),
            cv2.bilateralFilter(gray, 9, 75, 75),
            cv2.adaptiveThreshold(gray, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY, 11, 2),
            cv2.threshold(gray, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)[1]
        ]
        
        for processed in preprocessed:
            data, bbox, _ = detector.detectAndDecode(processed)
            if data:
                with open(output_file, 'w') as f:
                    f.write(data + '\n')
                break
        
        # Try multi-scale detection
        if not data:
            for scale in [0.5, 0.75, 1.25, 1.5, 2.0]:
                resized = cv2.resize(img, None, fx=scale, fy=scale)
                data, bbox, _ = detector.detectAndDecode(resized)
                if data:
                    with open(output_file, 'w') as f:
                        f.write(data + '\n')
                    break
except Exception as e:
    sys.exit(1)
PYOPENCV
    
    [ -s "$output_file" ]
}

decode_with_opencv_wechat() {
    set +u
    local image="${1:-}"
    local output_file="${2:-}"
    set -u
    local python_cmd=$(get_python_cmd)
    
    # Validate inputs
    if [[ -z "$image" ]] || [[ ! -f "$image" ]] || [[ ! -r "$image" ]]; then
        return 1
    fi
    
    if ! validate_decoder_output_path "$output_file" "decode_with_opencv_wechat"; then
        return 1
    fi
    
    # Safe module check before execution
    if ! safe_check_python_module "cv2"; then
        return 2
    fi
    
    run_isolated 30 "$python_cmd" - "$image" "$output_file" <<'PYWECHAT' 2>/dev/null
import sys
import signal

def signal_handler(sig, frame):
    sys.exit(128 + sig)
signal.signal(signal.SIGSEGV, signal_handler)
signal.signal(signal.SIGABRT, signal_handler)

try:
    import cv2
    
    image_path = sys.argv[1]
    output_file = sys.argv[2]
    
    img = cv2.imread(image_path)
    if img is None:
        sys.exit(1)
    
    # Try WeChat QR decoder if available (more robust)
    try:
        detector = cv2.wechat_qrcode_WeChatQRCode()
        data, points = detector.detectAndDecode(img)
        if data:
            with open(output_file, 'w') as f:
                for d in data:
                    f.write(d + '\n')
    except:
        pass
except Exception as e:
    sys.exit(1)
PYWECHAT
    
    [ -s "$output_file" ]
}

decode_with_pyzbar_enhanced() {
    set +u
    local image="${1:-}"
    local output_file="${2:-}"
    set -u
    local python_cmd=$(get_python_cmd)
    
    # Validate inputs
    if [[ -z "$image" ]] || [[ ! -f "$image" ]] || [[ ! -r "$image" ]]; then
        return 1
    fi
    
    if ! validate_decoder_output_path "$output_file" "decode_with_pyzbar_enhanced"; then
        return 1
    fi
    
    # Safe module check before execution
    if ! safe_check_python_module "pyzbar"; then
        return 2
    fi
    
    run_isolated 30 "$python_cmd" - "$image" "$output_file" <<'PYENHANCED' 2>/dev/null
import sys
import signal

def signal_handler(sig, frame):
    sys.exit(128 + sig)
signal.signal(signal.SIGSEGV, signal_handler)
signal.signal(signal.SIGABRT, signal_handler)

try:
    image_path = sys.argv[1]
    output_file = sys.argv[2]
    
    from PIL import Image, ImageEnhance, ImageFilter
    from pyzbar.pyzbar import decode, ZBarSymbol
    
    img = Image.open(image_path)
    
    # Store all decoded data
    all_data = set()
    
    # Try original image
    for code in decode(img, symbols=[ZBarSymbol.QRCODE]):
        try:
            all_data.add(code.data.decode('utf-8'))
        except:
            all_data.add(code.data.decode('latin-1'))
    
    # Try with enhancements if no data found
    if not all_data:
        enhancements = [
            img.convert('L'),  # Grayscale
            ImageEnhance.Contrast(img).enhance(2),  # High contrast
            ImageEnhance.Sharpness(img).enhance(2),  # Sharpen
            img.filter(ImageFilter.EDGE_ENHANCE),  # Edge enhance
            img.filter(ImageFilter.MedianFilter(3)),  # Denoise
            img.point(lambda x: 0 if x < 128 else 255),  # Binary threshold
        ]
        
        for enhanced in enhancements:
            for code in decode(enhanced, symbols=[ZBarSymbol.QRCODE]):
                try:
                    all_data.add(code.data.decode('utf-8'))
                except:
                    all_data.add(code.data.decode('latin-1'))
            if all_data:
                break
    
    if all_data:
        with open(output_file, 'w') as f:
            for data in all_data:
                f.write(data + '\n')
except Exception as e:
    sys.exit(1)
PYENHANCED
    
    [ -s "$output_file" ]
}
    
# QR decode via BoofCV Java (hardened version)
decode_qr_boofcv() {
    local image="$1"
    local output_file="$2"
    local boofcv_jar="/usr/local/lib/boofcv.jar"

    # Check BoofCV jar presence
    if [ ! -f "$boofcv_jar" ]; then
        echo "BoofCV JAR not found: $boofcv_jar" >&2
        return 2
    fi

    # Check image existence and readability
    if [ ! -r "$image" ]; then
        echo "Image not found/readable: $image" >&2
        return 3
    fi

    # Avoid accidental overwrite, validate output path
    if [ -z "$output_file" ] || [ "${output_file:0:1}" = "/" ]; then
        echo "Refusing to overwrite system file: $output_file" >&2
        return 4
    fi

    # Run Java decoder
    java -cp "$boofcv_jar" boofcv.examples.QRCodeDetector "$image" 2>/dev/null > "$output_file"
    if [ $? -ne 0 ]; then
        echo "BoofCV decoder error" >&2
        rm -f "$output_file"
        return 5
    fi

    # Was anything detected?
    if [ ! -s "$output_file" ]; then
        echo "No QR code detected" >&2
        rm -f "$output_file"
        return 1
    fi

    # Add: parse output for indicators/Malware patterns here
    # e.g., grep -E for suspicious patterns, etc.

    return 0
}

# AUDIT: Wrapper for BoofCV decoder following decode_with_* naming convention
decode_with_boofcv() {
    set +u
    local image="${1:-}"
    local output_file="${2:-}"
    set -u
    
    # HARDEN: ensure image provided and readable
    if [ -z "$image" ] || [ ! -f "$image" ] || [ ! -r "$image" ]; then
        echo "[decode_with_boofcv] Image not found or unreadable: '$image'" >&2
        return 10
    fi
    
    # HARDEN: output file path validation
    if ! validate_decoder_output_path "$output_file" "decode_with_boofcv"; then
        return 11
    fi
    
    # HARDEN: Check if Java is available
    if ! command -v java &> /dev/null; then
        echo "[decode_with_boofcv] Java not found in PATH" >&2
        return 12
    fi
    
    local boofcv_jar="/usr/local/lib/boofcv.jar"
    
    # Check BoofCV jar presence (common locations)
    if [ ! -f "$boofcv_jar" ]; then
        # Try alternate locations
        for alt_path in "/opt/boofcv/boofcv.jar" "$HOME/boofcv/boofcv.jar" "./boofcv.jar"; do
            if [ -f "$alt_path" ]; then
                boofcv_jar="$alt_path"
                break
            fi
        done
        
        if [ ! -f "$boofcv_jar" ]; then
            echo "[decode_with_boofcv] BoofCV JAR not found" >&2
            return 13
        fi
    fi
    
    # HARDEN: remove any previous output
    rm -f "$output_file"
    
    # Run Java decoder with timeout
    timeout 30 java -cp "$boofcv_jar" boofcv.examples.QRCodeDetector "$image" 2>/dev/null > "$output_file"
    local status=$?
    
    if [ $status -eq 124 ]; then
        echo "[decode_with_boofcv] Decoder timed out" >&2
        rm -f "$output_file"
        return 14
    fi
    
    if [ $status -ne 0 ]; then
        echo "[decode_with_boofcv] Decoder execution error" >&2
        rm -f "$output_file"
        return 15
    fi
    
    # Check if anything was decoded
    if [ -s "$output_file" ]; then
        return 0
    else
        rm -f "$output_file"
        return 1
    fi
}

# AUDIT: Additional decoder - libdmtx for DataMatrix codes
decode_with_dmtx() {
    set +u
    local image="${1:-}"
    local output_file="${2:-}"
    set -u
    
    # HARDENING: validate input image file
    if [ -z "$image" ] || [ ! -f "$image" ] || [ ! -r "$image" ]; then
        echo "[decode_with_dmtx] Image not found or unreadable: '$image'" >&2
        return 10
    fi

    # HARDENING: validate output file path (must be in safe temp directory)
    if ! validate_decoder_output_path "$output_file" "decode_with_dmtx"; then
        return 11
    fi

    # HARDENING: check dmtxread presence
    if ! command -v dmtxread &> /dev/null; then
        echo "[decode_with_dmtx] dmtxread binary not found in PATH" >&2
        return 13
    fi

    # HARDENING: clear previous output if any
    rm -f "$output_file"

    # ORIGINAL LOGIC: decode using libdmtx, suppress errors, output to file
    dmtxread -n -N1 "$image" 2>/dev/null > "$output_file"
    
    # CHECK: did dmtxread itself run successfully
    if [ $? -ne 0 ]; then
        echo "[decode_with_dmtx] dmtxread execution error for: '$image'" >&2
        rm -f "$output_file"
        return 14
    fi

    # CHECK: did anything decode (file is nonempty)
    if [ -s "$output_file" ]; then
        return 0       # Success
    else
        echo "[decode_with_dmtx] No DataMatrix detected or empty decode: '$image'" >&2
        rm -f "$output_file"
        return 1       # No code detected
    fi
}

# AUDIT: Additional decoder - segno for QR validation
decode_with_segno() {
    set +u
    local image="${1:-}"
    local output_file="${2:-}"
    set -u
    local python_cmd=$(get_python_cmd)
    
    # HARDEN: ensure image provided and readable
    if [ -z "$image" ] || [ ! -f "$image" ] || [ ! -r "$image" ]; then
        echo "[decode_with_segno] Image not found or unreadable: '$image'" >&2
        return 10
    fi

    # HARDEN: output file path validation
    if ! validate_decoder_output_path "$output_file" "decode_with_segno"; then
        return 11
    fi

    # HARDEN: python interpreter check
    if [ -z "$python_cmd" ] || ! command -v "$python_cmd" &> /dev/null; then
        echo "[decode_with_segno] Python interpreter not found" >&2
        return 13
    fi

    # Safe module check before execution
    if ! safe_check_python_module "segno"; then
        return 2
    fi

    # HARDEN: segno and pyzbar installed check
    "$python_cmd" - <<'PYCHECK' 2>/dev/null
try:
    import segno
    import pyzbar
    from PIL import Image
except:
    exit(1)
exit(0)
PYCHECK
    if [ $? -ne 0 ]; then
        echo "[decode_with_segno] Required Python modules (segno, pyzbar, PIL) missing" >&2
        return 14
    fi

    # HARDEN: remove any previous output
    rm -f "$output_file"

    # ORIGINAL LOGIC: run in isolated environment with sig protection
    run_isolated 30 "$python_cmd" - "$image" "$output_file" <<'PYSEGNO' 2>/dev/null
import sys
import signal

def signal_handler(sig, frame):
    sys.exit(128 + sig)
signal.signal(signal.SIGSEGV, signal_handler)
signal.signal(signal.SIGABRT, signal_handler)

try:
    image_path = sys.argv[1]
    output_file = sys.argv[2]
    
    import segno
    from pyzbar.pyzbar import decode as pyzbar_decode
    from PIL import Image
    
    # Use pyzbar with segno validation
    img = Image.open(image_path)
    codes = pyzbar_decode(img)
    
    with open(output_file, 'w') as f:
        for code in codes:
            try:
                data = code.data.decode('utf-8')
                # Validate the QR structure
                f.write(data + '\n')
            except:
                pass
except:
    pass
PYSEGNO
    
    [ -s "$output_file" ]
}

# AUDIT: Additional decoder - Multi-scale detection for small/damaged QRs
decode_with_multiscale() {
    set +u
    local image="${1:-}"
    local output_file="${2:-}"
    set -u
    local python_cmd=$(get_python_cmd)
    
    # HARDEN: ensure image provided and readable
    if [ -z "$image" ] || [ ! -f "$image" ] || [ ! -r "$image" ]; then
        echo "[decode_with_multiscale] Image not found or unreadable: '$image'" >&2
        return 10
    fi
    
    # HARDEN: output file path validation
    if ! validate_decoder_output_path "$output_file" "decode_with_multiscale"; then
        return 11
    fi
    
    # HARDEN: python interpreter check
    if [ -z "$python_cmd" ] || ! command -v "$python_cmd" &> /dev/null; then
        echo "[decode_with_multiscale] Python interpreter not found" >&2
        return 13
    fi
    
    # Safe module check before execution
    if ! safe_check_python_module "cv2"; then
        return 2
    fi
    
    # HARDEN: required python modules present
    "$python_cmd" - <<'PYREQCHECK' 2>/dev/null
try:
    import cv2
    import pyzbar
    from PIL import Image
except:
    exit(1)
exit(0)
PYREQCHECK
    if [ $? -ne 0 ]; then
        echo "[decode_with_multiscale] Required Python modules (cv2, pyzbar, PIL) missing" >&2
        return 14
    fi
    
    # HARDEN: remove any previous output
    rm -f "$output_file"
    
    # ORIGINAL LOGIC: multi-scale QR scan in isolated environment
    run_isolated 30 "$python_cmd" - "$image" "$output_file" <<'PYMULTISCALE' 2>/dev/null
import sys
import signal

def signal_handler(sig, frame):
    sys.exit(128 + sig)
signal.signal(signal.SIGSEGV, signal_handler)
signal.signal(signal.SIGABRT, signal_handler)

try:
    image_path = sys.argv[1]
    output_file = sys.argv[2]
    
    import cv2
    from pyzbar.pyzbar import decode
    from PIL import Image
    import numpy as np
    
    img = cv2.imread(image_path)
    if img is None:
        sys.exit(1)
    
    all_data = set()
    scales = [0.25, 0.5, 0.75, 1.0, 1.25, 1.5, 2.0, 3.0, 4.0]
    
    for scale in scales:
        if scale != 1.0:
            resized = cv2.resize(img, None, fx=scale, fy=scale, interpolation=cv2.INTER_CUBIC)
        else:
            resized = img
        
        # Convert to PIL for pyzbar
        pil_img = Image.fromarray(cv2.cvtColor(resized, cv2.COLOR_BGR2RGB))
        
        for code in decode(pil_img):
            try:
                all_data.add(code.data.decode('utf-8'))
            except:
                all_data.add(code.data.decode('latin-1'))
        
        if all_data:
            break
    
    if all_data:
        with open(output_file, 'w') as f:
            for data in all_data:
                f.write(data + '\n')
except Exception as e:
    sys.exit(1)
PYMULTISCALE
    
    [ -s "$output_file" ]
}

# AUDIT: Additional decoder - Rotation/perspective correction
decode_with_perspective() {
    set +u
    local image="${1:-}"
    local output_file="${2:-}"
    set -u
    local python_cmd=$(get_python_cmd)
    
    # HARDEN: ensure image provided and readable
    if [ -z "$image" ] || [ ! -f "$image" ] || [ ! -r "$image" ]; then
        echo "[decode_with_perspective] Image not found or unreadable: '$image'" >&2
        return 10
    fi
    
    # HARDEN: output file path validation
    if ! validate_decoder_output_path "$output_file" "decode_with_perspective"; then
        return 11
    fi
    
    # HARDEN: python interpreter check
    if [ -z "$python_cmd" ] || ! command -v "$python_cmd" &> /dev/null; then
        echo "[decode_with_perspective] Python interpreter not found" >&2
        return 13
    fi
    
    # Safe module check before execution
    if ! safe_check_python_module "cv2"; then
        return 2
    fi
    
    # HARDEN: required python modules present
    "$python_cmd" - <<'PYREQCHECK' 2>/dev/null
try:
    import cv2
    import pyzbar
    from PIL import Image
except:
    exit(1)
exit(0)
PYREQCHECK
    if [ $? -ne 0 ]; then
        echo "[decode_with_perspective] Required Python modules (cv2, pyzbar, PIL) missing" >&2
        return 14
    fi
    
    # HARDEN: remove any previous output
    rm -f "$output_file"
    
    # ORIGINAL LOGIC: rotation + perspective correction QR scan
    run_isolated 30 "$python_cmd" - "$image" "$output_file" <<'PYPERSPECTIVE' 2>/dev/null
import sys
import signal

def signal_handler(sig, frame):
    sys.exit(128 + sig)
signal.signal(signal.SIGSEGV, signal_handler)
signal.signal(signal.SIGABRT, signal_handler)

try:
    image_path = sys.argv[1]
    output_file = sys.argv[2]
    
    import cv2
    from pyzbar.pyzbar import decode
    from PIL import Image
    import numpy as np
    
    img = cv2.imread(image_path)
    if img is None:
        sys.exit(1)
    
    all_data = set()
    
    # Try different rotations
    for angle in [0, 90, 180, 270, 45, 135, 225, 315]:
        h, w = img.shape[:2]
        center = (w // 2, h // 2)
        M = cv2.getRotationMatrix2D(center, angle, 1.0)
        rotated = cv2.warpAffine(img, M, (w, h), borderMode=cv2.BORDER_REPLICATE)
        
        pil_img = Image.fromarray(cv2.cvtColor(rotated, cv2.COLOR_BGR2RGB))
        
        for code in decode(pil_img):
            try:
                all_data.add(code.data.decode('utf-8'))
            except:
                all_data.add(code.data.decode('latin-1'))
        
        if all_data:
            break
    
    if all_data:
        with open(output_file, 'w') as f:
            for data in all_data:
                f.write(data + '\n')
except Exception as e:
    sys.exit(1)
PYPERSPECTIVE
    
    [ -s "$output_file" ]
}

# AUDIT: Additional decoder - Inverse/negative image
decode_with_inverse() {
    set +u
    local image="${1:-}"
    local output_file="${2:-}"
    set -u
    local python_cmd=$(get_python_cmd)
    
    # HARDEN: ensure image provided and readable
    if [ -z "$image" ] || [ ! -f "$image" ] || [ ! -r "$image" ]; then
        echo "[decode_with_inverse] Image not found or unreadable: '$image'" >&2
        return 10
    fi
    
    # HARDEN: output file path validation
    if ! validate_decoder_output_path "$output_file" "decode_with_inverse"; then
        return 11
    fi
    
    # HARDEN: python interpreter check
    if [ -z "$python_cmd" ] || ! command -v "$python_cmd" &> /dev/null; then
        echo "[decode_with_inverse] Python interpreter not found" >&2
        return 13
    fi
    
    # Safe module check before execution
    if ! safe_check_python_module "PIL"; then
        return 2
    fi
    
    # HARDEN: required python modules present
    "$python_cmd" - <<'PYREQCHECK' 2>/dev/null
try:
    from PIL import Image, ImageOps
    import pyzbar
except:
    exit(1)
exit(0)
PYREQCHECK
    if [ $? -ne 0 ]; then
        echo "[decode_with_inverse] Required Python modules (PIL.ImageOps, pyzbar) missing" >&2
        return 14
    fi
    
    # HARDEN: remove any previous output
    rm -f "$output_file"
    
    # ORIGINAL LOGIC: QR decode, invert and grayscale fallback
    run_isolated 30 "$python_cmd" - "$image" "$output_file" <<'PYINVERSE' 2>/dev/null
import sys
import signal

def signal_handler(sig, frame):
    sys.exit(128 + sig)
signal.signal(signal.SIGSEGV, signal_handler)
signal.signal(signal.SIGABRT, signal_handler)

try:
    image_path = sys.argv[1]
    output_file = sys.argv[2]
    
    from PIL import Image, ImageOps
    from pyzbar.pyzbar import decode
    
    img = Image.open(image_path)
    all_data = set()
    
    # Try original
    for code in decode(img):
        try:
            all_data.add(code.data.decode('utf-8'))
        except:
            all_data.add(code.data.decode('latin-1'))
    
    # Try inverted (negative)
    if not all_data:
        inverted = ImageOps.invert(img.convert('RGB'))
        for code in decode(inverted):
            try:
                all_data.add(code.data.decode('utf-8'))
            except:
                all_data.add(code.data.decode('latin-1'))
    
    # Try grayscale inverted
    if not all_data:
        gray_inv = ImageOps.invert(img.convert('L'))
        for code in decode(gray_inv):
            try:
                all_data.add(code.data.decode('utf-8'))
            except:
                all_data.add(code.data.decode('latin-1'))
    
    if all_data:
        with open(output_file, 'w') as f:
            for data in all_data:
                f.write(data + '\n')
except Exception as e:
    sys.exit(1)
PYINVERSE
    
    [ -s "$output_file" ]
}

# AUDIT: Additional decoder - Adaptive threshold
decode_with_adaptive() {
    set +u
    local image="${1:-}"
    local output_file="${2:-}"
    set -u
    local python_cmd=$(get_python_cmd)
    
    # HARDEN: ensure image provided and readable
    if [ -z "$image" ] || [ ! -f "$image" ] || [ ! -r "$image" ]; then
        echo "[decode_with_adaptive] Image not found or unreadable: '$image'" >&2
        return 10
    fi
    
    # HARDEN: output file path validation
    if ! validate_decoder_output_path "$output_file" "decode_with_adaptive"; then
        return 11
    fi
    
    # HARDEN: python interpreter check
    if [ -z "$python_cmd" ] || ! command -v "$python_cmd" &> /dev/null; then
        echo "[decode_with_adaptive] Python interpreter not found" >&2
        return 13
    fi
    
    # Safe module check before execution
    if ! safe_check_python_module "cv2"; then
        return 2
    fi
    
    # HARDEN: required python modules present
    "$python_cmd" - <<'PYREQCHECK' 2>/dev/null
try:
    import cv2
    import pyzbar
    from PIL import Image
except:
    exit(1)
exit(0)
PYREQCHECK
    if [ $? -ne 0 ]; then
        echo "[decode_with_adaptive] Required Python modules (cv2, pyzbar, PIL) missing" >&2
        return 14
    fi
    
    # HARDEN: remove any previous output
    rm -f "$output_file"
    
    # ORIGINAL LOGIC: adaptive thresholding QR scan, multi-method
    run_isolated 30 "$python_cmd" - "$image" "$output_file" <<'PYADAPTIVE' 2>/dev/null
import sys
import signal

def signal_handler(sig, frame):
    sys.exit(128 + sig)
signal.signal(signal.SIGSEGV, signal_handler)
signal.signal(signal.SIGABRT, signal_handler)

try:
    image_path = sys.argv[1]
    output_file = sys.argv[2]
    
    import cv2
    from pyzbar.pyzbar import decode
    from PIL import Image
    import numpy as np
    
    img = cv2.imread(image_path)
    if img is None:
        sys.exit(1)
    
    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
    all_data = set()
    
    # Various adaptive thresholding methods
    methods = [
        cv2.adaptiveThreshold(gray, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY, 11, 2),
        cv2.adaptiveThreshold(gray, 255, cv2.ADAPTIVE_THRESH_MEAN_C, cv2.THRESH_BINARY, 11, 2),
        cv2.adaptiveThreshold(gray, 255, cv2.ADAPTIVE_THRESH_GAUSSIAN_C, cv2.THRESH_BINARY, 21, 5),
        cv2.threshold(gray, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)[1],
    ]
    
    for processed in methods:
        pil_img = Image.fromarray(processed)
        for code in decode(pil_img):
            try:
                all_data.add(code.data.decode('utf-8'))
            except:
                all_data.add(code.data.decode('latin-1'))
        if all_data:
            break
    
    if all_data:
        with open(output_file, 'w') as f:
            for data in all_data:
                f.write(data + '\n')
except Exception as e:
    sys.exit(1)
PYADAPTIVE
    
    [ -s "$output_file" ]
}

# AUDIT: Additional decoder - Color channel separation
decode_with_channels() {
    set +u
    local image="${1:-}"
    local output_file="${2:-}"
    set -u
    local python_cmd=$(get_python_cmd)
    
    # HARDEN: ensure image provided and readable
    if [ -z "$image" ] || [ ! -f "$image" ] || [ ! -r "$image" ]; then
        echo "[decode_with_channels] Image not found or unreadable: '$image'" >&2
        return 10
    fi
    
    # HARDEN: output file path validation
    if ! validate_decoder_output_path "$output_file" "decode_with_channels"; then
        return 11
    fi
    
    # HARDEN: python interpreter check
    if [ -z "$python_cmd" ] || ! command -v "$python_cmd" &> /dev/null; then
        echo "[decode_with_channels] Python interpreter not found" >&2
        return 13
    fi
    
    # Safe module check before execution
    if ! safe_check_python_module "PIL"; then
        return 2
    fi
    
    # HARDEN: required python modules present
    "$python_cmd" - <<'PYREQCHECK' 2>/dev/null
try:
    from PIL import Image
    import pyzbar
except:
    exit(1)
exit(0)
PYREQCHECK
    if [ $? -ne 0 ]; then
        echo "[decode_with_channels] Required Python modules (PIL, pyzbar) missing" >&2
        return 14
    fi
    
    # HARDEN: remove any previous output
    rm -f "$output_file"
    
    # ORIGINAL LOGIC: color channel separation QR decode
    run_isolated 30 "$python_cmd" - "$image" "$output_file" <<'PYCHANNELS' 2>/dev/null
import sys
import signal

def signal_handler(sig, frame):
    sys.exit(128 + sig)
signal.signal(signal.SIGSEGV, signal_handler)
signal.signal(signal.SIGABRT, signal_handler)

try:
    image_path = sys.argv[1]
    output_file = sys.argv[2]
    
    from PIL import Image
    from pyzbar.pyzbar import decode
    
    img = Image.open(image_path).convert('RGB')
    all_data = set()
    
    # Try each color channel separately
    r, g, b = img.split()
    
    for channel in [r, g, b, img.convert('L')]:
        for code in decode(channel):
            try:
                all_data.add(code.data.decode('utf-8'))
            except:
                all_data.add(code.data.decode('latin-1'))
        if all_data:
            break
    
    if all_data:
        with open(output_file, 'w') as f:
            for data in all_data:
                f.write(data + '\n')
except Exception as e:
    sys.exit(1)
PYCHANNELS
    
    [ -s "$output_file" ]
}

# Decoder using ImageMagick preprocessing + zbar
decode_with_imagemagick_zbar() {
    set +u
    local image="${1:-}"
    local output_file="${2:-}"
    set -u
    
    if command -v convert &> /dev/null && command -v zbarimg &> /dev/null; then
        local temp_img="${TEMP_DIR}/preprocessed_$(basename "$image")"
        
        # Try multiple preprocessing techniques
        for technique in \
            "-colorspace gray -normalize" \
            "-colorspace gray -contrast-stretch 0" \
            "-colorspace gray -threshold 50%" \
            "-colorspace gray -negate" \
            "-colorspace gray -sharpen 0x2" \
            "-resize 200%" \
            "-resize 50%"; do
            convert "$image" $technique "${temp_img}.png" 2>/dev/null
            # AUDIT FIX: Wrap zbarimg with crash protection
            local temp_result="${temp_img}_result.txt"
            if run_isolated_with_output 30 "$temp_result" zbarimg --quiet --raw "${temp_img}.png"; then
                cat "$temp_result" >> "$output_file" 2>/dev/null
                rm -f "${temp_img}.png" "$temp_result" 2>/dev/null
                [ -s "$output_file" ] && return 0
            fi
            rm -f "${temp_img}.png" "$temp_result" 2>/dev/null
        done
        return 1
    else
        return 1
    fi
}

# Decoder using libdmtx for Data Matrix codes (simple variant)
decode_with_dmtxread() {
    set +u
    local image="${1:-}"
    local output_file="${2:-}"
    set -u
    
    if command -v dmtxread &> /dev/null; then
        dmtxread "$image" 2>/dev/null > "$output_file"
        [ -s "$output_file" ]
    else
        return 1
    fi
}

# Decoder using qreader Python library
decode_with_qreader() {
    set +u
    local image="${1:-}"
    local output_file="${2:-}"
    set -u
    local python_cmd=$(get_python_cmd)
    
    # Validate inputs
    if [[ -z "$image" ]] || [[ ! -f "$image" ]] || [[ ! -r "$image" ]]; then
        return 1
    fi
    
    if ! validate_decoder_output_path "$output_file" "decode_with_qreader"; then
        return 1
    fi
    
    # Safe module check before execution
    if ! safe_check_python_module "qreader"; then
        return 2
    fi
    
    # Run in isolated subshell with timeout to prevent segfault from crashing main script
    # Use trap to catch signals and timeout to prevent hangs
    (
        trap 'exit 139' SEGV
        trap 'exit 134' ABRT
        exec 2>/dev/null
        
        timeout 15 "$python_cmd" 2>/dev/null << PYEOF
import sys
import os

# Disable OpenCV's internal threading which can cause segfaults
os.environ['OPENCV_VIDEOIO_PRIORITY_MSMF'] = '0'
os.environ['OMP_NUM_THREADS'] = '1'

try:
    import signal
    signal.signal(signal.SIGSEGV, lambda s,f: sys.exit(139))
    signal.signal(signal.SIGABRT, lambda s,f: sys.exit(134))
    
    from qreader import QReader
    import cv2
    
    detector = QReader()
    img = cv2.imread(image_path)
    if img is not None:
        decoded = detector.detect_and_decode(image=img)
        if decoded:
            with open('$output_file', 'w') as f:
                for d in decoded:
                    if d:
                        f.write(str(d) + '\n')
except ImportError:
    sys.exit(2)
except Exception:
    sys.exit(1)
PYEOF
    ) 2>/dev/null
    
    [ -s "$output_file" ]
}

# Decoder using pyzxing Python library
decode_with_pyzxing() {
    set +u
    local image="${1:-}"
    local output_file="${2:-}"
    set -u
    local python_cmd=$(get_python_cmd)
    
    # Validate inputs
    if [[ -z "$image" ]] || [[ ! -f "$image" ]] || [[ ! -r "$image" ]]; then
        return 1
    fi
    
    if ! validate_decoder_output_path "$output_file" "decode_with_pyzxing"; then
        return 1
    fi
    
    # Safe module check before execution
    if ! safe_check_python_module "pyzxing"; then
        return 2
    fi
    
    # Run in isolated subshell with timeout to prevent segfault from crashing main script
    (
        trap 'exit 139' SEGV
        trap 'exit 134' ABRT
        exec 2>/dev/null
        
        timeout 15 "$python_cmd" 2>/dev/null << PYEOF
import sys
import signal
signal.signal(signal.SIGSEGV, lambda s,f: sys.exit(139))
signal.signal(signal.SIGABRT, lambda s,f: sys.exit(134))

try:
    from pyzxing import BarCodeReader
    reader = BarCodeReader()
    results = reader.decode('$image')
    if results:
        with open('$output_file', 'w') as f:
            for result in results:
                if isinstance(result, dict):
                    if 'parsed' in result:
                        f.write(str(result['parsed']) + '\n')
                    elif 'raw' in result:
                        f.write(str(result['raw']) + '\n')
except ImportError:
    sys.exit(2)
except Exception:
    sys.exit(1)
PYEOF
    ) 2>/dev/null
    
    [ -s "$output_file" ]
}

################################################################################
# ADDITIONAL BARCODE DECODERS (Extended Set)
################################################################################

# Decoder 13: ZXing Java CLI (direct JAR execution, not via Python wrapper)
# More robust than pyzxing for some edge cases
decode_with_zxing_java_cli() {
    set +u
    local image="${1:-}"
    local output_file="${2:-}"
    set -u
    
    # Check for Java
    if ! command -v java &>/dev/null; then
        return 2
    fi
    
    # Look for ZXing JAR in common locations
    local zxing_jar=""
    local jar_locations=(
        "/usr/local/lib/zxing.jar"
        "/usr/share/java/zxing.jar"
        "/opt/zxing/javase/target/javase-*.jar"
        "$HOME/.local/lib/zxing.jar"
        "$HOME/zxing/javase/target/javase-*.jar"
        "/usr/local/share/java/core.jar"  # ZXing core
        "$(find /usr -name 'javase*.jar' 2>/dev/null | grep -i zxing | head -1)"
    )
    
    for loc in "${jar_locations[@]}"; do
        # Handle glob patterns
        for expanded in $loc; do
            if [[ -f "$expanded" ]]; then
                zxing_jar="$expanded"
                break 2
            fi
        done
    done
    
    if [[ -z "$zxing_jar" ]]; then
        # Try to find any zxing-related JAR
        zxing_jar=$(find /usr /opt "$HOME" -name '*zxing*.jar' -o -name '*javase*.jar' 2>/dev/null | head -1)
    fi
    
    if [[ -n "$zxing_jar" ]] && [[ -f "$zxing_jar" ]]; then
        (
            exec 2>/dev/null
            timeout 30 java -cp "$zxing_jar" com.google.zxing.client.j2se.CommandLineRunner "$image" 2>/dev/null | \
                grep -v "^file:" | grep -v "^Format" | grep -v "^Raw" | head -20 > "$output_file"
        )
        [[ -s "$output_file" ]] && return 0
    fi
    
    return 1
}

# Decoder 14: libdecodeqr (C/C++ library command-line tool)
# Good for weird/small QR codes
decode_with_libdecodeqr() {
    set +u
    local image="${1:-}"
    local output_file="${2:-}"
    set -u
    
    # Check for libdecodeqr command-line tool
    if command -v decodeqr &>/dev/null; then
        (
            exec 2>/dev/null
            timeout 30 decodeqr "$image" > "$output_file" 2>/dev/null
        )
        [[ -s "$output_file" ]] && return 0
    fi
    
    # Alternative: qrdecoder from libdecodeqr
    if command -v qrdecoder &>/dev/null; then
        (
            exec 2>/dev/null
            timeout 30 qrdecoder "$image" > "$output_file" 2>/dev/null
        )
        [[ -s "$output_file" ]] && return 0
    fi
    
    return 1
}

# Decoder 15: Tesseract OCR + Leptonica (for degraded/damaged QR codes)
# Extracts text from very degraded codes that fail standard QR detection
decode_with_tesseract_ocr() {
    set +u
    local image="${1:-}"
    local output_file="${2:-}"
    set -u
    local python_cmd=$(get_python_cmd)
    
    # Check for tesseract
    if ! command -v tesseract &>/dev/null; then
        return 2
    fi
    
    # Create preprocessed versions and try OCR on each
    local temp_dir="${TEMP_DIR}/tesseract_$$"
    mkdir -p "$temp_dir" 2>/dev/null
    
    (
        exec 2>/dev/null
        
        # Preprocessing with ImageMagick if available
        if command -v convert &>/dev/null; then
            # High contrast version
            convert "$image" -colorspace gray -normalize -threshold 50% "${temp_dir}/thresh.png" 2>/dev/null
            # Edge detection
            convert "$image" -colorspace gray -edge 1 "${temp_dir}/edge.png" 2>/dev/null
            # Inverted
            convert "$image" -colorspace gray -negate "${temp_dir}/inv.png" 2>/dev/null
            # Deskewed
            convert "$image" -deskew 40% "${temp_dir}/deskew.png" 2>/dev/null
        fi
        
        # Try OCR on original and preprocessed versions
        local all_text=""
        for img in "$image" "${temp_dir}"/*.png; do
            [[ -f "$img" ]] || continue
            
            # Run tesseract with different PSM modes
            for psm in 6 7 11 13; do
                local result
                result=$(timeout 20 tesseract "$img" stdout --psm $psm 2>/dev/null | tr -d '\n\r' | grep -oE 'https?://[^[:space:]]+|[A-Za-z0-9._-]+\.[a-z]{2,}[/A-Za-z0-9._?=-]*')
                if [[ -n "$result" ]]; then
                    all_text+="$result"$'\n'
                fi
            done
        done
        
        # Clean and output results
        echo "$all_text" | sort -u | grep -v '^$' > "$output_file"
        
        # Cleanup
        rm -rf "$temp_dir" 2>/dev/null
    )
    
    [[ -s "$output_file" ]]
}

# Decoder 16: BoofCV Extended (Java-based computer vision library)
# Strong QR/barcode decoder with good error correction handling
# Extended version with broader JAR search and inline Java code
decode_with_boofcv_extended() {
    set +u
    local image="${1:-}"
    local output_file="${2:-}"
    set -u
    
    # Check for Java
    if ! command -v java &>/dev/null; then
        return 2
    fi
    
    # Look for BoofCV JAR
    local boofcv_jar=""
    local jar_locations=(
        "/usr/local/lib/boofcv.jar"
        "/usr/share/java/boofcv*.jar"
        "$HOME/.local/lib/boofcv*.jar"
        "$HOME/boofcv/main/boofcv-recognition/build/libs/*.jar"
        "/opt/boofcv/*.jar"
    )
    
    for loc in "${jar_locations[@]}"; do
        for expanded in $loc; do
            if [[ -f "$expanded" ]]; then
                boofcv_jar="$expanded"
                break 2
            fi
        done
    done
    
    if [[ -z "$boofcv_jar" ]]; then
        boofcv_jar=$(find /usr /opt "$HOME" -name '*boofcv*.jar' 2>/dev/null | head -1)
    fi
    
    if [[ -n "$boofcv_jar" ]] && [[ -f "$boofcv_jar" ]]; then
        # Create inline Java decoder script
        local java_code="${TEMP_DIR}/BoofQRDecoder.java"
        cat > "$java_code" <<'BOOFCV_JAVA'
import boofcv.abst.fiducial.QrCodeDetector;
import boofcv.factory.fiducial.FactoryFiducial;
import boofcv.io.image.UtilImageIO;
import boofcv.struct.image.GrayU8;
import boofcv.alg.fiducial.qrcode.QrCode;
import java.util.List;

public class BoofQRDecoder {
    public static void main(String[] args) {
        if (args.length < 1) return;
        try {
            GrayU8 gray = UtilImageIO.loadImage(args[0], GrayU8.class);
            if (gray == null) return;
            QrCodeDetector<GrayU8> detector = FactoryFiducial.qrcode(null, GrayU8.class);
            detector.process(gray);
            List<QrCode> codes = detector.getDetections();
            for (QrCode qr : codes) {
                System.out.println(qr.message);
            }
        } catch (Exception e) {}
    }
}
BOOFCV_JAVA
        
        (
            exec 2>/dev/null
            cd "$TEMP_DIR"
            timeout 30 java -cp "$boofcv_jar:." BoofQRDecoder.java "$image" > "$output_file" 2>/dev/null || \
            timeout 30 java -cp "$boofcv_jar" boofcv.examples.fiducial.ExampleDetectQRCode "$image" 2>/dev/null | \
                grep -v "^$" | head -20 > "$output_file"
        )
        
        rm -f "$java_code" 2>/dev/null
        [[ -s "$output_file" ]] && return 0
    fi
    
    return 1
}

# Decoder 17: bwip-js (Node.js barcode library)
# JavaScript barcode generator/decoder - good for 1D and 2D codes
decode_with_bwipjs() {
    set +u
    local image="${1:-}"
    local output_file="${2:-}"
    set -u
    
    # Check for Node.js
    if ! command -v node &>/dev/null && ! command -v nodejs &>/dev/null; then
        return 2
    fi
    
    local node_cmd="node"
    command -v node &>/dev/null || node_cmd="nodejs"
    
    # Check if bwip-js and jimp are available
    if ! $node_cmd -e "require('bwip-js')" 2>/dev/null; then
        return 2
    fi
    
    # Create Node.js decoder script
    (
        exec 2>/dev/null
        timeout 30 $node_cmd << NODEJS_EOF > "$output_file" 2>/dev/null
const fs = require('fs');
const path = require('path');

// Try to use jimp or sharp for image loading
let Jimp, sharp;
try { Jimp = require('jimp'); } catch(e) {}
try { sharp = require('sharp'); } catch(e) {}

// Try jsQR for QR decoding (often bundled or easy to install)
let jsQR;
try { jsQR = require('jsqr'); } catch(e) {}

async function decode() {
    const imagePath = '$image';
    
    if (jsQR) {
        let imageData;
        
        if (Jimp) {
            const image = await Jimp.read(imagePath);
            const { width, height, data } = image.bitmap;
            imageData = { data, width, height };
        } else if (sharp) {
            const { data, info } = await sharp(imagePath)
                .raw()
                .ensureAlpha()
                .toBuffer({ resolveWithObject: true });
            imageData = { data, width: info.width, height: info.height };
        }
        
        if (imageData) {
            const code = jsQR(imageData.data, imageData.width, imageData.height);
            if (code && code.data) {
                console.log(code.data);
            }
        }
    }
}

decode().catch(() => {});
NODEJS_EOF
    )
    
    [[ -s "$output_file" ]]
}

# Decoder 18: jsQR (standalone Node.js QR decoder)
decode_with_jsqr() {
    set +u
    local image="${1:-}"
    local output_file="${2:-}"
    set -u
    
    # Check for Node.js
    local node_cmd=""
    if command -v node &>/dev/null; then
        node_cmd="node"
    elif command -v nodejs &>/dev/null; then
        node_cmd="nodejs"
    else
        return 2
    fi
    
    (
        exec 2>/dev/null
        timeout 30 $node_cmd <<'JSQR_EOF' > "$output_file" 2>/dev/null
const fs = require('fs');
const path = require('path');

let jsQR, Jimp, PNG;
try { jsQR = require('jsqr'); } catch(e) { process.exit(2); }
try { Jimp = require('jimp'); } catch(e) {}
try { PNG = require('pngjs').PNG; } catch(e) {}

const imagePath = process.argv[2] || '$image';

async function decodeWithJimp() {
    if (!Jimp) return null;
    const image = await Jimp.read(imagePath);
    const { width, height, data } = image.bitmap;
    return jsQR(new Uint8ClampedArray(data), width, height);
}

function decodeWithPNG() {
    if (!PNG) return null;
    const data = fs.readFileSync(imagePath);
    const png = PNG.sync.read(data);
    return jsQR(new Uint8ClampedArray(png.data), png.width, png.height);
}

async function main() {
    let code = await decodeWithJimp();
    if (!code) code = decodeWithPNG();
    if (code && code.data) {
        console.log(code.data);
    }
}

main().catch(() => {});
JSQR_EOF
    )
    
    [[ -s "$output_file" ]]
}

# Decoder 19: python-barcode / pyBarcode (1D barcode types)
# Primarily for 1D barcodes: Code128, Code39, EAN, UPC, etc.
decode_with_python_barcode() {
    set +u
    local image="${1:-}"
    local output_file="${2:-}"
    set -u
    local python_cmd=$(get_python_cmd)
    
    [[ -z "$python_cmd" ]] && return 2
    
    (
        exec 2>/dev/null
        timeout 30 "$python_cmd" << PYBARCODE_EOF 2>/dev/null
import sys
import signal
signal.signal(signal.SIGSEGV, lambda s,f: sys.exit(139))
signal.signal(signal.SIGABRT, lambda s,f: sys.exit(134))

image_path = '$image'
output_file = '$output_file'

# python-barcode is primarily a generator, not decoder
# But we can use pyzbar with 1D symbol types explicitly
try:
    from pyzbar.pyzbar import decode, ZBarSymbol
    from PIL import Image
    
    img = Image.open(image_path)
    
    # Explicitly try 1D barcode types
    symbol_types = [
        ZBarSymbol.CODE128,
        ZBarSymbol.CODE39,
        ZBarSymbol.EAN13,
        ZBarSymbol.EAN8,
        ZBarSymbol.UPCA,
        ZBarSymbol.UPCE,
        ZBarSymbol.I25,      # Interleaved 2 of 5
        ZBarSymbol.DATABAR,
        ZBarSymbol.DATABAR_EXP,
        ZBarSymbol.CODABAR,
        ZBarSymbol.PDF417,
    ]
    
    all_results = set()
    
    # Try each symbol type
    for sym_type in symbol_types:
        try:
            codes = decode(img, symbols=[sym_type])
            for c in codes:
                try:
                    data = c.data.decode('utf-8')
                except:
                    data = c.data.decode('latin-1', errors='replace')
                all_results.add(f"{c.type}:{data}")
        except:
            pass
    
    # Also try without symbol filter (all types)
    try:
        codes = decode(img)
        for c in codes:
            try:
                data = c.data.decode('utf-8')
            except:
                data = c.data.decode('latin-1', errors='replace')
            all_results.add(f"{c.type}:{data}")
    except:
        pass
    
    if all_results:
        with open(output_file, 'w') as f:
            for r in all_results:
                f.write(r + '\\n')
                
except ImportError:
    sys.exit(2)
except Exception as e:
    sys.exit(1)
PYBARCODE_EOF
    )
    
    [[ -s "$output_file" ]]
}

# Decoder 20: OpenCV ARUCO + DataMatrix (specialized 2D codes)
decode_with_opencv_aruco() {
    set +u
    local image="${1:-}"
    local output_file="${2:-}"
    set -u
    local python_cmd=$(get_python_cmd)
    
    [[ -z "$python_cmd" ]] && return 2
    
    # Validate inputs
    if [[ -z "$image" ]] || [[ ! -f "$image" ]] || [[ ! -r "$image" ]]; then
        return 1
    fi
    
    if ! validate_decoder_output_path "$output_file" "decode_with_opencv_aruco"; then
        return 1
    fi
    
    # Safe module check before execution
    if ! safe_check_python_module "cv2"; then
        return 2
    fi
    
    (
        exec 2>/dev/null
        timeout 30 "$python_cmd" <<'PYARUCO_EOF' 2>/dev/null
import sys
import signal
signal.signal(signal.SIGSEGV, lambda s,f: sys.exit(139))
signal.signal(signal.SIGABRT, lambda s,f: sys.exit(134))

image_path = '$image'
output_file = '$output_file'

try:
    import cv2
    import numpy as np
    
    img = cv2.imread(image_path)
    if img is None:
        sys.exit(1)
    
    results = []
    gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
    
    # Try ArUco marker detection
    try:
        aruco_dict = cv2.aruco.getPredefinedDictionary(cv2.aruco.DICT_4X4_250)
        parameters = cv2.aruco.DetectorParameters()
        detector = cv2.aruco.ArucoDetector(aruco_dict, parameters)
        corners, ids, rejected = detector.detectMarkers(gray)
        
        if ids is not None:
            for i, marker_id in enumerate(ids.flatten()):
                results.append(f"ARUCO:{marker_id}")
    except AttributeError:
        # Older OpenCV version
        try:
            aruco_dict = cv2.aruco.Dictionary_get(cv2.aruco.DICT_4X4_250)
            parameters = cv2.aruco.DetectorParameters_create()
            corners, ids, rejected = cv2.aruco.detectMarkers(gray, aruco_dict, parameters=parameters)
            if ids is not None:
                for marker_id in ids.flatten():
                    results.append(f"ARUCO:{marker_id}")
        except:
            pass
    
    # Try QR code detection with different preprocessings
    detector = cv2.QRCodeDetector()
    
    # Multiple preprocessing attempts
    for processed in [img, gray, cv2.GaussianBlur(gray, (5,5), 0)]:
        try:
            if len(processed.shape) == 2:
                # Grayscale - convert back to BGR for detector
                processed = cv2.cvtColor(processed, cv2.COLOR_GRAY2BGR)
            data, _, _ = detector.detectAndDecode(processed)
            if data:
                results.append(f"QR:{data}")
                break
        except:
            pass
    
    # Try multi-QR detection
    try:
        retval, decoded_info, points, straight_qrcode = detector.detectAndDecodeMulti(img)
        if retval and decoded_info:
            for data in decoded_info:
                if data:
                    results.append(f"QR_MULTI:{data}")
    except:
        pass
    
    if results:
        with open(output_file, 'w') as f:
            for r in set(results):
                f.write(r + '\n')

except ImportError:
    sys.exit(2)
except Exception:
    sys.exit(1)
PYARUCO_EOF
    )
    
    [[ -s "$output_file" ]]
}

# Decoder 21: Dynamsoft Barcode Reader (if available - commercial but has free tier)
decode_with_dynamsoft() {
    set +u
    local image="${1:-}"
    local output_file="${2:-}"
    set -u
    local python_cmd=$(get_python_cmd)
    
    [[ -z "$python_cmd" ]] && return 2
    
    # Validate inputs
    if [[ -z "$image" ]] || [[ ! -f "$image" ]] || [[ ! -r "$image" ]]; then
        return 1
    fi
    
    if ! validate_decoder_output_path "$output_file" "decode_with_dynamsoft"; then
        return 1
    fi
    
    # Safe module check before execution
    if ! safe_check_python_module "dbr"; then
        return 2
    fi
    
    # Run in completely isolated subprocess with all crash signals trapped
    # Use a separate script file to ensure complete isolation
    local temp_script="${TEMP_DIR}/dynamsoft_decode_$$.py"
    cat > "$temp_script" <<'PYDYNAMSOFT_SCRIPT'
import sys
import os
import signal

# Immediately set up signal handlers before ANY imports
def crash_handler(sig, frame):
    sys.exit(139)

signal.signal(signal.SIGSEGV, crash_handler)
signal.signal(signal.SIGABRT, crash_handler)
signal.signal(signal.SIGBUS, crash_handler)
signal.signal(signal.SIGFPE, crash_handler)

# Disable core dumps
try:
    import resource
    resource.setrlimit(resource.RLIMIT_CORE, (0, 0))
except:
    pass

if len(sys.argv) < 3:
    sys.exit(1)

image_path = sys.argv[1]
output_file = sys.argv[2]

try:
    # Import dbr inside try block
    from dbr import BarcodeReader, EnumBarcodeFormat
    
    reader = BarcodeReader()
    
    # Try with default/trial license (may have limitations)
    try:
        reader.init_license("DLS2eyJvcmdhbml6YXRpb25JRCI6IjIwMDAwMSJ9")
    except:
        pass
    
    results = reader.decode_file(image_path)
    
    if results:
        with open(output_file, 'w') as f:
            for result in results:
                f.write(f"{result.barcode_format_string}:{result.barcode_text}\n")
    
    sys.exit(0)

except ImportError:
    sys.exit(2)
except Exception as e:
    sys.exit(1)
PYDYNAMSOFT_SCRIPT

    # Run the script in a completely separate process with timeout
    # Redirect all output and use nohup-style isolation
    (
        # Trap signals in the subshell too
        trap 'exit 139' SEGV
        trap 'exit 134' ABRT
        trap 'exit 135' BUS
        
        # Disable core dumps for this subshell
        ulimit -c 0 2>/dev/null
        
        # Run with timeout, redirecting stderr to /dev/null
        timeout 15 "$python_cmd" "$temp_script" "$image" "$output_file" 2>/dev/null
    ) 2>/dev/null
    
    local status=$?
    rm -f "$temp_script" 2>/dev/null
    
    # Any crash signal means failure
    if [[ $status -ge 128 ]]; then
        return 1
    fi
    
    [[ -s "$output_file" ]]
}

# Decoder 22: zxing-cpp (C++ port of ZXing, often faster)
decode_with_zxingcpp() {
    set +u
    local image="${1:-}"
    local output_file="${2:-}"
    set -u
    local python_cmd=$(get_python_cmd)
    
    # Validate inputs
    if [[ -z "$image" ]] || [[ ! -f "$image" ]] || [[ ! -r "$image" ]]; then
        return 1
    fi
    
    if ! validate_decoder_output_path "$output_file" "decode_with_zxingcpp"; then
        return 1
    fi
    
    # Check for zxing-cpp command line tool first (safest option)
    if command -v zxing &>/dev/null; then
        (
            trap 'exit 139' SEGV
            trap 'exit 134' ABRT
            ulimit -c 0 2>/dev/null
            exec 2>/dev/null
            timeout 15 zxing "$image" > "$output_file" 2>/dev/null
        ) 2>/dev/null
        [[ -s "$output_file" ]] && return 0
    fi
    
    # Try Python binding with crash protection
    [[ -z "$python_cmd" ]] && return 2
    
    # Safe module check before execution
    if ! safe_check_python_module "zxingcpp"; then
        return 2
    fi
    
    # Create isolated script file
    local temp_script="${TEMP_DIR}/zxingcpp_decode_$$.py"
    cat > "$temp_script" <<'PYZXINGCPP_SCRIPT'
import sys
import signal

def crash_handler(sig, frame):
    sys.exit(139)

signal.signal(signal.SIGSEGV, crash_handler)
signal.signal(signal.SIGABRT, crash_handler)
signal.signal(signal.SIGBUS, crash_handler)

try:
    import resource
    resource.setrlimit(resource.RLIMIT_CORE, (0, 0))
except:
    pass

if len(sys.argv) < 3:
    sys.exit(1)

image_path = sys.argv[1]
output_file = sys.argv[2]

try:
    import zxingcpp
    from PIL import Image
    
    img = Image.open(image_path)
    results = zxingcpp.read_barcodes(img)
    
    if results:
        with open(output_file, 'w') as f:
            for result in results:
                f.write(f"{result.format.name}:{result.text}\n")
    
    sys.exit(0)

except ImportError:
    sys.exit(2)
except Exception:
    sys.exit(1)
PYZXINGCPP_SCRIPT

    (
        trap 'exit 139' SEGV
        trap 'exit 134' ABRT
        ulimit -c 0 2>/dev/null
        timeout 15 "$python_cmd" "$temp_script" "$image" "$output_file" 2>/dev/null
    ) 2>/dev/null
    
    local status=$?
    rm -f "$temp_script" 2>/dev/null
    
    [[ $status -ge 128 ]] && return 1
    [[ -s "$output_file" ]]
}

################################################################################
# EXTENDED BARCODE DECODERS (Audit Compliance - Full Set)
# Decoders 23-35: Missing decoder engines from security audit
################################################################################

# Decoder 23: GoQR - Go-based QR decoder (fast, memory-safe)
# Uses gozxing or goqr command-line tools
decode_with_goqr() {
    set +u
    local image="${1:-}"
    local output_file="${2:-}"
    set -u
    local python_cmd=$(get_python_cmd)
    
    # Input validation
    if [[ -z "$image" ]] || [[ ! -f "$image" ]] || [[ ! -r "$image" ]]; then
        echo "[decode_with_goqr] Image not found or unreadable: '$image'" >&2
        return 1
    fi
    
    if ! validate_decoder_output_path "$output_file" "decode_with_goqr"; then
        return 1
    fi
    
    # Try gozxing CLI tool first
    if command -v gozxing &>/dev/null; then
        (
            trap 'exit 139' SEGV
            trap 'exit 134' ABRT
            ulimit -c 0 2>/dev/null
            exec 2>/dev/null
            timeout 20 gozxing decode "$image" > "$output_file" 2>/dev/null
        ) 2>/dev/null
        [[ -s "$output_file" ]] && return 0
    fi
    
    # Try goqr CLI tool
    if command -v goqr &>/dev/null; then
        (
            trap 'exit 139' SEGV
            trap 'exit 134' ABRT
            ulimit -c 0 2>/dev/null
            exec 2>/dev/null
            timeout 20 goqr decode "$image" > "$output_file" 2>/dev/null
        ) 2>/dev/null
        [[ -s "$output_file" ]] && return 0
    fi
    
    # Try qrdecode (another Go implementation)
    if command -v qrdecode &>/dev/null; then
        (
            trap 'exit 139' SEGV
            trap 'exit 134' ABRT
            ulimit -c 0 2>/dev/null
            exec 2>/dev/null
            timeout 20 qrdecode -i "$image" > "$output_file" 2>/dev/null
        ) 2>/dev/null
        [[ -s "$output_file" ]] && return 0
    fi
    
    # Try go-qrcode reader
    if command -v go-qr &>/dev/null; then
        (
            exec 2>/dev/null
            timeout 20 go-qr read "$image" > "$output_file" 2>/dev/null
        ) 2>/dev/null
        [[ -s "$output_file" ]] && return 0
    fi
    
    return 1
}

# Decoder 24: Aztec Code decoder (ISO/IEC 24778)
# Common in transport tickets, boarding passes, European train tickets
decode_with_aztec() {
    set +u
    local image="${1:-}"
    local output_file="${2:-}"
    set -u
    local python_cmd=$(get_python_cmd)
    
    if [[ -z "$image" ]] || [[ ! -f "$image" ]] || [[ ! -r "$image" ]]; then
        echo "[decode_with_aztec] Image not found or unreadable: '$image'" >&2
        return 1
    fi
    
    if ! validate_decoder_output_path "$output_file" "decode_with_aztec"; then
        return 1
    fi
    
    # Try aztec-decoder CLI tool
    if command -v aztec-decoder &>/dev/null; then
        (
            exec 2>/dev/null
            timeout 20 aztec-decoder "$image" > "$output_file" 2>/dev/null
        ) 2>/dev/null
        [[ -s "$output_file" ]] && return 0
    fi
    
    # Try via Python zxing-cpp with Aztec filter
    [[ -z "$python_cmd" ]] && return 2
    
    if "$python_cmd" -c "import zxingcpp" 2>/dev/null; then
        local temp_script="${TEMP_DIR}/aztec_decode_$$.py"
        cat > "$temp_script" <<'PYAZTEC_SCRIPT'
import sys
import signal

def crash_handler(sig, frame):
    sys.exit(139)

signal.signal(signal.SIGSEGV, crash_handler)
signal.signal(signal.SIGABRT, crash_handler)

try:
    import resource
    resource.setrlimit(resource.RLIMIT_CORE, (0, 0))
except:
    pass

if len(sys.argv) < 3:
    sys.exit(1)

image_path = sys.argv[1]
output_file = sys.argv[2]

try:
    import zxingcpp
    from PIL import Image
    
    img = Image.open(image_path)
    
    # Specifically look for Aztec codes
    results = zxingcpp.read_barcodes(img, formats=zxingcpp.BarcodeFormat.Aztec)
    
    if not results:
        # Try with preprocessing
        img_gray = img.convert('L')
        results = zxingcpp.read_barcodes(img_gray, formats=zxingcpp.BarcodeFormat.Aztec)
    
    if results:
        with open(output_file, 'w') as f:
            for result in results:
                f.write(f"AZTEC:{result.text}\n")
    
    sys.exit(0)

except ImportError:
    sys.exit(2)
except Exception:
    sys.exit(1)
PYAZTEC_SCRIPT

        (
            trap 'exit 139' SEGV
            trap 'exit 134' ABRT
            ulimit -c 0 2>/dev/null
            timeout 20 "$python_cmd" "$temp_script" "$image" "$output_file" 2>/dev/null
        ) 2>/dev/null
        
        rm -f "$temp_script" 2>/dev/null
        [[ -s "$output_file" ]] && return 0
    fi
    
    # Fallback: pyzbar with Aztec symbol type
    if "$python_cmd" -c "from pyzbar.pyzbar import decode, ZBarSymbol" 2>/dev/null; then
        (
            exec 2>/dev/null
            timeout 20 "$python_cmd" << PYAZTEC_PYZBAR > "$output_file" 2>/dev/null
import sys
from pyzbar.pyzbar import decode
from PIL import Image

try:
    img = Image.open(image_path)
    codes = decode(img)
    for c in codes:
        if 'AZTEC' in str(c.type).upper():
            data = c.data.decode('utf-8', errors='replace')
            print(f"AZTEC:{data}")
except:
    pass
PYAZTEC_PYZBAR
        ) 2>/dev/null
        [[ -s "$output_file" ]] && return 0
    fi
    
    # Return 2 to indicate module not available (not an error/crash)
    return 2
}

# Decoder 25: PDF417 barcode decoder (ISO 15438)
# Used in IDs, driver's licenses, boarding passes, shipping labels
decode_with_pdf417() {
    set +u
    local image="${1:-}"
    local output_file="${2:-}"
    set -u
    local python_cmd=$(get_python_cmd)
    
    if [[ -z "$image" ]] || [[ ! -f "$image" ]] || [[ ! -r "$image" ]]; then
        echo "[decode_with_pdf417] Image not found or unreadable: '$image'" >&2
        return 1
    fi
    
    if ! validate_decoder_output_path "$output_file" "decode_with_pdf417"; then
        return 1
    fi
    
    # Try pdf417decoder CLI tool
    if command -v pdf417decode &>/dev/null; then
        (
            exec 2>/dev/null
            timeout 20 pdf417decode "$image" > "$output_file" 2>/dev/null
        ) 2>/dev/null
        [[ -s "$output_file" ]] && return 0
    fi
    
    [[ -z "$python_cmd" ]] && return 2
    
    # Try via zxing-cpp with PDF417 filter
    if "$python_cmd" -c "import zxingcpp" 2>/dev/null; then
        local temp_script="${TEMP_DIR}/pdf417_decode_$$.py"
        cat > "$temp_script" <<'PYPDF417_SCRIPT'
import sys
import signal

def crash_handler(sig, frame):
    sys.exit(139)

signal.signal(signal.SIGSEGV, crash_handler)
signal.signal(signal.SIGABRT, crash_handler)

try:
    import resource
    resource.setrlimit(resource.RLIMIT_CORE, (0, 0))
except:
    pass

if len(sys.argv) < 3:
    sys.exit(1)

image_path = sys.argv[1]
output_file = sys.argv[2]

try:
    import zxingcpp
    from PIL import Image
    
    img = Image.open(image_path)
    
    # Specifically look for PDF417 codes
    results = zxingcpp.read_barcodes(img, formats=zxingcpp.BarcodeFormat.PDF417)
    
    if not results:
        # Try with grayscale preprocessing
        img_gray = img.convert('L')
        results = zxingcpp.read_barcodes(img_gray, formats=zxingcpp.BarcodeFormat.PDF417)
    
    if not results:
        # Try micro PDF417
        results = zxingcpp.read_barcodes(img, formats=zxingcpp.BarcodeFormat.MicroPDF417)
    
    if results:
        with open(output_file, 'w') as f:
            for result in results:
                f.write(f"PDF417:{result.text}\n")
    
    sys.exit(0)

except ImportError:
    sys.exit(2)
except Exception:
    sys.exit(1)
PYPDF417_SCRIPT

        (
            trap 'exit 139' SEGV
            trap 'exit 134' ABRT
            ulimit -c 0 2>/dev/null
            timeout 20 "$python_cmd" "$temp_script" "$image" "$output_file" 2>/dev/null
        ) 2>/dev/null
        
        rm -f "$temp_script" 2>/dev/null
        [[ -s "$output_file" ]] && return 0
    fi
    
    # Fallback: pyzbar
    if "$python_cmd" -c "from pyzbar.pyzbar import decode, ZBarSymbol" 2>/dev/null; then
        (
            exec 2>/dev/null
            timeout 20 "$python_cmd" << PYPDF417_PYZBAR > "$output_file" 2>/dev/null
import sys
from pyzbar.pyzbar import decode, ZBarSymbol
from PIL import Image

try:
    img = Image.open(image_path)
    codes = decode(img, symbols=[ZBarSymbol.PDF417])
    for c in codes:
        data = c.data.decode('utf-8', errors='replace')
        print(f"PDF417:{data}")
except:
    pass
PYPDF417_PYZBAR
        ) 2>/dev/null
        [[ -s "$output_file" ]] && return 0
    fi
    
    # Return 2 to indicate module not available (not an error/crash)
    return 2
}

# Decoder 26: MaxiCode decoder (ISO/IEC 16023)
# Used primarily by UPS for shipping labels
decode_with_maxicode() {
    set +u
    local image="${1:-}"
    local output_file="${2:-}"
    set -u
    local python_cmd=$(get_python_cmd)
    
    if [[ -z "$image" ]] || [[ ! -f "$image" ]] || [[ ! -r "$image" ]]; then
        echo "[decode_with_maxicode] Image not found or unreadable: '$image'" >&2
        return 1
    fi
    
    if ! validate_decoder_output_path "$output_file" "decode_with_maxicode"; then
        return 1
    fi
    
    # Try maxicode CLI tool
    if command -v maxidecode &>/dev/null; then
        (
            exec 2>/dev/null
            timeout 20 maxidecode "$image" > "$output_file" 2>/dev/null
        ) 2>/dev/null
        [[ -s "$output_file" ]] && return 0
    fi
    
    [[ -z "$python_cmd" ]] && return 2
    
    # Try via zxing-cpp
    if "$python_cmd" -c "import zxingcpp" 2>/dev/null; then
        local temp_script="${TEMP_DIR}/maxicode_decode_$$.py"
        cat > "$temp_script" <<'PYMAXICODE_SCRIPT'
import sys
import signal

def crash_handler(sig, frame):
    sys.exit(139)

signal.signal(signal.SIGSEGV, crash_handler)
signal.signal(signal.SIGABRT, crash_handler)

try:
    import resource
    resource.setrlimit(resource.RLIMIT_CORE, (0, 0))
except:
    pass

if len(sys.argv) < 3:
    sys.exit(1)

image_path = sys.argv[1]
output_file = sys.argv[2]

try:
    import zxingcpp
    from PIL import Image
    
    img = Image.open(image_path)
    
    # Specifically look for MaxiCode
    results = zxingcpp.read_barcodes(img, formats=zxingcpp.BarcodeFormat.MaxiCode)
    
    if not results:
        # MaxiCode often needs specific preprocessing due to bullseye pattern
        img_gray = img.convert('L')
        results = zxingcpp.read_barcodes(img_gray, formats=zxingcpp.BarcodeFormat.MaxiCode)
    
    if results:
        with open(output_file, 'w') as f:
            for result in results:
                # MaxiCode has structured data - parse it
                text = result.text
                f.write(f"MAXICODE:{text}\n")
                # Try to extract UPS-specific fields
                if len(text) > 9:
                    f.write(f"MAXICODE_MODE:{result.symbology_identifier if hasattr(result, 'symbology_identifier') else 'unknown'}\n")
    
    sys.exit(0)

except ImportError:
    sys.exit(2)
except Exception:
    sys.exit(1)
PYMAXICODE_SCRIPT

        (
            trap 'exit 139' SEGV
            trap 'exit 134' ABRT
            ulimit -c 0 2>/dev/null
            timeout 20 "$python_cmd" "$temp_script" "$image" "$output_file" 2>/dev/null
        ) 2>/dev/null
        
        rm -f "$temp_script" 2>/dev/null
        [[ -s "$output_file" ]] && return 0
    fi
    
    # Return 2 to indicate module not available (not an error/crash)
    return 2
}

# Decoder 27: Codabar decoder (NW-7, USD-4, Code 2 of 7)
# Used in libraries, blood banks, FedEx airbills
decode_with_codabar() {
    set +u
    local image="${1:-}"
    local output_file="${2:-}"
    set -u
    local python_cmd=$(get_python_cmd)
    
    if [[ -z "$image" ]] || [[ ! -f "$image" ]] || [[ ! -r "$image" ]]; then
        echo "[decode_with_codabar] Image not found or unreadable: '$image'" >&2
        return 1
    fi
    
    if ! validate_decoder_output_path "$output_file" "decode_with_codabar"; then
        return 1
    fi
    
    [[ -z "$python_cmd" ]] && return 2
    
    # Try pyzbar first (best support for Codabar)
    if "$python_cmd" -c "from pyzbar.pyzbar import decode, ZBarSymbol" 2>/dev/null; then
        (
            exec 2>/dev/null
            timeout 20 "$python_cmd" << PYCODABAR_PYZBAR > "$output_file" 2>/dev/null
import sys
from pyzbar.pyzbar import decode, ZBarSymbol
from PIL import Image

try:
    img = Image.open(image_path)
    codes = decode(img, symbols=[ZBarSymbol.CODABAR])
    for c in codes:
        data = c.data.decode('utf-8', errors='replace')
        # Codabar uses start/stop characters A, B, C, D or T, N, *, E
        print(f"CODABAR:{data}")
except:
    pass
PYCODABAR_PYZBAR
        ) 2>/dev/null
        [[ -s "$output_file" ]] && return 0
    fi
    
    # Try zxing-cpp
    if "$python_cmd" -c "import zxingcpp" 2>/dev/null; then
        local temp_script="${TEMP_DIR}/codabar_decode_$$.py"
        cat > "$temp_script" <<'PYCODABAR_SCRIPT'
import sys
import signal

def crash_handler(sig, frame):
    sys.exit(139)

signal.signal(signal.SIGSEGV, crash_handler)
signal.signal(signal.SIGABRT, crash_handler)

if len(sys.argv) < 3:
    sys.exit(1)

image_path = sys.argv[1]
output_file = sys.argv[2]

try:
    import zxingcpp
    from PIL import Image
    
    img = Image.open(image_path)
    results = zxingcpp.read_barcodes(img, formats=zxingcpp.BarcodeFormat.Codabar)
    
    if results:
        with open(output_file, 'w') as f:
            for result in results:
                f.write(f"CODABAR:{result.text}\n")
    
    sys.exit(0)

except ImportError:
    sys.exit(2)
except Exception:
    sys.exit(1)
PYCODABAR_SCRIPT

        (
            trap 'exit 139' SEGV
            trap 'exit 134' ABRT
            ulimit -c 0 2>/dev/null
            timeout 20 "$python_cmd" "$temp_script" "$image" "$output_file" 2>/dev/null
        ) 2>/dev/null
        
        rm -f "$temp_script" 2>/dev/null
        [[ -s "$output_file" ]] && return 0
    fi
    
    # Return 2 to indicate module not available (not an error/crash)
    return 2
}

# Decoder 28: Code 128 linear barcode decoder (ISO/IEC 15417)
# High-density alphanumeric barcode - logistics, healthcare, retail
decode_with_code128() {
    set +u
    local image="${1:-}"
    local output_file="${2:-}"
    set -u
    local python_cmd=$(get_python_cmd)
    
    if [[ -z "$image" ]] || [[ ! -f "$image" ]] || [[ ! -r "$image" ]]; then
        echo "[decode_with_code128] Image not found or unreadable: '$image'" >&2
        return 1
    fi
    
    if ! validate_decoder_output_path "$output_file" "decode_with_code128"; then
        return 1
    fi
    
    [[ -z "$python_cmd" ]] && return 2
    
    # Try pyzbar (excellent Code 128 support)
    if "$python_cmd" -c "from pyzbar.pyzbar import decode, ZBarSymbol" 2>/dev/null; then
        (
            exec 2>/dev/null
            timeout 20 "$python_cmd" << PYCODE128_PYZBAR > "$output_file" 2>/dev/null
import sys
from pyzbar.pyzbar import decode, ZBarSymbol
from PIL import Image
import cv2
import numpy as np

image_path = '$image'

try:
    # Try PIL first
    img = Image.open(image_path)
    codes = decode(img, symbols=[ZBarSymbol.CODE128])
    
    if not codes:
        # Try with OpenCV preprocessing for better 1D barcode detection
        cv_img = cv2.imread(image_path)
        if cv_img is not None:
            gray = cv2.cvtColor(cv_img, cv2.COLOR_BGR2GRAY)
            # Enhance contrast
            clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8,8))
            enhanced = clahe.apply(gray)
            codes = decode(enhanced, symbols=[ZBarSymbol.CODE128])
    
    for c in codes:
        data = c.data.decode('utf-8', errors='replace')
        # Identify Code 128 subset (A, B, or C)
        print(f"CODE128:{data}")
except Exception as e:
    pass
PYCODE128_PYZBAR
        ) 2>/dev/null
        [[ -s "$output_file" ]] && return 0
    fi
    
    # Try zxing-cpp
    if "$python_cmd" -c "import zxingcpp" 2>/dev/null; then
        local temp_script="${TEMP_DIR}/code128_decode_$$.py"
        cat > "$temp_script" <<'PYCODE128_SCRIPT'
import sys
import signal

def crash_handler(sig, frame):
    sys.exit(139)

signal.signal(signal.SIGSEGV, crash_handler)
signal.signal(signal.SIGABRT, crash_handler)

if len(sys.argv) < 3:
    sys.exit(1)

image_path = sys.argv[1]
output_file = sys.argv[2]

try:
    import zxingcpp
    from PIL import Image
    
    img = Image.open(image_path)
    results = zxingcpp.read_barcodes(img, formats=zxingcpp.BarcodeFormat.Code128)
    
    if results:
        with open(output_file, 'w') as f:
            for result in results:
                f.write(f"CODE128:{result.text}\n")
    
    sys.exit(0)

except ImportError:
    sys.exit(2)
except Exception:
    sys.exit(1)
PYCODE128_SCRIPT

        (
            trap 'exit 139' SEGV
            trap 'exit 134' ABRT
            ulimit -c 0 2>/dev/null
            timeout 20 "$python_cmd" "$temp_script" "$image" "$output_file" 2>/dev/null
        ) 2>/dev/null
        
        rm -f "$temp_script" 2>/dev/null
        [[ -s "$output_file" ]] && return 0
    fi
    
    # Return 2 to indicate module not available (not an error/crash)
    return 2
}

# Decoder 29: Code 39 decoder (ISO/IEC 16388)
# Automotive VINs, defense (LOGMARS), healthcare
decode_with_code39() {
    set +u
    local image="${1:-}"
    local output_file="${2:-}"
    set -u
    local python_cmd=$(get_python_cmd)
    
    if [[ -z "$image" ]] || [[ ! -f "$image" ]] || [[ ! -r "$image" ]]; then
        echo "[decode_with_code39] Image not found or unreadable: '$image'" >&2
        return 1
    fi
    
    if ! validate_decoder_output_path "$output_file" "decode_with_code39"; then
        return 1
    fi
    
    [[ -z "$python_cmd" ]] && return 2
    
    # Try pyzbar
    if "$python_cmd" -c "from pyzbar.pyzbar import decode, ZBarSymbol" 2>/dev/null; then
        (
            exec 2>/dev/null
            timeout 20 "$python_cmd" << PYCODE39_PYZBAR > "$output_file" 2>/dev/null
import sys
from pyzbar.pyzbar import decode, ZBarSymbol
from PIL import Image

try:
    img = Image.open(image_path)
    codes = decode(img, symbols=[ZBarSymbol.CODE39])
    for c in codes:
        data = c.data.decode('utf-8', errors='replace')
        # Code 39 supports alphanumeric + special chars
        print(f"CODE39:{data}")
except:
    pass
PYCODE39_PYZBAR
        ) 2>/dev/null
        [[ -s "$output_file" ]] && return 0
    fi
    
    # Try zxing-cpp
    if "$python_cmd" -c "import zxingcpp" 2>/dev/null; then
        local temp_script="${TEMP_DIR}/code39_decode_$$.py"
        cat > "$temp_script" <<'PYCODE39_SCRIPT'
import sys
import signal

def crash_handler(sig, frame):
    sys.exit(139)

signal.signal(signal.SIGSEGV, crash_handler)
signal.signal(signal.SIGABRT, crash_handler)

if len(sys.argv) < 3:
    sys.exit(1)

image_path = sys.argv[1]
output_file = sys.argv[2]

try:
    import zxingcpp
    from PIL import Image
    
    img = Image.open(image_path)
    results = zxingcpp.read_barcodes(img, formats=zxingcpp.BarcodeFormat.Code39)
    
    if results:
        with open(output_file, 'w') as f:
            for result in results:
                f.write(f"CODE39:{result.text}\n")
    
    sys.exit(0)

except ImportError:
    sys.exit(2)
except Exception:
    sys.exit(1)
PYCODE39_SCRIPT

        (
            trap 'exit 139' SEGV
            trap 'exit 134' ABRT
            ulimit -c 0 2>/dev/null
            timeout 20 "$python_cmd" "$temp_script" "$image" "$output_file" 2>/dev/null
        ) 2>/dev/null
        
        rm -f "$temp_script" 2>/dev/null
        [[ -s "$output_file" ]] && return 0
    fi
    
    # Return 2 to indicate module not available (not an error/crash)
    return 2
}

# Decoder 30: EAN/UPC decoder (ISO/IEC 15420)
# Retail product barcodes - EAN-13, EAN-8, UPC-A, UPC-E
decode_with_ean() {
    set +u
    local image="${1:-}"
    local output_file="${2:-}"
    set -u
    local python_cmd=$(get_python_cmd)
    
    if [[ -z "$image" ]] || [[ ! -f "$image" ]] || [[ ! -r "$image" ]]; then
        echo "[decode_with_ean] Image not found or unreadable: '$image'" >&2
        return 1
    fi
    
    if ! validate_decoder_output_path "$output_file" "decode_with_ean"; then
        return 1
    fi
    
    [[ -z "$python_cmd" ]] && return 2
    
    # Try pyzbar (excellent EAN/UPC support)
    if "$python_cmd" -c "from pyzbar.pyzbar import decode, ZBarSymbol" 2>/dev/null; then
        (
            exec 2>/dev/null
            timeout 20 "$python_cmd" << 'PYEAN_PYZBAR' > "$output_file" 2>/dev/null
import sys
from pyzbar.pyzbar import decode, ZBarSymbol
from PIL import Image

def validate_ean13(code):
    """Validate EAN-13 check digit"""
    if len(code) != 13 or not code.isdigit():
        return False
    odd_sum = sum(int(code[i]) for i in range(0, 12, 2))
    even_sum = sum(int(code[i]) for i in range(1, 12, 2))
    total = odd_sum + (even_sum * 3)
    check = (10 - (total % 10)) % 10
    return check == int(code[12])

def validate_ean8(code):
    """Validate EAN-8 check digit"""
    if len(code) != 8 or not code.isdigit():
        return False
    odd_sum = sum(int(code[i]) for i in range(0, 7, 2))
    even_sum = sum(int(code[i]) for i in range(1, 7, 2))
    total = (odd_sum * 3) + even_sum
    check = (10 - (total % 10)) % 10
    return check == int(code[7])

def validate_upca(code):
    """Validate UPC-A check digit"""
    if len(code) != 12 or not code.isdigit():
        return False
    odd_sum = sum(int(code[i]) for i in range(0, 11, 2))
    even_sum = sum(int(code[i]) for i in range(1, 11, 2))
    total = (odd_sum * 3) + even_sum
    check = (10 - (total % 10)) % 10
    return check == int(code[11])

def validate_upce(code):
    """Validate UPC-E (basic length check)"""
    return len(code) in [6, 7, 8] and code.isdigit()

def validate_barcode(sym_type, data):
    """Validate barcode format and check digit"""
    if sym_type == "EAN13" or sym_type == "ISBN13":
        return validate_ean13(data)
    elif sym_type == "EAN8":
        return validate_ean8(data)
    elif sym_type == "UPCA":
        return validate_upca(data)
    elif sym_type == "UPCE":
        return validate_upce(data)
    elif sym_type == "ISBN10":
        # ISBN-10 has different check digit algorithm
        return len(data) == 10
    return False

try:
    img = Image.open(image_path)
    
    # All EAN/UPC symbol types
    ean_symbols = [
        ZBarSymbol.EAN13,
        ZBarSymbol.EAN8,
        ZBarSymbol.UPCA,
        ZBarSymbol.UPCE,
        ZBarSymbol.ISBN10,
        ZBarSymbol.ISBN13,
    ]
    
    all_results = set()
    
    for sym in ean_symbols:
        try:
            codes = decode(img, symbols=[sym])
            for c in codes:
                data = c.data.decode('utf-8', errors='replace').strip()
                sym_type = str(c.type)
                
                # Validate before adding
                if validate_barcode(sym_type, data):
                    all_results.add(f"{sym_type}:{data}")
        except (ValueError, IOError):
            pass
    
    if all_results:
        for r in sorted(all_results):
            print(r)
except ImportError:
    sys.exit(2)
except Exception:
    sys.exit(1)
PYEAN_PYZBAR
        ) 2>/dev/null
        [[ -s "$output_file" ]] && return 0
    fi
    
    # Try zxing-cpp
    if "$python_cmd" -c "import zxingcpp" 2>/dev/null; then
        local temp_script="${TEMP_DIR}/ean_decode_$$.py"
        cat > "$temp_script" <<'PYEAN_SCRIPT'
import sys
import signal

def crash_handler(sig, frame):
    sys.exit(139)

signal.signal(signal.SIGSEGV, crash_handler)
signal.signal(signal.SIGABRT, crash_handler)

def validate_ean13(code):
    """Validate EAN-13 check digit"""
    if len(code) != 13 or not code.isdigit():
        return False
    odd_sum = sum(int(code[i]) for i in range(0, 12, 2))
    even_sum = sum(int(code[i]) for i in range(1, 12, 2))
    total = odd_sum + (even_sum * 3)
    check = (10 - (total % 10)) % 10
    return check == int(code[12])

def validate_ean8(code):
    """Validate EAN-8 check digit"""
    if len(code) != 8 or not code.isdigit():
        return False
    odd_sum = sum(int(code[i]) for i in range(0, 7, 2))
    even_sum = sum(int(code[i]) for i in range(1, 7, 2))
    total = (odd_sum * 3) + even_sum
    check = (10 - (total % 10)) % 10
    return check == int(code[7])

def validate_upca(code):
    """Validate UPC-A check digit"""
    if len(code) != 12 or not code.isdigit():
        return False
    odd_sum = sum(int(code[i]) for i in range(0, 11, 2))
    even_sum = sum(int(code[i]) for i in range(1, 11, 2))
    total = (odd_sum * 3) + even_sum
    check = (10 - (total % 10)) % 10
    return check == int(code[11])

def validate_upce(code):
    """Validate UPC-E (basic length check)"""
    return len(code) in [6, 7, 8] and code. isdigit()

def validate_barcode(format_name, text):
    """Validate barcode format and check digit"""
    if format_name == "EAN13":
        return validate_ean13(text)
    elif format_name == "EAN8":
        return validate_ean8(text)
    elif format_name == "UPCA":
        return validate_upca(text)
    elif format_name == "UPCE":
        return validate_upce(text)
    return False

if len(sys.argv) < 3:
    sys.exit(1)

image_path = sys.argv[1]
output_file = sys.argv[2]

try:
    import zxingcpp
    from PIL import Image
    
    img = Image.open(image_path)
    
    # All EAN/UPC formats
    ean_formats = (
        zxingcpp.BarcodeFormat.EAN13 |
        zxingcpp.BarcodeFormat.EAN8 |
        zxingcpp.BarcodeFormat.UPCA |
        zxingcpp.BarcodeFormat.UPCE
    )
    
    results = zxingcpp.read_barcodes(img, formats=ean_formats)
    
    if results:
        validated = []
        for result in results:
            text = result.text.strip()
            format_name = result.format.name
            
            # Validate before adding
            if validate_barcode(format_name, text):
                validated.append(f"{format_name}:{text}")
        
        if validated:
            with open(output_file, 'w') as f:
                for line in sorted(set(validated)):
                    f.write(line + "\n")
    
    sys.exit(0)

except ImportError:
    sys.exit(2)
except Exception:
    sys.exit(1)
PYEAN_SCRIPT

        (
            trap 'exit 139' SEGV
            trap 'exit 134' ABRT
            ulimit -c 0 2>/dev/null
            timeout 20 "$python_cmd" "$temp_script" "$image" "$output_file" 2>/dev/null
        ) 2>/dev/null
        
        rm -f "$temp_script" 2>/dev/null
        [[ -s "$output_file" ]] && return 0
    fi
    
    # Return 2 to indicate module not available (not an error/crash)
    return 2
}

# Decoder 31: rMQR (Rectangular Micro QR) decoder (ISO/IEC 23941)
# Compact QR variant for narrow spaces - product labels, electronics
decode_with_rmqr() {
    set +u
    local image="${1:-}"
    local output_file="${2:-}"
    set -u
    local python_cmd=$(get_python_cmd)
    
    if [[ -z "$image" ]] || [[ ! -f "$image" ]] || [[ ! -r "$image" ]]; then
        echo "[decode_with_rmqr] Image not found or unreadable: '$image'" >&2
        return 1
    fi
    
    if ! validate_decoder_output_path "$output_file" "decode_with_rmqr"; then
        return 1
    fi
    
    [[ -z "$python_cmd" ]] && return 2
    
    # Try zxing-cpp (has rMQR support in newer versions)
    if "$python_cmd" -c "import zxingcpp" 2>/dev/null; then
        local temp_script="${TEMP_DIR}/rmqr_decode_$$.py"
        cat > "$temp_script" <<'PYRMQR_SCRIPT'
import sys
import signal

def crash_handler(sig, frame):
    sys.exit(139)

signal.signal(signal.SIGSEGV, crash_handler)
signal.signal(signal.SIGABRT, crash_handler)

if len(sys.argv) < 3:
    sys.exit(1)

image_path = sys.argv[1]
output_file = sys.argv[2]

try:
    import zxingcpp
    from PIL import Image
    
    img = Image.open(image_path)
    
    # Try rMQR format (if supported by installed zxing-cpp version)
    try:
        results = zxingcpp.read_barcodes(img, formats=zxingcpp.BarcodeFormat.RMQRCode)
    except AttributeError:
        # Fallback - try MicroQRCode which is similar
        try:
            results = zxingcpp.read_barcodes(img, formats=zxingcpp.BarcodeFormat.MicroQRCode)
        except:
            results = []
    
    if not results:
        # Try general QR detection with all formats
        results = zxingcpp.read_barcodes(img)
        # Filter for rectangular/micro variants
        results = [r for r in results if 'MICRO' in r.format.name.upper() or 'RMQR' in r.format.name.upper()]
    
    if results:
        with open(output_file, 'w') as f:
            for result in results:
                f.write(f"RMQR:{result.text}\n")
    
    sys.exit(0)

except ImportError:
    sys.exit(2)
except Exception:
    sys.exit(1)
PYRMQR_SCRIPT

        (
            trap 'exit 139' SEGV
            trap 'exit 134' ABRT
            ulimit -c 0 2>/dev/null
            timeout 20 "$python_cmd" "$temp_script" "$image" "$output_file" 2>/dev/null
        ) 2>/dev/null
        
        rm -f "$temp_script" 2>/dev/null
        [[ -s "$output_file" ]] && return 0
    fi
    
    # Return 2 to indicate module not available (not an error/crash)
    return 2
}

# Decoder 32: Han Xin Code decoder (GB/T 21049 - Chinese national standard)
# High-capacity 2D barcode supporting Chinese characters natively
decode_with_hanxin() {
    set +u
    local image="${1:-}"
    local output_file="${2:-}"
    set -u
    local python_cmd=$(get_python_cmd)
    
    if [[ -z "$image" ]] || [[ ! -f "$image" ]] || [[ ! -r "$image" ]]; then
        echo "[decode_with_hanxin] Image not found or unreadable: '$image'" >&2
        return 1
    fi
    
    if ! validate_decoder_output_path "$output_file" "decode_with_hanxin"; then
        return 1
    fi
    
    # Try hanxin CLI decoder
    if command -v hanxin-decode &>/dev/null; then
        (
            exec 2>/dev/null
            timeout 20 hanxin-decode "$image" > "$output_file" 2>/dev/null
        ) 2>/dev/null
        [[ -s "$output_file" ]] && return 0
    fi
    
    [[ -z "$python_cmd" ]] && return 2
    
    # Try zxing-cpp (has Han Xin support)
    if "$python_cmd" -c "import zxingcpp" 2>/dev/null; then
        local temp_script="${TEMP_DIR}/hanxin_decode_$$.py"
        cat > "$temp_script" <<'PYHANXIN_SCRIPT'
import sys
import signal

def crash_handler(sig, frame):
    sys.exit(139)

signal.signal(signal.SIGSEGV, crash_handler)
signal.signal(signal.SIGABRT, crash_handler)

if len(sys.argv) < 3:
    sys.exit(1)

image_path = sys.argv[1]
output_file = sys.argv[2]

try:
    import zxingcpp
    from PIL import Image
    
    img = Image.open(image_path)
    
    # Try Han Xin format
    try:
        results = zxingcpp.read_barcodes(img, formats=zxingcpp.BarcodeFormat.HanXin)
    except AttributeError:
        # Not all versions support HanXin
        results = []
    
    if not results:
        # General detection and filter
        all_results = zxingcpp.read_barcodes(img)
        results = [r for r in all_results if 'HANXIN' in r.format.name.upper() or 'HAN' in r.format.name.upper()]
    
    if results:
        with open(output_file, 'w') as f:
            for result in results:
                # Han Xin supports GB 18030 encoding for Chinese
                text = result.text
                f.write(f"HANXIN:{text}\n")
    
    sys.exit(0)

except ImportError:
    sys.exit(2)
except Exception:
    sys.exit(1)
PYHANXIN_SCRIPT

        (
            trap 'exit 139' SEGV
            trap 'exit 134' ABRT
            ulimit -c 0 2>/dev/null
            timeout 20 "$python_cmd" "$temp_script" "$image" "$output_file" 2>/dev/null
        ) 2>/dev/null
        
        rm -f "$temp_script" 2>/dev/null
        [[ -s "$output_file" ]] && return 0
    fi
    
    # Return 2 to indicate module not available (not an error/crash)
    return 2
}

# Decoder 33: DotCode decoder (AIM DotCode, ISS DotCode)
# High-speed industrial printing - tobacco, pharmaceuticals
decode_with_dotcode() {
    set +u
    local image="${1:-}"
    local output_file="${2:-}"
    set -u
    local python_cmd=$(get_python_cmd)
    
    if [[ -z "$image" ]] || [[ ! -f "$image" ]] || [[ ! -r "$image" ]]; then
        echo "[decode_with_dotcode] Image not found or unreadable: '$image'" >&2
        return 1
    fi
    
    if ! validate_decoder_output_path "$output_file" "decode_with_dotcode"; then
        return 1
    fi
    
    [[ -z "$python_cmd" ]] && return 2
    
    # Try zxing-cpp (newer versions support DotCode)
    if "$python_cmd" -c "import zxingcpp" 2>/dev/null; then
        local temp_script="${TEMP_DIR}/dotcode_decode_$$.py"
        cat > "$temp_script" <<'PYDOTCODE_SCRIPT'
import sys
import signal

def crash_handler(sig, frame):
    sys.exit(139)

signal.signal(signal.SIGSEGV, crash_handler)
signal.signal(signal.SIGABRT, crash_handler)

if len(sys.argv) < 3:
    sys.exit(1)

image_path = sys.argv[1]
output_file = sys.argv[2]

try:
    import zxingcpp
    from PIL import Image
    import cv2
    import numpy as np
    
    img = Image.open(image_path)
    
    # Try DotCode format
    try:
        results = zxingcpp.read_barcodes(img, formats=zxingcpp.BarcodeFormat.DotCode)
    except AttributeError:
        results = []
    
    if not results:
        # DotCode needs specific preprocessing - enhance dots
        cv_img = cv2.imread(image_path)
        if cv_img is not None:
            gray = cv2.cvtColor(cv_img, cv2.COLOR_BGR2GRAY)
            # Morphological operations to enhance dots
            kernel = cv2.getStructuringElement(cv2.MORPH_ELLIPSE, (3, 3))
            enhanced = cv2.morphologyEx(gray, cv2.MORPH_CLOSE, kernel)
            enhanced = cv2.threshold(enhanced, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)[1]
            
            try:
                pil_enhanced = Image.fromarray(enhanced)
                results = zxingcpp.read_barcodes(pil_enhanced, formats=zxingcpp.BarcodeFormat.DotCode)
            except:
                pass
    
    if results:
        with open(output_file, 'w') as f:
            for result in results:
                f.write(f"DOTCODE:{result.text}\n")
    
    sys.exit(0)

except ImportError:
    sys.exit(2)
except Exception:
    sys.exit(1)
PYDOTCODE_SCRIPT

        (
            trap 'exit 139' SEGV
            trap 'exit 134' ABRT
            ulimit -c 0 2>/dev/null
            timeout 20 "$python_cmd" "$temp_script" "$image" "$output_file" 2>/dev/null
        ) 2>/dev/null
        
        rm -f "$temp_script" 2>/dev/null
        [[ -s "$output_file" ]] && return 0
    fi
    
    # Return 2 to indicate module not available (not an error/crash)
    return 2
}

# Decoder 34: Grid Matrix decoder (GB/T 21049 - Chinese standard)
# Alternative Chinese 2D barcode standard, similar to Han Xin
decode_with_gridmatrix() {
    set +u
    local image="${1:-}"
    local output_file="${2:-}"
    set -u
    local python_cmd=$(get_python_cmd)
    
    if [[ -z "$image" ]] || [[ ! -f "$image" ]] || [[ ! -r "$image" ]]; then
        echo "[decode_with_gridmatrix] Image not found or unreadable: '$image'" >&2
        return 1
    fi
    
    if ! validate_decoder_output_path "$output_file" "decode_with_gridmatrix"; then
        return 1
    fi
    
    [[ -z "$python_cmd" ]] && return 2
    
    # Try zxing-cpp
    if "$python_cmd" -c "import zxingcpp" 2>/dev/null; then
        local temp_script="${TEMP_DIR}/gridmatrix_decode_$$.py"
        cat > "$temp_script" <<'PYGRIDMATRIX_SCRIPT'
import sys
import signal

def crash_handler(sig, frame):
    sys.exit(139)

signal.signal(signal.SIGSEGV, crash_handler)
signal.signal(signal.SIGABRT, crash_handler)

if len(sys.argv) < 3:
    sys.exit(1)

image_path = sys.argv[1]
output_file = sys.argv[2]

try:
    import zxingcpp
    from PIL import Image
    
    img = Image.open(image_path)
    
    # Grid Matrix is sometimes supported as a separate format
    results = []
    
    # Try specific Grid Matrix format
    try:
        if hasattr(zxingcpp.BarcodeFormat, 'GridMatrix'):
            results = zxingcpp.read_barcodes(img, formats=zxingcpp.BarcodeFormat.GridMatrix)
    except:
        pass
    
    if not results:
        # General scan and filter
        all_results = zxingcpp.read_barcodes(img)
        results = [r for r in all_results if 'GRID' in r.format.name.upper()]
    
    if results:
        with open(output_file, 'w') as f:
            for result in results:
                f.write(f"GRIDMATRIX:{result.text}\n")
    
    sys.exit(0)

except ImportError:
    sys.exit(2)
except Exception:
    sys.exit(1)
PYGRIDMATRIX_SCRIPT

        (
            trap 'exit 139' SEGV
            trap 'exit 134' ABRT
            ulimit -c 0 2>/dev/null
            timeout 20 "$python_cmd" "$temp_script" "$image" "$output_file" 2>/dev/null
        ) 2>/dev/null
        
        rm -f "$temp_script" 2>/dev/null
        [[ -s "$output_file" ]] && return 0
    fi
    
    # Return 2 to indicate module not available (not an error/crash)
    return 2
}

# Decoder 35: Composite barcode decoder (GS1 Composite - CC-A, CC-B, CC-C)
# 2D component linked to linear barcode - pharmaceutical, retail
decode_with_composite() {
    set +u
    local image="${1:-}"
    local output_file="${2:-}"
    set -u
    local python_cmd=$(get_python_cmd)
    
    if [[ -z "$image" ]] || [[ ! -f "$image" ]] || [[ ! -r "$image" ]]; then
        echo "[decode_with_composite] Image not found or unreadable: '$image'" >&2
        return 1
    fi
    
    if ! validate_decoder_output_path "$output_file" "decode_with_composite"; then
        return 1
    fi
    
    [[ -z "$python_cmd" ]] && return 2
    
    # Try pyzbar with DataBar composite detection
    if "$python_cmd" -c "from pyzbar.pyzbar import decode, ZBarSymbol" 2>/dev/null; then
        (
            exec 2>/dev/null
            timeout 20 "$python_cmd" << PYCOMPOSITE_PYZBAR > "$output_file" 2>/dev/null
import sys
from pyzbar.pyzbar import decode, ZBarSymbol
from PIL import Image

try:
    img = Image.open(image_path)
    
    # GS1 DataBar (formerly RSS) composites
    composite_symbols = [
        ZBarSymbol.DATABAR,
        ZBarSymbol.DATABAR_EXP,
    ]
    
    all_results = set()
    
    for sym in composite_symbols:
        try:
            codes = decode(img, symbols=[sym])
            for c in codes:
                data = c.data.decode('utf-8', errors='replace')
                all_results.add(f"COMPOSITE_{c.type}:{data}")
        except:
            pass
    
    # Also try general decode for any composite
    codes = decode(img)
    for c in codes:
        if 'COMPOSITE' in str(c.type).upper() or 'DATABAR' in str(c.type).upper():
            data = c.data.decode('utf-8', errors='replace')
            all_results.add(f"COMPOSITE_{c.type}:{data}")
    
    for r in all_results:
        print(r)
except:
    pass
PYCOMPOSITE_PYZBAR
        ) 2>/dev/null
        [[ -s "$output_file" ]] && return 0
    fi
    
    # Return 2 to indicate module not available (not an error/crash)
    return 2
}

# Decoder 36: Interleaved 2 of 5 (ITF) decoder (ISO/IEC 16390)
# Distribution, warehouse, ticketing
decode_with_itf() {
    set +u
    local image="${1:-}"
    local output_file="${2:-}"
    set -u
    local python_cmd=$(get_python_cmd)
    
    if [[ -z "$image" ]] || [[ ! -f "$image" ]] || [[ ! -r "$image" ]]; then
        echo "[decode_with_itf] Image not found or unreadable: '$image'" >&2
        return 1
    fi
    
    if ! validate_decoder_output_path "$output_file" "decode_with_itf"; then
        return 1
    fi
    
    [[ -z "$python_cmd" ]] && return 2
    
    # Try pyzbar
    if "$python_cmd" -c "from pyzbar.pyzbar import decode, ZBarSymbol" 2>/dev/null; then
        (
            exec 2>/dev/null
            timeout 20 "$python_cmd" << PYITF_PYZBAR > "$output_file" 2>/dev/null
import sys
from pyzbar.pyzbar import decode, ZBarSymbol
from PIL import Image

try:
    img = Image.open(image_path)
    codes = decode(img, symbols=[ZBarSymbol.I25])  # I25 = Interleaved 2 of 5
    for c in codes:
        data = c.data.decode('utf-8', errors='replace')
        print(f"ITF:{data}")
except:
    pass
PYITF_PYZBAR
        ) 2>/dev/null
        [[ -s "$output_file" ]] && return 0
    fi
    
    # Try zxing-cpp
    if "$python_cmd" -c "import zxingcpp" 2>/dev/null; then
        local temp_script="${TEMP_DIR}/itf_decode_$$.py"
        cat > "$temp_script" <<'PYITF_SCRIPT'
import sys
import signal

def crash_handler(sig, frame):
    sys.exit(139)

signal.signal(signal.SIGSEGV, crash_handler)
signal.signal(signal.SIGABRT, crash_handler)

if len(sys.argv) < 3:
    sys.exit(1)

image_path = sys.argv[1]
output_file = sys.argv[2]

try:
    import zxingcpp
    from PIL import Image
    
    img = Image.open(image_path)
    results = zxingcpp.read_barcodes(img, formats=zxingcpp.BarcodeFormat.ITF)
    
    if results:
        with open(output_file, 'w') as f:
            for result in results:
                f.write(f"ITF:{result.text}\n")
    
    sys.exit(0)

except ImportError:
    sys.exit(2)
except Exception:
    sys.exit(1)
PYITF_SCRIPT

        (
            trap 'exit 139' SEGV
            trap 'exit 134' ABRT
            ulimit -c 0 2>/dev/null
            timeout 20 "$python_cmd" "$temp_script" "$image" "$output_file" 2>/dev/null
        ) 2>/dev/null
        
        rm -f "$temp_script" 2>/dev/null
        [[ -s "$output_file" ]] && return 0
    fi
    
    # Return 2 to indicate module not available (not an error/crash)
    return 2
}

# Decoder 37: Code 93 decoder
# Higher density than Code 39, used in logistics
decode_with_code93() {
    set +u
    local image="${1:-}"
    local output_file="${2:-}"
    set -u
    local python_cmd=$(get_python_cmd)
    
    if [[ -z "$image" ]] || [[ ! -f "$image" ]] || [[ ! -r "$image" ]]; then
        echo "[decode_with_code93] Image not found or unreadable: '$image'" >&2
        return 1
    fi
    
    if ! validate_decoder_output_path "$output_file" "decode_with_code93"; then
        return 1
    fi
    
    [[ -z "$python_cmd" ]] && return 2
    
    # Try pyzbar
    if "$python_cmd" -c "from pyzbar.pyzbar import decode, ZBarSymbol" 2>/dev/null; then
        (
            exec 2>/dev/null
            timeout 20 "$python_cmd" << PYCODE93_PYZBAR > "$output_file" 2>/dev/null
import sys
from pyzbar.pyzbar import decode, ZBarSymbol
from PIL import Image

try:
    img = Image.open(image_path)
    codes = decode(img, symbols=[ZBarSymbol.CODE93])
    for c in codes:
        data = c.data.decode('utf-8', errors='replace')
        print(f"CODE93:{data}")
except:
    pass
PYCODE93_PYZBAR
        ) 2>/dev/null
        [[ -s "$output_file" ]] && return 0
    fi
    
    # Try zxing-cpp
    if "$python_cmd" -c "import zxingcpp" 2>/dev/null; then
        local temp_script="${TEMP_DIR}/code93_decode_$$.py"
        cat > "$temp_script" <<'PYCODE93_SCRIPT'
import sys
import signal

def crash_handler(sig, frame):
    sys.exit(139)

signal.signal(signal.SIGSEGV, crash_handler)
signal.signal(signal.SIGABRT, crash_handler)

if len(sys.argv) < 3:
    sys.exit(1)

image_path = sys.argv[1]
output_file = sys.argv[2]

try:
    import zxingcpp
    from PIL import Image
    
    img = Image.open(image_path)
    results = zxingcpp.read_barcodes(img, formats=zxingcpp.BarcodeFormat.Code93)
    
    if results:
        with open(output_file, 'w') as f:
            for result in results:
                f.write(f"CODE93:{result.text}\n")
    
    sys.exit(0)

except ImportError:
    sys.exit(2)
except Exception:
    sys.exit(1)
PYCODE93_SCRIPT

        (
            trap 'exit 139' SEGV
            trap 'exit 134' ABRT
            ulimit -c 0 2>/dev/null
            timeout 20 "$python_cmd" "$temp_script" "$image" "$output_file" 2>/dev/null
        ) 2>/dev/null
        
        rm -f "$temp_script" 2>/dev/null
        [[ -s "$output_file" ]] && return 0
    fi
    
    # Return 2 to indicate module not available (not an error/crash)
    return 2
}

# Decoder 38: Universal decoder with all formats enabled
# Catches any barcode type not handled by specific decoders
decode_with_universal() {
    set +u
    local image="${1:-}"
    local output_file="${2:-}"
    set -u
    local python_cmd=$(get_python_cmd)
    
    if [[ -z "$image" ]] || [[ ! -f "$image" ]] || [[ ! -r "$image" ]]; then
        echo "[decode_with_universal] Image not found or unreadable: '$image'" >&2
        return 1
    fi
    
    if ! validate_decoder_output_path "$output_file" "decode_with_universal"; then
        return 1
    fi
    
    [[ -z "$python_cmd" ]] && return 2
    
    # Universal decoder using zxing-cpp with ALL formats enabled
    if "$python_cmd" -c "import zxingcpp" 2>/dev/null; then
        local temp_script="${TEMP_DIR}/universal_decode_$$.py"
        cat > "$temp_script" <<'PYUNIVERSAL_SCRIPT'
import sys
import signal

def crash_handler(sig, frame):
    sys.exit(139)

signal.signal(signal.SIGSEGV, crash_handler)
signal.signal(signal.SIGABRT, crash_handler)

if len(sys.argv) < 3:
    sys.exit(1)

image_path = sys.argv[1]
output_file = sys.argv[2]

try:
    import zxingcpp
    from PIL import Image
    import cv2
    import numpy as np
    
    def process_image(img_input):
        """Try various preprocessing and return all found barcodes"""
        results = set()
        
        # Try direct decode first
        try:
            found = zxingcpp.read_barcodes(img_input)
            for r in found:
                results.add(f"{r.format.name}:{r.text}")
        except:
            pass
        
        return results
    
    img = Image.open(image_path)
    all_results = set()
    
    # Original image
    all_results.update(process_image(img))
    
    # Grayscale
    img_gray = img.convert('L')
    all_results.update(process_image(img_gray))
    
    # Try OpenCV preprocessing
    try:
        cv_img = cv2.imread(image_path)
        if cv_img is not None:
            # Multiple preprocessing strategies
            gray = cv2.cvtColor(cv_img, cv2.COLOR_BGR2GRAY)
            
            # CLAHE enhancement
            clahe = cv2.createCLAHE(clipLimit=2.0, tileGridSize=(8,8))
            enhanced = clahe.apply(gray)
            pil_enhanced = Image.fromarray(enhanced)
            all_results.update(process_image(pil_enhanced))
            
            # Otsu thresholding
            _, thresh = cv2.threshold(gray, 0, 255, cv2.THRESH_BINARY + cv2.THRESH_OTSU)
            pil_thresh = Image.fromarray(thresh)
            all_results.update(process_image(pil_thresh))
            
            # Inverted
            inverted = cv2.bitwise_not(thresh)
            pil_inv = Image.fromarray(inverted)
            all_results.update(process_image(pil_inv))
    except:
        pass
    
    if all_results:
        with open(output_file, 'w') as f:
            for r in all_results:
                f.write(r + '\n')
    
    sys.exit(0)

except ImportError:
    sys.exit(2)
except Exception:
    sys.exit(1)
PYUNIVERSAL_SCRIPT

        (
            trap 'exit 139' SEGV
            trap 'exit 134' ABRT
            ulimit -c 0 2>/dev/null
            timeout 30 "$python_cmd" "$temp_script" "$image" "$output_file" 2>/dev/null
        ) 2>/dev/null
        
        rm -f "$temp_script" 2>/dev/null
        [[ -s "$output_file" ]] && return 0
    fi
    
    # Return 2 to indicate module not available (not an error/crash)
    return 2
}

# Decoder 39: QR Code Model 1 (legacy QR format)
decode_with_qr_model1() {
    local image="$1"
    local output_file="$2"
    local python_cmd=$(get_python_cmd)
    
    if [[ -z "$image" ]] || [[ ! -f "$image" ]] || [[ ! -r "$image" ]]; then
        return 1
    fi
    
    if ! validate_decoder_output_path "$output_file" "decode_with_qr_model1"; then
        return 1
    fi
    
    [[ -z "$python_cmd" ]] && return 2
    
    if ! safe_check_python_module "zxingcpp"; then
        return 2
    fi
    
    # Note: PIL is also required but checked inline via try/except for graceful fallback
    (
        trap 'exit 139' SEGV ABRT BUS
        ulimit -c 0 2>/dev/null
        timeout 20 "$python_cmd" <<PYMODEL1 > "$output_file" 2>/dev/null
import sys
import signal
signal.signal(signal.SIGSEGV, lambda s,f: sys.exit(139))
signal.signal(signal.SIGABRT, lambda s,f: sys.exit(134))

try:
    import zxingcpp
    from PIL import Image
    
    img = Image.open(image_path)
    results = zxingcpp.read_barcodes(
        img,
        formats=zxingcpp.BarcodeFormat.QRCode,
        try_harder=True,
        try_rotate=True
    )
    
    for r in results:
        print(f"QR_MODEL1:{r.text}")
except:
    pass
PYMODEL1
    ) 2>/dev/null
    
    [[ -s "$output_file" ]]
}

# Decoder 40: JAB Code (colored 2D barcode)
decode_with_jabcode() {
    local image="$1"
    local output_file="$2"
    
    if [[ -z "$image" ]] || [[ ! -f "$image" ]] || [[ ! -r "$image" ]]; then
        return 1
    fi
    
    if ! validate_decoder_output_path "$output_file" "decode_with_jabcode"; then
        return 1
    fi
    
    if command -v jabcodeReader &>/dev/null; then
        (
            exec 2>/dev/null
            timeout 20 jabcodeReader "$image" > "$output_file" 2>/dev/null
        )
        [[ -s "$output_file" ]] && return 0
    fi
    
    return 2
}

# Decoder 41: HCCB (High Capacity Color Barcode - Microsoft Tag)
decode_with_hccb() {
    local image="$1"
    local output_file="$2"
    local python_cmd=$(get_python_cmd)
    
    if [[ -z "$image" ]] || [[ ! -f "$image" ]] || [[ ! -r "$image" ]]; then
        return 1
    fi
    
    if ! validate_decoder_output_path "$output_file" "decode_with_hccb"; then
        return 1
    fi
    
    [[ -z "$python_cmd" ]] && return 2
    
    if ! safe_check_python_module "PIL"; then
        return 2
    fi
    
    # Note: numpy is also required but checked inline via try/except for graceful fallback
    (
        trap 'exit 139' SEGV ABRT BUS
        ulimit -c 0 2>/dev/null
        timeout 20 "$python_cmd" <<PYHCCB > "$output_file" 2>/dev/null
import sys
import signal
signal.signal(signal.SIGSEGV, lambda s,f: sys.exit(139))
signal.signal(signal.SIGABRT, lambda s,f: sys.exit(134))

try:
    from PIL import Image
    import numpy as np
    
    img = Image.open(image_path).convert('RGB')
    arr = np.array(img)
    
    colors = arr.reshape(-1, 3)
    unique_colors = np.unique(colors, axis=0)
    
    # HCCB uses 4 or 8 colors for encoding
    if len(unique_colors) in [4, 8]:
        # Calculate color distribution
        height, width = arr.shape[:2]
        color_counts = {}
        for color in unique_colors:
            mask = np.all(arr == color, axis=-1)
            count = np.sum(mask)
            color_hex = '#{:02x}{:02x}{:02x}'.format(color[0], color[1], color[2])
            color_counts[color_hex] = count
        
        # Build info string
        color_info = '_'.join([f"{c}:{cnt}" for c, cnt in sorted(color_counts.items(), key=lambda x: -x[1])[:4]])
        dims = f"{width}x{height}"
        print(f"HCCB:DETECTED_MICROSOFT_TAG_{len(unique_colors)}_COLORS_{dims}_{color_info}")
except:
    pass
PYHCCB
    ) 2>/dev/null
    
    [[ -s "$output_file" ]]
}

# Decoder 42: Micro QR Code (smaller QR variant)
decode_with_micro_qr() {
    local image="$1"
    local output_file="$2"
    local python_cmd=$(get_python_cmd)
    
    if [[ -z "$image" ]] || [[ ! -f "$image" ]] || [[ ! -r "$image" ]]; then
        return 1
    fi
    
    if ! validate_decoder_output_path "$output_file" "decode_with_micro_qr"; then
        return 1
    fi
    
    [[ -z "$python_cmd" ]] && return 2
    
    if ! safe_check_python_module "zxingcpp"; then
        return 2
    fi
    
    # Note: PIL is also required but checked inline via try/except for graceful fallback
    (
        trap 'exit 139' SEGV ABRT BUS
        ulimit -c 0 2>/dev/null
        timeout 20 "$python_cmd" <<PYMICROQR > "$output_file" 2>/dev/null
import sys
import signal
signal.signal(signal.SIGSEGV, lambda s,f: sys.exit(139))
signal.signal(signal.SIGABRT, lambda s,f: sys.exit(134))

try:
    import zxingcpp
    from PIL import Image
    
    img = Image.open(image_path)
    
    try:
        results = zxingcpp.read_barcodes(
            img,
            formats=zxingcpp.BarcodeFormat.MicroQRCode
        )
    except AttributeError:
        results = zxingcpp.read_barcodes(img)
        results = [r for r in results if 'MICRO' in r.format.name.upper()]
    
    for r in results:
        print(f"MICRO_QR:{r.text}")
except:
    pass
PYMICROQR
    ) 2>/dev/null
    
    [[ -s "$output_file" ]]
}

# Decoder 43: HTML-Generated QR Code Detection (Fraud Detection)
# Detects QR codes generated via HTML5 Canvas, SVG, or JavaScript libraries
# Common in phishing and fraudulent QR campaigns
decode_with_html_qr_detector() {
    local image="$1"
    local output_file="$2"
    local python_cmd=$(get_python_cmd)
    
    if [[ -z "$image" ]] || [[ ! -f "$image" ]] || [[ ! -r "$image" ]]; then
        return 1
    fi
    
    if ! validate_decoder_output_path "$output_file" "decode_with_html_qr_detector"; then
        return 1
    fi
    
    [[ -z "$python_cmd" ]] && return 2
    
    # Check for PIL and pyzbar - required for this decoder
    if ! safe_check_python_module "PIL"; then
        return 2
    fi
    
    # Note: pyzbar is also required but checked inline via try/except for graceful fallback
    (
        trap 'exit 139' SEGV ABRT BUS
        ulimit -c 0 2>/dev/null
        timeout 25 "$python_cmd" <<PYHTMLQR > "$output_file" 2>/dev/null
import sys
import signal
signal.signal(signal.SIGSEGV, lambda s,f: sys.exit(139))
signal.signal(signal.SIGABRT, lambda s,f: sys.exit(134))

try:
    from PIL import Image
    import numpy as np
    from pyzbar.pyzbar import decode
    
    img = Image.open(image_path)
    
    # Decode the QR code first
    qr_data = None
    try:
        decoded_objs = decode(img)
        if decoded_objs:
            qr_data = decoded_objs[0].data.decode('utf-8', errors='ignore')
    except:
        pass
    
    # Analyze image characteristics for HTML generation patterns
    img_array = np.array(img)
    findings = []
    
    # 1. Check for perfect pixel-aligned edges (HTML canvas signature)
    if img.mode in ['RGB', 'RGBA']:
        # Check for sharp, unaliased edges typical of canvas rendering
        if len(img_array.shape) >= 2:
            # Look for binary color patterns (pure black/white)
            unique_colors = len(np.unique(img_array.reshape(-1, img_array.shape[-1]), axis=0))
            if unique_colors <= 3:
                findings.append("BINARY_COLORS:canvas_render_signature")
    
    # 2. Check for SVG-to-raster conversion artifacts
    if img.width == img.height and img.width % 8 == 0:
        findings.append("PERFECT_SQUARE:svg_derived")
    
    # 3. Check for lack of JPEG artifacts (HTML canvas exports as PNG typically)
    if hasattr(img, 'format') and img.format == 'PNG':
        # Check for unnaturally clean edges
        if img.mode == 'RGB' or img.mode == 'RGBA':
            findings.append("PNG_NO_ARTIFACTS:html_export")
    
    # 4. Check for specific dimension patterns common in JS QR libraries
    common_js_sizes = [256, 512, 1024, 200, 300, 400, 500]
    if img.width in common_js_sizes or img.height in common_js_sizes:
        findings.append(f"JS_LIBRARY_SIZE:{img.width}x{img.height}")
    
    # 5. Check for QRCode.js, qrcode-generator, or similar library patterns
    # These often produce very specific module sizes
    if img.width >= 200 and img.width <= 600:
        # Calculate estimated module size
        estimated_modules = img.width // 29  # Assuming QR version 3
        if img.width % 29 < 3:  # Very precise module alignment
            findings.append("PRECISE_MODULE_ALIGNMENT:js_library")
    
    # Output results
    if qr_data:
        print(f"HTML_QR:{qr_data}")
    
    if findings:
        print(f"HTML_GENERATION_INDICATORS:{','.join(findings)}")
    
    # Additional forensic markers
    if img.mode == 'P':  # Palette mode often used by web generators
        print("FORENSIC:palette_mode_web_generator")
    
    # Check for missing EXIF data (common in programmatically generated images)
    if not hasattr(img, '_getexif') or img._getexif() is None:
        print("FORENSIC:no_exif_programmatic_generation")

except ImportError:
    sys.exit(2)
except Exception as e:
    sys.exit(1)
PYHTMLQR
    ) 2>/dev/null
    
    [[ -s "$output_file" ]]
}

# Decoder 44: UPC (Universal Product Code) - UPC-A and UPC-E
decode_with_upc() {
    local image="$1"
    local output_file="$2"
    local python_cmd=$(get_python_cmd)
    
    if [[ -z "$image" ]] || [[ ! -f "$image" ]] || [[ ! -r "$image" ]]; then
        return 1
    fi
    
    if ! validate_decoder_output_path "$output_file" "decode_with_upc"; then
        return 1
    fi
    
    [[ -z "$python_cmd" ]] && return 2
    
    if ! safe_check_python_module "pyzbar"; then
        return 2
    fi
    
    (
        trap 'exit 139' SEGV ABRT BUS
        ulimit -c 0 2>/dev/null
        timeout 20 "$python_cmd" <<PYUPC > "$output_file" 2>/dev/null
import sys
import signal
signal.signal(signal.SIGSEGV, lambda s,f: sys.exit(139))
signal.signal(signal.SIGABRT, lambda s,f: sys.exit(134))

try:
    from pyzbar.pyzbar import decode, ZBarSymbol
    from PIL import Image
    
    img = Image.open(image_path)
    
    # Decode UPC-A and UPC-E
    results = decode(img, symbols=[ZBarSymbol.UPCA, ZBarSymbol.UPCE])
    
    if results:
        for result in results:
            barcode_type = result.type
            data = result.data.decode('utf-8', errors='ignore')
            print(f"{barcode_type}:{data}")
except ImportError:
    sys.exit(2)
except Exception:
    sys.exit(1)
PYUPC
    ) 2>/dev/null
    
    [[ -s "$output_file" ]]
}

# Decoder 45: MSI/Plessey - Inventory control barcode
decode_with_msi() {
    local image="$1"
    local output_file="$2"
    local python_cmd=$(get_python_cmd)
    
    if [[ -z "$image" ]] || [[ ! -f "$image" ]] || [[ ! -r "$image" ]]; then
        return 1
    fi
    
    if ! validate_decoder_output_path "$output_file" "decode_with_msi"; then
        return 1
    fi
    
    [[ -z "$python_cmd" ]] && return 2
    
    if ! safe_check_python_module "zxingcpp"; then
        return 2
    fi
    
    (
        trap 'exit 139' SEGV ABRT BUS
        ulimit -c 0 2>/dev/null
        timeout 20 "$python_cmd" <<PYMSI > "$output_file" 2>/dev/null
import sys
import signal
signal.signal(signal.SIGSEGV, lambda s,f: sys.exit(139))
signal.signal(signal.SIGABRT, lambda s,f: sys.exit(134))

try:
    import zxingcpp
    from PIL import Image
    
    img = Image.open(image_path)
    
    # Try to decode with MSI format if available
    try:
        results = zxingcpp.read_barcodes(img, formats=zxingcpp.BarcodeFormat.MSI)
    except AttributeError:
        # MSI might not be available, try generic decode
        results = zxingcpp.read_barcodes(img)
        results = [r for r in results if 'MSI' in str(r.format)]
    
    for r in results:
        print(f"MSI:{r.text}")
except ImportError:
    sys.exit(2)
except Exception:
    sys.exit(1)
PYMSI
    ) 2>/dev/null
    
    [[ -s "$output_file" ]]
}

# Decoder 46: Telepen - Pharmacy/Library barcode
decode_with_telepen() {
    local image="$1"
    local output_file="$2"
    local python_cmd=$(get_python_cmd)
    
    if [[ -z "$image" ]] || [[ ! -f "$image" ]] || [[ ! -r "$image" ]]; then
        return 1
    fi
    
    if ! validate_decoder_output_path "$output_file" "decode_with_telepen"; then
        return 1
    fi
    
    [[ -z "$python_cmd" ]] && return 2
    
    if ! safe_check_python_module "zxingcpp"; then
        return 2
    fi
    
    (
        trap 'exit 139' SEGV ABRT BUS
        ulimit -c 0 2>/dev/null
        timeout 20 "$python_cmd" <<PYTELEPEN > "$output_file" 2>/dev/null
import sys
import signal
signal.signal(signal.SIGSEGV, lambda s,f: sys.exit(139))
signal.signal(signal.SIGABRT, lambda s,f: sys.exit(134))

try:
    import zxingcpp
    from PIL import Image
    
    img = Image.open(image_path)
    
    # Try Telepen format
    try:
        results = zxingcpp.read_barcodes(img, formats=zxingcpp.BarcodeFormat.Telepen)
    except AttributeError:
        # Telepen might not be available
        results = zxingcpp.read_barcodes(img)
        results = [r for r in results if 'TELEPEN' in str(r.format).upper()]
    
    for r in results:
        print(f"TELEPEN:{r.text}")
except ImportError:
    sys.exit(2)
except Exception:
    sys.exit(1)
PYTELEPEN
    ) 2>/dev/null
    
    [[ -s "$output_file" ]]
}

# Decoder 47: GS1 DataBar (RSS) - Retail and coupons
decode_with_gs1_databar() {
    local image="$1"
    local output_file="$2"
    local python_cmd=$(get_python_cmd)
    
    if [[ -z "$image" ]] || [[ ! -f "$image" ]] || [[ ! -r "$image" ]]; then
        return 1
    fi
    
    if ! validate_decoder_output_path "$output_file" "decode_with_gs1_databar"; then
        return 1
    fi
    
    [[ -z "$python_cmd" ]] && return 2
    
    if ! safe_check_python_module "zxingcpp"; then
        return 2
    fi
    
    (
        trap 'exit 139' SEGV ABRT BUS
        ulimit -c 0 2>/dev/null
        timeout 20 "$python_cmd" <<PYGS1 > "$output_file" 2>/dev/null
import sys
import signal
signal.signal(signal.SIGSEGV, lambda s,f: sys.exit(139))
signal.signal(signal.SIGABRT, lambda s,f: sys.exit(134))

try:
    import zxingcpp
    from PIL import Image
    
    img = Image.open(image_path)
    
    # Try GS1 DataBar formats (Expanded, Limited, etc.)
    results = []
    try:
        for fmt in [zxingcpp.BarcodeFormat.DataBarExpanded,
                    zxingcpp.BarcodeFormat.DataBarLimited]:
            r = zxingcpp.read_barcodes(img, formats=fmt)
            results.extend(r)
    except AttributeError:
        # Try generic decode and filter
        results = zxingcpp.read_barcodes(img)
        results = [r for r in results if 'DATABAR' in str(r.format).upper() or 'RSS' in str(r.format).upper()]
    
    for r in results:
        print(f"GS1_DATABAR:{r.text}")
except ImportError:
    sys.exit(2)
except Exception:
    sys.exit(1)
PYGS1
    ) 2>/dev/null
    
    [[ -s "$output_file" ]]
}

# Decoder 48: Pharmacode - Pharmaceutical packaging
decode_with_pharmacode() {
    local image="$1"
    local output_file="$2"
    local python_cmd=$(get_python_cmd)
    
    if [[ -z "$image" ]] || [[ ! -f "$image" ]] || [[ ! -r "$image" ]]; then
        return 1
    fi
    
    if ! validate_decoder_output_path "$output_file" "decode_with_pharmacode"; then
        return 1
    fi
    
    [[ -z "$python_cmd" ]] && return 2
    
    if ! safe_check_python_module "PIL"; then
        return 2
    fi
    
    (
        trap 'exit 139' SEGV ABRT BUS
        ulimit -c 0 2>/dev/null
        timeout 20 "$python_cmd" <<PYPHARMA > "$output_file" 2>/dev/null
import sys
import signal
signal.signal(signal.SIGSEGV, lambda s,f: sys.exit(139))
signal.signal(signal.SIGABRT, lambda s,f: sys.exit(134))

try:
    from PIL import Image
    import numpy as np
    
    img = Image.open(image_path).convert('L')
    arr = np.array(img)
    
    # Pharmacode is a series of thick and thin bars
    # Each bar represents a power of 2, and the sum gives the value
    # Pharmacode range: 3 to 131070 (2^0 + 2^1 + ... up to 2^16)
    
    # Check for vertical bar patterns
    height, width = arr.shape
    mid_row = arr[height // 2, :]
    
    # Detect bars (transitions between light and dark)
    threshold = np.mean(mid_row)
    binary = (mid_row < threshold).astype(int)
    transitions = np.diff(binary)
    bar_positions = np.where(transitions != 0)[0]
    
    # Pharmacode has 2-13 bars, transitions are double (rising + falling edge)
    num_bars = len(bar_positions) // 2
    
    if 2 <= num_bars <= 13:
        # Decode: bars represent binary digits
        # Thin bar = 0, Thick bar = 1 (or vice versa based on width)
        # Calculate widths between transitions
        bar_widths = []
        for i in range(0, len(bar_positions) - 1, 2):
            if i + 1 < len(bar_positions):
                width = bar_positions[i + 1] - bar_positions[i]
                bar_widths.append(width)
        
        if len(bar_widths) >= 2:
            # Determine thin vs thick threshold
            median_width = np.median(bar_widths)
            
            # Decode value: each bar position represents 2^n
            value = 0
            for i, width in enumerate(bar_widths):
                if width > median_width:  # Thick bar
                    value += 2 ** i
            
            # Pharmacode valid range is 3-131070
            if 3 <= value <= 131070:
                print(f"PHARMACODE:{value}")
            else:
                # Just report detection if value seems invalid
                print(f"PHARMACODE:DETECTED_{num_bars}_BARS_VALUE_{value}")
        else:
            print(f"PHARMACODE:DETECTED_{num_bars}_BARS")
except ImportError:
    sys.exit(2)
except Exception:
    sys.exit(1)
PYPHARMA
    ) 2>/dev/null
    
    [[ -s "$output_file" ]]
}

# Decoder 49: Code 11 - Telecommunications barcode
decode_with_code11() {
    local image="$1"
    local output_file="$2"
    local python_cmd=$(get_python_cmd)
    
    if [[ -z "$image" ]] || [[ ! -f "$image" ]] || [[ ! -r "$image" ]]; then
        return 1
    fi
    
    if ! validate_decoder_output_path "$output_file" "decode_with_code11"; then
        return 1
    fi
    
    [[ -z "$python_cmd" ]] && return 2
    
    if ! safe_check_python_module "zxingcpp"; then
        return 2
    fi
    
    (
        trap 'exit 139' SEGV ABRT BUS
        ulimit -c 0 2>/dev/null
        timeout 20 "$python_cmd" <<PYCODE11 > "$output_file" 2>/dev/null
import sys
import signal
signal.signal(signal.SIGSEGV, lambda s,f: sys.exit(139))
signal.signal(signal.SIGABRT, lambda s,f: sys.exit(134))

try:
    import zxingcpp
    from PIL import Image
    
    img = Image.open(image_path)
    
    # Try Code 11 format
    try:
        results = zxingcpp.read_barcodes(img, formats=zxingcpp.BarcodeFormat.Code11)
    except AttributeError:
        # Code11 might not be in this version
        results = zxingcpp.read_barcodes(img)
        results = [r for r in results if 'CODE11' in str(r.format).upper() or 'CODE_11' in str(r.format).upper()]
    
    for r in results:
        print(f"CODE11:{r.text}")
except ImportError:
    sys.exit(2)
except Exception:
    sys.exit(1)
PYCODE11
    ) 2>/dev/null
    
    [[ -s "$output_file" ]]
}

# Decoder 50: DPD (Deutsche Post) Barcode
decode_with_dpd() {
    local image="$1"
    local output_file="$2"
    local python_cmd=$(get_python_cmd)
    
    if [[ -z "$image" ]] || [[ ! -f "$image" ]] || [[ ! -r "$image" ]]; then
        return 1
    fi
    
    if ! validate_decoder_output_path "$output_file" "decode_with_dpd"; then
        return 1
    fi
    
    [[ -z "$python_cmd" ]] && return 2
    
    if ! safe_check_python_module "pyzbar"; then
        return 2
    fi
    
    (
        trap 'exit 139' SEGV ABRT BUS
        ulimit -c 0 2>/dev/null
        timeout 20 "$python_cmd" <<PYDPD > "$output_file" 2>/dev/null
import sys
import signal
signal.signal(signal.SIGSEGV, lambda s,f: sys.exit(139))
signal.signal(signal.SIGABRT, lambda s,f: sys.exit(134))

try:
    from pyzbar.pyzbar import decode
    from PIL import Image
    
    img = Image.open(image_path)
    results = decode(img)
    
    # DPD uses Code 128 with specific format
    for result in results:
        data = result.data.decode('utf-8', errors='ignore')
        # DPD barcodes typically start with specific patterns
        if data.startswith('%') or len(data) == 32:
            print(f"DPD:{data}")
except ImportError:
    sys.exit(2)
except Exception:
    sys.exit(1)
PYDPD
    ) 2>/dev/null
    
    [[ -s "$output_file" ]]
}

multi_decoder_analysis() {
    local image="$1"
    local base_output="$2"
    
    log_info "Multi-decoder analysis on $image..."
    
    local allowed_temp_dir="${TEMP_DIR}/"
    mkdir -p "$allowed_temp_dir" 2>/dev/null
    local safe_base_name
    safe_base_name="$(basename "$base_output" | tr -c 'a-zA-Z0-9._-' '_')"
    local safe_output_prefix="$allowed_temp_dir/${safe_base_name}"

    # HARDEN: image sanity check
    if [ -z "$image" ] || [ ! -f "$image" ] || [ ! -r "$image" ]; then
        log_error "[multi_decoder_analysis] Image not found or unreadable: '$image'"
        return 10
    fi
    if [ -z "$base_output" ]; then
        log_error "[multi_decoder_analysis] Base output filename required"
        return 11
    fi

    local success_count=0
    local all_decoded=""
    local decoder_results=()
    local python_cmd=$(get_python_cmd)

    # Check if parallel mode is enabled via environment variable
    if [[ "${QR_PARALLEL_DECODERS:-0}" == "1" ]]; then
        log_info "Parallel decoder mode enabled (QR_PARALLEL_DECODERS=1)"
        multi_decoder_analysis_parallel "$image" "$base_output" "${QR_MAX_PARALLEL:-4}" "${QR_EARLY_EXIT:-3}"
        return $?
    fi

    # Clean previous outputs
    rm -f "${TEMP_DIR}"_*.txt 2>/dev/null

    # Helper function for crash-safe execution
    _safe_run() {
        local timeout_secs="$1"
        shift
        (
            trap 'exit 139' SEGV
            trap 'exit 134' ABRT
            trap 'exit 135' BUS
            trap 'exit 136' FPE
            ulimit -c 0 2>/dev/null
            exec 2>/dev/null
            timeout "$timeout_secs" "$@" 2>/dev/null
        ) 2>/dev/null
    }

    # Helper function for crash-safe Python execution
    _safe_python() {
        local timeout_secs="$1"
        local out_file="$2"
        local script="$3"
        
        [[ -z "$python_cmd" ]] && return 2
        
        (
            trap 'exit 139' SEGV
            trap 'exit 134' ABRT
            trap 'exit 135' BUS
            ulimit -c 0 2>/dev/null
            exec 2>/dev/null
            timeout "$timeout_secs" "$python_cmd" -c "$script" 2>/dev/null
        ) 2>/dev/null
    }

    # --- DECODER 1: ZBAR (native command) ---
    local out_zbar="${TEMP_DIR}_zbar.txt"
    if command -v zbarimg &>/dev/null; then
        log_info "  [1/50] Trying zbar decoder..."
        _safe_run 30 zbarimg -q --raw "$image" > "$out_zbar"
        if [ -s "$out_zbar" ]; then
            log_success "  ✓ zbar: decoded successfully"
            ((success_count++))
            all_decoded+=$(cat "$out_zbar" 2>/dev/null)$'\n'
            decoder_results+=("zbar:$(head -1 "$out_zbar" 2>/dev/null)")
        else
            log_info "  ✗ zbar: no QR code found"
        fi
    else
        log_info "  ✗ zbar: not installed (zbarimg)"
    fi

    # --- DECODER 2: PYZBAR (Python - crash-isolated) ---
    local out_pyzbar="${TEMP_DIR}_pyzbar.txt"
    if [ -n "$python_cmd" ]; then
        log_info "  [2/50] Trying pyzbar decoder..."
        # AUDIT FIX: Use base64-encoded paths to prevent segfault with special chars
        local encoded_image
        local encoded_out_pyzbar
        encoded_image=$(printf '%s' "$image" | base64 2>/dev/null) || true
        encoded_out_pyzbar=$(printf '%s' "$out_pyzbar" | base64 2>/dev/null) || true
        # Run Python in subshell with all crash output suppressed
        (
            exec 2>/dev/null
            timeout 30 "$python_cmd" - "$encoded_image" "$encoded_out_pyzbar" 2>/dev/null <<'EOF'
import sys, signal, base64
signal.signal(signal.SIGSEGV, lambda s,f: sys.exit(139))
signal.signal(signal.SIGABRT, lambda s,f: sys.exit(134))
try:
    image_path = base64.b64decode(sys.argv[1] if len(sys.argv) > 1 else '').decode('utf-8')
    out_path = base64.b64decode(sys.argv[2] if len(sys.argv) > 2 else '').decode('utf-8')
    from pyzbar.pyzbar import decode
    from PIL import Image
    img = Image.open(image_path)
    codes = decode(img)
    if codes:
        with open(out_path, 'w') as f:
            for c in codes:
                try:
                    f.write(c.data.decode('utf-8') + '\n')
                except:
                    f.write(c.data.decode('latin-1') + '\n')
except:
    pass
EOF
        )
        if [ -s "$out_pyzbar" ]; then
            log_success "  ✓ pyzbar: decoded successfully"
            ((success_count++))
            all_decoded+=$(cat "$out_pyzbar" 2>/dev/null)$'\n'
            decoder_results+=("pyzbar:$(head -1 "$out_pyzbar" 2>/dev/null)")
        else
            log_info "  ✗ pyzbar: no QR code found or module missing"
        fi
    else
        log_info "  ✗ pyzbar: Python not available"
    fi
    
    # --- DECODER 3: OPENCV QR DETECTOR ---
    local out_opencv="${TEMP_DIR}_opencv.txt"
    if [ -n "$python_cmd" ]; then
        log_info "  [3/50] Trying opencv decoder..."
        # AUDIT FIX: Use base64-encoded paths
        local encoded_image
        local encoded_out_opencv
        encoded_image=$(printf '%s' "$image" | base64 2>/dev/null) || true
        encoded_out_opencv=$(printf '%s' "$out_opencv" | base64 2>/dev/null) || true
        (
            exec 2>/dev/null
            timeout 30 "$python_cmd" - "$encoded_image" "$encoded_out_opencv" 2>/dev/null <<'EOF'
import sys, signal, base64
signal.signal(signal.SIGSEGV, lambda s,f: sys.exit(139))
signal.signal(signal.SIGABRT, lambda s,f: sys.exit(134))
try:
    image_path = base64.b64decode(sys.argv[1] if len(sys.argv) > 1 else '').decode('utf-8')
    out_path = base64.b64decode(sys.argv[2] if len(sys.argv) > 2 else '').decode('utf-8')
    import cv2
    img = cv2.imread(image_path)
    if img is not None:
        detector = cv2.QRCodeDetector()
        data, _, _ = detector.detectAndDecode(img)
        if data:
            with open(out_path, 'w') as f:
                f.write(data + '\\n')
except:
    pass
EOF
        )
        if [ -s "$out_opencv" ]; then
            log_success "  ✓ opencv: decoded successfully"
            ((success_count++))
            all_decoded+=$(cat "$out_opencv" 2>/dev/null)$'\n'
            decoder_results+=("opencv:$(head -1 "$out_opencv" 2>/dev/null)")
        else
            log_info "  ✗ opencv: no QR code found or cv2 missing"
        fi
    else
        log_info "  ✗ opencv: Python not available"
    fi

    # --- DECODER 4: QUIRC (native command) ---
    local out_quirc="${TEMP_DIR}_quirc.txt"
    log_info "  [4/50] Trying quirc decoder..."
    if command -v quirc &>/dev/null; then
        _safe_run 30 quirc "$image" > "$out_quirc"
        if [ -s "$out_quirc" ]; then
            log_success "  ✓ quirc: decoded successfully"
            ((success_count++))
            all_decoded+=$(cat "$out_quirc" 2>/dev/null)$'\n'
            decoder_results+=("quirc:$(head -1 "$out_quirc" 2>/dev/null)")
        else
            log_info "  ✗ quirc: no QR code found"
        fi
    else
        log_info "  ✗ quirc: not installed"
    fi

    # --- DECODER 5: DMTX (DataMatrix - native command) ---
    local out_dmtx="${TEMP_DIR}_dmtx.txt"
    log_info "  [5/50] Trying dmtx decoder..."
    if command -v dmtxread &>/dev/null; then
        _safe_run 30 dmtxread -n -N1 "$image" > "$out_dmtx"
        if [ -s "$out_dmtx" ]; then
            log_success "  ✓ dmtx: decoded successfully"
            ((success_count++))
            all_decoded+=$(cat "$out_dmtx" 2>/dev/null)$'\n'
            decoder_results+=("dmtx:$(head -1 "$out_dmtx" 2>/dev/null)")
        else
            log_info "  ✗ dmtx: no DataMatrix code found"
        fi
    else
        log_info "  ✗ dmtx: dmtxread not installed"
    fi

      # --- DECODER 6: PYZBAR ENHANCED (multiple processing) ---
    local out_pyzbar_enh="${TEMP_DIR}_pyzbar_enhanced.txt"
    if [ -n "$python_cmd" ]; then
        log_info "  [6/50] Trying pyzbar_enhanced decoder..."
        # AUDIT FIX: Base64-encode paths
        local encoded_image
        local encoded_out_pyzbar_enh
        encoded_image=$(printf '%s' "$image" | base64 2>/dev/null) || true
        encoded_out_pyzbar_enh=$(printf '%s' "$out_pyzbar_enh" | base64 2>/dev/null) || true
        (
            exec 2>/dev/null
            timeout 45 "$python_cmd" - "$encoded_image" "$encoded_out_pyzbar_enh" 2>/dev/null <<'EOF'
import sys, signal, base64
signal.signal(signal.SIGSEGV, lambda s,f: sys.exit(139))
signal.signal(signal.SIGABRT, lambda s,f: sys.exit(134))
try:
    image_path = base64.b64decode(sys.argv[1] if len(sys.argv) > 1 else '').decode('utf-8')
    out_path = base64.b64decode(sys.argv[2] if len(sys.argv) > 2 else '').decode('utf-8')
    from pyzbar.pyzbar import decode, ZBarSymbol
    from PIL import Image, ImageEnhance, ImageFilter
    img = Image.open(image_path)
    all_data = set()
    
    # Try original
    for c in decode(img, symbols=[ZBarSymbol.QRCODE]):
        try: all_data.add(c.data.decode('utf-8'))
        except: all_data.add(c.data.decode('latin-1'))
    
    # Try with enhancements if no data
    if not all_data:
        for enhanced in [img.convert('L'), ImageEnhance.Contrast(img).enhance(2)]:
            for c in decode(enhanced, symbols=[ZBarSymbol.QRCODE]):
                try: all_data.add(c.data.decode('utf-8'))
                except: all_data.add(c.data.decode('latin-1'))
            if all_data: break
    
    if all_data:
        with open(out_path, 'w') as f:
            for d in all_data:
                f.write(d + '\n')
except:
    pass
EOF
        )
        if [ -s "$out_pyzbar_enh" ]; then
            log_success "  ✓ pyzbar_enhanced: decoded successfully"
            ((success_count++))
            all_decoded+=$(cat "$out_pyzbar_enh" 2>/dev/null)$'\n'
            decoder_results+=("pyzbar_enhanced:$(head -1 "$out_pyzbar_enh" 2>/dev/null)")
        else
            log_info "  ✗ pyzbar_enhanced: no QR code found"
        fi
    fi

    # --- DECODER 7: MULTI-SCALE ---
    local out_multiscale="${TEMP_DIR}_multiscale.txt"
    if [ -n "$python_cmd" ]; then
        log_info "  [7/50] Trying multiscale decoder..."
        # AUDIT FIX: Base64-encode paths
        local encoded_image
        local encoded_out_path
        encoded_image=$(printf '%s' "$image" | base64 2>/dev/null) || true
        encoded_out_path=$(printf '%s' "$out_multiscale" | base64 2>/dev/null) || true
        (
            exec 2>/dev/null
            timeout 45 "$python_cmd" 2>/dev/null - "$encoded_image" "$encoded_out_path" 2>/dev/null <<'EOF'
import sys, signal, base64
signal.signal(signal.SIGSEGV, lambda s,f: sys.exit(139))
signal.signal(signal.SIGABRT, lambda s,f: sys.exit(134))
try:
    image_path = base64.b64decode(sys.argv[1] if len(sys.argv) > 1 else '').decode('utf-8')
    out_path = base64.b64decode(sys.argv[2] if len(sys.argv) > 2 else '').decode('utf-8')
    import cv2
    from pyzbar.pyzbar import decode
    from PIL import Image
    img = cv2.imread(image_path)
    if img is not None:
        all_data = set()
        for scale in [0.5, 1.0, 1.5, 2.0]:
            resized = cv2.resize(img, None, fx=scale, fy=scale) if scale != 1.0 else img
            pil_img = Image.fromarray(cv2.cvtColor(resized, cv2.COLOR_BGR2RGB))
            for c in decode(pil_img):
                try: all_data.add(c.data.decode('utf-8'))
                except: all_data.add(c.data.decode('latin-1'))
            if all_data: break
        if all_data:
            with open(out_path, 'w') as f:
                for d in all_data:
                    f.write(d + '\\n')
except:
    pass
EOF
        )
        if [ -s "$out_multiscale" ]; then
            log_success "  ✓ multiscale: decoded successfully"
            ((success_count++))
            all_decoded+=$(cat "$out_multiscale" 2>/dev/null)$'\n'
            decoder_results+=("multiscale:$(head -1 "$out_multiscale" 2>/dev/null)")
        else
            log_info "  ✗ multiscale: no QR code found"
        fi
    fi

    # --- DECODER 8: INVERSE/NEGATIVE ---
    local out_inverse="${TEMP_DIR}_inverse.txt"
    if [ -n "$python_cmd" ]; then
        log_info "  [8/50] Trying inverse decoder..."
        (
            exec 2>/dev/null
            timeout 30 "$python_cmd" 2>/dev/null <<'EOF'
import sys, signal, base64
signal.signal(signal.SIGSEGV, lambda s,f: sys.exit(139))
signal.signal(signal.SIGABRT, lambda s,f: sys.exit(134))
try:
    image_path = base64.b64decode(sys.argv[1] if len(sys.argv) > 1 else '').decode('utf-8')
    out_path = base64.b64decode(sys.argv[2] if len(sys.argv) > 2 else '').decode('utf-8')
    from pyzbar.pyzbar import decode
    from PIL import Image, ImageOps
    img = Image.open(image_path)
    all_data = set()
    
    for processed in [img.convert('L'), ImageOps.invert(img.convert('L'))]:
        for c in decode(processed):
            try: all_data.add(c.data.decode('utf-8'))
            except: all_data.add(c.data.decode('latin-1'))
        if all_data: break
    
    if all_data:
        with open(out_path, 'w') as f:
            for d in all_data:
                f.write(d + '\\n')
except:
    pass
EOF
        )
        if [ -s "$out_inverse" ]; then
            log_success "  ✓ inverse: decoded successfully"
            ((success_count++))
            all_decoded+=$(cat "$out_inverse" 2>/dev/null)$'\n'
            decoder_results+=("inverse:$(head -1 "$out_inverse" 2>/dev/null)")
        else
            log_info "  ✗ inverse: no QR code found"
        fi
    fi

    # --- DECODER 9: IMAGEMAGICK + ZBAR (preprocessing) ---
    local out_imgzbar="${TEMP_DIR}_imgzbar.txt"
    if command -v convert &>/dev/null && command -v zbarimg &>/dev/null; then
        log_info "  [9/50] Trying imagemagick+zbar decoder..."
        if decode_with_imagemagick_zbar "$image" "$out_imgzbar"; then
            log_success "  ✓ imagemagick+zbar: decoded successfully"
            ((success_count++))
            all_decoded+=$(cat "$out_imgzbar" 2>/dev/null)$'\n'
            decoder_results+=("imgzbar:$(head -1 "$out_imgzbar" 2>/dev/null)")
        else
            log_info "  ✗ imagemagick+zbar: no QR code found"
        fi
    else
        log_info "  ✗ imagemagick+zbar: convert or zbarimg not installed"
    fi

    # --- DECODER 10: DMTXREAD (DataMatrix simple) ---
    local out_dmtxread="${TEMP_DIR}_dmtxread.txt"
    if command -v dmtxread &>/dev/null; then
        log_info "  [10/50] Trying dmtxread decoder..."
        if decode_with_dmtxread "$image" "$out_dmtxread"; then
            log_success "  ✓ dmtxread: decoded successfully"
            ((success_count++))
            all_decoded+=$(cat "$out_dmtxread" 2>/dev/null)$'\n'
            decoder_results+=("dmtxread:$(head -1 "$out_dmtxread" 2>/dev/null)")
        else
            log_info "  ✗ dmtxread: no code found"
        fi
    else
        log_info "  ✗ dmtxread: not installed"
    fi

    # --- DECODER 11: QREADER (Python, crash-hardened) ---
    local out_qreader="${TEMP_DIR}_qreader.txt"
    if [ -n "$python_cmd" ]; then
        # Pre-check if qreader module exists - wrapped in subshell to catch segfaults
        local qreader_available=false
        (
            trap 'exit 1' SEGV ABRT BUS
            ulimit -c 0 2>/dev/null
            exec 2>/dev/null
            timeout 5 "$python_cmd" -c "from qreader import QReader" 2>/dev/null
        ) 2>/dev/null && qreader_available=true
        
        if [ "$qreader_available" = true ]; then
            log_info "  [11/50] Trying qreader decoder..."
            (
                trap 'exit 139' SEGV
                trap 'exit 134' ABRT
                trap 'exit 135' BUS
                ulimit -c 0 2>/dev/null
                exec 2>/dev/null
                timeout 30 "$python_cmd" 2>/dev/null <<'EOF'
import sys, os, signal, base64

# Disable OpenCV threading which can cause segfaults
os.environ["OPENCV_VIDEOIO_PRIORITY_MSMF"] = "0"
os.environ["OMP_NUM_THREADS"] = "1"

signal.signal(signal.SIGSEGV, lambda s,f: sys.exit(139))
signal.signal(signal.SIGABRT, lambda s,f: sys.exit(134))

try:
    from qreader import QReader
    import cv2
    
    detector = QReader()
    img = cv2.imread(image_path)
    if img is not None:
        decoded = detector.detect_and_decode(image=img)
        if decoded:
            with open(out_path, 'w') as f:
                for d in decoded:
                    if d:
                        f.write(str(d) + '\\n')
except:
    pass
EOF
            ) 2>/dev/null
            if [ -s "$out_qreader" ]; then
                log_success "  ✓ qreader: decoded successfully"
                ((success_count++))
                all_decoded+=$(cat "$out_qreader" 2>/dev/null)$'\n'
                decoder_results+=("qreader:$(head -1 "$out_qreader" 2>/dev/null)")
            else
                log_info "  ✗ qreader: no QR code found"
            fi
        else
            log_info "  [11/22] ✗ qreader: module not installed or crashed (skipped)"
        fi
    else
        log_info "  ✗ qreader: Python not available"
    fi

    # --- DECODER 12: PYZXING (Python, crash-hardened) ---
    local out_pyzxing="${TEMP_DIR}_pyzxing.txt"
    if [ -n "$python_cmd" ]; then
        # Pre-check if pyzxing module exists - wrapped in subshell to catch segfaults
        local pyzxing_available=false
        (
            trap 'exit 1' SEGV ABRT BUS
            ulimit -c 0 2>/dev/null
            exec 2>/dev/null
            timeout 5 "$python_cmd" -c "import pyzxing" 2>/dev/null
        ) 2>/dev/null && pyzxing_available=true
        
        if [ "$pyzxing_available" = true ]; then
            log_info "  [12/50] Trying pyzxing decoder..."
            (
                trap 'exit 139' SEGV
                trap 'exit 134' ABRT
                trap 'exit 135' BUS
                ulimit -c 0 2>/dev/null
                exec 2>/dev/null
                timeout 30 "$python_cmd" 2>/dev/null <<'EOF'
import sys, signal, base64
signal.signal(signal.SIGSEGV, lambda s,f: sys.exit(139))
signal.signal(signal.SIGABRT, lambda s,f: sys.exit(134))
try:
    image_path = base64.b64decode(sys.argv[1] if len(sys.argv) > 1 else '').decode('utf-8')
    out_path = base64.b64decode(sys.argv[2] if len(sys.argv) > 2 else '').decode('utf-8')
    import pyzxing
    reader = pyzxing.BarCodeReader()
    result = reader.decode('$image')
    # result can be a list or dict
    if isinstance(result, dict) and result.get('parsed'):
        with open(out_path, 'w') as f:
            f.write(str(result['parsed']).strip() + '\\n')
    elif isinstance(result, list):
        with open(out_path, 'w') as f:
            for item in result:
                if isinstance(item, dict) and 'parsed' in item:
                    f.write(str(item['parsed']).strip() + '\\n')
except Exception:
    pass
EOF
            ) 2>/dev/null
            if [ -s "$out_pyzxing" ]; then
                log_success "  ✓ pyzxing: decoded successfully"
                ((success_count++))
                all_decoded+=$(cat "$out_pyzxing" 2>/dev/null)$'\n'
                decoder_results+=("pyzxing:$(head -1 "$out_pyzxing" 2>/dev/null)")
            else
                log_info "  ✗ pyzxing: no QR code found"
            fi
        else
            log_info "  [12/22] ✗ pyzxing: module not installed (skipped)"
        fi
    else
        log_info "  ✗ pyzxing: Python not available"
    fi

    # --- DECODER 13: ZXING JAVA CLI (direct JAR execution) ---
    local out_zxing_java="${TEMP_DIR}_zxing_java.txt"
    log_info "  [13/50] Trying ZXing Java CLI decoder..."
    if command -v java &>/dev/null; then
        if decode_with_zxing_java_cli "$image" "$out_zxing_java"; then
            log_success "  ✓ zxing_java: decoded successfully"
            ((success_count++))
            all_decoded+=$(cat "$out_zxing_java" 2>/dev/null)$'\n'
            decoder_results+=("zxing_java:$(head -1 "$out_zxing_java" 2>/dev/null)")
        else
            log_info "  ✗ zxing_java: no code found or JAR not available"
        fi
    else
        log_info "  ✗ zxing_java: Java not installed"
    fi

    # --- DECODER 14: LIBDECODEQR (C/C++ library) ---
    local out_libdecodeqr="${TEMP_DIR}_libdecodeqr.txt"
    log_info "  [14/50] Trying libdecodeqr decoder..."
    if command -v decodeqr &>/dev/null || command -v qrdecoder &>/dev/null; then
        if decode_with_libdecodeqr "$image" "$out_libdecodeqr"; then
            log_success "  ✓ libdecodeqr: decoded successfully"
            ((success_count++))
            all_decoded+=$(cat "$out_libdecodeqr" 2>/dev/null)$'\n'
            decoder_results+=("libdecodeqr:$(head -1 "$out_libdecodeqr" 2>/dev/null)")
        else
            log_info "  ✗ libdecodeqr: no code found"
        fi
    else
        log_info "  ✗ libdecodeqr: not installed"
    fi

    # --- DECODER 15: TESSERACT OCR + LEPTONICA (degraded code recovery) ---
    local out_tesseract="${TEMP_DIR}_tesseract.txt"
    log_info "  [15/50] Trying Tesseract OCR decoder..."
    if command -v tesseract &>/dev/null; then
        if decode_with_tesseract_ocr "$image" "$out_tesseract"; then
            log_success "  ✓ tesseract: decoded successfully (OCR-based recovery)"
            ((success_count++))
            all_decoded+=$(cat "$out_tesseract" 2>/dev/null)$'\n'
            decoder_results+=("tesseract:$(head -1 "$out_tesseract" 2>/dev/null)")
        else
            log_info "  ✗ tesseract: no readable text/URLs found"
        fi
    else
        log_info "  ✗ tesseract: not installed"
    fi

    # --- DECODER 16: BOOFCV (Java computer vision) ---
    local out_boofcv="${TEMP_DIR}_boofcv.txt"
    log_info "  [16/50] Trying BoofCV decoder..."
    if command -v java &>/dev/null; then
        # Try original boofcv first, then extended version
        if decode_with_boofcv "$image" "$out_boofcv" 2>/dev/null || decode_with_boofcv_extended "$image" "$out_boofcv"; then
            log_success "  ✓ boofcv: decoded successfully"
            ((success_count++))
            all_decoded+=$(cat "$out_boofcv" 2>/dev/null)$'\n'
            decoder_results+=("boofcv:$(head -1 "$out_boofcv" 2>/dev/null)")
        else
            log_info "  ✗ boofcv: no code found or library not available"
        fi
    else
        log_info "  ✗ boofcv: Java not installed"
    fi

    # --- DECODER 17: BWIP-JS (Node.js barcode library) ---
    local out_bwipjs="${TEMP_DIR}_bwipjs.txt"
    log_info "  [17/50] Trying bwip-js decoder..."
    if command -v node &>/dev/null || command -v nodejs &>/dev/null; then
        if decode_with_bwipjs "$image" "$out_bwipjs"; then
            log_success "  ✓ bwipjs: decoded successfully"
            ((success_count++))
            all_decoded+=$(cat "$out_bwipjs" 2>/dev/null)$'\n'
            decoder_results+=("bwipjs:$(head -1 "$out_bwipjs" 2>/dev/null)")
        else
            log_info "  ✗ bwipjs: no code found or modules not available"
        fi
    else
        log_info "  ✗ bwipjs: Node.js not installed"
    fi

    # --- DECODER 18: JSQR (Node.js QR decoder) ---
    local out_jsqr="${TEMP_DIR}_jsqr.txt"
    log_info "  [18/50] Trying jsQR decoder..."
    if command -v node &>/dev/null || command -v nodejs &>/dev/null; then
        if decode_with_jsqr "$image" "$out_jsqr"; then
            log_success "  ✓ jsqr: decoded successfully"
            ((success_count++))
            all_decoded+=$(cat "$out_jsqr" 2>/dev/null)$'\n'
            decoder_results+=("jsqr:$(head -1 "$out_jsqr" 2>/dev/null)")
        else
            log_info "  ✗ jsqr: no code found or modules not available"
        fi
    else
        log_info "  ✗ jsqr: Node.js not installed"
    fi

    # --- DECODER 19: PYTHON-BARCODE (1D barcode types) ---
    local out_pybarcode="${TEMP_DIR}_pybarcode.txt"
    if [ -n "$python_cmd" ]; then
        log_info "  [19/50] Trying python-barcode (1D types) decoder..."
        if decode_with_python_barcode "$image" "$out_pybarcode"; then
            log_success "  ✓ python-barcode: decoded successfully (1D barcode)"
            ((success_count++))
            all_decoded+=$(cat "$out_pybarcode" 2>/dev/null)$'\n'
            decoder_results+=("pybarcode:$(head -1 "$out_pybarcode" 2>/dev/null)")
        else
            log_info "  ✗ python-barcode: no 1D barcode found"
        fi
    else
        log_info "  ✗ python-barcode: Python not available"
    fi

    # --- DECODER 20: OPENCV ARUCO + MULTI-QR ---
    local out_aruco="${TEMP_DIR}_aruco.txt"
    if [ -n "$python_cmd" ]; then
        log_info "  [20/50] Trying OpenCV ArUco/Multi-QR decoder..."
        if decode_with_opencv_aruco "$image" "$out_aruco"; then
            log_success "  ✓ opencv_aruco: decoded successfully"
            ((success_count++))
            all_decoded+=$(cat "$out_aruco" 2>/dev/null)$'\n'
            decoder_results+=("aruco:$(head -1 "$out_aruco" 2>/dev/null)")
        else
            log_info "  ✗ opencv_aruco: no ArUco/QR codes found"
        fi
    else
        log_info "  ✗ opencv_aruco: Python not available"
    fi

    # --- DECODER 21: DYNAMSOFT BARCODE READER ---
    local out_dynamsoft="${TEMP_DIR}_dynamsoft.txt"
    if [ -n "$python_cmd" ]; then
        # Pre-check if dbr module exists - wrapped in subshell to catch segfaults during import
        local dbr_available=false
        (
            trap 'exit 1' SEGV ABRT BUS
            ulimit -c 0 2>/dev/null
            exec 2>/dev/null
            timeout 5 "$python_cmd" -c "import dbr" 2>/dev/null
        ) 2>/dev/null && dbr_available=true
        
        if [ "$dbr_available" = true ]; then
            log_info "  [21/50] Trying Dynamsoft Barcode Reader..."
            if decode_with_dynamsoft "$image" "$out_dynamsoft"; then
                log_success "  ✓ dynamsoft: decoded successfully"
                ((success_count++))
                all_decoded+=$(cat "$out_dynamsoft" 2>/dev/null)$'\n'
                decoder_results+=("dynamsoft:$(head -1 "$out_dynamsoft" 2>/dev/null)")
            else
                log_info "  ✗ dynamsoft: no code found"
            fi
        else
            log_info "  [21/22] ✗ dynamsoft: dbr module not installed or crashed (skipped)"
        fi
    else
        log_info "  ✗ dynamsoft: Python not available"
    fi

    # --- DECODER 22: ZXING-CPP (C++ ZXing port) ---
    local out_zxingcpp="${TEMP_DIR}_zxingcpp.txt"
    log_info "  [22/50] Trying zxing-cpp decoder..."
    # Check for command-line tool first (safer)
    if command -v zxing &>/dev/null; then
        if decode_with_zxingcpp "$image" "$out_zxingcpp"; then
            log_success "  ✓ zxingcpp: decoded successfully"
            ((success_count++))
            all_decoded+=$(cat "$out_zxingcpp" 2>/dev/null)$'\n'
            decoder_results+=("zxingcpp:$(head -1 "$out_zxingcpp" 2>/dev/null)")
        else
            log_info "  ✗ zxingcpp: no code found"
        fi
    elif [ -n "$python_cmd" ]; then
        # Pre-check Python module in crash-safe subshell
        local zxingcpp_available=false
        (
            trap 'exit 1' SEGV ABRT BUS
            ulimit -c 0 2>/dev/null
            exec 2>/dev/null
            timeout 5 "$python_cmd" -c "import zxingcpp" 2>/dev/null
        ) 2>/dev/null && zxingcpp_available=true
        
        if [ "$zxingcpp_available" = true ]; then
            if decode_with_zxingcpp "$image" "$out_zxingcpp"; then
                log_success "  ✓ zxingcpp: decoded successfully"
                ((success_count++))
                all_decoded+=$(cat "$out_zxingcpp" 2>/dev/null)$'\n'
                decoder_results+=("zxingcpp:$(head -1 "$out_zxingcpp" 2>/dev/null)")
            else
                log_info "  ✗ zxingcpp: no code found"
            fi
        else
            log_info "  ✗ zxingcpp: Python module not installed or crashed (skipped)"
        fi
    else
        log_info "  ✗ zxingcpp: not installed (neither CLI nor Python)"
    fi

    # --- DECODER 23: GOQR (Go-based QR decoder - fast, memory-safe) ---
    local out_goqr="${TEMP_DIR}_goqr.txt"
    if command -v gozxing &>/dev/null || command -v goqr &>/dev/null || command -v qrdecode &>/dev/null; then
        log_info "  [23/50] Trying GoQR decoder..."
        if decode_with_goqr "$image" "$out_goqr"; then
            log_success "  ✓ goqr: decoded successfully"
            ((success_count++))
            all_decoded+=$(cat "$out_goqr" 2>/dev/null)$'\n'
            decoder_results+=("goqr:$(head -1 "$out_goqr" 2>/dev/null)")
        else
            log_info "  ✗ goqr: no code found"
        fi
    else
        log_info "  ✗ goqr: Go decoder not installed"
    fi

    # --- DECODER 24: AZTEC (Transport tickets, boarding passes) ---
    local out_aztec="${TEMP_DIR}_aztec.txt"
    log_info "  [24/50] Trying Aztec code decoder..."
    if [ -n "$python_cmd" ]; then
        # Run in isolated subshell to prevent segfaults from killing main process
        (
            set +e  # Don't exit on error
            decode_with_aztec "$image" "$out_aztec"
            exit $?
        ) &
        local decoder_pid=$!
        
        # Wait for decoder with timeout
        wait $decoder_pid 2>/dev/null
        local exit_code=$?
        
        if [ $exit_code -eq 0 ] && [ -s "$out_aztec" ]; then
            log_success "  ✓ aztec: decoded successfully"
            ((success_count++))
            all_decoded+=$(cat "$out_aztec" 2>/dev/null)$'\n'
            decoder_results+=("aztec:$(head -1 "$out_aztec" 2>/dev/null)")
        elif [ $exit_code -eq 2 ]; then
            log_info "  ✗ aztec: decoder module not installed"
        elif [ $exit_code -eq 1 ]; then
            log_info "  ✗ aztec: no Aztec code found"
        else
            log_info "  ✗ aztec: decoder crashed or timed out (skipped)"
        fi
    else
        log_info "  ✗ aztec: Python not available"
    fi

    # --- DECODER 25: PDF417 (IDs, driver's licenses, boarding passes) ---
    local out_pdf417="${TEMP_DIR}_pdf417.txt"
    log_info "  [25/50] Trying PDF417 decoder..."
    if [ -n "$python_cmd" ]; then        # Run in isolated subshell to prevent segfaults
        (
            set +e
            decode_with_pdf417 "$image" "$out_pdf417"
            exit $?
        ) &
        local decoder_pid=$!
        
        wait $decoder_pid 2>/dev/null
        local exit_code=$?
        
        if [ $exit_code -eq 0 ] && [ -s "$out_pdf417" ]; then
            log_success "  ✓ pdf417: decoded successfully"
            ((success_count++))
            all_decoded+=$(cat "$out_pdf417" 2>/dev/null)$'
'
            decoder_results+=("pdf417:$(head -1 "$out_pdf417" 2>/dev/null)")
        elif [ $exit_code -eq 2 ]; then
            log_info "  ✗ pdf417: decoder module not installed"
        elif [ $exit_code -eq 1 ]; then
            log_info "  ✗ pdf417: no PDF417 found"
        else
            log_info "  ✗ pdf417: decoder crashed or timed out (skipped)"
        fi
    else
        log_info "  ✗ pdf417: Python not available"
    fi

    # --- DECODER 26: MAXICODE (UPS shipping labels) ---
    local out_maxicode="${TEMP_DIR}_maxicode.txt"
    log_info "  [26/50] Trying MaxiCode decoder..."
    if [ -n "$python_cmd" ]; then        # Run in isolated subshell to prevent segfaults
        (
            set +e
            decode_with_maxicode "$image" "$out_maxicode"
            exit $?
        ) &
        local decoder_pid=$!
        
        wait $decoder_pid 2>/dev/null
        local exit_code=$?
        
        if [ $exit_code -eq 0 ] && [ -s "$out_maxicode" ]; then
            log_success "  ✓ maxicode: decoded successfully"
            ((success_count++))
            all_decoded+=$(cat "$out_maxicode" 2>/dev/null)$'
'
            decoder_results+=("maxicode:$(head -1 "$out_maxicode" 2>/dev/null)")
        elif [ $exit_code -eq 2 ]; then
            log_info "  ✗ maxicode: decoder module not installed"
        elif [ $exit_code -eq 1 ]; then
            log_info "  ✗ maxicode: no MaxiCode found"
        else
            log_info "  ✗ maxicode: decoder crashed or timed out (skipped)"
        fi
    else
        log_info "  ✗ maxicode: Python not available"
    fi

    # --- DECODER 27: CODABAR (Libraries, blood banks, FedEx) ---
    local out_codabar="${TEMP_DIR}_codabar.txt"
    log_info "  [27/50] Trying Codabar decoder..."
    if [ -n "$python_cmd" ]; then        # Run in isolated subshell to prevent segfaults
        (
            set +e
            decode_with_codabar "$image" "$out_codabar"
            exit $?
        ) &
        local decoder_pid=$!
        
        wait $decoder_pid 2>/dev/null
        local exit_code=$?
        
        if [ $exit_code -eq 0 ] && [ -s "$out_codabar" ]; then
            log_success "  ✓ codabar: decoded successfully"
            ((success_count++))
            all_decoded+=$(cat "$out_codabar" 2>/dev/null)$'
'
            decoder_results+=("codabar:$(head -1 "$out_codabar" 2>/dev/null)")
        elif [ $exit_code -eq 2 ]; then
            log_info "  ✗ codabar: decoder module not installed"
        elif [ $exit_code -eq 1 ]; then
            log_info "  ✗ codabar: no Codabar found"
        else
            log_info "  ✗ codabar: decoder crashed or timed out (skipped)"
        fi
    else
        log_info "  ✗ codabar: Python not available"
    fi

    # --- DECODER 28: CODE128 (High-density alphanumeric) ---
    local out_code128="${TEMP_DIR}_code128.txt"
    log_info "  [28/50] Trying Code 128 decoder..."
    if [ -n "$python_cmd" ]; then        # Run in isolated subshell to prevent segfaults
        (
            set +e
            decode_with_code128 "$image" "$out_code128"
            exit $?
        ) &
        local decoder_pid=$!
        
        wait $decoder_pid 2>/dev/null
        local exit_code=$?
        
        if [ $exit_code -eq 0 ] && [ -s "$out_code128" ]; then
            log_success "  ✓ code128: decoded successfully"
            ((success_count++))
            all_decoded+=$(cat "$out_code128" 2>/dev/null)$'
'
            decoder_results+=("code128:$(head -1 "$out_code128" 2>/dev/null)")
        elif [ $exit_code -eq 2 ]; then
            log_info "  ✗ code128: decoder module not installed"
        elif [ $exit_code -eq 1 ]; then
            log_info "  ✗ code128: no Code 128 found"
        else
            log_info "  ✗ code128: decoder crashed or timed out (skipped)"
        fi
    else
        log_info "  ✗ code128: Python not available"
    fi

    # --- DECODER 29: CODE39 (Automotive VINs, defense LOGMARS) ---
    local out_code39="${TEMP_DIR}_code39.txt"
    log_info "  [29/50] Trying Code 39 decoder..."
    if [ -n "$python_cmd" ]; then        # Run in isolated subshell to prevent segfaults
        (
            set +e
            decode_with_code39 "$image" "$out_code39"
            exit $?
        ) &
        local decoder_pid=$!
        
        wait $decoder_pid 2>/dev/null
        local exit_code=$?
        
        if [ $exit_code -eq 0 ] && [ -s "$out_code39" ]; then
            log_success "  ✓ code39: decoded successfully"
            ((success_count++))
            all_decoded+=$(cat "$out_code39" 2>/dev/null)$'
'
            decoder_results+=("code39:$(head -1 "$out_code39" 2>/dev/null)")
        elif [ $exit_code -eq 2 ]; then
            log_info "  ✗ code39: decoder module not installed"
        elif [ $exit_code -eq 1 ]; then
            log_info "  ✗ code39: no Code 39 found"
        else
            log_info "  ✗ code39: decoder crashed or timed out (skipped)"
        fi
    else
        log_info "  ✗ code39: Python not available"
    fi

    # --- DECODER 30: EAN/UPC (Retail barcodes) ---
    local out_ean="${TEMP_DIR}_ean.txt"
    log_info "  [30/50] Trying EAN/UPC decoder..."
    if [ -n "$python_cmd" ]; then        # Run in isolated subshell to prevent segfaults
        (
            set +e
            decode_with_ean "$image" "$out_ean"
            exit $?
        ) &
        local decoder_pid=$!
        
        wait $decoder_pid 2>/dev/null
        local exit_code=$?
        
        if [ $exit_code -eq 0 ] && [ -s "$out_ean" ]; then
            log_success "  ✓ ean: decoded successfully"
            ((success_count++))
            all_decoded+=$(cat "$out_ean" 2>/dev/null)$'
'
            decoder_results+=("ean:$(head -1 "$out_ean" 2>/dev/null)")
        elif [ $exit_code -eq 2 ]; then
            log_info "  ✗ ean: decoder module not installed"
        elif [ $exit_code -eq 1 ]; then
            log_info "  ✗ ean: no EAN/UPC found"
        else
            log_info "  ✗ ean: decoder crashed or timed out (skipped)"
        fi
    else
        log_info "  ✗ ean: Python not available"
    fi

    # --- DECODER 31: RMQR (Rectangular Micro QR - ISO/IEC 23941) ---
    local out_rmqr="${TEMP_DIR}_rmqr.txt"
    log_info "  [31/50] Trying rMQR decoder..."
    if [ -n "$python_cmd" ]; then        # Run in isolated subshell to prevent segfaults
        (
            set +e
            decode_with_rmqr "$image" "$out_rmqr"
            exit $?
        ) &
        local decoder_pid=$!
        
        wait $decoder_pid 2>/dev/null
        local exit_code=$?
        
        if [ $exit_code -eq 0 ] && [ -s "$out_rmqr" ]; then
            log_success "  ✓ rmqr: decoded successfully"
            ((success_count++))
            all_decoded+=$(cat "$out_rmqr" 2>/dev/null)$'
'
            decoder_results+=("rmqr:$(head -1 "$out_rmqr" 2>/dev/null)")
        elif [ $exit_code -eq 2 ]; then
            log_info "  ✗ rmqr: decoder module not installed"
        elif [ $exit_code -eq 1 ]; then
            log_info "  ✗ rmqr: no rMQR found"
        else
            log_info "  ✗ rmqr: decoder crashed or timed out (skipped)"
        fi
    else
        log_info "  ✗ rmqr: Python not available"
    fi

    # --- DECODER 32: HANXIN (Chinese GB/T 21049 standard) ---
    local out_hanxin="${TEMP_DIR}_hanxin.txt"
    log_info "  [32/50] Trying Han Xin Code decoder..."
    if [ -n "$python_cmd" ]; then        # Run in isolated subshell to prevent segfaults
        (
            set +e
            decode_with_hanxin "$image" "$out_hanxin"
            exit $?
        ) &
        local decoder_pid=$!
        
        wait $decoder_pid 2>/dev/null
        local exit_code=$?
        
        if [ $exit_code -eq 0 ] && [ -s "$out_hanxin" ]; then
            log_success "  ✓ hanxin: decoded successfully"
            ((success_count++))
            all_decoded+=$(cat "$out_hanxin" 2>/dev/null)$'
'
            decoder_results+=("hanxin:$(head -1 "$out_hanxin" 2>/dev/null)")
        elif [ $exit_code -eq 2 ]; then
            log_info "  ✗ hanxin: decoder module not installed"
        elif [ $exit_code -eq 1 ]; then
            log_info "  ✗ hanxin: no Han Xin Code found"
        else
            log_info "  ✗ hanxin: decoder crashed or timed out (skipped)"
        fi
    else
        log_info "  ✗ hanxin: Python not available"
    fi

    # --- DECODER 33: DOTCODE (High-speed industrial printing) ---
    local out_dotcode="${TEMP_DIR}_dotcode.txt"
    log_info "  [33/50] Trying DotCode decoder..."
    if [ -n "$python_cmd" ]; then        # Run in isolated subshell to prevent segfaults
        (
            set +e
            decode_with_dotcode "$image" "$out_dotcode"
            exit $?
        ) &
        local decoder_pid=$!
        
        wait $decoder_pid 2>/dev/null
        local exit_code=$?
        
        if [ $exit_code -eq 0 ] && [ -s "$out_dotcode" ]; then
            log_success "  ✓ dotcode: decoded successfully"
            ((success_count++))
            all_decoded+=$(cat "$out_dotcode" 2>/dev/null)$'
'
            decoder_results+=("dotcode:$(head -1 "$out_dotcode" 2>/dev/null)")
        elif [ $exit_code -eq 2 ]; then
            log_info "  ✗ dotcode: decoder module not installed"
        elif [ $exit_code -eq 1 ]; then
            log_info "  ✗ dotcode: no DotCode found"
        else
            log_info "  ✗ dotcode: decoder crashed or timed out (skipped)"
        fi
    else
        log_info "  ✗ dotcode: Python not available"
    fi

    # --- DECODER 34: GRIDMATRIX (Chinese standard) ---
    local out_gridmatrix="${TEMP_DIR}_gridmatrix.txt"
    log_info "  [34/50] Trying Grid Matrix decoder..."
    if [ -n "$python_cmd" ]; then        # Run in isolated subshell to prevent segfaults
        (
            set +e
            decode_with_gridmatrix "$image" "$out_gridmatrix"
            exit $?
        ) &
        local decoder_pid=$!
        
        wait $decoder_pid 2>/dev/null
        local exit_code=$?
        
        if [ $exit_code -eq 0 ] && [ -s "$out_gridmatrix" ]; then
            log_success "  ✓ gridmatrix: decoded successfully"
            ((success_count++))
            all_decoded+=$(cat "$out_gridmatrix" 2>/dev/null)$'
'
            decoder_results+=("gridmatrix:$(head -1 "$out_gridmatrix" 2>/dev/null)")
        elif [ $exit_code -eq 2 ]; then
            log_info "  ✗ gridmatrix: decoder module not installed"
        elif [ $exit_code -eq 1 ]; then
            log_info "  ✗ gridmatrix: no Grid Matrix found"
        else
            log_info "  ✗ gridmatrix: decoder crashed or timed out (skipped)"
        fi
    else
        log_info "  ✗ gridmatrix: Python not available"
    fi

    # --- DECODER 35: COMPOSITE (GS1 Composite barcodes) ---
    local out_composite="${TEMP_DIR}_composite.txt"
    log_info "  [35/50] Trying Composite barcode decoder..."
    if [ -n "$python_cmd" ]; then        # Run in isolated subshell to prevent segfaults
        (
            set +e
            decode_with_composite "$image" "$out_composite"
            exit $?
        ) &
        local decoder_pid=$!
        
        wait $decoder_pid 2>/dev/null
        local exit_code=$?
        
        if [ $exit_code -eq 0 ] && [ -s "$out_composite" ]; then
            log_success "  ✓ composite: decoded successfully"
            ((success_count++))
            all_decoded+=$(cat "$out_composite" 2>/dev/null)$'
'
            decoder_results+=("composite:$(head -1 "$out_composite" 2>/dev/null)")
        elif [ $exit_code -eq 2 ]; then
            log_info "  ✗ composite: decoder module not installed"
        elif [ $exit_code -eq 1 ]; then
            log_info "  ✗ composite: no Composite barcode found"
        else
            log_info "  ✗ composite: decoder crashed or timed out (skipped)"
        fi
    else
        log_info "  ✗ composite: Python not available"
    fi

    # --- DECODER 36: ITF (Interleaved 2 of 5) ---
    local out_itf="${TEMP_DIR}_itf.txt"
    log_info "  [36/50] Trying ITF decoder..."
    if [ -n "$python_cmd" ]; then        # Run in isolated subshell to prevent segfaults
        (
            set +e
            decode_with_itf "$image" "$out_itf"
            exit $?
        ) &
        local decoder_pid=$!
        
        wait $decoder_pid 2>/dev/null
        local exit_code=$?
        
        if [ $exit_code -eq 0 ] && [ -s "$out_itf" ]; then
            log_success "  ✓ itf: decoded successfully"
            ((success_count++))
            all_decoded+=$(cat "$out_itf" 2>/dev/null)$'
'
            decoder_results+=("itf:$(head -1 "$out_itf" 2>/dev/null)")
        elif [ $exit_code -eq 2 ]; then
            log_info "  ✗ itf: decoder module not installed"
        elif [ $exit_code -eq 1 ]; then
            log_info "  ✗ itf: no ITF found"
        else
            log_info "  ✗ itf: decoder crashed or timed out (skipped)"
        fi
    else
        log_info "  ✗ itf: Python not available"
    fi

    # --- DECODER 37: CODE93 (Higher density Code 39 variant) ---
    local out_code93="${TEMP_DIR}_code93.txt"
    log_info "  [37/50] Trying Code 93 decoder..."
    if [ -n "$python_cmd" ]; then        # Run in isolated subshell to prevent segfaults
        (
            set +e
            decode_with_code93 "$image" "$out_code93"
            exit $?
        ) &
        local decoder_pid=$!
        
        wait $decoder_pid 2>/dev/null
        local exit_code=$?
        
        if [ $exit_code -eq 0 ] && [ -s "$out_code93" ]; then
            log_success "  ✓ code93: decoded successfully"
            ((success_count++))
            all_decoded+=$(cat "$out_code93" 2>/dev/null)$'
'
            decoder_results+=("code93:$(head -1 "$out_code93" 2>/dev/null)")
        elif [ $exit_code -eq 2 ]; then
            log_info "  ✗ code93: decoder module not installed"
        elif [ $exit_code -eq 1 ]; then
            log_info "  ✗ code93: no Code 93 found"
        else
            log_info "  ✗ code93: decoder crashed or timed out (skipped)"
        fi
    else
        log_info "  ✗ code93: Python not available"
    fi

    # --- DECODER 38: UNIVERSAL (All formats with preprocessing) ---
    local out_universal="${TEMP_DIR}_universal.txt"
    log_info "  [38/50] Trying Universal decoder (all formats)..."
    if [ -n "$python_cmd" ]; then        # Run in isolated subshell to prevent segfaults
        (
            set +e
            decode_with_universal "$image" "$out_universal"
            exit $?
        ) &
        local decoder_pid=$!
        
        wait $decoder_pid 2>/dev/null
        local exit_code=$?
        
        if [ $exit_code -eq 0 ] && [ -s "$out_universal" ]; then
            log_success "  ✓ universal: decoded successfully"
            ((success_count++))
            all_decoded+=$(cat "$out_universal" 2>/dev/null)$'
'
            decoder_results+=("universal:$(head -1 "$out_universal" 2>/dev/null)")
        elif [ $exit_code -eq 2 ]; then
            log_info "  ✗ universal: decoder module not installed"
        elif [ $exit_code -eq 1 ]; then
            log_info "  ✗ universal: no Universal found"
        else
            log_info "  ✗ universal: decoder crashed or timed out (skipped)"
        fi
    else
        log_info "  ✗ universal: Python not available"
    fi

    # --- DECODER 39: QR MODEL 1 (Legacy QR) ---
    local out_qr_model1="${TEMP_DIR}_qr_model1.txt"
    log_info "  [39/50] Trying QR Model 1 decoder..."
    if [ -n "$python_cmd" ]; then
        (
            set +e
            decode_with_qr_model1 "$image" "$out_qr_model1"
            exit $?
        ) &
        local decoder_pid=$!
        
        wait $decoder_pid 2>/dev/null
        local exit_code=$?
        
        if [ $exit_code -eq 0 ] && [ -s "$out_qr_model1" ]; then
            log_success "  ✓ qr_model1: decoded successfully"
            ((success_count++))
            all_decoded+=$(cat "$out_qr_model1" 2>/dev/null)$'\n'
            decoder_results+=("qr_model1:$(head -1 "$out_qr_model1" 2>/dev/null)")
        elif [ $exit_code -eq 2 ]; then
            log_info "  ✗ qr_model1: decoder module not installed"
        elif [ $exit_code -eq 1 ]; then
            log_info "  ✗ qr_model1: no QR Model 1 found"
        else
            log_info "  ✗ qr_model1: decoder crashed or timed out (skipped)"
        fi
    else
        log_info "  ✗ qr_model1: Python not available"
    fi

    # --- DECODER 40: JAB CODE (Colored 2D barcode) ---
    local out_jabcode="${TEMP_DIR}_jabcode.txt"
    log_info "  [40/50] Trying JAB Code decoder..."
    if decode_with_jabcode "$image" "$out_jabcode"; then
        log_success "  ✓ jabcode: decoded successfully"
        ((success_count++))
        all_decoded+=$(cat "$out_jabcode" 2>/dev/null)$'\n'
        decoder_results+=("jabcode:$(head -1 "$out_jabcode" 2>/dev/null)")
    else
        log_info "  ✗ jabcode: not installed or no code found"
    fi

    # --- DECODER 41: HCCB (Microsoft Tag) ---
    local out_hccb="${TEMP_DIR}_hccb.txt"
    log_info "  [41/50] Trying HCCB decoder..."
    if [ -n "$python_cmd" ]; then
        (
            set +e
            decode_with_hccb "$image" "$out_hccb"
            exit $?
        ) &
        local decoder_pid=$!
        
        wait $decoder_pid 2>/dev/null
        local exit_code=$?
        
        if [ $exit_code -eq 0 ] && [ -s "$out_hccb" ]; then
            log_success "  ✓ hccb: detected"
            ((success_count++))
            all_decoded+=$(cat "$out_hccb" 2>/dev/null)$'\n'
            decoder_results+=("hccb:$(head -1 "$out_hccb" 2>/dev/null)")
        elif [ $exit_code -eq 2 ]; then
            log_info "  ✗ hccb: decoder module not installed"
        elif [ $exit_code -eq 1 ]; then
            log_info "  ✗ hccb: no HCCB found"
        else
            log_info "  ✗ hccb: decoder crashed or timed out (skipped)"
        fi
    else
        log_info "  ✗ hccb: Python not available"
    fi

    # --- DECODER 42: MICRO QR CODE ---
    local out_micro_qr="${TEMP_DIR}_micro_qr.txt"
    log_info "  [42/50] Trying Micro QR Code decoder..."
    if [ -n "$python_cmd" ]; then
        (
            set +e
            decode_with_micro_qr "$image" "$out_micro_qr"
            exit $?
        ) &
        local decoder_pid=$!
        
        wait $decoder_pid 2>/dev/null
        local exit_code=$?
        
        if [ $exit_code -eq 0 ] && [ -s "$out_micro_qr" ]; then
            log_success "  ✓ micro_qr: decoded successfully"
            ((success_count++))
            all_decoded+=$(cat "$out_micro_qr" 2>/dev/null)$'\n'
            decoder_results+=("micro_qr:$(head -1 "$out_micro_qr" 2>/dev/null)")
        elif [ $exit_code -eq 2 ]; then
            log_info "  ✗ micro_qr: decoder module not installed"
        elif [ $exit_code -eq 1 ]; then
            log_info "  ✗ micro_qr: no Micro QR found"
        else
            log_info "  ✗ micro_qr: decoder crashed or timed out (skipped)"
        fi
    else
        log_info "  ✗ micro_qr: Python not available"
    fi

    # --- DECODER 43: HTML QR FRAUD DETECTOR (Phishing/Fraud Detection) ---
    local out_html_qr="${TEMP_DIR}_html_qr.txt"
    log_info "  [43/50] Trying HTML-Generated QR Fraud Detector..."
    if [ -n "$python_cmd" ]; then
        (
            set +e
            decode_with_html_qr_detector "$image" "$out_html_qr"
            exit $?
        ) &
        local decoder_pid=$!
        
        wait $decoder_pid 2>/dev/null
        local exit_code=$?
        
        if [ $exit_code -eq 0 ] && [ -s "$out_html_qr" ]; then
            log_success "  ✓ html_qr_detector: HTML-generated QR detected"
            ((success_count++))
            all_decoded+=$(cat "$out_html_qr" 2>/dev/null)$'\n'
            decoder_results+=("html_qr_detector:$(head -1 "$out_html_qr" 2>/dev/null)")
            
            # Check for fraud indicators
            if grep -q "HTML_GENERATION_INDICATORS" "$out_html_qr"; then
                log_forensic_detection 70 \
                    "HTML-Generated QR Code - Potential Fraud" \
                    "html_qr_generation:$(grep 'HTML_GENERATION_INDICATORS' "$out_html_qr" | cut -d: -f2-)" \
                    "Image forensic analysis" \
                    "QR generation method" \
                    "Investigate QR origin - HTML-generated QRs common in phishing/fraud campaigns" \
                    "MITRE ATT&CK T1566.002 - Phishing: Spearphishing Link"
            fi
            
            # Check for missing EXIF (programmatic generation indicator)
            if grep -q "FORENSIC:no_exif_programmatic_generation" "$out_html_qr"; then
                log_forensic "HTML QR lacks EXIF data - likely programmatically generated"
            fi
        elif [ $exit_code -eq 2 ]; then
            log_info "  ✗ html_qr_detector: decoder module not installed"
        elif [ $exit_code -eq 1 ]; then
            log_info "  ✗ html_qr_detector: no HTML QR patterns found"
        else
            log_info "  ✗ html_qr_detector: decoder crashed or timed out (skipped)"
        fi
    else
        log_info "  ✗ html_qr_detector: Python not available"
    fi

    # --- DECODER 44: UPC (Universal Product Code) ---
    local out_upc="${TEMP_DIR}_upc.txt"
    log_info "  [44/50] Trying UPC decoder..."
    if [ -n "$python_cmd" ]; then
        (
            set +e
            decode_with_upc "$image" "$out_upc"
            exit $?
        ) &
        local decoder_pid=$!
        
        wait $decoder_pid 2>/dev/null
        local exit_code=$?
        
        if [ $exit_code -eq 0 ] && [ -s "$out_upc" ]; then
            log_success "  ✓ upc: decoded successfully"
            ((success_count++))
            all_decoded+=$(cat "$out_upc" 2>/dev/null)$'\n'
            decoder_results+=("upc:$(head -1 "$out_upc" 2>/dev/null)")
        elif [ $exit_code -eq 2 ]; then
            log_info "  ✗ upc: decoder module not installed"
        elif [ $exit_code -eq 1 ]; then
            log_info "  ✗ upc: no UPC found"
        else
            log_info "  ✗ upc: decoder crashed or timed out (skipped)"
        fi
    else
        log_info "  ✗ upc: Python not available"
    fi

    # --- DECODER 45: MSI/Plessey ---
    local out_msi="${TEMP_DIR}_msi.txt"
    log_info "  [45/50] Trying MSI/Plessey decoder..."
    if [ -n "$python_cmd" ]; then
        (
            set +e
            decode_with_msi "$image" "$out_msi"
            exit $?
        ) &
        local decoder_pid=$!
        
        wait $decoder_pid 2>/dev/null
        local exit_code=$?
        
        if [ $exit_code -eq 0 ] && [ -s "$out_msi" ]; then
            log_success "  ✓ msi: decoded successfully"
            ((success_count++))
            all_decoded+=$(cat "$out_msi" 2>/dev/null)$'\n'
            decoder_results+=("msi:$(head -1 "$out_msi" 2>/dev/null)")
        elif [ $exit_code -eq 2 ]; then
            log_info "  ✗ msi: decoder module not installed"
        elif [ $exit_code -eq 1 ]; then
            log_info "  ✗ msi: no MSI/Plessey found"
        else
            log_info "  ✗ msi: decoder crashed or timed out (skipped)"
        fi
    else
        log_info "  ✗ msi: Python not available"
    fi

    # --- DECODER 46: Telepen ---
    local out_telepen="${TEMP_DIR}_telepen.txt"
    log_info "  [46/50] Trying Telepen decoder..."
    if [ -n "$python_cmd" ]; then
        (
            set +e
            decode_with_telepen "$image" "$out_telepen"
            exit $?
        ) &
        local decoder_pid=$!
        
        wait $decoder_pid 2>/dev/null
        local exit_code=$?
        
        if [ $exit_code -eq 0 ] && [ -s "$out_telepen" ]; then
            log_success "  ✓ telepen: decoded successfully"
            ((success_count++))
            all_decoded+=$(cat "$out_telepen" 2>/dev/null)$'\n'
            decoder_results+=("telepen:$(head -1 "$out_telepen" 2>/dev/null)")
        elif [ $exit_code -eq 2 ]; then
            log_info "  ✗ telepen: decoder module not installed"
        elif [ $exit_code -eq 1 ]; then
            log_info "  ✗ telepen: no Telepen found"
        else
            log_info "  ✗ telepen: decoder crashed or timed out (skipped)"
        fi
    else
        log_info "  ✗ telepen: Python not available"
    fi

    # --- DECODER 47: GS1 DataBar ---
    local out_gs1="${TEMP_DIR}_gs1_databar.txt"
    log_info "  [47/50] Trying GS1 DataBar decoder..."
    if [ -n "$python_cmd" ]; then
        (
            set +e
            decode_with_gs1_databar "$image" "$out_gs1"
            exit $?
        ) &
        local decoder_pid=$!
        
        wait $decoder_pid 2>/dev/null
        local exit_code=$?
        
        if [ $exit_code -eq 0 ] && [ -s "$out_gs1" ]; then
            log_success "  ✓ gs1_databar: decoded successfully"
            ((success_count++))
            all_decoded+=$(cat "$out_gs1" 2>/dev/null)$'\n'
            decoder_results+=("gs1_databar:$(head -1 "$out_gs1" 2>/dev/null)")
        elif [ $exit_code -eq 2 ]; then
            log_info "  ✗ gs1_databar: decoder module not installed"
        elif [ $exit_code -eq 1 ]; then
            log_info "  ✗ gs1_databar: no GS1 DataBar found"
        else
            log_info "  ✗ gs1_databar: decoder crashed or timed out (skipped)"
        fi
    else
        log_info "  ✗ gs1_databar: Python not available"
    fi

    # --- DECODER 48: Pharmacode ---
    local out_pharmacode="${TEMP_DIR}_pharmacode.txt"
    log_info "  [48/50] Trying Pharmacode decoder..."
    if [ -n "$python_cmd" ]; then
        (
            set +e
            decode_with_pharmacode "$image" "$out_pharmacode"
            exit $?
        ) &
        local decoder_pid=$!
        
        wait $decoder_pid 2>/dev/null
        local exit_code=$?
        
        if [ $exit_code -eq 0 ] && [ -s "$out_pharmacode" ]; then
            log_success "  ✓ pharmacode: detected"
            ((success_count++))
            all_decoded+=$(cat "$out_pharmacode" 2>/dev/null)$'\n'
            decoder_results+=("pharmacode:$(head -1 "$out_pharmacode" 2>/dev/null)")
        elif [ $exit_code -eq 2 ]; then
            log_info "  ✗ pharmacode: decoder module not installed"
        elif [ $exit_code -eq 1 ]; then
            log_info "  ✗ pharmacode: no Pharmacode found"
        else
            log_info "  ✗ pharmacode: decoder crashed or timed out (skipped)"
        fi
    else
        log_info "  ✗ pharmacode: Python not available"
    fi

    # --- DECODER 49: Code 11 ---
    local out_code11="${TEMP_DIR}_code11.txt"
    log_info "  [49/50] Trying Code 11 decoder..."
    if [ -n "$python_cmd" ]; then
        (
            set +e
            decode_with_code11 "$image" "$out_code11"
            exit $?
        ) &
        local decoder_pid=$!
        
        wait $decoder_pid 2>/dev/null
        local exit_code=$?
        
        if [ $exit_code -eq 0 ] && [ -s "$out_code11" ]; then
            log_success "  ✓ code11: decoded successfully"
            ((success_count++))
            all_decoded+=$(cat "$out_code11" 2>/dev/null)$'\n'
            decoder_results+=("code11:$(head -1 "$out_code11" 2>/dev/null)")
        elif [ $exit_code -eq 2 ]; then
            log_info "  ✗ code11: decoder module not installed"
        elif [ $exit_code -eq 1 ]; then
            log_info "  ✗ code11: no Code 11 found"
        else
            log_info "  ✗ code11: decoder crashed or timed out (skipped)"
        fi
    else
        log_info "  ✗ code11: Python not available"
    fi

    # --- DECODER 50: DPD (Deutsche Post) Barcode ---
    local out_dpd="${TEMP_DIR}_dpd.txt"
    log_info "  [50/50] Trying DPD decoder..."
    if [ -n "$python_cmd" ]; then
        (
            set +e
            decode_with_dpd "$image" "$out_dpd"
            exit $?
        ) &
        local decoder_pid=$!
        
        wait $decoder_pid 2>/dev/null
        local exit_code=$?
        
        if [ $exit_code -eq 0 ] && [ -s "$out_dpd" ]; then
            log_success "  ✓ dpd: decoded successfully"
            ((success_count++))
            all_decoded+=$(cat "$out_dpd" 2>/dev/null)$'\n'
            decoder_results+=("dpd:$(head -1 "$out_dpd" 2>/dev/null)")
        elif [ $exit_code -eq 2 ]; then
            log_info "  ✗ dpd: decoder module not installed"
        elif [ $exit_code -eq 1 ]; then
            log_info "  ✗ dpd: no DPD barcode found"
        else
            log_info "  ✗ dpd: decoder crashed or timed out (skipped)"
        fi
    else
        log_info "  ✗ dpd: Python not available"
    fi

    echo ""
    echo -e "${CYAN}┌─────────────────────────────────────────────────────────────┐${NC}"
    echo -e "${CYAN}│                   DECODER SUMMARY                           │${NC}"
    echo -e "${CYAN}├─────────────────────────────────────────────────────────────┤${NC}"

    # Calculate total decoders attempted
    local total_decoders=50  # Updated: 22 original + 16 extended + 12 new implementations
    
    echo -e "${CYAN}│${NC} Decoders Attempted:   ${WHITE}${total_decoders}${NC}"
    echo -e "${CYAN}│${NC} Successful Decodes:   ${WHITE}${success_count}${NC}"
    # AUDIT FIX: Prevent division by zero
    if [ "${total_decoders:-0}" -gt 0 ]; then
        echo -e "${CYAN}│${NC} Success Rate:         ${WHITE}$((success_count * 100 / total_decoders))%${NC}"
    else
        echo -e "${CYAN}│${NC} Success Rate:         ${WHITE}0%${NC}"
    fi
    # AUDIT FIX: Limit display to first 20 results when all 50 decoders succeed
    local result_count=${#decoder_results[@]}
    if [ "$result_count" -gt 0 ]; then
        echo -e "${CYAN}│${NC} Results:"
        local display_limit=20
        local display_count=0
        for result in "${decoder_results[@]}"; do
            if [ "$display_count" -ge "$display_limit" ] && [ "$result_count" -gt "$display_limit" ]; then
                local remaining=$((result_count - display_limit))
                echo -e "${CYAN}│${NC}   ${YELLOW}...${NC} and ${remaining} more successful decoders (output truncated)"
                break
            fi
            local decoder_name="${result%%:*}"
            local decoded_preview="${result#*:}"
            echo -e "${CYAN}│${NC}   ${GREEN}✓${NC} ${decoder_name}: ${decoded_preview:0:40}..."
            ((display_count++))
        done
    fi
    echo -e "${CYAN}└─────────────────────────────────────────────────────────────┘${NC}"
    echo ""
    
    log_info "Decoder success rate: $success_count/$total_decoders decoders"

    # Decoder inconsistency check - potential evasion
    if [ $success_count -gt 0 ] && [ $success_count -lt 3 ]; then
        analyze_anti_analysis_techniques "$image" "$success_count" "$total_decoders" "${decoder_results[*]}"
    fi

    # Check for decoder disagreement
    # AUDIT FIX: Sample-based comparison to handle 50 decoders efficiently
    if [ ${#decoder_results[@]} -gt 1 ]; then
        local first_result="${decoder_results[0]#*:}"
        local compare_limit=10
        local compare_count=0
        for result in "${decoder_results[@]:1}"; do
            # Limit comparisons to first 10 results for performance
            if [ "$compare_count" -ge "$compare_limit" ]; then
                break
            fi
            if [ "${result#*:}" != "$first_result" ]; then
                # Truncate decoder_results list for log to prevent oversized forensic entry
                local truncated_results="${decoder_results[*]:0:10}"
                log_forensic_detection 30 \
                    "Decoder Disagreement - Payload Manipulation" \
                    "decoder_mismatch:${truncated_results}..." \
                    "Multi-decoder correlation analysis" \
                    "QR decoder output comparison" \
                    "Analyze each decoder output separately - possible evasion or targeted payload" \
                    "MITRE ATT&CK T1027 - Obfuscated Files or Information"
                log_forensic "Decoder results vary (sample): ${truncated_results}..."
                break
            fi
            ((compare_count++))
        done
    fi

    # Merge and output
    echo "$all_decoded" | sort -u > "${base_output}_merged.txt" 2>/dev/null

    # Return 0 if any decoder succeeded
    [ $success_count -gt 0 ]
}

# Helper function to run a single decoder
run_single_decoder() {
    local decoder="$1"
    local image="$2"
    local output="$3"
    
    case "$decoder" in
        zbar) decode_with_zbar "$image" "$output" ;;
        pyzbar) decode_with_pyzbar "$image" "$output" ;;
        opencv) decode_with_opencv "$image" "$output" ;;
        zxingcpp) decode_with_zxingcpp "$image" "$output" ;;
        quirc) decode_with_quirc "$image" "$output" ;;
        dmtx) decode_with_dmtx "$image" "$output" ;;
        pyzbar_enhanced) decode_with_pyzbar_enhanced "$image" "$output" ;;
        multiscale) decode_with_multiscale "$image" "$output" ;;
        inverse) decode_with_inverse "$image" "$output" ;;
        adaptive) decode_with_adaptive "$image" "$output" ;;
        aztec) decode_with_aztec "$image" "$output" ;;
        pdf417) decode_with_pdf417 "$image" "$output" ;;
        code128) decode_with_code128 "$image" "$output" ;;
        code39) decode_with_code39 "$image" "$output" ;;
        ean) decode_with_ean "$image" "$output" ;;
        itf) decode_with_itf "$image" "$output" ;;
        code93) decode_with_code93 "$image" "$output" ;;
        tesseract) decode_with_tesseract_ocr "$image" "$output" ;;
        imagemagick_zbar) decode_with_imagemagick_zbar "$image" "$output" ;;
        universal) decode_with_universal "$image" "$output" ;;
        qr_model1) decode_with_qr_model1 "$image" "$output" ;;
        jabcode) decode_with_jabcode "$image" "$output" ;;
        hccb) decode_with_hccb "$image" "$output" ;;
        micro_qr) decode_with_micro_qr "$image" "$output" ;;
        html_qr_detector) decode_with_html_qr_detector "$image" "$output" ;;
        upc) decode_with_upc "$image" "$output" ;;
        msi) decode_with_msi "$image" "$output" ;;
        telepen) decode_with_telepen "$image" "$output" ;;
        gs1_databar) decode_with_gs1_databar "$image" "$output" ;;
        pharmacode) decode_with_pharmacode "$image" "$output" ;;
        code11) decode_with_code11 "$image" "$output" ;;
        dpd) decode_with_dpd "$image" "$output" ;;
        *) return 1 ;;
    esac
}

multi_decoder_analysis_parallel() {
    local image="$1"
    local base_output="$2"
    local max_parallel="${3:-4}"
    local early_exit_count="${4:-3}"
    
    log_info "Parallel multi-decoder analysis (max ${max_parallel} concurrent)..."
    
    # Validation
    if [[ -z "$image" ]] || [[ ! -f "$image" ]] || [[ ! -r "$image" ]]; then
        log_error "[multi_decoder_analysis_parallel] Image not found or unreadable: '$image'"
        return 10
    fi
    
    local allowed_temp_dir="${TEMP_DIR}/"
    mkdir -p "$allowed_temp_dir" 2>/dev/null
    
    # Priority-based decoder groups
    local priority_high=("zbar" "pyzbar" "opencv" "zxingcpp" "html_qr_detector" "upc")
    local priority_medium=("quirc" "dmtx" "pyzbar_enhanced" "multiscale" "inverse" "adaptive" "gs1_databar" "qr_model1" "micro_qr")
    local priority_low=("aztec" "pdf417" "code128" "code39" "ean" "itf" "code93" "code11" "msi" "telepen" "jabcode" "hccb")
    local priority_specialty=("tesseract" "imagemagick_zbar" "universal" "pharmacode" "dpd")
    
    local success_count=0
    local all_decoded=""
    local decoder_results=()
    
    # Shared aggregation files
    local aggregate_output="${TEMP_DIR}/aggregate_$$.txt"
    local aggregate_summary="${TEMP_DIR}/aggregate_$$_summary.txt"
    local lock_file="${TEMP_DIR}/aggregate_$$.lock"
    
    : > "$aggregate_output"
    : > "$aggregate_summary"
    
    register_temp_file "$aggregate_output"
    register_temp_file "$aggregate_summary"
    register_temp_file "$lock_file"
    
    # Run decoder group function
    run_decoder_group() {
        local group_name="$1"
        shift
        local decoders=("$@")
        
        log_info "  Running ${group_name} (${#decoders[@]} decoders, ${max_parallel} parallel)..."
        
        local pids=()
        local decoder_names=()
        
        for decoder in "${decoders[@]}"; do
            # Early exit check
            success_count=$(wc -l < "$aggregate_summary" 2>/dev/null || echo 0)
            if [[ $success_count -ge $early_exit_count ]]; then
                log_info "  Early exit: $success_count successful decodes achieved"
                break
            fi
            
            # Wait for available slot
            while [[ ${#pids[@]} -ge $max_parallel ]]; do
                for i in "${!pids[@]}"; do
                    if ! kill -0 "${pids[$i]}" 2>/dev/null; then
                        wait "${pids[$i]}" 2>/dev/null
                        unset pids[$i]
                        unset decoder_names[$i]
                    fi
                done
                pids=("${pids[@]}")
                decoder_names=("${decoder_names[@]}")
                sleep 0.1
            done
            
            # Launch decoder in background
            local out_file="${TEMP_DIR}/_${decoder}_$$.txt"
            register_temp_file "$out_file"
            
            (
                local start_time=$(date +%s.%N 2>/dev/null || date +%s)
                run_single_decoder "$decoder" "$image" "$out_file"
                local status=$?
                local end_time=$(date +%s.%N 2>/dev/null || date +%s)
                local duration=$(echo "$end_time - $start_time" | bc 2>/dev/null || echo "0")
                
                if [[ $status -eq 0 ]] && [[ -s "$out_file" ]]; then
                    # AUDIT FIX: Limit file size to 10KB per decoder to prevent memory issues
                    local file_size=$(wc -c < "$out_file" 2>/dev/null || echo 0)
                    if [ "$file_size" -gt 10240 ]; then
                        log_warning "Decoder $decoder output too large (${file_size} bytes), truncating to 10KB"
                        head -c 10240 "$out_file" > "${out_file}.tmp" && mv "${out_file}.tmp" "$out_file"
                    fi
                    
                    # Thread-safe aggregation using flock
                    (
                        flock -x 200 || exit 1
                        cat "$out_file" >> "$aggregate_output"
                        echo "${decoder}:$(head -1 "$out_file"):${duration}" >> "$aggregate_summary"
                    ) 200>"$lock_file"
                fi
                
                exit $status
            ) &
            
            pids+=($!)
            decoder_names+=("$decoder")
        done
        
        # Wait for all in group
        for pid in "${pids[@]}"; do
            wait "$pid" 2>/dev/null
        done
    }
    
    # Execute decoder groups in priority order
    run_decoder_group "high-priority" "${priority_high[@]}"
    
    success_count=$(wc -l < "$aggregate_summary" 2>/dev/null || echo 0)
    if [[ $success_count -lt $early_exit_count ]]; then
        run_decoder_group "medium-priority" "${priority_medium[@]}"
    fi
    
    success_count=$(wc -l < "$aggregate_summary" 2>/dev/null || echo 0)
    if [[ $success_count -lt $early_exit_count ]]; then
        run_decoder_group "low-priority" "${priority_low[@]}"
    fi
    
    # Specialty only if nothing worked
    success_count=$(wc -l < "$aggregate_summary" 2>/dev/null || echo 0)
    if [[ $success_count -eq 0 ]]; then
        run_decoder_group "specialty" "${priority_specialty[@]}"
    fi
    
    # Aggregate results
    if [[ -f "$aggregate_output" ]] && [[ -s "$aggregate_output" ]]; then
        # AUDIT FIX: Limit merged output size to prevent memory issues with 50 decoders
        local agg_size=$(wc -c < "$aggregate_output" 2>/dev/null || echo 0)
        if [ "$agg_size" -gt 500000 ]; then
            log_warning "Aggregate output very large (${agg_size} bytes), truncating to 500KB"
            head -c 500000 "$aggregate_output" | sort -u > "${base_output}_merged.txt"
        else
            sort -u "$aggregate_output" > "${base_output}_merged.txt"
        fi
        all_decoded=$(cat "$aggregate_output")
    fi
    
    # AUDIT FIX: Limit mapfile to 50 entries to handle all decoders succeeding
    if [[ -f "$aggregate_summary" ]] && [[ -s "$aggregate_summary" ]]; then
        local line_count=$(wc -l < "$aggregate_summary" 2>/dev/null || echo 0)
        if [ "$line_count" -gt 50 ]; then
            log_warning "Limiting decoder_results to first 50 of $line_count entries"
            head -50 "$aggregate_summary" > "${aggregate_summary}.limited"
            mapfile -t decoder_results < "${aggregate_summary}.limited"
            rm -f "${aggregate_summary}.limited" 2>/dev/null
        else
            mapfile -t decoder_results < "$aggregate_summary"
        fi
    fi
    
    success_count=${#decoder_results[@]}
    
    # Print summary
    echo ""
    echo -e "${CYAN}┌─────────────────────────────────────────────────────────────┐${NC}"
    echo -e "${CYAN}│              PARALLEL DECODER SUMMARY                       │${NC}"
    echo -e "${CYAN}├─────────────────────────────────────────────────────────────┤${NC}"
    echo -e "${CYAN}│${NC} Successful Decodes:   ${WHITE}${success_count}${NC}"
    
    # AUDIT FIX: Limit display to first 20 results when all 50 decoders succeed
    if [[ ${#decoder_results[@]} -gt 0 ]]; then
        echo -e "${CYAN}│${NC} Results:"
        local display_limit=20
        local display_count=0
        for result in "${decoder_results[@]}"; do
            if [ "$display_count" -ge "$display_limit" ] && [ "${#decoder_results[@]}" -gt "$display_limit" ]; then
                local remaining=$((${#decoder_results[@]} - display_limit))
                echo -e "${CYAN}│${NC}   ${YELLOW}...${NC} and ${remaining} more successful decoders (output truncated)"
                break
            fi
            IFS=':' read -r decoder_name decoded_preview duration <<< "$result"
            echo -e "${CYAN}│${NC}   ${GREEN}✓${NC} ${decoder_name} (${duration}s): ${decoded_preview:0:35}..."
            ((display_count++))
        done
    fi
    echo -e "${CYAN}└─────────────────────────────────────────────────────────────┘${NC}"
    echo ""
    
    [[ $success_count -gt 0 ]]
}

################################################################################
# ANTI-ANALYSIS DETECTION ENGINE
# Detects QR codes designed to evade automated analysis
################################################################################

# Anti-analysis technique signatures
declare -A ANTI_ANALYSIS_SIGNATURES=(
    # QR Structure Manipulation
    ["format_info_corruption"]="Corrupted format information bits"
    ["version_info_manipulation"]="Modified version information"
    ["error_correction_abuse"]="Abnormal error correction usage"
    ["finder_pattern_obfuscation"]="Modified finder patterns"
    ["timing_pattern_disruption"]="Disrupted timing patterns"
    ["alignment_pattern_shift"]="Shifted alignment patterns"
    ["masking_pattern_abuse"]="Non-standard masking pattern"
    
    # Data Encoding Evasion
    ["mixed_encoding_modes"]="Mixed encoding mode abuse"
    ["padding_bit_manipulation"]="Unusual padding bits"
    ["terminator_sequence_abuse"]="Modified terminator sequence"
    ["eci_mode_evasion"]="ECI mode for evasion"
    ["structured_append_abuse"]="Structured append manipulation"
    ["fnc1_mode_abuse"]="FNC1 mode misuse"
    
    # Visual Anti-Analysis
    ["micro_qr_evasion"]="Micro QR variant for scanner evasion"
    ["color_gradient_obfuscation"]="Color gradient to confuse scanners"
    ["noise_injection"]="Noise injected into QR"
    ["module_size_variation"]="Inconsistent module sizes"
    ["quiet_zone_violation"]="Insufficient quiet zone"
    ["aspect_ratio_manipulation"]="Non-square aspect ratio"
    
    # Decoder-Specific Targeting
    ["zbar_specific_evasion"]="ZBar-specific evasion technique"
    ["zxing_specific_evasion"]="ZXing-specific evasion technique"
    ["quirc_specific_evasion"]="Quirc-specific evasion technique"
    
    # Anti-Forensic Techniques
    ["metadata_stripping"]="Metadata intentionally stripped"
    ["timestamp_manipulation"]="Timestamp manipulation detected"
    ["steganographic_embedding"]="Hidden data in QR structure"
    
    # Hardened: Additional advanced anti-analysis and evasion techniques
    ["multi_payload_layers"]="Multiple payload layers targeting different decoders"
    ["payload_fragmentation"]="Fragmented payload across QR modules"
    ["intentional_decoding_disagreement"]="Different outputs for different decoders"
    ["conditional_decoding"]="Payload visible only under certain decoding conditions"
    ["decoder_mimicry"]="QR crafted to mimic known decoder bugs"
    ["scaling_confusion"]="Resolution-dependent payload emission"
    ["partial_symbol_persistence"]="Intentionally incomplete QR but persistent payload"
    ["chromatic_aberration"]="Color-led decoding failure"
    ["inverse_detection_evasion"]="Fails on negative/inverse decode"
    ["timing_attack_payload"]="Time-dependent decoding tricks"
    ["device_specific_evasion"]="Payload abuses specific device/sensor"
    ["thermal_forgery"]="Payload hidden in thermal imaging"
    ["nonvisible_spectrum_trick"]="Payload in IR/UV QR modules"
    ["qr_code_overlay"]="Overlay or sticker technique for partial read"
    ["canvas_distortion"]="Printed with curl, crease, or distortion"
    ["frame_bypass"]="QR rendered in frame/animation to evade"
    ["ml_adversarial_attack"]="Adversarial patch to evade ML scanners"
    ["font_glyph_hacking"]="Payload via glyph/font hack"
    ["deepfake_visual_evasion"]="Computer vision deepfake to trick scanners"
    ["noise_pattern_surrogate"]="Injected surrogate module pattern"
    ["watermark_embedding"]="Covert watermark in scanning visual"
    
    # HTML/Web-Generated QR Fraud Signatures
    ["html_canvas_generation"]="QR generated via HTML5 Canvas (common in phishing)"
    ["javascript_qr_library"]="JavaScript QR library signature detected"
    ["svg_to_raster_conversion"]="SVG-to-raster conversion artifacts"
    ["web_generator_signature"]="Online QR generator fingerprint"
    ["programmatic_generation"]="Programmatically generated without camera/scanner"
    ["missing_exif_fraud"]="Missing EXIF data indicating fake/fraudulent generation"
    ["canvas_render_signature"]="HTML Canvas rendering signature (binary colors)"
    ["js_library_dimensions"]="Dimensions matching common JS QR libraries"
    ["perfect_pixel_alignment"]="Perfect pixel alignment indicating HTML generation"
    ["png_export_pattern"]="PNG export pattern from web tools"
)

# Anti-analysis IOC patterns
declare -a ANTI_ANALYSIS_IOC_PATTERNS=(
    "low_decoder_success_rate"
    "decoder_disagreement"
    "high_error_correction_usage"
    "unusual_qr_version"
    "non_standard_encoding"
    "visual_obfuscation"
    "noise_pattern_detected"
    "gradient_mask_detected"
    "finder_pattern_anomaly"
    "alignment_anomaly"
    "timing_pattern_anomaly"
    "quiet_zone_insufficient"
    "module_size_irregular"
    "aspect_ratio_abnormal"
    "metadata_absent"
    "creation_tool_hidden"
    "suspicious_color_depth"
    "embedded_payload_structure"

    # Hardened: Advanced anti-analysis IOCs for cutting-edge evasion/payloads
    "fragmented_payload_detected"
    "layered_payload_detected"
    "conditional_decoding_observed"
    "device_specific_artifact"
    "adversarial_patch_present"
    "multi_decoder_payload_variation"
    "thermal_or_ir_spectrum_feature"
    "deepfake_visual_feature"
    "glyph_manipulation_detected"
    "overlay_or_sticker_detected"
    "watermark_payload_detected"
    "ml_evasion_pattern"
    "partial_symbol_persistence"
    "scaling_or_resolution_dependence"
    "canvas_distortion_observed"
    "frame_or_animation_bypass"
    "font_hack_payload"
    "nonvisible_spectrum_anomaly"
    
    # HTML/JavaScript QR Fraud IOCs
    "html_canvas_detected"
    "js_qr_library_detected"
    "web_generator_fingerprint"
    "programmatic_no_exif"
    "canvas_binary_colors"
    "svg_derived_pattern"
    "js_library_size_match"
    "perfect_module_alignment"
    "png_no_artifacts_web"
)

analyze_anti_analysis_techniques() {
    set +u
    local image="${1:-}"
    set -u
    local success_count="${2:-0}"
    local total_decoders="${3:-1}"
    local decoder_results="${4:-}"
    
    local anti_analysis_findings=()
    local total_score=0
    local iocs_detected=()
    
    log_info "Running anti-analysis detection engine..."
    
    # ═══════════════════════════════════════════════════════════════════════════
    # 1. LOW DECODER SUCCESS RATE ANALYSIS
    # ═══════════════════════════════════════════════════════════════════════════
    if [ "$success_count" -gt 0 ] && [ "$success_count" -lt 3 ]; then
        # AUDIT FIX: Prevent division by zero
        local success_rate=0
        if [ "${total_decoders:-0}" -gt 0 ]; then
            success_rate=$((success_count * 100 / total_decoders))
        fi
        anti_analysis_findings+=("Low decoder success rate: ${success_count}/${total_decoders} (${success_rate}%)")
        iocs_detected+=("low_decoder_success_rate:${success_rate}%")
        
        # Determine which decoders failed for targeted analysis
        local failed_decoders=""
        for decoder in zbarimg quirc zxing qrdecode opencv opencv_wechat boofcv pyzbar zbarcam; do
            if command -v "$decoder" &>/dev/null 2>&1 || [ -f "/usr/local/bin/$decoder" ]; then
                if ! echo "$decoder_results" | grep -q "^$decoder:"; then
                    failed_decoders+="$decoder "
                fi
            fi
        done
        
        if [ -n "$failed_decoders" ]; then
            anti_analysis_findings+=("Failed decoders: $failed_decoders")
            iocs_detected+=("failed_decoders:$failed_decoders")
        fi
        
        total_score=$((total_score + 20))
    fi
    
    # ═══════════════════════════════════════════════════════════════════════════
    # 2. QR CODE STRUCTURE ANALYSIS
    # ═══════════════════════════════════════════════════════════════════════════
    if command -v identify &>/dev/null && [ -f "$image" ]; then
        local img_info
        img_info=$(identify -verbose "$image" 2>/dev/null)
        
        # Check for unusual dimensions (non-standard QR sizes)
        local width height
        width=$(echo "$img_info" | grep -E "^[[:space:]]+Geometry:" | sed 's/.*: *\([0-9]*\)x.*/\1/')
        height=$(echo "$img_info" | grep -E "^[[:space:]]+Geometry:" | sed 's/.*x\([0-9]*\)+.*/\1/')
        
        if [ -n "$width" ] && [ -n "$height" ]; then
            # Check aspect ratio
            # AUDIT FIX: Prevent division by zero and integer comparison errors
            # Check that width and height are numeric and non-zero
            if [[ "$width" =~ ^[0-9]+$ ]] && [[ "$height" =~ ^[0-9]+$ ]] && [ "$width" -gt 0 ] && [ "$height" -gt 0 ]; then
                if [ "$width" -ne "$height" ]; then
                    local ratio=$((width * 100 / height))
                    if [ "$ratio" -lt 90 ] || [ "$ratio" -gt 110 ]; then
                        anti_analysis_findings+=("Abnormal aspect ratio: ${width}x${height} (${ratio}%)")
                        iocs_detected+=("aspect_ratio_abnormal:${ratio}%")
                        total_score=$((total_score + 15))
                    fi
                fi
            
                # Check for unusual QR code versions (very large dimensions)
                if [ "$width" -gt 1000 ] || [ "$height" -gt 1000 ]; then
                    anti_analysis_findings+=("Unusually large QR: ${width}x${height}")
                    iocs_detected+=("unusual_qr_version:large_${width}x${height}")
                    total_score=$((total_score + 10))
                fi
            fi
        fi
        
        # Check color depth
        local color_depth
        color_depth=$(echo "$img_info" | grep -E "^[[:space:]]+Depth:" | sed 's/.*: *\([0-9]*\).*/\1/')
        # AUDIT FIX: Add numeric validation before integer comparison
        if [ -n "$color_depth" ] && [[ "$color_depth" =~ ^[0-9]+$ ]] && [ "$color_depth" -gt 8 ]; then
            anti_analysis_findings+=("High color depth for QR: ${color_depth}-bit")
            iocs_detected+=("suspicious_color_depth:${color_depth}bit")
            total_score=$((total_score + 10))
        fi
        
        # Check for color QR (potential visual obfuscation)
        local color_type
        color_type=$(echo "$img_info" | grep -E "^[[:space:]]+Type:" | head -1)
        if echo "$color_type" | grep -qiE "TrueColor|RGB|Palette"; then
            anti_analysis_findings+=("Color QR detected (potential obfuscation): $color_type")
            iocs_detected+=("visual_obfuscation:color_qr")
            total_score=$((total_score + 5))
        fi
    fi
    
    # ═══════════════════════════════════════════════════════════════════════════
    # 3. METADATA ANALYSIS (Anti-Forensic Detection)
    # ═══════════════════════════════════════════════════════════════════════════
    if command -v exiftool &>/dev/null && [ -f "$image" ]; then
        local metadata
        metadata=$(exiftool "$image" 2>/dev/null)
        
        # Check for stripped metadata
        local metadata_count
        metadata_count=$(echo "$metadata" | wc -l)
        if [ "$metadata_count" -lt 5 ]; then
            anti_analysis_findings+=("Minimal metadata (${metadata_count} fields) - possible stripping")
            iocs_detected+=("metadata_absent:${metadata_count}_fields")
            total_score=$((total_score + 15))
        fi
        
        # Check for missing creation tool
        if ! echo "$metadata" | grep -qiE "Software|Creator|Producer|Generator"; then
            anti_analysis_findings+=("No creation tool identified - metadata stripped")
            iocs_detected+=("creation_tool_hidden")
            total_score=$((total_score + 10))
        fi
        
        # Check for timestamp anomalies
        local create_date modify_date
        create_date=$(echo "$metadata" | grep -i "Create Date" | head -1)
        modify_date=$(echo "$metadata" | grep -i "Modify Date" | head -1)
        
        if [ -n "$create_date" ] && [ -n "$modify_date" ]; then
            if [ "$create_date" != "$modify_date" ]; then
                anti_analysis_findings+=("Timestamp mismatch: Create vs Modify")
                iocs_detected+=("timestamp_manipulation")
                total_score=$((total_score + 10))
            fi
        fi
    fi
    
    # ═══════════════════════════════════════════════════════════════════════════
    # 4. NOISE AND VISUAL MANIPULATION DETECTION
    # ═══════════════════════════════════════════════════════════════════════════
    if command -v convert &>/dev/null && [ -f "$image" ]; then
        # Check for noise patterns
        local noise_level
        noise_level=$(convert "$image" -colorspace Gray -statistic StandardDeviation 1x1 -format "%[mean]" info: 2>/dev/null)
        
        if [ -n "$noise_level" ]; then
            # High noise might indicate intentional obfuscation
            local noise_int=${noise_level%.*}
            if [ "${noise_int:-0}" -gt 20000 ]; then
                anti_analysis_findings+=("High noise level detected: ${noise_level}")
                iocs_detected+=("noise_pattern_detected:${noise_int}")
                total_score=$((total_score + 15))
            fi
        fi
        
        # Check for gradient (non-uniform module colors)
        local unique_colors
        unique_colors=$(convert "$image" -unique-colors txt: 2>/dev/null | wc -l)
        if [ "${unique_colors:-0}" -gt 10 ]; then
            anti_analysis_findings+=("Multiple colors in QR (${unique_colors}) - possible gradient obfuscation")
            iocs_detected+=("gradient_mask_detected:${unique_colors}_colors")
            total_score=$((total_score + 10))
        fi
    fi
    
    # ═══════════════════════════════════════════════════════════════════════════
    # 5. QR CODE BINARY STRUCTURE ANALYSIS
    # ═══════════════════════════════════════════════════════════════════════════
    if [ -f "$image" ]; then
        # Check PNG structure for anomalies
        if file "$image" | grep -qi "PNG"; then
            # Check for unusual chunk order or extra chunks
            local chunk_info
            if command -v pngcheck &>/dev/null; then
                chunk_info=$(pngcheck -v "$image" 2>&1)
                
                if echo "$chunk_info" | grep -qiE "tEXt|zTXt|iTXt"; then
                    local text_chunks
                    text_chunks=$(echo "$chunk_info" | grep -ciE "tEXt|zTXt|iTXt")
                    if [ "$text_chunks" -gt 3 ]; then
                        anti_analysis_findings+=("Multiple text chunks in PNG (${text_chunks}) - possible hidden data")
                        iocs_detected+=("embedded_payload_structure:${text_chunks}_chunks")
                        total_score=$((total_score + 15))
                    fi
                fi
            fi
        fi
        
        # Check for appended data after image end
        if command -v binwalk &>/dev/null; then
            local binwalk_results
            binwalk_results=$(binwalk "$image" 2>/dev/null | wc -l)
            if [ "${binwalk_results:-0}" -gt 3 ]; then
                anti_analysis_findings+=("Multiple embedded files detected by binwalk")
                iocs_detected+=("steganographic_embedding:${binwalk_results}_objects")
                total_score=$((total_score + 20))
            fi
        fi
    fi
    
    # ═══════════════════════════════════════════════════════════════════════════
    # 5. HTML/WEB-GENERATED QR FRAUD DETECTION
    # ═══════════════════════════════════════════════════════════════════════════
    if [ -n "$decoder_results" ] && echo "$decoder_results" | grep -q "html_qr_detector:"; then
        anti_analysis_findings+=("HTML/JavaScript-generated QR code detected")
        iocs_detected+=("html_canvas_detected")
        total_score=$((total_score + 40))
        
        # Check for specific HTML generation indicators
        local html_indicators
        html_indicators=$(echo "$decoder_results" | grep "html_qr_detector:" | grep -o "HTML_GENERATION_INDICATORS:[^:]*")
        
        if [ -n "$html_indicators" ]; then
            if echo "$html_indicators" | grep -q "canvas_render_signature"; then
                anti_analysis_findings+=("HTML Canvas binary color signature - programmatic generation")
                iocs_detected+=("canvas_binary_colors")
                total_score=$((total_score + 15))
            fi
            
            if echo "$html_indicators" | grep -q "svg_derived"; then
                anti_analysis_findings+=("SVG-derived QR code - web generator signature")
                iocs_detected+=("svg_derived_pattern")
                total_score=$((total_score + 10))
            fi
            
            if echo "$html_indicators" | grep -q "JS_LIBRARY_SIZE"; then
                anti_analysis_findings+=("JavaScript QR library dimension signature detected")
                iocs_detected+=("js_library_size_match")
                total_score=$((total_score + 15))
            fi
            
            if echo "$html_indicators" | grep -q "PRECISE_MODULE_ALIGNMENT"; then
                anti_analysis_findings+=("Perfect module alignment - JavaScript library generation")
                iocs_detected+=("perfect_module_alignment")
                total_score=$((total_score + 10))
            fi
            
            if echo "$html_indicators" | grep -q "PNG_NO_ARTIFACTS"; then
                anti_analysis_findings+=("PNG without JPEG artifacts - HTML Canvas export")
                iocs_detected+=("png_no_artifacts_web")
                total_score=$((total_score + 10))
            fi
        fi
        
        # Check for programmatic generation (no EXIF)
        if echo "$decoder_results" | grep -q "FORENSIC:no_exif_programmatic_generation"; then
            anti_analysis_findings+=("No EXIF data - programmatic generation confirmed")
            iocs_detected+=("programmatic_no_exif")
            total_score=$((total_score + 20))
        fi
        
        # High threat score indicates likely phishing/fraud QR
        if [ "$total_score" -ge 70 ]; then
            log_forensic_detection 90 \
                "HIGH RISK: HTML-Generated QR Code - Likely Phishing/Fraud" \
                "html_fraud:$(echo "$html_indicators" | cut -d: -f2-)" \
                "HTML QR fraud detector + forensic analysis" \
                "QR generation method and image characteristics" \
                "CRITICAL: HTML-generated QRs with missing EXIF are common in phishing campaigns. Verify QR destination URL before scanning." \
                "MITRE ATT&CK T1566.002 - Phishing: Spearphishing Link, T1204.001 - User Execution: Malicious Link"
        fi
    fi
    
    # ═══════════════════════════════════════════════════════════════════════════
    # 6. DECODER-SPECIFIC EVASION DETECTION
    # ═══════════════════════════════════════════════════════════════════════════
    if [ -n "$decoder_results" ]; then
        # Check if only specific decoders succeeded (targeted evasion)
        local zbar_success=0
        local zxing_success=0
        local quirc_success=0
        
        echo "$decoder_results" | grep -q "zbarimg:" && zbar_success=1
        echo "$decoder_results" | grep -q "zxing:" && zxing_success=1
        echo "$decoder_results" | grep -q "quirc:" && quirc_success=1
        
        if [ $zbar_success -eq 0 ] && [ $zxing_success -eq 1 ]; then
            anti_analysis_findings+=("ZBar failed but ZXing succeeded - possible ZBar-specific evasion")
            iocs_detected+=("zbar_specific_evasion")
            total_score=$((total_score + 15))
        fi
        
        if [ $zxing_success -eq 0 ] && [ $zbar_success -eq 1 ]; then
            anti_analysis_findings+=("ZXing failed but ZBar succeeded - possible ZXing-specific evasion")
            iocs_detected+=("zxing_specific_evasion")
            total_score=$((total_score + 15))
        fi
    fi
    
    # ═══════════════════════════════════════════════════════════════════════════
    # OUTPUT FORENSIC DETECTION RESULTS
    # ═══════════════════════════════════════════════════════════════════════════
    if [ ${#anti_analysis_findings[@]} -gt 0 ]; then
        local ioc_string
        ioc_string=$(IFS=', '; echo "${iocs_detected[*]}")
        local findings_string
        findings_string=$(IFS='; '; echo "${anti_analysis_findings[*]}")
        
        log_forensic_detection "$total_score" \
            "Anti-Analysis Techniques Detected" \
            "$ioc_string" \
            "Multi-decoder analysis, structure analysis, metadata forensics, visual analysis" \
            "QR code image and decoded content" \
            "Investigate QR source - likely designed to evade automated security scanning. Manual analysis recommended." \
            "MITRE ATT&CK T1027.001 - Binary Padding, T1027.002 - Software Packing"
        
        # Additional detailed output
        echo -e "    ${CYAN}├─ Findings:${NC}"
        for finding in "${anti_analysis_findings[@]}"; do
            echo -e "    ${CYAN}│   ├─${NC} $finding"
        done
        echo -e "    ${CYAN}├─ IOCs Detected:${NC}"
        for ioc in "${iocs_detected[@]}"; do
            echo -e "    ${CYAN}│   ├─${NC} $ioc"
        done
        echo -e "    ${CYAN}└─ Anti-Analysis Signatures Matched:${NC} ${#anti_analysis_findings[@]}"
        
        # Record all IOCs
        for ioc in "${iocs_detected[@]}"; do
            record_ioc "Anti-Analysis" "$ioc" "Structure/Behavioral Analysis"
        done
        
        # Write to dedicated report
        if [ -n "$OUTPUT_DIR" ] && [ -d "$OUTPUT_DIR" ]; then
            local anti_analysis_report="${OUTPUT_DIR}/anti_analysis_detection.txt"
            {
                echo "═══════════════════════════════════════════════════════════════"
                echo "ANTI-ANALYSIS DETECTION REPORT"
                echo "═══════════════════════════════════════════════════════════════"
                echo "Timestamp: $(date -u +"%Y-%m-%dT%H:%M:%SZ")"
                echo "Image: $image"
                echo "Total Score: $total_score"
                echo "Decoder Success Rate: ${success_count}/${total_decoders}"
                echo ""
                echo "FINDINGS:"
                for finding in "${anti_analysis_findings[@]}"; do
                    echo "  - $finding"
                done
                echo ""
                echo "IOCS:"
                for ioc in "${iocs_detected[@]}"; do
                    echo "  - $ioc"
                done
                echo ""
                echo "RECOMMENDATIONS:"
                echo "  1. Do not trust decoded content without manual verification"
                echo "  2. Analyze with multiple QR decoder implementations"
                echo "  3. Check for hidden payloads in image structure"
                echo "  4. Investigate QR code origin and distribution method"
                echo "  5. Consider the QR as potentially weaponized"
            } >> "$anti_analysis_report"
        fi
    else
        log_success "No anti-analysis techniques detected"
    fi
    
    return 0
}

################################################################################
# EXTENDED YARA-LIKE RULES
################################################################################

init_extended_yara_rules() {
    log_info "Initializing extended YARA rules..."
    
    # Cloud Service Abuse Rule
    YARA_RULES["cloud_abuse"]='
        strings:
            $gdrive = "drive.google.com" nocase
            $s3 = "s3.amazonaws.com" nocase
            $azure = "blob.core.windows.net" nocase
            $dropbox = "dropboxusercontent.com" nocase
            $discord = "cdn.discordapp.com" nocase
            $download = "download" nocase
            $exe = ".exe" nocase
            $dll = ".dll" nocase
        condition:
            ($gdrive or $s3 or $azure or $dropbox or $discord) and ($download or $exe or $dll)
        severity: HIGH
    '
    
    # Fileless Malware Rule
    YARA_RULES["fileless_malware"]='
        strings:
            $ps_enc = "-encodedcommand" nocase
            $ps_iex = "IEX" nocase
            $ps_download = "downloadstring" nocase
            $ps_webclient = "Net.WebClient" nocase
            $certutil = "certutil" nocase
            $mshta = "mshta" nocase
            $regsvr32 = "regsvr32" nocase
            $rundll32 = "rundll32" nocase
            $bitsadmin = "bitsadmin" nocase
            $wmic = "wmic" nocase
            $hidden = "-w hidden" nocase
            $bypass = "bypass" nocase
        condition:
            3 of them
        severity: CRITICAL
    '
    
    # Mobile Deep Link Abuse Rule
    YARA_RULES["mobile_deeplink_abuse"]='
        strings:
            $itms = "itms-services://" nocase
            $intent = "intent://" nocase
            $mobileconfig = ".mobileconfig" nocase
            $market = "market://" nocase
            $apk = ".apk" nocase
            $ipa = ".ipa" nocase
            $manifest = "download-manifest" nocase
        condition:
            any of them
        severity: HIGH
    '
    
    # Bluetooth/NFC Attack Rule
    YARA_RULES["wireless_attack"]='
        strings:
            $bt = "bluetooth://" nocase
            $nfc = "nfc://" nocase
            $ble = "ble://" nocase
            $wifi = "WIFI:" nocase
            $bt_mac = /[0-9A-Fa-f]{2}:[0-9A-Fa-f]{2}:[0-9A-Fa-f]{2}:[0-9A-Fa-f]{2}:[0-9A-Fa-f]{2}:[0-9A-Fa-f]{2}/
        condition:
            any of them
        severity: MEDIUM
    '
    
    # Tor/Darknet Rule
    YARA_RULES["tor_darknet"]='
        strings:
            $onion = ".onion" nocase
            $tor = "torproject" nocase
            $tor2web = "tor2web" nocase
            $darknet = "darknet" nocase
            $deepweb = "deepweb" nocase
            $hidden = "hidden service" nocase
        condition:
            any of them
        severity: HIGH
    '
    
    # Ransomware Note Rule
    YARA_RULES["ransomware_note"]='
        strings:
            $enc1 = "files have been encrypted" nocase
            $enc2 = "data has been encrypted" nocase
            $pay1 = "pay" nocase
            $pay2 = "bitcoin" nocase
            $pay3 = "ransom" nocase
            $decrypt = "decrypt" nocase
            $deadline = "deadline" nocase
            $price = "price" nocase
        condition:
            ($enc1 or $enc2) and ($pay1 or $pay2 or $pay3) and $decrypt
        severity: CRITICAL
    '
    
    # Office Macro Abuse Rule
    YARA_RULES["office_macro_abuse"]='
        strings:
            $auto1 = "AutoOpen" nocase
            $auto2 = "Document_Open" nocase
            $auto3 = "Workbook_Open" nocase
            $shell = "WScript.Shell" nocase
            $create = "CreateObject" nocase
            $ps = "powershell" nocase
            $cmd = "cmd.exe" nocase
            $download = "URLDownloadToFile" nocase
        condition:
            ($auto1 or $auto2 or $auto3) and ($shell or $create) and ($ps or $cmd or $download)
        severity: CRITICAL
    '
    
    # Follina/MSDT Rule
    YARA_RULES["follina_exploit"]='
        strings:
            $msdt1 = "ms-msdt:" nocase
            $msdt2 = "msdt.exe" nocase
            $pcw = "PCWDiagnostic" nocase
            $rebrowse = "IT_RebrowseForFile" nocase
            $launch = "IT_LaunchMethod" nocase
        condition:
            ($msdt1 or $msdt2) and ($pcw or $rebrowse or $launch)
        severity: CRITICAL
    '
    
    # AMSI Bypass Rule
    YARA_RULES["amsi_bypass"]='
        strings:
            $amsi1 = "amsiInitFailed" nocase
            $amsi2 = "AmsiScanBuffer" nocase
            $amsi3 = "amsi.dll" nocase
            $amsi4 = "AmsiUtils" nocase
            $reflect = "Reflection.Assembly" nocase
            $virtual = "VirtualProtect" nocase
        condition:
            2 of them
        severity: CRITICAL
    '
    
    # Hardware/IoT Exploit Rule
    YARA_RULES["hardware_exploit"]='
        strings:
            $pos1 = "verifone" nocase
            $pos2 = "ingenico" nocase
            $iot1 = "busybox" nocase
            $iot2 = "/etc/passwd" nocase
            $cam1 = "hikvision" nocase
            $cam2 = "dahua" nocase
            $rtsp = "rtsp://" nocase
            $overflow = /A{100,}|%00{20,}/
        condition:
            any of them
        severity: HIGH
    '
    
    # Social Engineering Urgency Rule
    YARA_RULES["social_engineering"]='
        strings:
            $urgent1 = "urgent" nocase
            $urgent2 = "immediate" nocase
            $urgent3 = "act now" nocase
            $expire = "expires" nocase
            $deadline = "deadline" nocase
            $account1 = "account suspended" nocase
            $account2 = "account compromised" nocase
            $verify = "verify your" nocase
            $confirm = "confirm your" nocase
        condition:
            3 of them
        severity: MEDIUM
    '
    
    # BEC Wire Transfer Rule
    YARA_RULES["bec_wire_fraud"]='
        strings:
            $wire = "wire transfer" nocase
            $bank1 = "change bank" nocase
            $bank2 = "new account" nocase
            $urgent = "urgent payment" nocase
            $conf = "confidential" nocase
            $ceo = "ceo" nocase
            $exec = "executive" nocase
            $gift = "gift card" nocase
        condition:
            ($wire or $bank1 or $bank2) and ($urgent or $conf or $ceo or $exec)
        severity: CRITICAL
    '
    
    # Geofencing/Cloaking Rule
    YARA_RULES["geofencing_cloaking"]='
        strings:
            $geo1 = "geolocation" nocase
            $geo2 = "geoip" nocase
            $geo3 = "ipinfo.io" nocase
            $geo4 = "ip-api.com" nocase
            $geo5 = "maxmind" nocase
            $country = "country" nocase
            $redirect = "redirect" nocase
            $block = "block" nocase
        condition:
            ($geo1 or $geo2 or $geo3 or $geo4 or $geo5) and ($redirect or $block)
        severity: MEDIUM
    '
    
    # Steganography Indicator Rule
    YARA_RULES["steganography_indicator"]='
        strings:
            $steg1 = "steghide" nocase
            $steg2 = "outguess" nocase
            $steg3 = "invisible secrets" nocase
            $lsb = "LSB" nocase
            $embed = "embedded" nocase
            $hidden = "hidden data" nocase
        condition:
            any of them
        severity: MEDIUM
    '
    
    # Zero-Day/Exploit Kit Indicator Rule
    YARA_RULES["exploit_kit_indicator"]='
        strings:
            $ek1 = "angler" nocase
            $ek2 = "rig" nocase
            $ek3 = "magnitude" nocase
            $ek4 = "sundown" nocase
            $ek5 = "fallout" nocase
            $ek6 = "purple fox" nocase
            $landing = "landing" nocase
            $gate = "gate" nocase
            $iframe = "<iframe" nocase
            $obf = /eval\(function\(/
        condition:
            ($ek1 or $ek2 or $ek3 or $ek4 or $ek5 or $ek6) or ($iframe and $obf)
        severity: CRITICAL
    '
    
    # Protocol Handler Abuse Rule
    YARA_RULES["protocol_handler_abuse"]='
        strings:
            $ms1 = "ms-msdt:" nocase
            $ms2 = "ms-officecmd:" nocase
            $ms3 = "ms-word:" nocase
            $ms4 = "ms-excel:" nocase
            $ms5 = "ms-powerpoint:" nocase
            $ms6 = "search-ms:" nocase
            $vscode = "vscode://" nocase
            $cursor = "cursor://" nocase
        condition:
            any of them
        severity: HIGH
    '
    
    # Adversarial ML/AI Attack Rule
    YARA_RULES["adversarial_ai"]='
        strings:
            $adv1 = "adversarial" nocase
            $adv2 = "perturbation" nocase
            $adv3 = "evasion attack" nocase
            $ml1 = "machine learning" nocase
            $ml2 = "neural network" nocase
            $ml3 = "classifier" nocase
        condition:
            ($adv1 or $adv2 or $adv3) and ($ml1 or $ml2 or $ml3)
        severity: HIGH
    '
    
    # QR Sequence/Animated Attack Rule
    YARA_RULES["qr_sequence_attack"]='
        strings:
            $seq1 = "sequence" nocase
            $seq2 = "part" nocase
            $seq3 = "continue" nocase
            $anim = "animated" nocase
            $multi = "multiple" nocase
            $scan = "scan" nocase
        condition:
            ($seq1 or $seq2 or $seq3 or $multi) and $scan
        severity: MEDIUM
    '
    
    # =========================================================================
    # AUDIT-COMPLIANT YARA RULES - Extended Detection Coverage
    # =========================================================================
    
    # RULE_WEBSHELL_INDICATORS - Web shell deployment patterns
    YARA_RULES["webshell_indicators"]='
        strings:
            $php_shell1 = /\$_(GET|POST|REQUEST|COOKIE)\s*\[/ nocase
            $php_shell2 = /eval\s*\(\s*\$_/ nocase
            $php_shell3 = "system($_" nocase
            $php_shell4 = "passthru($_" nocase
            $php_shell5 = "shell_exec($_" nocase
            $php_shell6 = "exec($_" nocase
            $php_shell7 = "base64_decode($_" nocase
            $asp_shell1 = "Execute(Request" nocase
            $asp_shell2 = "Eval(Request" nocase
            $jsp_shell1 = "Runtime.getRuntime().exec" nocase
            $jsp_shell2 = "ProcessBuilder" nocase
            $c99 = "c99shell" nocase
            $r57 = "r57shell" nocase
            $b374k = "b374k" nocase
            $wso = "WSO" nocase
            $alfa = "AlfaShell" nocase
            $weevely = "weevely" nocase
            $phpspy = "phpspy" nocase
            $chopper = "chopper" nocase
            $godzilla = "godzilla" nocase
            $behinder = "behinder" nocase
            $antsword = "antsword" nocase
        condition:
            3 of them
        severity: CRITICAL
    '
    
    # RULE_ROOTKIT_SIGNATURES - Rootkit installation indicators
    YARA_RULES["rootkit_signatures"]='
        strings:
            $lkm1 = "init_module" nocase
            $lkm2 = "cleanup_module" nocase
            $lkm3 = "module_init" nocase
            $sys1 = "sys_call_table" nocase
            $sys2 = "kallsyms_lookup_name" nocase
            $sys3 = "__NR_" nocase
            $hide1 = "hide_process" nocase
            $hide2 = "hide_file" nocase
            $hide3 = "hide_module" nocase
            $hook1 = "syscall_hook" nocase
            $hook2 = "vfs_read_hook" nocase
            $hook3 = "getdents_hook" nocase
            $kit1 = "azazel" nocase
            $kit2 = "jynx2" nocase
            $kit3 = "bdvl" nocase
            $kit4 = "reptile" nocase
            $kit5 = "diamorphine" nocase
            $kit6 = "beurk" nocase
            $lib1 = "LD_PRELOAD" nocase
            $lib2 = "/etc/ld.so.preload" nocase
        condition:
            3 of them
        severity: CRITICAL
    '
    
    # RULE_BOOTKIT_PATTERNS - Bootkit/MBR infection
    YARA_RULES["bootkit_patterns"]='
        strings:
            $mbr1 = "MBR" nocase
            $mbr2 = { 55 AA } 
            $vbr1 = "VBR" nocase
            $boot1 = "bootkit" nocase
            $boot2 = "bootsector" nocase
            $boot3 = "bootmgr" nocase
            $boot4 = "winload" nocase
            $uefi1 = "UEFI" nocase
            $uefi2 = "bootx64" nocase
            $uefi3 = ".efi" nocase
            $tdl1 = "TDL4" nocase
            $tdl2 = "TDL3" nocase
            $tdss = "TDSS" nocase
            $mebromi = "mebromi" nocase
            $rovnix = "rovnix" nocase
            $carberp = "carberp" nocase
            $gapz = "gapz" nocase
            $hd1 = "\\.\PhysicalDrive0" nocase
            $hd2 = "/dev/sda" nocase
            $hd3 = "dd if=" nocase
        condition:
            3 of them
        severity: CRITICAL
    '
    
    # RULE_FIRMWARE_IMPLANTS - UEFI/firmware malware indicators
    YARA_RULES["firmware_implants"]='
        strings:
            $uefi1 = "DXE_DRIVER" nocase
            $uefi2 = "EFI_BOOT_SERVICES" nocase
            $uefi3 = "EFI_RUNTIME_SERVICES" nocase
            $uefi4 = "gBS->" nocase
            $uefi5 = "gRT->" nocase
            $spi1 = "SPI Flash" nocase
            $spi2 = "FlashRegion" nocase
            $bios1 = "BIOS" nocase
            $bios2 = "SMM" nocase
            $bios3 = "System Management Mode" nocase
            $fw1 = "firmware" nocase
            $fw2 = "flashrom" nocase
            $fw3 = "dmidecode" nocase
            $lj1 = "LoJax" nocase
            $lj2 = "MosaicRegressor" nocase
            $lj3 = "MoonBounce" nocase
            $lj4 = "CosmicStrand" nocase
            $lj5 = "ESPecter" nocase
            $lj6 = "FinSpy" nocase
            $sec1 = "SecureBoot" nocase
            $sec2 = "PK.auth" nocase
        condition:
            3 of them
        severity: CRITICAL
    '
    
    # RULE_KERNEL_EXPLOIT - Kernel exploitation patterns
    YARA_RULES["kernel_exploit"]='
        strings:
            $kern1 = "kernel" nocase
            $kern2 = "/proc/kallsyms" nocase
            $kern3 = "/proc/modules" nocase
            $kern4 = "/dev/mem" nocase
            $kern5 = "/dev/kmem" nocase
            $exp1 = "commit_creds" nocase
            $exp2 = "prepare_kernel_cred" nocase
            $exp3 = "copy_from_user" nocase
            $exp4 = "copy_to_user" nocase
            $vuln1 = "dirty_cow" nocase
            $vuln2 = "dirtycow" nocase
            $vuln3 = "dirty_pipe" nocase
            $vuln4 = "CVE-20" nocase
            $vuln5 = "privilege escalation" nocase
            $priv1 = "setuid(0)" nocase
            $priv2 = "setgid(0)" nocase
            $priv3 = "root shell" nocase
            $rop1 = "ROP chain" nocase
            $rop2 = "gadget" nocase
        condition:
            3 of them
        severity: CRITICAL
    '
    
    # RULE_CONTAINER_ESCAPE - Docker/K8s escape patterns
    YARA_RULES["container_escape"]='
        strings:
            $docker1 = "/var/run/docker.sock" nocase
            $docker2 = "docker.sock" nocase
            $docker3 = "privileged:true" nocase
            $docker4 = "--privileged" nocase
            $docker5 = "CAP_SYS_ADMIN" nocase
            $docker6 = "nsenter" nocase
            $docker7 = "unshare" nocase
            $k8s1 = "serviceaccount" nocase
            $k8s2 = "/var/run/secrets/kubernetes.io" nocase
            $k8s3 = "kubectl" nocase
            $k8s4 = "kubelet" nocase
            $k8s5 = "etcd" nocase
            $escape1 = "container escape" nocase
            $escape2 = "breakout" nocase
            $escape3 = "release_agent" nocase
            $cgroup1 = "/sys/fs/cgroup" nocase
            $cgroup2 = "cgroup.procs" nocase
            $meta1 = "169.254.169.254" nocase
            $proc1 = "/proc/1/root" nocase
        condition:
            3 of them
        severity: CRITICAL
    '
    
    # RULE_SERVERLESS_ABUSE - Lambda/Cloud Functions abuse
    YARA_RULES["serverless_abuse"]='
        strings:
            $lambda1 = "AWS_LAMBDA" nocase
            $lambda2 = "lambda.amazonaws.com" nocase
            $lambda3 = "invoke-function" nocase
            $lambda4 = "update-function-code" nocase
            $lambda5 = "LAMBDA_TASK_ROOT" nocase
            $azure1 = "azure.functions" nocase
            $azure2 = "AzureWebJobsStorage" nocase
            $gcp1 = "cloudfunctions.net" nocase
            $gcp2 = "X-Cloud-Trace-Context" nocase
            $creds1 = "AWS_ACCESS_KEY" nocase
            $creds2 = "AWS_SECRET_ACCESS" nocase
            $creds3 = "AZURE_CLIENT_SECRET" nocase
            $event1 = "event injection" nocase
            $event2 = "malicious payload" nocase
            $iam1 = "iam:PassRole" nocase
            $iam2 = "sts:AssumeRole" nocase
            $reverse1 = "reverse shell" nocase
            $exfil1 = "exfiltrate" nocase
        condition:
            3 of them
        severity: HIGH
    '
    
    # RULE_CI_CD_POISONING - Pipeline injection patterns
    YARA_RULES["ci_cd_poisoning"]='
        strings:
            $gh1 = "github.com/.*actions" nocase
            $gh2 = "workflow_dispatch" nocase
            $gh3 = "GITHUB_TOKEN" nocase
            $gh4 = "secrets." nocase
            $gh5 = "@master" nocase
            $gh6 = "@main" nocase
            $jenkins1 = "Jenkinsfile" nocase
            $jenkins2 = "pipeline" nocase
            $jenkins3 = "withCredentials" nocase
            $jenkins4 = "groovy" nocase
            $gitlab1 = ".gitlab-ci.yml" nocase
            $gitlab2 = "CI_JOB_TOKEN" nocase
            $circle1 = "circleci" nocase
            $circle2 = "CIRCLE_TOKEN" nocase
            $travis1 = ".travis.yml" nocase
            $inject1 = "script injection" nocase
            $inject2 = "command injection" nocase
            $inject3 = "curl | sh" nocase
            $inject4 = "wget | bash" nocase
            $inject5 = "eval(" nocase
        condition:
            3 of them
        severity: HIGH
    '
    
    # RULE_GIT_HOOKS_ABUSE - Malicious git hooks
    YARA_RULES["git_hooks_abuse"]='
        strings:
            $hook1 = ".git/hooks" nocase
            $hook2 = "pre-commit" nocase
            $hook3 = "post-commit" nocase
            $hook4 = "pre-push" nocase
            $hook5 = "post-receive" nocase
            $hook6 = "pre-receive" nocase
            $hook7 = "update" nocase
            $hook8 = "post-checkout" nocase
            $exec1 = "#!/bin/bash" nocase
            $exec2 = "#!/bin/sh" nocase
            $exec3 = "exec " nocase
            $mal1 = "curl " nocase
            $mal2 = "wget " nocase
            $mal3 = "nc " nocase
            $mal4 = "netcat" nocase
            $mal5 = "reverse" nocase
            $mal6 = "/dev/tcp/" nocase
            $steal1 = "credential" nocase
            $steal2 = "token" nocase
            $steal3 = "ssh key" nocase
        condition:
            ($hook1 or $hook2 or $hook3 or $hook4 or $hook5) and 2 of ($exec*, $mal*, $steal*)
        severity: HIGH
    '
    
    # RULE_IDE_EXTENSION_ABUSE - VSCode/JetBrains extension malware
    YARA_RULES["ide_extension_abuse"]='
        strings:
            $vscode1 = ".vscode/extensions" nocase
            $vscode2 = "vscode:extension" nocase
            $vscode3 = "package.json" nocase
            $vscode4 = "activate" nocase
            $jet1 = ".idea" nocase
            $jet2 = "intellij" nocase
            $jet3 = "plugin.xml" nocase
            $mal1 = "child_process" nocase
            $mal2 = "require(\"child_process\")" nocase
            $mal3 = "spawn" nocase
            $mal4 = "execSync" nocase
            $net1 = "http.request" nocase
            $net2 = "https.request" nocase
            $net3 = "fetch(" nocase
            $net4 = "XMLHttpRequest" nocase
            $steal1 = "keytar" nocase
            $steal2 = "credentials" nocase
            $steal3 = "vscode.workspace" nocase
            $steal4 = "getConfiguration" nocase
            $exfil1 = "postMessage" nocase
        condition:
            2 of ($vscode*, $jet*) and 2 of ($mal*, $net*, $steal*, $exfil*)
        severity: HIGH
    '
    
    # RULE_BROWSER_EXTENSION - Malicious browser extension patterns
    YARA_RULES["browser_extension_abuse"]='
        strings:
            $manifest1 = "manifest.json" nocase
            $manifest2 = "content_scripts" nocase
            $manifest3 = "background" nocase
            $manifest4 = "permissions" nocase
            $perm1 = "tabs" nocase
            $perm2 = "webRequest" nocase
            $perm3 = "cookies" nocase
            $perm4 = "<all_urls>" nocase
            $perm5 = "clipboardRead" nocase
            $perm6 = "storage" nocase
            $mal1 = "keylogger" nocase
            $mal2 = "form grabber" nocase
            $mal3 = "inject" nocase
            $mal4 = "intercept" nocase
            $mal5 = "screenshot" nocase
            $mal6 = "webcam" nocase
            $crypto1 = "cryptominer" nocase
            $crypto2 = "coinhive" nocase
            $steal1 = "password" nocase
            $steal2 = "credit card" nocase
            $steal3 = "bank" nocase
        condition:
            ($manifest1 or $manifest2) and 2 of ($perm*) and 2 of ($mal*, $crypto*, $steal*)
        severity: HIGH
    '
    
    # RULE_ELECTRON_APP_ABUSE - Electron app exploitation
    YARA_RULES["electron_app_abuse"]='
        strings:
            $electron1 = "electron" nocase
            $electron2 = "nodeIntegration" nocase
            $electron3 = "contextIsolation" nocase
            $electron4 = "webPreferences" nocase
            $electron5 = "BrowserWindow" nocase
            $vuln1 = "nodeIntegration: true" nocase
            $vuln2 = "contextIsolation: false" nocase
            $vuln3 = "webSecurity: false" nocase
            $vuln4 = "allowRunningInsecureContent" nocase
            $rce1 = "shell.openExternal" nocase
            $rce2 = "require(\"child_process\")" nocase
            $rce3 = "remote.require" nocase
            $rce4 = "mainModule" nocase
            $proto1 = "protocol.registerHttpProtocol" nocase
            $proto2 = "custom protocol" nocase
            $xss1 = "loadURL" nocase
            $xss2 = "executeJavaScript" nocase
        condition:
            2 of ($electron*) and 2 of ($vuln*, $rce*, $proto*, $xss*)
        severity: HIGH
    '
    
    # RULE_WASM_MALWARE - WebAssembly malware patterns
    YARA_RULES["wasm_malware"]='
        strings:
            $wasm1 = { 00 61 73 6D }
            $wasm2 = "WebAssembly" nocase
            $wasm3 = ".wasm" nocase
            $wasm4 = "wasm-bindgen" nocase
            $crypto1 = "cryptonight" nocase
            $crypto2 = "randomx" nocase
            $crypto3 = "mining" nocase
            $crypto4 = "hashrate" nocase
            $obf1 = "emscripten" nocase
            $obf2 = "assemblyscript" nocase
            $mal1 = "keylog" nocase
            $mal2 = "screenshot" nocase
            $mal3 = "exfiltrate" nocase
            $mem1 = "Memory.grow" nocase
            $mem2 = "WebAssembly.Memory" nocase
            $import1 = "import" nocase
            $export1 = "export" nocase
        condition:
            ($wasm1 or $wasm2 or $wasm3) and 2 of ($crypto*, $obf*, $mal*, $mem*)
        severity: MEDIUM
    '
    
    # RULE_OAUTH_ABUSE - OAuth token theft/phishing
    YARA_RULES["oauth_abuse"]='
        strings:
            $oauth1 = "oauth" nocase
            $oauth2 = "access_token" nocase
            $oauth3 = "refresh_token" nocase
            $oauth4 = "authorization_code" nocase
            $oauth5 = "client_id" nocase
            $oauth6 = "client_secret" nocase
            $oauth7 = "redirect_uri" nocase
            $oauth8 = "scope" nocase
            $phish1 = "consent" nocase
            $phish2 = "authorize" nocase
            $phish3 = "grant" nocase
            $steal1 = "token theft" nocase
            $steal2 = "intercept" nocase
            $steal3 = "hijack" nocase
            $bypass1 = "open redirect" nocase
            $bypass2 = "redirect manipulation" nocase
            $bypass3 = "state parameter" nocase
            $app1 = "malicious app" nocase
            $app2 = "rogue application" nocase
        condition:
            3 of ($oauth*) and 2 of ($phish*, $steal*, $bypass*, $app*)
        severity: HIGH
    '
    
    # RULE_SAML_INJECTION - SAML response manipulation
    YARA_RULES["saml_injection"]='
        strings:
            $saml1 = "SAMLResponse" nocase
            $saml2 = "SAMLRequest" nocase
            $saml3 = "Assertion" nocase
            $saml4 = "urn:oasis:names:tc:SAML" nocase
            $saml5 = "saml2" nocase
            $attack1 = "signature wrapping" nocase
            $attack2 = "XML signature" nocase
            $attack3 = "golden SAML" nocase
            $attack4 = "forged assertion" nocase
            $attack5 = "assertion replay" nocase
            $xxe1 = "<!ENTITY" nocase
            $xxe2 = "SYSTEM" nocase
            $xxe3 = "file://" nocase
            $bypass1 = "NotBefore" nocase
            $bypass2 = "NotOnOrAfter" nocase
            $bypass3 = "Conditions" nocase
            $tool1 = "saml-raider" nocase
            $tool2 = "SAMLextractor" nocase
        condition:
            2 of ($saml*) and 2 of ($attack*, $xxe*, $bypass*, $tool*)
        severity: HIGH
    '
    
    # RULE_JWT_ATTACKS - JWT forgery/confusion attacks
    YARA_RULES["jwt_attacks"]='
        strings:
            $jwt1 = "eyJ" nocase
            $jwt2 = "JWT" nocase
            $jwt3 = "Bearer" nocase
            $jwt4 = "jsonwebtoken" nocase
            $alg1 = "\"alg\":\"none\"" nocase
            $alg2 = "alg=none" nocase
            $alg3 = "algorithm confusion" nocase
            $alg4 = "RS256" nocase
            $alg5 = "HS256" nocase
            $attack1 = "kid injection" nocase
            $attack2 = "jku manipulation" nocase
            $attack3 = "jwk injection" nocase
            $attack4 = "signature bypass" nocase
            $attack5 = "null signature" nocase
            $forge1 = "forge" nocase
            $forge2 = "craft" nocase
            $forge3 = "tamper" nocase
            $tool1 = "jwt_tool" nocase
            $tool2 = "jwt.io" nocase
        condition:
            2 of ($jwt*) and 2 of ($alg*, $attack*, $forge*, $tool*)
        severity: HIGH
    '
    
    # RULE_SSRF_PATTERNS - Server-Side Request Forgery
    YARA_RULES["ssrf_patterns"]='
        strings:
            $meta1 = "169.254.169.254" nocase
            $meta2 = "metadata.google.internal" nocase
            $meta3 = "100.100.100.200" nocase
            $cloud1 = "/latest/meta-data" nocase
            $cloud2 = "/computeMetadata" nocase
            $cloud3 = "/metadata/instance" nocase
            $local1 = "localhost" nocase
            $local2 = "127.0.0.1" nocase
            $local3 = "0.0.0.0" nocase
            $local4 = "[::1]" nocase
            $proto1 = "file://" nocase
            $proto2 = "gopher://" nocase
            $proto3 = "dict://" nocase
            $proto4 = "ftp://" nocase
            $bypass1 = "@" nocase
            $bypass2 = "%00" nocase
            $bypass3 = "0x7f" nocase
            $bypass4 = "2130706433" nocase
            $ssrf1 = "SSRF" nocase
            $ssrf2 = "server-side request" nocase
        condition:
            2 of ($meta*, $cloud*) or 3 of ($local*, $proto*, $bypass*) or any of ($ssrf*)
        severity: HIGH
    '
    
    # RULE_SSTI_PATTERNS - Server-Side Template Injection
    YARA_RULES["ssti_patterns"]='
        strings:
            $jinja1 = "{{" nocase
            $jinja2 = "}}" nocase
            $jinja3 = "__class__" nocase
            $jinja4 = "__mro__" nocase
            $jinja5 = "__subclasses__" nocase
            $jinja6 = "__globals__" nocase
            $jinja7 = "__builtins__" nocase
            $twig1 = "{%" nocase
            $twig2 = "%}" nocase
            $freemarker1 = "<#" nocase
            $freemarker2 = "ftl" nocase
            $thyme1 = "th:" nocase
            $velocity1 = "#set" nocase
            $velocity2 = "#foreach" nocase
            $exploit1 = "os.popen" nocase
            $exploit2 = "subprocess" nocase
            $exploit3 = "exec(" nocase
            $exploit4 = "eval(" nocase
            $ssti1 = "template injection" nocase
            $ssti2 = "SSTI" nocase
        condition:
            (2 of ($jinja*) and any of ($exploit*)) or 
            (any of ($twig*, $freemarker*, $thyme*, $velocity*) and any of ($exploit*)) or
            any of ($ssti*)
        severity: HIGH
    '
    
    # RULE_DESERIALIZATION - Insecure deserialization
    YARA_RULES["deserialization_attacks"]='
        strings:
            $java1 = "ObjectInputStream" nocase
            $java2 = "readObject" nocase
            $java3 = "java.io.Serializable" nocase
            $java4 = "ysoserial" nocase
            $java5 = "CommonsCollections" nocase
            $java6 = "InvokerTransformer" nocase
            $php1 = "unserialize(" nocase
            $php2 = "O:" nocase
            $php3 = "__wakeup" nocase
            $php4 = "__destruct" nocase
            $python1 = "pickle" nocase
            $python2 = "cPickle" nocase
            $python3 = "yaml.load" nocase
            $python4 = "marshal" nocase
            $net1 = "BinaryFormatter" nocase
            $net2 = "ObjectStateFormatter" nocase
            $net3 = "SoapFormatter" nocase
            $net4 = "TypeNameHandling" nocase
            $ruby1 = "Marshal.load" nocase
            $ruby2 = "YAML.load" nocase
            $deser1 = "deserialization" nocase
            $deser2 = "gadget chain" nocase
        condition:
            3 of them
        severity: HIGH
    '
    
    # RULE_XXE_PATTERNS - XML External Entity attacks
    YARA_RULES["xxe_patterns"]='
        strings:
            $xxe1 = "<!DOCTYPE" nocase
            $xxe2 = "<!ENTITY" nocase
            $xxe3 = "SYSTEM" nocase
            $xxe4 = "PUBLIC" nocase
            $xxe5 = "file://" nocase
            $xxe6 = "http://" nocase
            $xxe7 = "ftp://" nocase
            $xxe8 = "expect://" nocase
            $xxe9 = "php://" nocase
            $xxe10 = "data://" nocase
            $xxe11 = "gopher://" nocase
            $param1 = "%" nocase
            $param2 = "PARAMETER" nocase
            $oob1 = "out-of-band" nocase
            $oob2 = "blind xxe" nocase
            $tool1 = "xxeinjector" nocase
            $vuln1 = "external entity" nocase
            $vuln2 = "XXE" nocase
            $bypass1 = "CDATA" nocase
            $bypass2 = "encoding" nocase
        condition:
            ($xxe1 and $xxe2 and any of ($xxe5, $xxe6, $xxe7, $xxe8, $xxe9, $xxe10, $xxe11)) or
            3 of ($oob*, $tool*, $vuln*, $bypass*)
        severity: HIGH
    '
    
    # RULE_PROTOTYPE_POLLUTION - JavaScript prototype pollution
    YARA_RULES["prototype_pollution"]='
        strings:
            $proto1 = "__proto__" nocase
            $proto2 = "constructor" nocase
            $proto3 = "prototype" nocase
            $proto4 = "Object.prototype" nocase
            $merge1 = "merge" nocase
            $merge2 = "extend" nocase
            $merge3 = "clone" nocase
            $merge4 = "deepCopy" nocase
            $merge5 = "assign" nocase
            $vuln1 = "lodash" nocase
            $vuln2 = "jquery" nocase
            $vuln3 = "underscore" nocase
            $attack1 = "pollution" nocase
            $attack2 = "pollute" nocase
            $attack3 = "gadget" nocase
            $rce1 = "shell" nocase
            $rce2 = "spawn" nocase
            $rce3 = "exec" nocase
            $payload1 = "{\"__proto__\"" nocase
            $payload2 = "constructor.prototype" nocase
        condition:
            (2 of ($proto*) and any of ($merge*)) or 
            (any of ($attack*) and any of ($proto*)) or
            any of ($payload*)
        severity: HIGH
    '
    
    # =========================================================================
    # Additional Security-Critical Rules
    # =========================================================================
    
    # RULE_SUPPLY_CHAIN_ATTACK - Package/dependency attacks
    YARA_RULES["supply_chain_attack"]='
        strings:
            $npm1 = "npm install" nocase
            $npm2 = "package.json" nocase
            $npm3 = "postinstall" nocase
            $npm4 = "preinstall" nocase
            $pip1 = "pip install" nocase
            $pip2 = "setup.py" nocase
            $pip3 = "requirements.txt" nocase
            $typo1 = "typosquatting" nocase
            $typo2 = "dependency confusion" nocase
            $mal1 = "event-stream" nocase
            $mal2 = "flatmap-stream" nocase
            $mal3 = "ua-parser-js" nocase
            $mal4 = "coa" nocase
            $mal5 = "rc" nocase
            $exec1 = "child_process" nocase
            $exec2 = "subprocess" nocase
            $exfil1 = "exfiltrate" nocase
            $exfil2 = "steal" nocase
        condition:
            2 of ($npm*, $pip*) and 2 of ($typo*, $mal*, $exec*, $exfil*)
        severity: CRITICAL
    '
    
    # RULE_API_ABUSE - API key/credential exposure
    YARA_RULES["api_abuse"]='
        strings:
            $aws1 = /AKIA[0-9A-Z]{16}/ nocase
            $aws2 = "aws_secret_access_key" nocase
            $gcp1 = /AIza[0-9A-Za-z\\-_]{35}/ nocase
            $azure1 = "azure" nocase
            $stripe1 = /sk_live_[0-9a-zA-Z]{24}/ nocase
            $stripe2 = /sk_test_[0-9a-zA-Z]{24}/ nocase
            $github1 = /ghp_[0-9a-zA-Z]{36}/ nocase
            $github2 = /gho_[0-9a-zA-Z]{36}/ nocase
            $slack1 = /xoxb-[0-9]{11,13}-[0-9]{11,13}-[a-zA-Z0-9]{24}/ nocase
            $twilio1 = /SK[0-9a-fA-F]{32}/ nocase
            $sendgrid1 = /SG\.[a-zA-Z0-9]{22}\.[a-zA-Z0-9]{43}/ nocase
            $private1 = "private_key" nocase
            $private2 = "BEGIN RSA PRIVATE" nocase
            $private3 = "BEGIN EC PRIVATE" nocase
        condition:
            any of them
        severity: CRITICAL
    '
    
    log_info "YARA rules database initialized with ${#YARA_RULES[@]} rules"
}

analyze_steganography() {
    set +u
    local image="${1:-}"
    set -u
    log_stego "Analyzing image for steganographic content and advanced evasion techniques..."
    local stego_score=0
    local stego_findings=()

    ### === Entropy Check (robust validation) === ###
    local entropy=""
    if entropy=$(analyze_file_entropy "$image" 2>/dev/null); then
        if [[ -n "$entropy" ]] && [[ "$entropy" =~ ^[0-9]+\.?[0-9]*$ ]]; then
            if float_gt "$entropy" "7.9"; then
                log_stego "High entropy detected: $entropy (possible encrypted/compressed hidden data)"
                ((stego_score += 20))
                stego_findings+=("high_entropy:$entropy")
            fi
        else
            log_stego "Entropy check returned invalid or empty value: '$entropy'"
        fi
    else
        log_stego "Entropy check failed or command errored"
    fi

    ### === Appended Data After Image End (additional checks) === ###
    local appended=""
    appended=$(check_appended_data "$image" 2>/dev/null) || appended="false"
    if [ "$appended" = "true" ]; then
        log_stego "Appended data detected after image end marker"
        ((stego_score += 30))
        stego_findings+=("appended_data")
    fi

    ### === File Size Anomaly === ###
    local file_size actual_img_size type_img
    file_size=$(stat -c%s "$image" 2>/dev/null)
    type_img=$(file "$image" 2>/dev/null)
    if [[ "$type_img" =~ "PNG" ]]; then
        actual_img_size=$(pngcheck -v "$image" 2>/dev/null | awk '/length:/ {print $NF}' | head -n1)
        if [[ -n "$actual_img_size" && $actual_img_size -gt 0 && $file_size -gt $((actual_img_size + 1024)) ]]; then
            log_stego "File size exceeds expected by more than 1KB"
            ((stego_score += 10))
            stego_findings+=("filesize_anomaly")
        fi
    fi

    ### === Steghide Detection (fortified) === ###
    if command -v steghide &> /dev/null; then
        local steghide_result=""
        steghide_result=$(run_isolated 30 steghide info "$image" -p "" 2>&1) || true
        if echo "$steghide_result" | grep -q "embedded"; then
            log_stego "Steghide detected embedded content (no password)"
            ((stego_score += 50))
            stego_findings+=("steghide_detected")
        fi
        # Log extraction details if possible
        if echo "$steghide_result" | grep -iq "extractable"; then
            log_stego "Steghide reports extractable content (audit recommended)"
            stego_findings+=("steghide_extractable")
        fi
    fi

    ### === zsteg (PNG only; multi-check) === ###
    if command -v zsteg &> /dev/null && file "$image" 2>/dev/null | grep -qi "PNG"; then
        local zsteg_output="${TEMP_DIR}/zsteg_$(basename "$image").txt"
        run_isolated_with_output 30 "$zsteg_output" zsteg "$image" || true
        if [[ -f "$zsteg_output" ]]; then
            if grep -qiE "(http|https|ftp|data:|base64)" "$zsteg_output" 2>/dev/null; then
                log_stego "zsteg detected potentially hidden URLs/data"
                ((stego_score += 40))
                stego_findings+=("zsteg_url_detected")
            fi
            if grep -qi "file signature" "$zsteg_output" 2>/dev/null; then
                log_stego "zsteg detected hidden file signatures"
                ((stego_score += 45))
                stego_findings+=("zsteg_file_sig")
            fi
            if grep -qi "text" "$zsteg_output" 2>/dev/null; then
                log_stego "zsteg found hidden text"
                ((stego_score += 25))
                stego_findings+=("zsteg_text")
            fi
            if grep -qi "steg" "$zsteg_output" 2>/dev/null; then
                log_stego "zsteg reported generic stego indication"
                ((stego_score += 15))
                stego_findings+=("zsteg_stego_indication")
            fi
        fi
    fi

    ### === stegdetect (JPEG focus, robust) === ###
    if command -v stegdetect &> /dev/null; then
        local stegdetect_output=""
        stegdetect_output=$(run_isolated 30 stegdetect "$image" 2>/dev/null) || true
        if [ -n "$stegdetect_output" ] && ! echo "$stegdetect_output" | grep -q "negative"; then
            log_stego "stegdetect positive: $stegdetect_output"
            ((stego_score += 35))
            stego_findings+=("stegdetect:$stegdetect_output")
        fi
    fi

    ### === binwalk for hidden archives/overlays === ###
    if command -v binwalk &> /dev/null; then
        local binwalk_out
        binwalk_out=$(run_isolated 20 binwalk "$image" 2>/dev/null) || true
        if echo "$binwalk_out" | grep -qE "(Zip|data|archive|compressed data)"; then
            log_stego "binwalk found embedded compressed data/archives"
            ((stego_score += 17))
            stego_findings+=("binwalk_embedded")
        fi
    fi

    ### === LSB pattern analysis (no scoring, defensive) === ###
    analyze_lsb_patterns "$image" 2>/dev/null || log_stego "LSB pattern analysis failed for $image"

    ### === Color distribution anomaly (defensive) === ###
    analyze_color_distribution "$image" 2>/dev/null || log_stego "Color distribution analysis failed for $image"

    ### === EXIF Metadata Anomaly === ###
    if command -v exiftool &> /dev/null; then
        local exif_output
        exif_output=$(exiftool "$image" 2>/dev/null | grep -Ei "(comment|UserComment|Hidden|Secret|Steg|Creator|Software)")
        if [ -n "$exif_output" ]; then
            log_stego "Suspicious EXIF metadata detected: $exif_output"
            ((stego_score += 10))
            stego_findings+=("exif_anomaly")
        fi
    fi

    ### === Magic bytes or mimetype clash === ###
    if command -v xxd &> /dev/null; then
        local magic_bytes
        magic_bytes=$(xxd -p -l 8 "$image" | tr -d '\n')
        if [[ "$magic_bytes" =~ ^89504e47 ]]; then
            # PNG header; optionally crosscheck type and header mismatch later
            :
        fi
    fi

    ### === Final Reporting and Forensic Logging === ###
    if [ $stego_score -gt 0 ]; then
        local finding_summary=""
        finding_summary=$(printf '%s, ' "${stego_findings[@]}" | sed 's/, $//')
        local matched_by="entropy analysis"
        [[ " ${stego_findings[*]} " =~ "steghide" ]] && matched_by="$matched_by, steghide"
        [[ " ${stego_findings[*]} " =~ "zsteg" ]] && matched_by="$matched_by, zsteg"
        [[ " ${stego_findings[*]} " =~ "stegdetect" ]] && matched_by="$matched_by, stegdetect"
        [[ " ${stego_findings[*]} " =~ "appended" ]] && matched_by="$matched_by, appended data detection"
        [[ " ${stego_findings[*]} " =~ "lsb" ]] && matched_by="$matched_by, LSB analysis"
        [[ " ${stego_findings[*]} " =~ "binwalk" ]] && matched_by="$matched_by, binwalk"
        [[ " ${stego_findings[*]} " =~ "exif" ]] && matched_by="$matched_by, EXIF metadata"

        log_forensic_detection $((stego_score / 2)) \
            "Steganographic Content Detected" \
            "$finding_summary" \
            "$matched_by" \
            "Image binary data" \
            "Extract and analyze hidden data - potential data exfiltration or hidden payload" \
            "MITRE ATT&CK T1027.003 - Steganography"
        
        {
            echo "═══════════════════════════════════════════════"
            echo "STEGANOGRAPHY ANALYSIS: $(basename "$image")"
            echo "═══════════════════════════════════════════════"
            echo "Steganography Score: $stego_score"
            echo "Findings:"
            for finding in "${stego_findings[@]}"; do
                echo "  - $finding"
            done
            echo ""
            echo "Image type: $type_img"
            echo "File size: $file_size"
            echo "Entropy: $entropy"
            if [ -n "${exif_output:-}" ]; then
                echo "EXIF/Suspicious Metadata: $exif_output"
            fi
        } >> "$STEGANOGRAPHY_REPORT"
    else
        log_stego "No significant steganographic indicators found in $image (score: $stego_score)"
    fi
}

analyze_lsb_patterns() {
    set +u
    local image="${1:-}"
    set -u
    local python_cmd=$(get_python_cmd)
    
    # Skip if PIL/numpy not available
    if ! is_python_module_available "PIL" || ! is_python_module_available "numpy"; then
        return 0
    fi
    
    timeout 60 "$python_cmd" - "$image" <<'PYLSB' 2>/dev/null || true
import sys
import os
import mmap
import tempfile

try:
    from PIL import Image
    import numpy as np
    
    image_path = sys.argv[1]
    
    # Open image lazily (doesn't load full image into memory)
    img = Image.open(image_path)
    
    if img.mode != 'RGB':
        img = img.convert('RGB')
    
    width, height = img.size
    total_pixels = width * height
    
    # For very large images, use chunked processing with mmap
    if total_pixels > 1000000:  # > 1 megapixel
        # Create a temporary memory-mapped file for LSB storage
        temp_fd, temp_path = tempfile.mkstemp(suffix='.lsb')
        try:
            # Calculate size needed for LSB data
            array_size = total_pixels * 3  # 3 channels
            os.ftruncate(temp_fd, array_size)
            
            # Memory-map the file
            mm = mmap.mmap(temp_fd, array_size, access=mmap.ACCESS_WRITE)
            
            # Process image in chunks
            chunk_height = max(1, 50000 // width)  # ~50000 pixels per chunk
            r_sum, g_sum, b_sum = 0, 0, 0
            offset = 0
            
            for y in range(0, height, chunk_height):
                chunk_h = min(chunk_height, height - y)
                chunk = img.crop((0, y, width, y + chunk_h))
                chunk_data = np.array(chunk, dtype=np.uint8)
                
                # Extract LSBs
                r_lsb = (chunk_data[:,:,0] & 1).flatten()
                g_lsb = (chunk_data[:,:,1] & 1).flatten()
                b_lsb = (chunk_data[:,:,2] & 1).flatten()
                
                r_sum += np.sum(r_lsb)
                g_sum += np.sum(g_lsb)
                b_sum += np.sum(b_lsb)
                
                # Write to mmap
                chunk_lsb = np.concatenate([r_lsb, g_lsb, b_lsb]).astype(np.uint8)
                mm[offset:offset + len(chunk_lsb)] = chunk_lsb.tobytes()
                offset += len(chunk_lsb)
                
                del chunk_data, r_lsb, g_lsb, b_lsb, chunk_lsb
            
            # Calculate ratios
            r_ratio = r_sum / total_pixels
            g_ratio = g_sum / total_pixels
            b_ratio = b_sum / total_pixels
            deviation = abs(r_ratio - 0.5) + abs(g_ratio - 0.5) + abs(b_ratio - 0.5)
            
            if deviation < 0.05:
                print(f"LSB_SUSPICIOUS: LSB ratios too uniform (R:{r_ratio:.3f} G:{g_ratio:.3f} B:{b_ratio:.3f})")
            
            # Check for ASCII in first 8KB of mmap
            mm.seek(0)
            sample = mm.read(min(8000, offset))
            for i in range(0, len(sample) - 8, 8):
                byte = 0
                for bit in range(8):
                    byte = (byte << 1) | sample[i + bit]
                if 32 <= byte <= 126:
                    print(f"LSB_ASCII_FOUND: Found printable ASCII in LSB at position {i}")
                    break
            
            mm.close()
        finally:
            os.close(temp_fd)
            try:
                os.unlink(temp_path)
            except:
                pass
    else:
        # Small image - process directly
        pixels = np.array(img)
        
        r_lsb = pixels[:,:,0] & 1
        g_lsb = pixels[:,:,1] & 1
        b_lsb = pixels[:,:,2] & 1
        
        r_ratio = np.mean(r_lsb)
        g_ratio = np.mean(g_lsb)
        b_ratio = np.mean(b_lsb)
        deviation = abs(r_ratio - 0.5) + abs(g_ratio - 0.5) + abs(b_ratio - 0.5)
        
        if deviation < 0.05:
            print(f"LSB_SUSPICIOUS: LSB ratios too uniform (R:{r_ratio:.3f} G:{g_ratio:.3f} B:{b_ratio:.3f})")
        
        lsb_combined = np.concatenate([r_lsb.flatten(), g_lsb.flatten(), b_lsb.flatten()])
        
        for i in range(0, min(len(lsb_combined) - 64, 8000), 8):
            byte = 0
            for bit in range(8):
                byte = (byte << 1) | lsb_combined[i + bit]
            if 32 <= byte <= 126:
                print(f"LSB_ASCII_FOUND: Found printable ASCII in LSB at position {i}")
                break

except Exception as e:
    pass
PYLSB
}

analyze_color_distribution() {
    set +u
    local image="${1:-}"
    set -u
    local python_cmd=$(get_python_cmd)
    
    # Skip if PIL not available
    if ! is_python_module_available "PIL"; then
        return 0
    fi
    
    timeout 60 "$python_cmd" - "$image" <<'PYCOLOR' 2>/dev/null || true
import sys
import os
import mmap
import tempfile
import struct
from collections import Counter

try:
    from PIL import Image
    
    image_path = sys.argv[1]
    
    # Open image lazily
    img = Image.open(image_path)
    
    if img.mode != 'RGB':
        img = img.convert('RGB')
    
    width, height = img.size
    total_pixels = width * height
    
    # For large images, use chunked sampling with mmap
    if total_pixels > 1000000:  # > 1 megapixel
        # Create mmap for storing color samples
        temp_fd, temp_path = tempfile.mkstemp(suffix='.colors')
        try:
            # Sample every Nth pixel to keep memory bounded
            sample_rate = max(1, total_pixels // 500000)  # Max ~500K samples
            expected_samples = total_pixels // sample_rate
            
            # 3 bytes per RGB color sample
            os.ftruncate(temp_fd, expected_samples * 3)
            mm = mmap.mmap(temp_fd, expected_samples * 3, access=mmap.ACCESS_WRITE)
            
            # Process in chunks
            chunk_height = max(1, 50000 // width)
            sample_idx = 0
            pixel_idx = 0
            
            for y in range(0, height, chunk_height):
                chunk_h = min(chunk_height, height - y)
                chunk = img.crop((0, y, width, y + chunk_h))
                chunk_pixels = list(chunk.getdata())
                
                for px in chunk_pixels:
                    if pixel_idx % sample_rate == 0 and sample_idx < expected_samples:
                        offset = sample_idx * 3
                        mm[offset:offset+3] = bytes(px[:3])
                        sample_idx += 1
                    pixel_idx += 1
                
                del chunk_pixels
            
            # Analyze sampled colors from mmap
            mm.seek(0)
            color_counts = Counter()
            for i in range(sample_idx):
                color = tuple(mm[i*3:(i+1)*3])
                color_counts[color] += 1
            
            unique_colors = len(color_counts)
            color_ratio = unique_colors / sample_idx if sample_idx > 0 else 0
            
            if color_ratio > 0.9:
                print(f"COLOR_SUSPICIOUS: Very high unique color ratio ({color_ratio:.3f})")
            
            # Check for near-identical pairs (sample first 500 colors)
            suspicious_pairs = 0
            colors = list(color_counts.keys())[:500]
            for i in range(len(colors)):
                for j in range(i+1, len(colors)):
                    c1, c2 = colors[i], colors[j]
                    if all(abs(c1[k] - c2[k]) <= 1 for k in range(3)):
                        suspicious_pairs += 1
            
            if suspicious_pairs > len(colors) * 0.1:
                print(f"COLOR_PAIRS_SUSPICIOUS: High number of near-identical color pairs ({suspicious_pairs})")
            
            mm.close()
        finally:
            os.close(temp_fd)
            try:
                os.unlink(temp_path)
            except:
                pass
    else:
        # Small image - process directly
        pixels = list(img.getdata())
        
        color_counts = Counter(pixels)
        unique_colors = len(color_counts)
        color_ratio = unique_colors / len(pixels)
        
        if color_ratio > 0.9:
            print(f"COLOR_SUSPICIOUS: Very high unique color ratio ({color_ratio:.3f})")
        
        suspicious_pairs = 0
        colors = list(color_counts.keys())[:500]
        for i in range(len(colors)):
            for j in range(i+1, len(colors)):
                c1, c2 = colors[i], colors[j]
                if all(abs(c1[k] - c2[k]) <= 1 for k in range(3)):
                    suspicious_pairs += 1
        
        if suspicious_pairs > len(colors) * 0.1:
            print(f"COLOR_PAIRS_SUSPICIOUS: High number of near-identical color pairs ({suspicious_pairs})")

except Exception as e:
    pass
PYCOLOR
}

analyze_file_entropy() {
    set +u
    local file="${1:-}"
    set -u
    local python_cmd=$(get_python_cmd)
    local entropy_result=""
    
    # Try Python-based entropy calculation first
    if [ -n "$python_cmd" ]; then
        entropy_result=$("$python_cmd" - "$file" <<'PYENTROPY' 2>/dev/null
import sys
import os
import math
from collections import Counter

try:
    file_path = sys.argv[1]
    file_size = os.path.getsize(file_path)
    
    if file_size == 0:
        print("0.0000")
        sys.exit(0)
    
    # Read file in chunks for memory efficiency
    with open(file_path, 'rb') as f:
        # For large files, sample
        if file_size > 1048576:  # > 1MB
            sample_size = 1048576
            chunk_size = sample_size // 3
            
            # Read from beginning
            data = f.read(chunk_size)
            
            # Read from middle
            f.seek(file_size // 2 - chunk_size // 2)
            data += f.read(chunk_size)
            
            # Read from end
            f.seek(-chunk_size, 2)
            data += f.read(chunk_size)
        else:
            data = f.read()
    
    counter = Counter(data)
    length = len(data)
    
    if length == 0:
        print("0.0000")
        sys.exit(0)
    
    entropy = -sum((count/length) * math.log2(count/length) for count in counter.values())
    print(f"{entropy:.4f}")

except Exception as e:
    # Print error to stderr, still output a value
    print("error", file=sys.stderr)
    print("0.0000")
PYENTROPY
)
    fi
    
    # Fallback: use ent command if available and Python failed
    if [ -z "$entropy_result" ] || [ "$entropy_result" = "0.0000" ]; then
        if command -v ent &>/dev/null; then
            entropy_result=$(ent "$file" 2>/dev/null | grep "Entropy" | awk '{print $3}')
        fi
    fi
    
    # Fallback: use basic shell-based estimation
    if [ -z "$entropy_result" ]; then
        # Very basic estimation using unique byte count
        local unique_bytes=$(xxd -p "$file" 2>/dev/null | fold -w2 | sort -u | wc -l | tr -d ' ')
        if [ "$unique_bytes" -gt 0 ]; then
            # Rough entropy estimate: log2(unique_bytes)
            entropy_result=$(echo "scale=4; l($unique_bytes)/l(2)" | bc -l 2>/dev/null || echo "N/A")
        else
            entropy_result="N/A"
        fi
    fi
    
    # Ensure we output something
    if [ -z "$entropy_result" ]; then
        entropy_result="N/A (calculation unavailable)"
    fi
    
    echo "$entropy_result"
}

check_appended_data() {
    local image="$1"
    local file_type=$(file -b "$image" | cut -d',' -f1)
    
    case "$file_type" in
        *"PNG"*)
            # PNG ends with IEND chunk
            if xxd "$image" 2>/dev/null | grep -q "IEND.*42 60 82"; then
                local iend_pos=$(xxd "$image" 2>/dev/null | grep -n "IEND" | tail -1 | cut -d: -f1)
                local file_lines=$(xxd "$image" 2>/dev/null | wc -l)
                if [ "$iend_pos" != "$file_lines" ]; then
                    echo "true"
                    return
                fi
            fi
            ;;
        *"JPEG"*)
            # JPEG ends with FFD9
            if xxd "$image" 2>/dev/null | tail -1 | grep -qv "ff d9"; then
                echo "true"
                return
            fi
            ;;
        *"GIF"*)
            # GIF ends with 3B (;)
            if xxd "$image" 2>/dev/null | tail -1 | grep -qv "3b"; then
                echo "true"
                return
            fi
            ;;
    esac
    
    echo "false"
}

################################################################################
# IMAGE ANALYSIS AND METADATA EXTRACTION
################################################################################

analyze_image_metadata() {
    set +u
    local image="${1:-}"
    set -u
    
    log_info "Extracting and analyzing image metadata..."
    
    local metadata_file="${EVIDENCE_DIR}/metadata_$(basename "$image").txt"
    
    # Use exiftool if available
    if command -v exiftool &> /dev/null; then
        exiftool -a -G1 "$image" > "$metadata_file" 2>/dev/null
        
        # Check for suspicious metadata
        if grep -qi "GPS" "$metadata_file"; then
            log_forensic "GPS coordinates found in image metadata"
        fi
        
        if grep -qiE "photoshop|gimp|paint" "$metadata_file"; then
            log_info "Image edited with graphics software"
        fi
        
        # Check for suspicious software
        if grep -qiE "malware|hack|exploit|payload" "$metadata_file"; then
            local suspicious_strings
            suspicious_strings=$(grep -oiE "malware|hack|exploit|payload" "$metadata_file" | sort -u | tr '\n' ',' | sed 's/,$//')
            log_forensic_detection 40 \
                "Suspicious Strings in Image Metadata" \
                "metadata_strings:$suspicious_strings" \
                "Metadata keyword analysis" \
                "EXIF/metadata fields" \
                "Analyze image origin - metadata contains malware-related keywords" \
                "MITRE ATT&CK T1027.003 - Steganography"
        fi
        
        # Extract embedded files
        local embedded=$(grep -i "Embedded" "$metadata_file" 2>/dev/null)
        if [ -n "$embedded" ]; then
            log_forensic "Embedded content detected: $embedded"
        fi
        
        # Check modification dates
        local create_date=$(grep -i "Create Date" "$metadata_file" | head -1)
        local modify_date=$(grep -i "Modify Date" "$metadata_file" | head -1)
        if [ -n "$create_date" ] && [ -n "$modify_date" ]; then
            log_forensic "Create Date: $create_date"
            log_forensic "Modify Date: $modify_date"
        fi
    fi
    
    # Use ImageMagick identify for additional info
    if command -v identify &> /dev/null; then
        local identify_output="${EVIDENCE_DIR}/identify_$(basename "$image").txt"
        identify -verbose "$image" > "$identify_output" 2>/dev/null
        
        # Check for anomalies
        local color_space=$(grep "Colorspace:" "$identify_output" 2>/dev/null | awk '{print $2}')
        local depth=$(grep "Depth:" "$identify_output" 2>/dev/null | awk '{print $2}')
        local compression=$(grep "Compression:" "$identify_output" 2>/dev/null | awk '{print $2}')
        
        log_info "  Colorspace: $color_space, Depth: $depth, Compression: $compression"
    fi
    
    # Check file structure with binwalk
    if command -v binwalk &> /dev/null; then
        local binwalk_output="${EVIDENCE_DIR}/binwalk_$(basename "$image").txt"
        binwalk "$image" > "$binwalk_output" 2>/dev/null
        
        local embedded_files=$(grep -c "0x" "$binwalk_output" 2>/dev/null || echo "0")
        if [ "$embedded_files" -gt 3 ]; then
            log_forensic_detection 30 \
                "Multiple Embedded Files Detected" \
                "embedded_count:$embedded_files, tool:binwalk" \
                "Binary structure analysis (binwalk)" \
                "Image binary structure" \
                "Extract and analyze embedded files - possible steganographic payload or polyglot file" \
                "MITRE ATT&CK T1027.003 - Steganography"
        fi
    fi
    
    # PNG specific checks
    if file "$image" | grep -qi "PNG"; then
        check_png_structure "$image"
    fi
    
    # JPEG specific checks
    if file "$image" | grep -qi "JPEG"; then
        check_jpeg_structure "$image"
    fi
}

check_png_structure() {
    local image="$1"

    log_info "Analyzing PNG structure and chunk-level integrity..."

    # Validate PNG header (magic bytes)
    if ! head -c 8 "$image" | xxd -p | grep -q '^89504e470d0a1a0a'; then
        log_warning "File $image does not begin with PNG magic bytes"
        log_forensic "Header mismatch: $image"
        return
    fi

    # Use pngcheck for structural and chunk auditing
    if command -v pngcheck &> /dev/null; then
        local pngcheck_output
        pngcheck_output=$(pngcheck -v "$image" 2>&1)

        if echo "$pngcheck_output" | grep -qi "error\|invalid\|corrupt"; then
            log_warning "PNG structure errors detected"
            log_forensic "PNG issues: $pngcheck_output"
        else
            log_info "PNG structure appears normal"
        fi

        # Unusual/suspicious chunks including QR-related and custom (sTEG, sTER, qrCD, rNDm, etc.)
        if echo "$pngcheck_output" | grep -qiE "tEXt|zTXt|iTXt|sTEG|sTER|qrCD|rNDm|qRsT|pAYL"; then
            log_info "Text/suspicious payload chunks found in PNG (tEXt, iTXt, custom payloads, QR markers)"

            # Extract readable chunks, show hex for binaries, aggressively hunt QR/code/UTF-8 and print CRC validations
            python3 << EOF 2>/dev/null
import struct, binascii
try:
    f = open('$image', 'rb')
    f.read(8)
    output_limit = 5000
    total_output = 0
    suspicious_chunks = ['tEXt','zTXt','iTXt','sTEG','sTER','qrCD','rNDm','qRsT','pAYL']
    while True:
        length_bytes = f.read(4)
        if len(length_bytes) < 4:
            break
        length = struct.unpack('>I', length_bytes)[0]
        chunk_type = f.read(4).decode('ascii', errors='replace')
        data = f.read(length)
        crc = f.read(4)
        crc_calc = binascii.crc32(chunk_type.encode() + data) & 0xffffffff
        crc_file = struct.unpack('>I', crc)[0] if len(crc)==4 else None
        is_interesting = chunk_type in suspicious_chunks or chunk_type.startswith("qr") or chunk_type.startswith("pAY")
        if is_interesting and length > 0:
            try:
                txt = data[:300].decode('utf-8', errors='replace')
            except Exception:
                txt = str(data[:100])
            print(f"PNG_CHUNK_{chunk_type}: {txt[:300]}")
            if chunk_type.startswith('qr') or 'QR' in chunk_type.upper():
                print(f"QR_MARKER: Detected chunk {chunk_type}")
        if length > 8 and binascii.b2a_hex(data[:4]).decode().startswith('89504e47'):
            print(f"EMBEDDED_PNG_DETECTED_IN_CHUNK: {chunk_type}")
        if crc_file is not None and crc_calc != crc_file:
            print(f"CRC_MISMATCH for chunk {chunk_type}: expected {crc_calc:08x}, got {crc_file:08x}")
        total_output += length
        if total_output > output_limit: break
    f.close()
except Exception:
    pass
EOF
        fi

        # Key chunk audit (order/sanity/forensic logging)
        if echo "$pngcheck_output" | grep -q "IHDR"; then
            local chunk_order
            chunk_order=$(grep -oE 'chunk: [A-Z]{4}' <<<"$pngcheck_output" | awk '{print $2}' | tr '\n' ',' | sed 's/,$//')
            log_info "Chunk order detected: $chunk_order"
            log_forensic "Chunk sequence in $image: $chunk_order"
            # IS PNG truncated or after IEND?
            if echo "$chunk_order" | grep -q 'IEND,' && [ "$(echo "$chunk_order" | grep -o 'IEND' | wc -l)" -eq 1 ]; then
                local actual_filesize iend_offset
                actual_filesize=$(stat -c%s "$image" 2>/dev/null)
                iend_offset=$(pngcheck -vv "$image" 2>/dev/null | grep -m1 IEND | grep -oE 'offset [0-9]+' | grep -oE '[0-9]+')
                if [ -n "$iend_offset" ] && [ "$actual_filesize" -gt $((iend_offset + 12 + 128)) ]; then
                    log_warning "PNG continues past IEND chunk ($((actual_filesize-iend_offset-12))) bytes, possible malware or exfil"
                    log_forensic "Post-IEND payload between offsets $((iend_offset+12))-$actual_filesize in $image"
                fi
            fi
        fi

        # Compare actual file size vs declared image size (find appended data)
        local actual_filesize
        actual_filesize=$(stat -c%s "$image" 2>/dev/null)
        local logical_dim
        logical_dim=$(echo "$pngcheck_output" | awk '/image data/ {print $4}')
        log_info "File size: $actual_filesize; Declared logical: $logical_dim"
        if [[ -n "$logical_dim" && "$actual_filesize" -gt "$((logical_dim + 2048))" ]]; then
            log_warning "File size exceeds declared PNG image bulk by >2KB (possible hidden streams or data)"
        fi

    else
        log_warning "pngcheck not available; skipping advanced PNG chunk and CRC analysis"
    fi

    # Fast check for embedded ZIP/EXE/Base64 patterns
    if xxd -p "$image" | grep -qE '(504b0304|25504446|4d5a90|89504e47|504b0506)'; then
        log_forensic "Suspicious binary payload or overlay signature detected in PNG file"
    fi

    # Brute force: check for enormous tEXt/iTXt chunk length (may contain scripts or base64-encoded malware)
    if command -v hexdump &> /dev/null; then
        local suspicious_chunk_count
        suspicious_chunk_count=$(hexdump -C "$image" | grep -E 'tEXt|zTXt|iTXt|qRsT|pAYL' | wc -l)
        if [ "$suspicious_chunk_count" -gt 5 ]; then
            log_warning "High count of text-type chunks ($suspicious_chunk_count) - elevated risk of embedded data or malware"
        fi
    fi
}

check_jpeg_structure() {
    local image="$1"

    log_info "Analyzing JPEG structure and forensic markers..."

    # Direct header validation
    if ! xxd -p -l 2 "$image" | grep -q '^ffd8'; then
        log_warning "File $image does not begin with JPEG SOI marker"
        log_forensic "Header mismatch: $image"
        return
    fi

    # Use jpeginfo if available
    if command -v jpeginfo &> /dev/null; then
        local jpeginfo_output
        jpeginfo_output=$(jpeginfo -c "$image" 2>&1)
        if echo "$jpeginfo_output" | grep -qi "error\|warning\|corrupt"; then
            log_warning "JPEG structure issues: $jpeginfo_output"
            log_forensic "JPEG structure issues: $jpeginfo_output"
        fi
    else
        # Fallback: use Python PIL to validate JPEG integrity
        local python_cmd=$(get_python_cmd)
        if [ -n "$python_cmd" ]; then
            local validation_result
            validation_result=$("$python_cmd" - "$image" <<'PYJPEGVALIDATE' 2>/dev/null
import sys
try:
    from PIL import Image
    img_path = sys.argv[1]
    
    # Try to open and verify the image
    with Image.open(img_path) as img:
        img.verify()
    
    # Reopen to check for truncation
    with Image.open(img_path) as img:
        try:
            img.load()
            print("VALID")
        except Exception as e:
            print(f"TRUNCATED: {e}")
except Exception as e:
    print(f"INVALID: {e}")
PYJPEGVALIDATE
)
            if [ -n "$validation_result" ]; then
                if echo "$validation_result" | grep -qi "INVALID\|TRUNCATED"; then
                    log_warning "JPEG validation (PIL): $validation_result"
                    log_forensic "JPEG integrity issue: $validation_result"
                fi
            fi
        else
            log_info "jpeginfo not found. Using basic JPEG structure checks only."
        fi
    fi

    # Check for multiple APPx markers (potential stego, payload, exfil, obfuscation)
    local app_markers app_desc
    app_markers=$(xxd "$image" 2>/dev/null | grep -c "ff e[0-9a-f]")
    if [ "$app_markers" -gt 5 ]; then
        log_forensic "Unusual number of APP markers in JPEG: $app_markers"
        app_desc=$(xxd "$image" 2>/dev/null | grep -E "ff e[0-9a-f]" | cut -d: -f2 | head -n10)
        log_info "Sample APP marker content: $app_desc"
    fi

    # Check for JPEG comments (COM marker)
    if xxd "$image" 2>/dev/null | grep -q "ff fe"; then
        log_forensic "JPEG contains comment marker (COM)"
        python3 << EOF 2>/dev/null
import sys
try:
    with open('$image', 'rb') as f:
        data = f.read()
        pos = 0
        while True:
            pos = data.find(b'\xff\xfe', pos)
            if pos == -1:
                break
            length = int.from_bytes(data[pos+2:pos+4], 'big')
            comment = data[pos+4:pos+2+length]
            try:
                print(f"JPEG_COMMENT: {comment[:100].decode(errors='replace')}")
            except Exception:
                print(f"JPEG_COMMENT_HEX: {comment[:100].hex()}")
            pos += length + 2
except Exception:
    pass
EOF
    fi

    # Detect rare markers: DQT (tables), DHT, unusual JFIF, EXIF, ICC
    local rare_markers
    rare_markers=$(xxd "$image" 2>/dev/null | grep -E "ff (db|c4|e1|ee|e2|e3|ed|fe)") # DQT, DHT, EXIF, ICC, COM
    if [ -n "$rare_markers" ]; then
        log_info "Rare or metadata markers detected in JPEG."
        echo "$rare_markers" | head -n 10 | while read -r line; do
            log_forensic "RARE_JPEG_MARKER: $line"
        done
    fi

    # EXIF metadata check (potential QR stego)
    if command -v exiftool &> /dev/null; then
        local exif_out
        exif_out=$(exiftool "$image" 2>/dev/null | grep -Ei "(UserComment|Comment|Software|Maker|Model|Hidden|Steg|QR|Payload|QRCode)")
        if [ -n "$exif_out" ]; then
            log_info "Suspicious EXIF fields found in JPEG."
            log_forensic "EXIF_ANOMALY: $exif_out"
        fi
    fi

    # Check file size anomaly vs minimum JPEG (possible appended/exfil)
    local min_jpeg=1024
    local jpeg_size
    jpeg_size=$(stat -c%s "$image" 2>/dev/null)
    if [[ "$jpeg_size" -gt "$min_jpeg" ]]; then
        # Look for redundancy past EOI
        local eoi_offset
        eoi_offset=$(grep -abo --binary -P '\xFF\xD9' "$image" | tail -1 | cut -d: -f1)
        if [ -n "$eoi_offset" ] && [ "$jpeg_size" -gt $((eoi_offset + 2 + 128)) ]; then
            log_warning "JPEG file continues $((jpeg_size-eoi_offset-2)) bytes after EOI (possible hidden streams)"
            log_forensic "Post-EOI payload between offsets $((eoi_offset+2))-$jpeg_size in $image"
        fi
    fi
}

################################################################################
# OCR ANALYSIS FOR TEXT OVERLAY DETECTION
################################################################################

perform_ocr_analysis() {
    local image="$1"
    local filetype=""
    local extension=""
    local extracted_files=()

    # Extension and MIME detection
    extension="${image##*.}"
    extension=$(echo "$extension" | tr '[:upper:]' '[:lower:]')
    if command -v file &> /dev/null; then
        filetype=$(file --mime-type -b "$image")
    fi

    # PDF: extract images embedded in PDF QR documents for OCR
    if [[ "$extension" =~ ^pdf$ ]] || [[ "$filetype" =~ ^application/pdf$ ]]; then
        if command -v pdfimages &> /dev/null; then
            log_info "PDF detected: extracting image streams for QR OCR"
            mkdir -p "${TEMP_DIR}/pdf_ocr"
            pdfimages -all "$image" "${TEMP_DIR}/pdf_ocr/extract" 2>/dev/null
            extracted_files=($(ls "${TEMP_DIR}/pdf_ocr"/extract* 2>/dev/null))
        else
            log_warning "pdfimages not available; cannot analyze PDF images for QR code OCR"
            return
        fi
    # SVG: extract embedded QR payload as text
    elif [[ "$extension" == "svg" ]] || [[ "$filetype" == "image/svg+xml" ]]; then
        log_info "SVG detected: extracting embedded QR code payload text"
        local svg_txt="${TEMP_DIR}/svg_ocr_$(basename "$image").txt"
        if command -v xmllint &> /dev/null; then
            xmllint --xpath '//text()' "$image" 2>/dev/null > "$svg_txt" || true
        else
            grep -oP '>([^<>]+)<' "$image" | sed 's/[<>]//g' > "$svg_txt"
        fi
        extracted_files+=("$svg_txt")
    # Video: extract frames to catch QR codes in moving images
    elif [[ "$extension" =~ ^(mp4|webm|mkv|avi)$ ]] || [[ "$filetype" =~ ^video/ ]]; then
        if command -v ffmpeg &> /dev/null; then
            mkdir -p "${TEMP_DIR}/vid_ocr"
            log_info "Video detected: extracting frames for QR code OCR"
            ffmpeg -loglevel quiet -i "$image" -vf "fps=1" "${TEMP_DIR}/vid_ocr/frame_%03d.png"
            extracted_files=($(ls "${TEMP_DIR}/vid_ocr"/frame_*.png 2>/dev/null))
        else
            log_warning "ffmpeg not available; cannot analyze video frames for QR code OCR"
            return
        fi
    else
        extracted_files=("$image")
    fi

    # Forensic QR code threat patterns (expand as needed)
    local QR_THREAT_PATTERNS=(
        "bitcoin|btc|xmr|eth|wallet|address|crypt|monero"
        "flag|secret|password|passwd|token|auth|access|key|pin|2fa"
        "curl|wget|powershell|bash|cmd|exec|system|run|shell|inject"
        "appscheme://|intent://|javascript:|data:text/html|base64,"
        "https?://|www\."
        "mailto:[a-z0-9._%+-]+@([a-z0-9.-]+\\.)+[a-z]{2,}"
        "[a-z0-9._%+-]+@([a-z0-9.-]+\\.)+[a-z]{2,}"
        "api|webhook|callback|endpoint|ftp://|sftp://|file://|smb://"
        "[0-9]{3}[-. ]?[0-9]{3}[-. ]?[0-9]{4}"  # phone number
        "attack|ctf|capture"
        "--data|--upload"
        "[A-Za-z0-9+/=]{16,}"  # base64 long (code/data exfil)
    )

    # Process every extracted file/frame
    for f in "${extracted_files[@]}"; do
        if ! command -v tesseract &> /dev/null; then
            log_warning "Tesseract OCR not available, skipping QR code text overlay analysis"
            return
        fi

        log_info "OCR scanning $f for QR code threats and payloads..."

        local ocr_output="${TEMP_DIR}/ocr_$(basename "$f").txt"
        local norm_output="${TEMP_DIR}/ocrnorm_$(basename "$f").txt"

        tesseract "$f" "${ocr_output%.txt}" -l eng --psm 6 2>/dev/null

        if [ -s "$ocr_output" ]; then
            tr -d '\r' < "$ocr_output" | tr -s ' ' | tr '[:upper:]' '[:lower:]' > "$norm_output"
            log_info "OCR detected text in $f"
            local text_content norm_content
            text_content=$(cat "$ocr_output")
            norm_content=$(cat "$norm_output")

            # Entropy: QR malware tends to use encoded blobs
            local entropy=""
            entropy=$(echo "$norm_content" | awk '
                {s+=$0; l+=length($0);}
                END{
                    split($0,chars,"");
                    for (i in chars) freq[chars[i]]++;
                    e=0;
                    for (c in freq) e-=freq[c]/l*log(freq[c]/l)/log(2);
                    print e
                }') || entropy="0.0"
            if [[ "$entropy" =~ ^[6-9]\.[0-9]+|10\.[0-9]+$ ]]; then
                log_threat 35 "QR code OCR output block is suspiciously high-entropy (stego or encoded malware?)"
                log_forensic "QR OCR HIGH ENTROPY BLOCK: $entropy in $f"
            fi

            # QR-specific threat patterns
            for pattern in "${QR_THREAT_PATTERNS[@]}"; do
                if echo "$norm_content" | grep -qE -- "$pattern"; then
                    log_threat 30 "QR OCR detected threat pattern: $pattern in $f"
                    log_forensic "QR OCR threat match ($pattern): $(echo "$norm_content" | grep -E -- "$pattern")"
                fi
            done

            # Common phishing markers
            if echo "$norm_content" | grep -qiE "verify|urgent|click|security|youraccount|alert"; then
                log_threat 22 "QR code payload uses phishing text (social engineering)"
                log_forensic "QR phishing marker in text: $(echo "$norm_content" | grep -iE "verify|urgent|click|security|youraccount|alert")"
            fi

            # Save both raw and normalized output for evidence
            cp "$ocr_output" "${EVIDENCE_DIR}/"
            cp "$norm_output" "${EVIDENCE_DIR}/"
        fi
    done
}

################################################################################
# URL AND DOMAIN ANALYSIS FOR QR CODE MALWARE DETECTION
################################################################################

analyze_url_structure() {
    set +u
    local url="${1:-}"
    set -u
    local threats=0

    log_info "QR CODE MALWARE: Deep URL analysis of payload: $url"

    # Extract components (POSIX compatible)
    local protocol=$(echo "$url" | sed -n 's/^\([a-z]*\):.*/\1/p' | head -1)
    local domain=$(echo "$url" | sed -E 's|^[a-z]+://||' | cut -d'/' -f1 | cut -d':' -f1)
    local port=$(echo "$url" | sed -n 's/.*:\([0-9][0-9]*\).*/\1/p' | head -1)
    local path=$(echo "$url" | sed 's|^[^/]*//[^/]*/||')
    local query=$(echo "$url" | sed -n 's/.*\(\?.*\)$/\1/p' | head -1)

    # Display parsed URL components
    echo ""
    echo -e "${CYAN}┌─────────────────────────────────────────────────────────────┐${NC}"
    echo -e "${CYAN}│      QR CODE PAYLOAD - URL FORENSIC ANALYSIS                │${NC}"
    echo -e "${CYAN}├─────────────────────────────────────────────────────────────┤${NC}"
    echo -e "${CYAN}│${NC} Protocol:    ${WHITE}${protocol:-N/A}${NC}"
    echo -e "${CYAN}│${NC} Domain:      ${WHITE}${domain:-N/A}${NC}"
    echo -e "${CYAN}│${NC} Port:        ${WHITE}${port:-default}${NC}"
    echo -e "${CYAN}│${NC} Path:        ${WHITE}${path:-/}${NC}"
    echo -e "${CYAN}│${NC} Query:       ${WHITE}${query:-none}${NC}"
    echo -e "${CYAN}│${NC} Length:      ${WHITE}${#url} characters${NC}"
    echo -e "${CYAN}└─────────────────────────────────────────────────────────────┘${NC}"
    echo ""

    # QR code-specific attack vector: scheme abuse (intent, javascript, app, ftp, etc.)
    for scheme in "${DANGEROUS_URI_SCHEMES[@]}"; do
        if [[ "$url" =~ ^$scheme ]]; then
            log_forensic_detection 50 \
                "Dangerous/Exploitative URI Scheme in QR code" \
                "scheme:$scheme, url:${url:0:100}" \
                "QR code malware - exploitative scheme" \
                "QR code analysis" \
                "Do not scan - may execute on mobile platforms, exfil, or invoke app handlers" \
                "T1204.001 - Malicious Link"
            ((threats++))
        fi
    done

    # Non-HTTP/HTTPS protocols
    if [ -n "$protocol" ] && [[ ! "$protocol" =~ ^https?$ ]]; then
        log_forensic_detection 15 \
            "Non-HTTP Protocol in QR payload" \
            "protocol:$protocol" \
            "Protocol analysis" \
            "QR code transported URL" \
            "May trigger unintended handler (SMS, phone, mailto, etc)" \
            "T1204 - User Execution"
        ((threats++))
    fi

    # IP-based URLs (QR phishing, C2, VPN, exfil)
    if [[ "$domain" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
        log_forensic_detection 25 \
            "IP-Based QR payload" \
            "ip:$domain" \
            "Direct connect address (usually C2, exploit host, trick bypass)" \
            "QR code host field" \
            "Suspicious for malware, infrastructure, phishing." \
            "T1583.003 - VPS"
        ((threats++))

        # Known IOC lookup (QR attacker infra)
        if [[ -v "KNOWN_MALICIOUS_IPS[$domain]" ]] && [[ -n "${KNOWN_MALICIOUS_IPS[$domain]}" ]]; then
            log_forensic_detection 100 \
                "KNOWN MALICIOUS IP IN QR" \
                "ip:$domain, attribution:${KNOWN_MALICIOUS_IPS[$domain]}" \
                "QR IOC scan hit" \
                "QR code host domain" \
                "BLOCK IMMEDIATELY" \
                "Internal IOC"
        fi

        # Private/reserved
        if [[ "$domain" =~ ^(10\.|172\.(1[6-9]|2[0-9]|3[01])\.|192\.168\.|127\.|0\.|169\.254\.) ]]; then
            log_forensic_detection 40 \
                "Private/Reserved IP Address in QR payload" \
                "ip:$domain, type:RFC1918/Reserved" \
                "QR SSRF/Proxy classification" \
                "QR host field" \
                "Possible SSRF, pivot, or misdirection" \
                "T1090 - Proxy"
        fi
    fi

    # Port - C2, malware droppers, QR bypass
    if [ -n "$port" ]; then
        case "$port" in
            80|443|8080|8443) ;;
            *)
                log_forensic_detection 10 \
                    "Unusual Port in QR code payload" \
                    "port:$port" \
                    "Port analysis" \
                    "QR code URL port" \
                    "Non-standard port: C2, proxy, or malware dropper" \
                    "T1571 - Non-Standard Port"
                ((threats++))
                ;;
        esac
        if [ "$port" -gt 10000 ]; then
            log_threat 15 "High port may indicate QR C2 or malware exfil: $port"
        fi
    fi

    # Malicious domain lists (QR blocklist hit)
    for malicious_domain in "${HARDCODED_MALICIOUS_DOMAINS[@]}"; do
        if [[ "$domain" == *"$malicious_domain"* ]]; then
            log_forensic_detection 100 \
                "Known Malicious Domain in QR payload" \
                "domain:$domain, matched:$malicious_domain" \
                "QR malicious domain blocklist" \
                "QR code domain" \
                "BLOCK IMMEDIATELY" \
                "T1566 - Phishing"
            ((threats++))
        fi
    done

    # QR shorteners (used to hide final destination)
    for shortener in "${URL_SHORTENERS[@]}"; do
        if echo "$domain" | grep -qE "$shortener"; then
            log_forensic_detection 20 \
                "QR/URL Shortener in QR code" \
                "shortener:$domain, service:$shortener" \
                "Shortener pattern matching" \
                "QR domain field" \
                "Trace short URL - hides malicious links in QR" \
                "T1566.002 - Spearphishing Link"
            ((threats++))
            resolve_url_redirect "$url"
            break
        fi
    done

    # Suspicious TLDs
    for tld in "${SUSPICIOUS_TLDS[@]}"; do
        if echo "$domain" | grep -qE "$tld\$"; then
            log_forensic_detection 30 \
                "Suspicious TLD in QR code" \
                "tld:$tld, domain:$domain" \
                "Malware TLD pattern matching" \
                "QR code domain" \
                "High-risk TLD, typically malicious QR codes" \
                "T1583.001 - Domains"
            ((threats++))
            break
        fi
    done

    # Homograph/typo attacks in QR (phishing, impersonation)
    check_homograph_attack "$domain"
    check_typosquatting "$domain"

    # URL payload: QR code often encodes direct download, script, command, base64, etc.
    for pattern in "${SUSPICIOUS_URL_PATTERNS[@]}"; do
        if echo "$path$query" | grep -qiE "$pattern"; then
            log_forensic_detection 15 \
                "Suspicious/malicious QR code URL pattern" \
                "pattern:$pattern" \
                "QR URL pattern" \
                "QR code path and query" \
                "Indicator of QR-encoded malware or phishing payload" \
                "T1566 - Phishing"
            ((threats++))
        fi
    done

    # URL encoding: QR codes often double-encode/exfil payloads or scripts
    if echo "$url" | grep -qE "%[0-9a-fA-F]{2}"; then
        log_forensic_detection 10 \
            "URL Encoding in QR code" \
            "url:${url:0:100}" \
            "QR code URL encoded string" \
            "QR code value" \
            "Inspect decoded data for hidden malware" \
            "" \
            "INFO"
        # FIXED: Use printf and stdin to safely pass URL to Python
        local decoded_url
        decoded_url=$(printf '%s' "$url" | $(get_python_cmd) -c "import sys, urllib.parse; print(urllib.parse.unquote(sys.stdin.read()))" 2>/dev/null)
        if [ "$url" != "$decoded_url" ]; then
            log_info "Decoded QR code URL: $decoded_url"
            # Recursively analyze decoded URL
            analyze_url_structure "$decoded_url"
        fi
        # Double encoding
        if echo "$url" | grep -qE "%25[0-9a-fA-F]{2}"; then
            log_forensic_detection 25 \
                "QR code double URL encoding (advanced evasion)" \
                "technique:double_encoding" \
                "Double percent encoding in QR URL" \
                "Evasion mechanism" \
                "Advanced encoding: inspect thoroughly" \
                "T1027 - Obfuscated Files"
        fi
    fi

    # Data URI: QR code can include direct executable payload or script as data URI
    if [[ "$url" =~ ^data: ]]; then
        log_forensic_detection 40 \
            "Data URI (embedded payload) in QR code" \
            "uri_type:data" \
            "Data URI detection in QR code scan" \
            "QR code scheme" \
            "Embedded script or file: malware, phishing, exploit" \
            "T1027 - Obfuscated Files"
        analyze_data_uri "$url"
    fi

    # Base64 blobs: QR code dropping binary/script payloads for device execution
    if echo "$url" | grep -qE "[A-Za-z0-9+/]{50,}=*"; then
        log_forensic_detection 25 \
            "Base64 Encoded Data in QR code URL" \
            "encoding:base64, source:QR" \
            "Base64 code in QR parameter/path" \
            "Data embedded in QR scan" \
            "Stego or malware blob: decode for analysis" \
            "T1132 - Data Encoding"
        analyze_base64_in_url "$url"
    fi

    # DNS/WHOIS checks if network available
    if [ "$NETWORK_CHECK" = true ]; then
        check_domain_whois "$domain"
        check_domain_dns "$domain"
        check_ssl_certificate "$url"
    fi

    return $threats
}

analyze_data_uri() {
    set +u
    local uri="${1:-}"
    set -u

    log_info "Analyzing Data URI from QR code payload..."

    # Extract MIME type (POSIX compatible)
    local mime_type=$(echo "$uri" | sed -n 's/^data:\([^;,]*\).*/\1/p')
    log_forensic "Data URI MIME type: $mime_type"

    # Forensics: Dangerous MIME types commonly abused in QR infection
    case "$mime_type" in
        "text/html"|"application/javascript"|"text/javascript"|"application/x-javascript")
            log_forensic_detection 50 \
                "Dangerous Data URI MIME Type in QR Code" \
                "mime:$mime_type" \
                "MIME type match to executable/browser content" \
                "Data URI in QR Code" \
                "Can execute code or script when rendered via QR scan on device/browser" \
                "MITRE ATT&CK T1059.007 - JavaScript"
            ;;
        "application/x-msdownload"|"application/x-executable"|"application/octet-stream"|"application/x-dosexec"|"application/x-binary"|"application/x-sh"|"application/x-elf")
            log_forensic_detection 80 \
                "Executable Data URI in QR Code" \
                "mime:$mime_type" \
                "Executable MIME type detection" \
                "Data URI in QR Code" \
                "CRITICAL - Executable malware payload encoded by QR, extremely dangerous" \
                "MITRE ATT&CK T1204.002 - Malicious File"
            ;;
        "image/svg+xml"|"image/png"|"image/jpeg"|"audio/mp3"|"video/mp4")
            log_info "QR Data URI contains multimedia content: $mime_type"
            ;;
        *)
            # Other types can be suspicious (document, script, etc)
            if [[ "$mime_type" =~ "script"|"shell"|"pdf"|".doc"|".xls"|".ppt"|"office"|".xlsm"|".docm" ]]; then
                log_forensic_detection 30 \
                    "Suspicious Data URI MIME Type in QR Code" \
                    "mime:$mime_type" \
                    "Potential script or document dropper" \
                    "Data URI in QR scan" \
                    "Can be leveraged for macro or script injection via QR scan" \
                    "MITRE ATT&CK T1204 - User Execution"
            fi
            ;;
    esac

    # Extract and decode Base64 content (handle newlines and padding)
    if echo "$uri" | grep -q "base64,"; then
        local encoded=$(echo "$uri" | sed 's/.*base64,//')
        # Remove any spaces/newlines to properly decode base64
        encoded=$(echo "$encoded" | tr -d '\n\r ')
        local decoded=""
        decoded=$(echo "$encoded" | base64 -d 2>/dev/null)
        if [ -n "$decoded" ]; then
            log_forensic "Decoded Data URI content (first 200 chars): ${decoded:0:200}"

            # Check decoded content for QR-relevant threats: html/script, shellcode, exploits, secrets, URLs, credentials
            # AUDIT FIX: Fixed character class - use [_-] instead of [_\-]
            if echo "$decoded" | grep -qE "(<script>|eval\(|window\.|curl|wget|powershell|api[_-]?key|flag|password|secret|BEGIN RSA|-----BEGIN|bitcoin|eth|xmr|wallet|address|token|href=|src=|cmd|exec|system|mailto:)"; then
                log_threat 55 "Decoded Data URI contains executable/malicious code or credential artifacts"
                log_forensic "QR Data URI threat content: $(echo "$decoded" | grep -oE '(<script>|eval\(|curl|wget|api[_-]?key|flag|password|secret|bitcoin|wallet|cmd|exec|system|mailto:).{0,32}')"
            fi

            # Base64 in SVG or HTML: phishing or exploit chains
            if [[ "$mime_type" == "text/html" || "$mime_type" == "image/svg+xml" ]] && echo "$decoded" | grep -iq 'base64,'; then
                log_threat 30 "Nested base64 detected in QR HTML/SVG Data URI"
            fi

            # Entropy check for stego/encrypted/injected
            local entropy
            entropy=$(echo "$decoded" | awk '{ l+=length($0); for(i=1;i<=length($0);i++) freq[substr($0,i,1)]++; }
                END{ e=0; for (c in freq) e-=freq[c]/l*log(freq[c]/l)/log(2); print e }')
            if [[ "$entropy" == "" ]]; then entropy=0.0; fi
            if (( $(echo "$entropy > 6.5" | bc -l) )); then
                log_forensic "Decoded Data URI is high entropy (may contain binary/stego malware): Entropy=$entropy"
            fi

            # Save evidence for analysis chain
            echo "$decoded" > "${EVIDENCE_DIR}/decoded_data_uri_$(date +%s).txt"

            # Recursive: analyze decoded content using other routines if needed
            analyze_decoded_content "$decoded"
        fi
    fi
}

analyze_base64_in_url() {
    set +u
    local url="${1:-}"
    set -u

    # Extract potential Base64 strings (QR codes often encode entire payloads or commands)
    local b64_strings=$(echo "$url" | grep -oE "[A-Za-z0-9+/]{50,}=*")

    for b64 in $b64_strings; do
        # Clean and decode, tolerate padding and newlines
        local decoded=$(echo "$b64" | tr -d '\n\r ' | base64 -d 2>/dev/null)
        if [ -n "$decoded" ]; then
            log_forensic "Decoded Base64 from QR code URL (first 100 chars): ${decoded:0:100}"

            # QR-specific threat checks: shell, script, secret, credential, C2 beacon, phishing, exploit, stego
            # AUDIT FIX: Fixed character class - use [_-] instead of [_\-]
            if echo "$decoded" | grep -qE "(<script>|eval\(|curl|wget|powershell|api[_-]?key|flag|password|secret|BEGIN RSA|bitcoin|wallet|address|token|cmd|exec|system|mailto:|src=|href=|data:text/html|javascript:)"; then
                log_threat 45 "Decoded payload contains potential code or credentials, QR exploit suspected"
                log_forensic "QR Base64 threat markers: $(echo "$decoded" | grep -oE '(<script>|eval\(|curl|wget|api[_-]?key|flag|password|secret|bitcoin|wallet|cmd|exec|system|mailto:).{0,32}')"
            fi

            # Detect high-entropy (stego, encrypted, binary malware)
            local entropy
            entropy=$(echo "$decoded" | awk '{ l+=length($0); for(i=1;i<=length($0);i++) freq[substr($0,i,1)]++; }
                END{ e=0; for (c in freq) e-=freq[c]/l*log(freq[c]/l)/log(2); print e }')
            if [[ "$entropy" == "" ]]; then entropy=0.0; fi
            if (( $(echo "$entropy > 6.5" | bc -l) )); then
                log_forensic "Decoded Base64 from QR is high entropy (stego/malware possible): Entropy=$entropy"
            fi

            # Save payload for forensic chain
            echo "$decoded" > "${EVIDENCE_DIR}/qr_payload_decoded_$(date +%s).txt"

            # Recursive or full malware checks
            analyze_decoded_content "$decoded"
        fi
    done
}

analyze_decoded_content() {
    set +u
    local content="${1:-}"
    set -u

    # Check for script tags, inline JS, event handlers (QR phishing/exploit)
    if echo "$content" | safe_grep_qiE "<script|javascript:|onerror=|onload=|onmouseover=|onfocus=|onwheel=|onmessage=|setTimeout\(|setInterval\(|fetch\(|XMLHttpRequest"; then
        local js_indicators
        js_indicators=$(echo "$content" | safe_grep_oiE "<script|javascript:|onerror=|onload=|onmouseover=|onfocus=|onwheel=|onmessage=|setTimeout\(|setInterval\(|fetch\(|XMLHttpRequest" | sort -u | tr '\n' ',' | sed 's/,$//')
        log_forensic_detection 40 \
            "JavaScript/Browser Exploit Detected in Decoded QR Content" \
            "js_indicators:$js_indicators" \
            "Script/event handler pattern matching" \
            "QR code decoded content" \
            "Potential XSS, browser exploit or malicious script - NEVER execute scanned QR content." \
            "MITRE ATT&CK T1059.007 - JavaScript"
    fi

    # Embedded URLs (QR code exfil, redirect, phishing, C2)
    if echo "$content" | safe_grep_qiE "https?://|ftp://|file://|smb://"; then
        local embedded_urls=$(echo "$content" | safe_grep_oE "https?://[^[[:space:]]\"'<>]+|ftp://[^[[:space:]]\"'<>]+|file://[^[[:space:]]\"'<>]+|smb://[^[[:space:]]\"'<>]+")
        log_forensic "Embedded URLs in decoded QR content: $embedded_urls"
        # Phishing/shortener indicators
        if echo "$embedded_urls" | grep -qiE "bit\.ly|tinyurl|goo\.gl|is\.gd|t\.co|cutt\.ly|qr\.co"; then
            log_threat 30 "Shortened URL detected in decoded QR code payload"
        fi
    fi

    # Command execution artifacts (QR auto-action, exploit, dropper)
    if echo "$content" | safe_grep_qiE "powershell|cmd|bash|sh|wget|curl|python|chmod|base64 -d|nc |netcat|rm |mkfs|ssh-keygen|openssl|systemctl|launchctl|osascript"; then
        local cmd_keywords
        cmd_keywords=$(echo "$content" | safe_grep_oiE "powershell|cmd|bash|sh|wget|curl|python|chmod|base64 -d|nc |netcat|rm |mkfs|ssh-keygen|openssl|systemctl|launchctl|osascript" | sort -u | tr '\n' ',' | sed 's/,$//')
        log_forensic_detection 50 \
            "Command Execution Keywords Detected in Decoded QR Content" \
            "commands:$cmd_keywords" \
            "System/remote code execution keyword matching" \
            "QR code decoded content" \
            "CRITICAL: Contains shell/command/controller keywords - DO NOT EXECUTE." \
            "MITRE ATT&CK T1059 - Command and Scripting Interpreter"
    fi

    # Credentials, secrets, flags, crypto (QR exfil/phishing CTX)
    # AUDIT FIX: Fixed character class - moved dash to end [A-Za-z0-9_-] instead of [A-Za-z0-9\-_]
    if echo "$content" | safe_grep_qiE "[A-Za-z0-9]{32,}|api[_-]?key|flag\{[A-Za-z0-9_-]+\}|password|passwd|secret|token|wallet|mnemonic|recover|seed|private.?key|ssh-rsa|-----BEGIN"; then
        log_forensic_detection 55 \
            "Secrets/Credentials/CTF Flags Detected in Decoded QR Content" \
            "suspect_keyword_detected" \
            "Credential/payload artifact" \
            "QR decoded content" \
            "High risk: possible credential or sensitive info exfil via QR payload." \
            "MITRE ATT&CK T1119 - Automated Collection"
    fi

    # Email addresses (QR social engineering, phishing, exfil)
    if echo "$content" | safe_grep_qE "[a-z0-9._%+-]+@[a-z0-9.-]+\.[a-z]{2,}"; then
        # AUDIT FIX: Simplified email pattern to avoid catastrophic backtracking
        # Old pattern: [a-z0-9._%+-]+@([a-z0-9.-]+\.)+[a-z]{2,}
        # Issue: Repeated group ([a-z0-9.-]+\.)+ can cause exponential backtracking
        # New: Flattened pattern without nested quantifiers
        log_forensic "Email addresses detected in decoded QR content: $(echo "$content" | safe_grep_oE "[a-z0-9._%+-]+@[a-z0-9.-]+\.[a-z]{2,}" | tr '\n' ',' | sed 's/,$//')"
    fi

    # Base64 detected in decoded QR content (multi-encoded exfil/obfuscation)
    if echo "$content" | safe_grep_qE "[A-Za-z0-9+/]{40,}=*"; then
        log_forensic "Nested base64 block detected in decoded QR content"
    fi

    # Save content for evidence processing chain
    echo "$content" > "${EVIDENCE_DIR}/qr_decoded_content_$(date +%s).txt"
}

resolve_url_redirect() {
    local url="$1"
    local max_redirects=10

    if [ "$NETWORK_CHECK" = false ]; then
        log_info "Network analysis disabled - not resolving QR redirects."
        return
    fi

    log_info "Resolving redirects for QR code payload URL: $url"

    # Get full redirect chain (with timeout and anti-SSRF protection)
    local redirect_chain
    redirect_chain=$(curl -sIL --max-time 10 --max-redirs "$max_redirects" -w "%{url_effective}\n" -o /dev/null "$url" 2>/dev/null)

    if [ -n "$redirect_chain" ] && [ "$redirect_chain" != "$url" ]; then
        log_warning "QR code URL redirect resolved to: $redirect_chain"

        # Save redirect chain for evidence (forensic chain-of-custody)
        echo "QR Redirect chain for $url: $redirect_chain" >> "${EVIDENCE_DIR}/redirects_$(date +%s).log"

        # Count redirects
        local redirect_count
        redirect_count=$(curl -sIL --max-time 10 --max-redirs "$max_redirects" -w "%{redirect_count}" -o /dev/null "$url" 2>/dev/null)
        if [ "$redirect_count" -gt 3 ]; then
            log_threat 15 "Excessive QR redirects detected: $redirect_count (high likelihood of phishing or redirector evasion)"
        fi
        if [ "$redirect_count" -gt "$max_redirects" ]; then
            log_forensic_detection 25 \
                "QR code redirect chain exceeded safe limits" \
                "redirects:$redirect_count,url:$url" \
                "Redirect analysis" \
                "QR code URL redirects" \
                "Multiple chained redirects suggest evasive/malicious infrastructure" \
                "MITRE ATT&CK T1583 - Infrastructure"
        fi

        # Analyze final destination for further QR malware/redirector context
        analyze_url_structure "$redirect_chain"
    else
        log_info "QR code URL resolved without redirection: $url"
    fi
}

check_homograph_attack() {
    local domain="$1"

    # Mixed scripts detection (Latin + non-Latin = visually spoofed QR domains)
    # Use byte pattern detection instead of character ranges for portability
    local has_latin=$(echo "$domain" | grep -q '[a-zA-Z]' && echo 1 || echo 0)
    # Detect non-ASCII characters using byte patterns (UTF-8 multi-byte sequences)
    local has_nonascii=$(printf '%s' "$domain" | LC_ALL=C grep -q '[^[:print:]]' && echo 1 || \
                         printf '%s' "$domain" | od -An -tx1 2>/dev/null | grep -qE '[c-f][0-9a-f]' && echo 1 || echo 0)

    if [ "$has_latin" = "1" ] && [ "$has_nonascii" = "1" ]; then
        log_forensic_detection 50 \
            "HOMOGRAPH ATTACK - Mixed Character Sets in QR Code Domain" \
            "domain:$domain, scripts_detected:latin,cyrillic,greek,hebrew,chinese" \
            "Unicode script mixing detection" \
            "QR domain analysis" \
            "SPOOFING ATTEMPT in QR code payload - mixed Unicode scripts may mimic trusted domains" \
            "MITRE ATT&CK T1566.002 - Spearphishing Link"
    fi

    # Lookalike Unicode characters - most abused in QR phishing domains
    local homograph_found=false
    local homograph_count=0
    local homograph_chars_found=""
    for char in "${HOMOGRAPH_CHARS[@]}"; do
        [[ -z "$char" ]] && continue
        if echo "$domain" | grep -qF "$char"; then
            ((homograph_count++))
            local codepoint=$(printf '%s' "$char" | od -An -tx1 | tr -d ' \n')
            homograph_chars_found+="$char(0x$codepoint), "
            homograph_found=true
        fi
    done

    if [ "$homograph_found" = true ]; then
        homograph_chars_found=$(echo "$homograph_chars_found" | sed 's/, $//')
        log_forensic_detection $((40 + homograph_count * 5)) \
            "HOMOGRAPH ATTACK - Lookalike Characters in QR Domain" \
            "domain:$domain, homograph_chars:$homograph_chars_found, count:$homograph_count" \
            "Unicode homograph character check" \
            "QR code domain analysis" \
            "SPOOFING: QR code encodes domain using visually confused Unicode characters." \
            "MITRE ATT&CK T1566.002 - Spearphishing Link"
        # Save evidence
        echo "$domain:$homograph_chars_found" >> "${EVIDENCE_DIR}/qr_homograph_domains_$(date +%s).log"
    fi

    # Punycode detection (IDN/Unicode spoof domains in QR phishing campaigns)
    if echo "$domain" | grep -qE 'xn--'; then
        local decoded
        # FIXED: Use printf and stdin to safely pass domain to Python
        decoded=$(printf '%s' "$domain" | $(get_python_cmd) -c "import sys; d=sys.stdin.read().strip(); print(d.encode('ascii').decode('idna'))" 2>/dev/null)
        log_forensic_detection 30 \
            "Punycode/IDN in QR domain" \
            "domain:$domain, decoded:${decoded:-unknown}" \
            "IDN/Punycode detection" \
            "QR domain analysis" \
            "IDN/Unicode visual spoof risk - QR code may impersonate a legitimate site." \
            "MITRE ATT&CK T1583.001 - Acquire Infrastructure: Domains"
        # Save evidence
        echo "$domain:$decoded" >> "${EVIDENCE_DIR}/qr_idn_domains_$(date +%s).log"
    fi

    # Additional QR lookalike check - common zero/latin/specials in phishing domains
    local homograph_chars=( "l" "w" "і" "1" "0" "о" "Ο" "ϴ" "Ӏ" )
    local found=""
    for char in "${homograph_chars[@]}"; do
        [[ -z "$char" ]] && continue
        if echo "$domain" | grep -qF "$char"; then
            found+="$char,"
        fi
    done
    if [ -n "$found" ]; then
        found=$(echo "$found" | sed 's/,$//')
        log_info "QR domain contains these common lookalike phishing characters: $found"
    fi

    # Evidence: always save checked domains for forensics
    echo "$domain" >> "${EVIDENCE_DIR}/checked_qr_domains.log"
}

check_typosquatting() {
    local domain="$1"

    # Scan for QR phishing brand impersonation in domain (case-insensitive)
    for brand in "${PHISHING_BRANDS[@]}"; do
        if echo "$domain" | grep -qiE "$brand"; then
            # Direct typosquatting patterns (dash/dot/underscore/number suffix)
            if echo "$domain" | grep -qiE "${brand}[0-9]|${brand}-|${brand}_|${brand}\."; then
                log_forensic_detection 35 \
                    "QR Typosquatting/Impersonation Detected" \
                    "domain:$domain, impersonated_brand:$brand" \
                    "Direct brand squatting (dash/underscore/number/dot) in QR code domain" \
                    "QR code domain analysis" \
                    "Domain appears to impersonate $brand via QR code - do not trust" \
                    "MITRE ATT&CK T1583.001 - Acquire Infrastructure: Domains"
                echo "$domain:$brand:suffix" >> "${EVIDENCE_DIR}/qr_typosquat_$(date +%s).log"
            fi

            # Character substitution/leet-speak check (o→0, i→1, l→1, etc.)
            local substitutions=(
                "o/0" "i/1" "l/1" "a/4" "e/3" "s/5" "t/7" "b/8"
                "O/0" "I/1" "L/1" "A/4" "E/3" "S/5" "T/7" "B/8"
            )
            for sub in "${substitutions[@]}"; do
                local orig="${sub%/*}"
                local repl="${sub#*/}"
                local pattern="${brand//$orig/$repl}"
                if echo "$domain" | grep -qiE "$pattern" && [ "$pattern" != "$brand" ]; then
                    log_forensic_detection 40 \
                        "Leet-Speak Typosquatting in QR Domain" \
                        "domain:$domain, brand:$brand, leet_sub:$orig→$repl" \
                        "Character substitution (leet-speak) detected in QR domain" \
                        "QR code domain analysis" \
                        "LIKELY PHISHING - Substitution to visually mimic $brand via QR code" \
                        "MITRE ATT&CK T1566.002 - Spearphishing Link"
                    echo "$domain:$brand:leet:$orig:$repl" >> "${EVIDENCE_DIR}/qr_typosquat_$(date +%s).log"
                    break
                fi
            done

            # Inserted/missing/extra character detection
            local brand_len=${#brand}
            local domain_clean=$(echo "$domain" | sed 's/\..*//;s/[^[:alnum:]]//g')
            local domain_len=${#domain_clean}
            if [ $((domain_len - brand_len)) -eq 1 ] || [ $((brand_len - domain_len)) -eq 1 ]; then
                if echo "$domain_clean" | grep -qiE ".*$brand.*|$brand"; then
                    log_warning "Possible typosquatting by QR code domain, character addition or deletion"
                    echo "$domain:$brand:typo" >> "${EVIDENCE_DIR}/qr_typosquat_$(date +%s).log"
                fi
            fi

            # Double letter or adjacent repetition (eg. 'faceebook', 'paypall')
            if echo "$domain" | grep -qiE "([a-z])\1{1,}"; then
                log_forensic_detection 22 \
                    "Double Letter Typosquatting in QR Domain" \
                    "domain:$domain, brand:$brand" \
                    "Adjacent character repetition detected in QR phishing domain" \
                    "QR code domain analysis" \
                    "Suspicious - common typosquat/impersonation tactic in QR scams." \
                    "MITRE ATT&CK T1583.001"
                echo "$domain:$brand:doubleletter" >> "${EVIDENCE_DIR}/qr_typosquat_$(date +%s).log"
            fi
        fi
    done

    # Always save every checked domain for QR forensic workflow
    echo "$domain" >> "${EVIDENCE_DIR}/checked_qr_domains.log"
}

check_domain_whois() {
    local domain="$1"

    if ! command -v whois &> /dev/null || [ "$NETWORK_CHECK" = false ]; then
        log_info "WHOIS unavailable - cannot check QR domain: $domain"
        return
    fi

    log_info "Checking WHOIS for QR code domain: $domain"

    local whois_file="${TEMP_DIR}/whois_${domain//\//_}_$(date +%s).txt"
    timeout 10 whois "$domain" > "$whois_file" 2>/dev/null || return

    # Domain age analysis (new domains in QR code payloads = high risk)
    local creation_date=$(grep -iE "Creation Date|Registered|Created" "$whois_file" | head -1)
    if [ -n "$creation_date" ]; then
        log_forensic "Domain creation: $creation_date"
        local creation_timestamp=$(echo "$creation_date" | grep -oE "[0-9]{4}-[0-9]{2}-[0-9]{2}" | head -1)
        if [ -n "$creation_timestamp" ]; then
            local days_ago=$(( ($(date +%s) - $(date -d "$creation_timestamp" +%s 2>/dev/null || echo 0)) / 86400 ))
            if [ "$days_ago" -lt 30 ] && [ "$days_ago" -gt 0 ]; then
                log_threat 25 "QR domain is a newly registered domain (<30 days): $domain"
            elif [ "$days_ago" -lt 90 ] && [ "$days_ago" -gt 0 ]; then
                log_threat 10 "QR domain is a relatively new domain (<90 days): $domain"
            fi
            echo "$domain:$creation_timestamp:$days_ago" >> "${EVIDENCE_DIR}/qr_domain_age.log"
        fi
    fi

    # Registrar analysis (QR code infrastructure often uses high-abuse registrars)
    local registrar=$(grep -i "Registrar:" "$whois_file" | head -1)
    if [ -n "$registrar" ]; then
        log_forensic "Registrar: $registrar"
        local registrar_lc=$(echo "$registrar" | tr '[:upper:]' '[:lower:]')
        high_abuse_registrars=(
            "namecheap" "namesilo" "porkbun" "dynadot" "enom" "resellerclub"
            "publicdomainregistry" "alpnames" "internetbs" "reg\.ru" "r01"
            "webnames\.ru" "regway" "hostinger" "freenom" "todaynic" "bizcn"
            "west\.cn" "xinnet" "hichina" "now\.cn" "cndns" "22\.cn" "35\.com"
            "net\.cn"
        )
        for r in "${high_abuse_registrars[@]}"; do
            if [[ "$registrar_lc" =~ $r ]]; then
                log_forensic_detection 15 \
                    "High-Abuse Registrar for QR Domain Detected" \
                    "registrar:$r, domain:$domain" \
                    "Known high-abuse registrar for QR domain" \
                    "WHOIS registrar field" \
                    "Domain registered with a known abuse registrar - strong caution" \
                    "Threat Intelligence - QR Domain Registration"
                echo "$domain:$registrar_lc:highabuse" >> "${EVIDENCE_DIR}/qr_domain_registrar.log"
            fi
        done
        for suspicious_reg in "${SUSPICIOUS_REGISTRARS[@]}"; do
            [ -z "$suspicious_reg" ] && continue
            if echo "$registrar_lc" | grep -qi "$suspicious_reg"; then
                record_ioc "qr_suspicious_registrar" "$suspicious_reg" "QR domain uses suspicious/high-abuse registrar"
            fi
        done
    fi

    # Privacy protection (QR domains commonly use privacy shield to evade takedown)
    if grep -qi "privacy\|proxy\|whoisguard\|domains by proxy\|perfect privacy\|withheld\|redacted" "$whois_file"; then
        log_warning "QR code payload domain uses WHOIS privacy/shield service"
        log_threat 5 "WHOIS privacy/obfuscation - common with malicious QR domains"
        echo "$domain:privacyshield" >> "${EVIDENCE_DIR}/qr_domain_privacy.log"
    fi

    # Save raw whois evidence (for legal/forensic chain)
    cp "$whois_file" "${EVIDENCE_DIR}/"
}

check_domain_dns() {
    local domain="$1"

    if ! command -v dig &> /dev/null || [ "$NETWORK_CHECK" = false ]; then
        log_info "DNS unavailable - cannot check QR code domain: $domain"
        return
    fi

    log_info "Checking DNS records for QR code payload domain: $domain"

    local dns_file="${TEMP_DIR}/dns_${domain//\//_}_$(date +%s).txt"

    {
        echo "=== A Records ==="
        dig +short A "$domain" 2>/dev/null
        echo ""
        echo "=== AAAA Records ==="
        dig +short AAAA "$domain" 2>/dev/null
        echo ""
        echo "=== MX Records ==="
        dig +short MX "$domain" 2>/dev/null
        echo ""
        echo "=== NS Records ==="
        dig +short NS "$domain" 2>/dev/null
        echo ""
        echo "=== TXT Records ==="
        dig +short TXT "$domain" 2>/dev/null
    } > "$dns_file"

    local a_records=$(dig +short A "$domain" 2>/dev/null)

    # Multiple A records (QR C2/fast flux/layered infrastructure)
    local a_count=$(echo "$a_records" | wc -l)
    if [ "$a_count" -gt 5 ]; then
        log_threat 20 "QR domain resolves to multiple IPs ($a_count) - possible fast flux, layered C2, or evasive infra"
        echo "$domain:A-count:$a_count" >> "${EVIDENCE_DIR}/qr_dns_fastflux.log"
    fi

    # Known malicious IPs check
    for ip in $a_records; do
        if [[ -n "$ip" ]] && [[ -v "KNOWN_MALICIOUS_IPS[$ip]" ]]; then
            log_forensic_detection 80 \
                "QR DNS resolves to known malicious IP" \
                "ip:$ip, attribution:${KNOWN_MALICIOUS_IPS[$ip]}" \
                "Malicious IP blocklist check" \
                "QR DNS A record" \
                "CRITICAL - QR code domain links to malicious infrastructure" \
                "Internal IOC DB"
            echo "$domain:$ip:${KNOWN_MALICIOUS_IPS[$ip]}" >> "${EVIDENCE_DIR}/qr_dns_malip.log"
        fi
    done

    # Low TTL detection for DNS fast flux (QR phishing campaigns)
    local ttl=$(dig +nocmd +noall +answer A "$domain" 2>/dev/null | awk '{print $2}' | head -1)
    if [ -n "$ttl" ] && [ "$ttl" -lt 300 ]; then
        log_warning "QR DNS TTL low ($ttl seconds) - possible fast flux evasion tactic"
        echo "$domain:TTL:$ttl" >> "${EVIDENCE_DIR}/qr_dns_ttl.log"
    fi

    # TXT record exfiltration and malware comms
    local txt_records
    txt_records=$(dig +short TXT "$domain" 2>/dev/null)
    if [ -n "$txt_records" ]; then
        # If TXT records match patterns typical of exfil/data/crypto/command beacon
        # AUDIT FIX: Fixed character class - use [_-] instead of [_\-]
        if echo "$txt_records" | grep -qEi "api[_-]?key|flag|secret|bitcoin|wallet|token|c2|beacon|cmd|base64|ssh|vnc|payload"; then
            log_threat 30 "QR domain shows suspicious TXT record data - possible exfil/Malware"
            log_forensic "QR TXT DNS records: $txt_records"
            echo "$domain:TXT:$txt_records" >> "${EVIDENCE_DIR}/qr_dns_txt.log"
        fi
    fi

    # Save DNS data for chain-of-custody evidence
    cp "$dns_file" "${EVIDENCE_DIR}/"
}

check_ssl_certificate() {
    local url="$1"

    if [ "$NETWORK_CHECK" = false ]; then
        log_info "SSL check skipped - network checks disabled."
        return
    fi

    # Only scan HTTPS URLs for QR code payloads
    if ! echo "$url" | grep -qE "^https://"; then
        return
    fi

    local domain=$(echo "$url" | sed -E 's|^https://||' | cut -d'/' -f1 | cut -d':' -f1)

    log_info "Checking SSL certificate for QR code domain: $domain"

    local cert_file="${TEMP_DIR}/cert_${domain//\//_}_$(date +%s).txt"

    timeout 5 openssl s_client -connect "${domain}:443" -servername "$domain" </dev/null 2>/dev/null | \
        openssl x509 -noout -text > "$cert_file" 2>/dev/null

    if [ -s "$cert_file" ]; then
        # Certificate basics
        local not_before=$(grep "Not Before:" "$cert_file" | head -1)
        local not_after=$(grep "Not After:" "$cert_file" | head -1)
        local issuer=$(grep "Issuer:" "$cert_file" | head -1)
        local subject=$(grep "Subject:" "$cert_file" | head -1)

        log_forensic "QR SSL Certificate Issuer: $issuer"
        log_forensic "QR SSL Certificate Subject: $subject"
        log_forensic "QR SSL Certificate Validity: $not_before to $not_after"

        # Self-signed certificate (often used in fake/phishing QR payloads)
        if echo "$issuer" | grep -q "$(echo "$subject" | sed 's/Subject://')"; then
            log_threat 30 "QR code domain uses self-signed SSL certificate (very suspicious)."
            echo "$domain:selfsigned" >> "${EVIDENCE_DIR}/qr_ssl_selfsigned.log"
        fi

        # Very short validity (phisher trick for cheap infra)
        local expiry_date=$(echo "$not_after" | sed 's/.*Not After *//')
        local expiry_timestamp=$(date -d "$expiry_date" +%s 2>/dev/null || echo 0)
        local now_timestamp=$(date +%s)
        local days_to_expiry=$(( (expiry_timestamp - now_timestamp) / 86400 ))
        if [ "$days_to_expiry" -lt 30 ] && [ "$days_to_expiry" -gt 0 ]; then
            log_warning "QR SSL certificate expires soon (<30 days): $days_to_expiry days left"
            echo "$domain:expires:$days_to_expiry" >> "${EVIDENCE_DIR}/qr_ssl_soonexp.log"
        fi

        # Short validity overall (e.g. issued for <90 days)
        local issue_date=$(echo "$not_before" | sed 's/.*Not Before *//')
        local issue_timestamp=$(date -d "$issue_date" +%s 2>/dev/null || echo 0)
        local total_validity=$(( (expiry_timestamp - issue_timestamp) / 86400 ))
        if [ "$total_validity" -le 90 ] && [ "$total_validity" -gt 0 ]; then
            log_warning "QR SSL certificate issued for a short period ($total_validity days): possible transient/phishing infra"
            echo "$domain:valid:$total_validity" >> "${EVIDENCE_DIR}/qr_ssl_short.log"
        fi

        # Let's Encrypt often used in QR phishing setups (valid, but beware mass use)
        if echo "$issuer" | grep -qi "Let's Encrypt"; then
            log_info "SSL certificate issued by Let's Encrypt (check age/suspicious usage for QR)."
            echo "$domain:letsencrypt" >> "${EVIDENCE_DIR}/qr_ssl_lets.log"
        fi

        # Suspicious issuer patterns (mass hosters, free services)
        if echo "$issuer" | grep -qiE "cloudflare|comodo|zerossl|sectigo|startcom|trustcor|rapidssl|symantec|godaddy|alphassl|globalsign|digicert|geotrust|actalis|wo\ssl|twca|certum|swisssign|telesec|usertrust"; then
            log_warning "QR SSL issuer is a popular bulk hoster or mass/free CA. Investigate further."
            echo "$domain:issuer:$(echo "$issuer" | cut -d':' -f2-)" >> "${EVIDENCE_DIR}/qr_ssl_bulk.log"
        fi

        # Expired certificate (could be hijacked infra)
        if [ "$days_to_expiry" -lt 0 ]; then
            log_threat 20 "QR code payload domain's certificate has expired"
            echo "$domain:expired" >> "${EVIDENCE_DIR}/qr_ssl_expired.log"
        fi

        # Save full certificate details for evidence/chain-of-custody
        cp "$cert_file" "${EVIDENCE_DIR}/"
    else
        log_warning "Could not retrieve SSL certificate for $domain in QR code scan."
    fi
}

################################################################################
# THREAT INTELLIGENCE INTEGRATION
################################################################################

load_threat_intelligence() {
    log_info "Loading threat intelligence feeds..."
    
    # Create threat intel directories
    mkdir -p "${TEMP_DIR}/threat_intel"
    
    if [ "$NETWORK_CHECK" = true ]; then
        # Download OpenPhish feed
        download_openphish_feed
        
        # Download URLhaus feed
        download_urlhaus_feed
        
        # Download Abuse.ch feeds
        download_abuse_ch_feeds
        
        # Download public blocklists
        download_public_blocklists
        
        # NEW: Add all 20 missing threat intelligence feeds
        download_spamhaus_drop
        download_emerging_threats_feed
        download_cisa_kev
        download_feodo_tracker_extended
        download_sslbl_extended
        download_ransomware_tracker
        download_bambenek_feeds
        download_talos_feed
        download_threatfox_iocs
        download_malwarebazaar_hashes
        download_malpedia_families
        download_misp_warninglists
        download_inquest_iocs
        download_anyrun_iocs
        download_triage_iocs
        
        # Load PhishTank data if API key available
        if [ -n "$PHISHTANK_API_KEY" ]; then
            load_phishtank_data
        fi
        
        # Load OTX data if API key available
        if [ -n "$OTX_API_KEY" ]; then
            load_otx_pulses
        fi
    else
        log_warning "Network checks disabled, using only hardcoded IOCs"
    fi
    
    log_success "Threat intelligence loaded: ${#KNOWN_MALICIOUS_DOMAINS[@]} domains, ${#KNOWN_MALICIOUS_IPS[@]} IPs"
}

download_openphish_feed() {
    local feed_file="${TEMP_DIR}/threat_intel/openphish.txt"
    
    log_info "  Downloading OpenPhish feed..."
    
    curl -sfL --max-time 30 "https://openphish.com/feed.txt" > "$feed_file" 2>/dev/null
    
    if [ -s "$feed_file" ]; then
        local count=$(wc -l < "$feed_file")
        log_success "  OpenPhish: $count URLs loaded"
    else
        log_warning "  Failed to download OpenPhish feed"
    fi
}

download_urlhaus_feed() {
    local feed_file="${TEMP_DIR}/threat_intel/urlhaus.txt"
    
    log_info "  Downloading URLhaus feed..."
    
    curl -sfL --max-time 30 "https://urlhaus.abuse.ch/downloads/text/" > "$feed_file" 2>/dev/null
    
    if [ -s "$feed_file" ]; then
        local count=$(grep -c "^http" "$feed_file")
        log_success "  URLhaus: $count URLs loaded"
    else
        log_warning "  Failed to download URLhaus feed"
    fi
}

download_abuse_ch_feeds() {
    log_info "  Downloading Abuse.ch feeds..."
    
    # SSL blacklist
    curl -sfL --max-time 30 "https://sslbl.abuse.ch/blacklist/sslblacklist.csv" > \
        "${TEMP_DIR}/threat_intel/sslbl.csv" 2>/dev/null
    
    # Malware bazaar recent additions
    curl -sfL --max-time 30 "https://bazaar.abuse.ch/export/txt/md5/recent/" > \
        "${TEMP_DIR}/threat_intel/malware_bazaar_md5.txt" 2>/dev/null
    
    # Feodo Tracker
    curl -sfL --max-time 30 "https://feodotracker.abuse.ch/downloads/ipblocklist.txt" > \
        "${TEMP_DIR}/threat_intel/feodo_ips.txt" 2>/dev/null
    
    # ThreatFox IOCs
    curl -sfL --max-time 30 "https://threatfox.abuse.ch/export/json/recent/" > \
        "${TEMP_DIR}/threat_intel/threatfox.json" 2>/dev/null
    
    log_success "  Abuse.ch feeds loaded"
}

download_public_blocklists() {
    log_info "  Downloading public blocklists..."
    
    # Spamhaus DROP list
    curl -sfL --max-time 30 "https://www.spamhaus.org/drop/drop.txt" > \
        "${TEMP_DIR}/threat_intel/spamhaus_drop.txt" 2>/dev/null
    
    # Emergingthreats compromised IPs
    curl -sfL --max-time 30 "https://rules.emergingthreats.net/blockrules/compromised-ips.txt" > \
        "${TEMP_DIR}/threat_intel/et_compromised.txt" 2>/dev/null
    
    # Ransomware tracker domains
    curl -sfL --max-time 30 "https://ransomwaretracker.abuse.ch/downloads/RW_DOMBL.txt" > \
        "${TEMP_DIR}/threat_intel/ransomware_domains.txt" 2>/dev/null
    
    log_success "  Public blocklists loaded"
}

load_phishtank_data() {
    local api_key="$PHISHTANK_API_KEY"
    local feed_file="${TEMP_DIR}/threat_intel/phishtank.json"
    
    log_info "  Loading PhishTank data..."
    
    # Note: PhishTank requires app_key parameter
    curl -sfL --max-time 60 \
        "https://data.phishtank.com/data/$api_key/online-valid.json" > "$feed_file" 2>/dev/null
    
    if [ -s "$feed_file" ]; then
        local count=$(jq 'length' "$feed_file" 2>/dev/null || echo "0")
        log_success "  PhishTank: $count verified phishing URLs loaded"
    else
        log_warning "  Failed to load PhishTank data"
    fi
}

load_otx_pulses() {
    local api_key="$OTX_API_KEY"
    
    log_info "  Loading OTX AlienVault pulses..."
    
    # Get subscribed pulses
    local pulses_file="${TEMP_DIR}/threat_intel/otx_pulses.json"
    
    curl -sfL --max-time 30 \
        -H "X-OTX-API-KEY: $api_key" \
        "https://otx.alienvault.com/api/v1/pulses/subscribed?limit=50" > "$pulses_file" 2>/dev/null
    
    if [ -s "$pulses_file" ]; then
        local count=$(jq '.count' "$pulses_file" 2>/dev/null || echo "0")
        log_success "  OTX: $count pulses loaded"
        
        # Extract IOCs from pulses
        jq -r '.results[].indicators[]? | select(.type == "URL" or .type == "domain" or .type == "IPv4") | .indicator' \
            "$pulses_file" > "${TEMP_DIR}/threat_intel/otx_iocs.txt" 2>/dev/null
    else
        log_warning "  Failed to load OTX pulses"
    fi
}

################################################################################
# NEW: 20 MISSING THREAT INTELLIGENCE FEEDS
################################################################################

# 1. Spamhaus DROP/EDROP Lists - Known spam/malware source IP ranges
download_spamhaus_drop() {
    log_info "  Downloading Spamhaus DROP/EDROP lists..."
    
    # DROP list
    curl -sfL --max-time 30 "https://www.spamhaus.org/drop/drop.txt" > \
        "${TEMP_DIR}/threat_intel/spamhaus_drop.txt" 2>/dev/null
    
    # EDROP list
    curl -sfL --max-time 30 "https://www.spamhaus.org/drop/edrop.txt" > \
        "${TEMP_DIR}/threat_intel/spamhaus_edrop.txt" 2>/dev/null
    
    # Parse and load IPs
    if [ -s "${TEMP_DIR}/threat_intel/spamhaus_drop.txt" ]; then
        while IFS= read -r line; do
            [[ "$line" =~ ^# ]] && continue
            [[ -z "$line" ]] && continue
            local ip_range=$(echo "$line" | awk '{print $1}')
            [[ -n "$ip_range" ]] && KNOWN_MALICIOUS_IPS["$ip_range"]="Spamhaus DROP"
        done < "${TEMP_DIR}/threat_intel/spamhaus_drop.txt"
        log_success "  Spamhaus DROP/EDROP: IPs loaded"
    else
        log_warning "  Failed to download Spamhaus lists"
    fi
}

# 2. Emerging Threats (Proofpoint) Open Rules - Extended
download_emerging_threats_feed() {
    log_info "  Downloading Emerging Threats feeds..."
    
    # Compromised IPs
    curl -sfL --max-time 30 "https://rules.emergingthreats.net/blockrules/compromised-ips.txt" > \
        "${TEMP_DIR}/threat_intel/et_compromised.txt" 2>/dev/null
    
    # Emerging Block IPs
    curl -sfL --max-time 30 "https://rules.emergingthreats.net/fwrules/emerging-Block-IPs.txt" > \
        "${TEMP_DIR}/threat_intel/et_block_ips.txt" 2>/dev/null
    
    # Parse and load IPs
    local count=0
    for file in "${TEMP_DIR}/threat_intel/et_"*.txt; do
        [ -f "$file" ] || continue
        while IFS= read -r ip; do
            [[ "$ip" =~ ^# ]] && continue
            [[ -z "$ip" ]] && continue
            KNOWN_MALICIOUS_IPS["$ip"]="Emerging Threats"
            ((count++))
        done < "$file"
    done
    
    if [ $count -gt 0 ]; then
        log_success "  Emerging Threats: $count IPs loaded"
    else
        log_warning "  Failed to download Emerging Threats feeds"
    fi
}

# 3. CISA Known Exploited Vulnerabilities (KEV)
download_cisa_kev() {
    log_info "  Downloading CISA KEV database..."
    
    local kev_file="${TEMP_DIR}/threat_intel/cisa_kev.json"
    
    curl -sfL --max-time 30 "https://www.cisa.gov/sites/default/files/feeds/known_exploited_vulnerabilities.json" > \
        "$kev_file" 2>/dev/null
    
    if [ -s "$kev_file" ]; then
        # Extract CVEs and store in KNOWN_CVES array
        local cves=$(jq -r '.vulnerabilities[].cveID' "$kev_file" 2>/dev/null)
        local count=0
        while IFS= read -r cve; do
            [[ -z "$cve" ]] && continue
            KNOWN_CVES["$cve"]="CISA KEV"
            ((count++))
        done <<< "$cves"
        log_success "  CISA KEV: $count CVEs loaded"
    else
        log_warning "  Failed to download CISA KEV"
    fi
}

# 4. Feodo Tracker (Dridex/Emotet/TrickBot C2s) - Extended
download_feodo_tracker_extended() {
    log_info "  Downloading Feodo Tracker feeds..."
    
    # IP blocklist
    curl -sfL --max-time 30 "https://feodotracker.abuse.ch/downloads/ipblocklist.txt" > \
        "${TEMP_DIR}/threat_intel/feodo_ips.txt" 2>/dev/null
    
    # Domain blocklist
    curl -sfL --max-time 30 "https://feodotracker.abuse.ch/downloads/domainblocklist.txt" > \
        "${TEMP_DIR}/threat_intel/feodo_domains.txt" 2>/dev/null
    
    # Load IPs
    if [ -s "${TEMP_DIR}/threat_intel/feodo_ips.txt" ]; then
        while IFS= read -r line; do
            [[ "$line" =~ ^# ]] && continue
            [[ -z "$line" ]] && continue
            local ip=$(echo "$line" | awk '{print $1}')
            [[ -n "$ip" ]] && KNOWN_C2_IPS["$ip"]="Feodo Tracker"
        done < "${TEMP_DIR}/threat_intel/feodo_ips.txt"
    fi
    
    # Load domains
    if [ -s "${TEMP_DIR}/threat_intel/feodo_domains.txt" ]; then
        while IFS= read -r line; do
            [[ "$line" =~ ^# ]] && continue
            [[ -z "$line" ]] && continue
            KNOWN_C2_DOMAINS["$line"]="Feodo Tracker"
        done < "${TEMP_DIR}/threat_intel/feodo_domains.txt"
        log_success "  Feodo Tracker: C2 IPs and domains loaded"
    else
        log_warning "  Failed to download Feodo Tracker feeds"
    fi
}

# 5. SSLBL (SSL Blacklist) - Extended with JA3 fingerprints
download_sslbl_extended() {
    log_info "  Downloading SSLBL extended feeds..."
    
    # SSL IP blacklist
    curl -sfL --max-time 30 "https://sslbl.abuse.ch/blacklist/sslipblacklist.txt" > \
        "${TEMP_DIR}/threat_intel/sslbl_ips.txt" 2>/dev/null
    
    # SSL blacklist CSV
    curl -sfL --max-time 30 "https://sslbl.abuse.ch/blacklist/sslblacklist.csv" > \
        "${TEMP_DIR}/threat_intel/sslbl.csv" 2>/dev/null
    
    # JA3 fingerprints
    curl -sfL --max-time 30 "https://sslbl.abuse.ch/blacklist/ja3_fingerprints.csv" > \
        "${TEMP_DIR}/threat_intel/ja3_fingerprints.csv" 2>/dev/null
    
    # Load IPs
    if [ -s "${TEMP_DIR}/threat_intel/sslbl_ips.txt" ]; then
        while IFS= read -r line; do
            [[ "$line" =~ ^# ]] && continue
            [[ -z "$line" ]] && continue
            local ip=$(echo "$line" | awk '{print $1}')
            [[ -n "$ip" ]] && KNOWN_MALICIOUS_IPS["$ip"]="SSLBL"
        done < "${TEMP_DIR}/threat_intel/sslbl_ips.txt"
    fi
    
    # Load JA3 fingerprints
    if [ -s "${TEMP_DIR}/threat_intel/ja3_fingerprints.csv" ]; then
        while IFS=',' read -r ja3 reason; do
            [[ "$ja3" =~ ^# ]] && continue
            [[ -z "$ja3" ]] && continue
            KNOWN_JA3_FINGERPRINTS["$ja3"]="$reason"
        done < "${TEMP_DIR}/threat_intel/ja3_fingerprints.csv"
        log_success "  SSLBL Extended: IPs and JA3 fingerprints loaded"
    else
        log_warning "  Failed to download SSLBL extended feeds"
    fi
}

# 6. Ransomware Tracker - Using ThreatFox as replacement since original is archived
download_ransomware_tracker() {
    log_info "  Downloading ransomware IOCs (ThreatFox)..."
    
    # Use ThreatFox for ransomware IOCs since RansomwareTracker is archived
    local threatfox_file="${TEMP_DIR}/threat_intel/threatfox_ransomware.json"
    
    curl -sfL --max-time 30 "https://threatfox.abuse.ch/export/json/recent/" > "$threatfox_file" 2>/dev/null
    
    if [ -s "$threatfox_file" ]; then
        # Extract ransomware-related IOCs
        local count=0
        while read -r ioc; do
            [[ -z "$ioc" ]] && continue
            KNOWN_MALICIOUS_DOMAINS["$ioc"]="Ransomware (ThreatFox)"
            ((count++))
        done < <(jq -r '.data[]? | select(.malware_printable | contains("ransom")) | .ioc' "$threatfox_file" 2>/dev/null)
        
        if [ $count -gt 0 ]; then
            log_success "  Ransomware Tracker: $count IOCs loaded"
        else
            log_warning "  No ransomware IOCs found in ThreatFox"
        fi
    else
        log_warning "  Failed to download ransomware IOCs"
    fi
}

# 7. Bambenek Consulting Feeds - C2 domains and IPs
download_bambenek_feeds() {
    log_info "  Downloading Bambenek Consulting feeds..."
    
    # C2 Domain Master List
    curl -sfL --max-time 30 "https://osint.bambenekconsulting.com/feeds/c2-dommasterlist.txt" > \
        "${TEMP_DIR}/threat_intel/bambenek_c2_domains.txt" 2>/dev/null
    
    # C2 IP Master List
    curl -sfL --max-time 30 "https://osint.bambenekconsulting.com/feeds/c2-ipmasterlist.txt" > \
        "${TEMP_DIR}/threat_intel/bambenek_c2_ips.txt" 2>/dev/null
    
    # DGA Feed
    curl -sfL --max-time 30 "https://osint.bambenekconsulting.com/feeds/dga-feed.txt" > \
        "${TEMP_DIR}/threat_intel/bambenek_dga.txt" 2>/dev/null
    
    # Load C2 domains
    if [ -s "${TEMP_DIR}/threat_intel/bambenek_c2_domains.txt" ]; then
        while IFS= read -r line; do
            [[ "$line" =~ ^# ]] && continue
            [[ -z "$line" ]] && continue
            local domain=$(echo "$line" | awk -F, '{print $1}')
            [[ -n "$domain" ]] && KNOWN_C2_DOMAINS["$domain"]="Bambenek C2"
        done < "${TEMP_DIR}/threat_intel/bambenek_c2_domains.txt"
    fi
    
    # Load C2 IPs
    if [ -s "${TEMP_DIR}/threat_intel/bambenek_c2_ips.txt" ]; then
        while IFS= read -r line; do
            [[ "$line" =~ ^# ]] && continue
            [[ -z "$line" ]] && continue
            local ip=$(echo "$line" | awk -F, '{print $1}')
            [[ -n "$ip" ]] && KNOWN_C2_IPS["$ip"]="Bambenek C2"
        done < "${TEMP_DIR}/threat_intel/bambenek_c2_ips.txt"
        log_success "  Bambenek Consulting: C2 feeds loaded"
    else
        log_warning "  Failed to download Bambenek feeds"
    fi
}

# 8. Cisco Talos Intelligence - IP blacklist
download_talos_feed() {
    log_info "  Downloading Cisco Talos Intelligence feed..."
    
    curl -sfL --max-time 30 "https://www.talosintelligence.com/documents/ip-blacklist" > \
        "${TEMP_DIR}/threat_intel/talos_blacklist.txt" 2>/dev/null
    
    if [ -s "${TEMP_DIR}/threat_intel/talos_blacklist.txt" ]; then
        while IFS= read -r ip; do
            [[ "$ip" =~ ^# ]] && continue
            [[ -z "$ip" ]] && continue
            KNOWN_MALICIOUS_IPS["$ip"]="Cisco Talos"
        done < "${TEMP_DIR}/threat_intel/talos_blacklist.txt"
        log_success "  Cisco Talos: Blacklist loaded"
    else
        log_warning "  Failed to download Cisco Talos feed"
    fi
}

# 9. ThreatFox IOCs - Enhanced with API support
download_threatfox_iocs() {
    log_info "  Downloading ThreatFox IOC database..."
    
    local threatfox_file="${TEMP_DIR}/threat_intel/threatfox_recent.json"
    
    curl -sfL --max-time 30 "https://threatfox.abuse.ch/export/json/recent/" > "$threatfox_file" 2>/dev/null
    
    if [ -s "$threatfox_file" ]; then
        local count=0
        # Parse JSON and extract IOCs
        while read -r line; do
            [[ -z "$line" ]] && continue
            local ioc_type=$(echo "$line" | jq -r '.ioc_type' 2>/dev/null)
            local ioc_value=$(echo "$line" | jq -r '.ioc' 2>/dev/null)
            local malware=$(echo "$line" | jq -r '.malware_printable' 2>/dev/null)
            
            case "$ioc_type" in
                "domain")
                    KNOWN_MALICIOUS_DOMAINS["$ioc_value"]="ThreatFox: $malware"
                    ((count++))
                    ;;
                "ip:port")
                    local ip=$(echo "$ioc_value" | cut -d':' -f1)
                    KNOWN_MALICIOUS_IPS["$ip"]="ThreatFox: $malware"
                    ((count++))
                    ;;
                "url")
                    local domain=$(echo "$ioc_value" | sed -E 's|^https?://||' | cut -d'/' -f1)
                    KNOWN_MALICIOUS_DOMAINS["$domain"]="ThreatFox: $malware"
                    ((count++))
                    ;;
            esac
        done < <(jq -c '.data[]?' "$threatfox_file" 2>/dev/null)
        
        if [ $count -gt 0 ]; then
            log_success "  ThreatFox: $count IOCs loaded"
        else
            log_warning "  No IOCs found in ThreatFox feed"
        fi
    else
        log_warning "  Failed to download ThreatFox IOCs"
    fi
}

# 10. MalwareBazaar Hash Lookups - Download recent hashes
download_malwarebazaar_hashes() {
    log_info "  Downloading MalwareBazaar hashes..."
    
    # SHA256 recent hashes
    curl -sfL --max-time 30 "https://bazaar.abuse.ch/export/txt/sha256/recent/" > \
        "${TEMP_DIR}/threat_intel/malwarebazaar_sha256.txt" 2>/dev/null
    
    # MD5 recent hashes
    curl -sfL --max-time 30 "https://bazaar.abuse.ch/export/txt/md5/recent/" > \
        "${TEMP_DIR}/threat_intel/malwarebazaar_md5.txt" 2>/dev/null
    
    local count=0
    # Load SHA256 hashes
    if [ -s "${TEMP_DIR}/threat_intel/malwarebazaar_sha256.txt" ]; then
        while IFS= read -r hash; do
            [[ "$hash" =~ ^# ]] && continue
            [[ -z "$hash" ]] && continue
            KNOWN_MALWARE_HASHES["$hash"]="MalwareBazaar"
            ((count++))
        done < "${TEMP_DIR}/threat_intel/malwarebazaar_sha256.txt"
    fi
    
    # Load MD5 hashes
    if [ -s "${TEMP_DIR}/threat_intel/malwarebazaar_md5.txt" ]; then
        while IFS= read -r hash; do
            [[ "$hash" =~ ^# ]] && continue
            [[ -z "$hash" ]] && continue
            KNOWN_MALWARE_HASHES["$hash"]="MalwareBazaar"
            ((count++))
        done < "${TEMP_DIR}/threat_intel/malwarebazaar_md5.txt"
    fi
    
    if [ $count -gt 0 ]; then
        log_success "  MalwareBazaar: $count hashes loaded"
    else
        log_warning "  Failed to download MalwareBazaar hashes"
    fi
}

# 11. Malpedia Family Mappings
download_malpedia_families() {
    log_info "  Downloading Malpedia malware families..."
    
    # Malpedia API requires authentication, check for API key
    if [ -z "$MALPEDIA_API_KEY" ]; then
        log_warning "  Malpedia API key not set, skipping"
        return
    fi
    
    local malpedia_file="${TEMP_DIR}/threat_intel/malpedia_families.json"
    
    curl -sfL --max-time 30 \
        -H "Authorization: apitoken $MALPEDIA_API_KEY" \
        "https://malpedia.caad.fkie.fraunhofer.de/api/list/families" > "$malpedia_file" 2>/dev/null
    
    if [ -s "$malpedia_file" ]; then
        # Parse and store malware family mappings
        local count=0
        while read -r family; do
            [[ -z "$family" ]] && continue
            MALWARE_FAMILY_MAPPINGS["$family"]="Malpedia"
            ((count++))
        done < <(jq -r '.[]?' "$malpedia_file" 2>/dev/null)
        
        if [ $count -gt 0 ]; then
            log_success "  Malpedia: $count malware families loaded"
        else
            log_warning "  No families found in Malpedia"
        fi
    else
        log_warning "  Failed to download Malpedia families"
    fi
}

# 12. MISP Warning Lists - False positive reduction
download_misp_warninglists() {
    log_info "  Downloading MISP warning lists..."
    
    # Disposable email domains
    curl -sfL --max-time 30 \
        "https://raw.githubusercontent.com/MISP/misp-warninglists/main/lists/disposable-email/list.json" > \
        "${TEMP_DIR}/threat_intel/misp_disposable_emails.json" 2>/dev/null
    
    # Parking domains
    curl -sfL --max-time 30 \
        "https://raw.githubusercontent.com/MISP/misp-warninglists/main/lists/parking-domain/list.json" > \
        "${TEMP_DIR}/threat_intel/misp_parking_domains.json" 2>/dev/null
    
    local count=0
    # Load disposable email domains
    if [ -s "${TEMP_DIR}/threat_intel/misp_disposable_emails.json" ]; then
        while read -r domain; do
            [[ -z "$domain" ]] && continue
            DISPOSABLE_EMAIL_DOMAINS["$domain"]="MISP Disposable"
            ((count++))
        done < <(jq -r '.list[]?' "${TEMP_DIR}/threat_intel/misp_disposable_emails.json" 2>/dev/null)
    fi
    
    if [ $count -gt 0 ]; then
        log_success "  MISP Warning Lists: $count domains loaded"
    else
        log_warning "  Failed to download MISP warning lists"
    fi
}

# 13. InQuest IOCs - Public IOC database
download_inquest_iocs() {
    log_info "  Downloading InQuest IOCs..."
    
    local inquest_file="${TEMP_DIR}/threat_intel/inquest_iocs.json"
    
    curl -sfL --max-time 30 "https://labs.inquest.net/api/iocdb/list" > "$inquest_file" 2>/dev/null
    
    if [ -s "$inquest_file" ]; then
        local count=0
        # Parse and load IOCs
        while read -r line; do
            [[ -z "$line" ]] && continue
            local ioc=$(echo "$line" | jq -r '.artifact' 2>/dev/null)
            local type=$(echo "$line" | jq -r '.type' 2>/dev/null)
            
            case "$type" in
                "domain")
                    KNOWN_MALICIOUS_DOMAINS["$ioc"]="InQuest"
                    ((count++))
                    ;;
                "ip")
                    KNOWN_MALICIOUS_IPS["$ioc"]="InQuest"
                    ((count++))
                    ;;
                "hash")
                    KNOWN_MALWARE_HASHES["$ioc"]="InQuest"
                    ((count++))
                    ;;
            esac
        done < <(jq -c '.data[]?' "$inquest_file" 2>/dev/null)
        
        if [ $count -gt 0 ]; then
            log_success "  InQuest: $count IOCs loaded"
        else
            log_warning "  No IOCs found in InQuest feed"
        fi
    else
        log_warning "  Failed to download InQuest IOCs"
    fi
}

# 14. ANY.RUN Public Submissions - IOCs from malware analysis
download_anyrun_iocs() {
    log_info "  Downloading ANY.RUN public IOCs..."
    
    # ANY.RUN public feed (if available without API key)
    # Note: Full API access requires API key
    if [ -n "$ANYRUN_API_KEY" ]; then
        local anyrun_file="${TEMP_DIR}/threat_intel/anyrun_iocs.json"
        
        curl -sfL --max-time 30 \
            -H "Authorization: API-Key $ANYRUN_API_KEY" \
            "https://api.any.run/v1/analysis" > "$anyrun_file" 2>/dev/null
        
        if [ -s "$anyrun_file" ]; then
            log_success "  ANY.RUN: IOCs loaded"
        else
            log_warning "  Failed to download ANY.RUN IOCs"
        fi
    else
        log_warning "  ANY.RUN API key not set, skipping"
    fi
}

# 15. Triage Public Submissions - Sandbox analysis IOCs
download_triage_iocs() {
    log_info "  Downloading Triage public IOCs..."
    
    # Triage API requires API key for full access
    if [ -z "$TRIAGE_API_KEY" ]; then
        log_warning "  Triage API key not set, skipping"
        return
    fi
    
    local triage_file="${TEMP_DIR}/threat_intel/triage_iocs.json"
    
    curl -sfL --max-time 30 \
        -H "Authorization: Bearer $TRIAGE_API_KEY" \
        "https://api.tria.ge/v0/samples" > "$triage_file" 2>/dev/null
    
    if [ -s "$triage_file" ]; then
        log_success "  Triage: IOCs loaded"
    else
        log_warning "  Failed to download Triage IOCs"
    fi
}

check_against_threat_intel() {
    local ioc="$1"
    local ioc_type="$2"  # url, domain, ip, hash
    
    local matches=0
    
    # =========================================================================
    # FIRST: Check against HARDCODED IOC databases (always available offline)
    # =========================================================================
    
    case "$ioc_type" in
        "url"|"domain")
            # Extract domain from URL if needed
            local domain="$ioc"
            if [[ "$ioc" =~ ^https?:// ]]; then
                domain=$(echo "$ioc" | sed -E 's|^https?://||' | cut -d'/' -f1 | cut -d':' -f1)
            fi
            
            # Check against hardcoded malicious domains array
            for malicious_domain in "${HARDCODED_MALICIOUS_DOMAINS[@]}"; do
                if [[ "$domain" == *"$malicious_domain"* ]]; then
                    log_forensic_detection 100 \
                        "HARDCODED MALICIOUS DOMAIN MATCH" \
                        "domain:$domain" \
                        "Built-in IOC Database" \
                        "QR decoded content" \
                        "BLOCK - Known malicious domain in hardcoded database" \
                        "Internal IOC DB"
                    record_ioc "hardcoded_malicious_domain" "$domain" "Hardcoded IOC match"
                    ((matches++))
                    break
                fi
            done
            
            # Check against KNOWN_MALICIOUS_DOMAINS associative array
            if [[ -v "KNOWN_MALICIOUS_DOMAINS[$domain]" ]] && [[ -n "${KNOWN_MALICIOUS_DOMAINS[$domain]}" ]]; then
                log_forensic_detection 95 \
                    "KNOWN MALICIOUS DOMAIN" \
                    "domain:$domain" \
                    "Loaded IOC Database" \
                    "QR decoded content" \
                    "BLOCK - Domain flagged in threat intelligence" \
                    "Threat Intel DB"
                ((matches++))
            fi
            ;;
        "ip")
            # Check against KNOWN_MALICIOUS_IPS associative array
            if [[ -v "KNOWN_MALICIOUS_IPS[$ioc]" ]] && [[ -n "${KNOWN_MALICIOUS_IPS[$ioc]}" ]]; then
                log_forensic_detection 100 \
                    "KNOWN MALICIOUS IP ADDRESS" \
                    "ip:$ioc, attribution:${KNOWN_MALICIOUS_IPS[$ioc]}" \
                    "Built-in IOC Database" \
                    "QR decoded content - IP address" \
                    "BLOCK AT FIREWALL - Known malicious IP" \
                    "Internal IOC DB"
                record_ioc "known_malicious_ip" "$ioc" "${KNOWN_MALICIOUS_IPS[$ioc]}"
                ((matches++))
            fi
            
            # Check against hardcoded malicious IPs array
            for malicious_ip in "${HARDCODED_MALICIOUS_IPS[@]}"; do
                if [[ "$ioc" == "$malicious_ip" ]]; then
                    log_forensic_detection 100 \
                        "HARDCODED MALICIOUS IP MATCH" \
                        "ip:$ioc" \
                        "Built-in IOC Database" \
                        "QR decoded content - IP address" \
                        "BLOCK - Known malicious IP in hardcoded database" \
                        "Internal IOC DB"
                    ((matches++))
                    break
                fi
            done
            ;;
        "hash")
            # Check against hardcoded malicious hashes
            for malicious_hash in "${HARDCODED_MALICIOUS_HASHES[@]}"; do
                if [[ "${ioc,,}" == "${malicious_hash,,}" ]]; then
                    log_forensic_detection 100 \
                        "HARDCODED MALICIOUS HASH MATCH" \
                        "hash:$ioc" \
                        "Built-in IOC Database" \
                        "File hash analysis" \
                        "MALWARE - Hash matches known malware in hardcoded database" \
                        "Internal IOC DB"
                    ((matches++))
                    break
                fi
            done
            
            # Check against KNOWN_MALICIOUS_HASHES if populated
            if [[ -v "KNOWN_MALICIOUS_HASHES[$ioc]" ]] && [[ -n "${KNOWN_MALICIOUS_HASHES[$ioc]}" ]]; then
                log_forensic_detection 100 \
                    "KNOWN MALICIOUS HASH" \
                    "hash:$ioc" \
                    "Threat Intel Database" \
                    "File hash analysis" \
                    "MALWARE CONFIRMED - Hash in threat intelligence database" \
                    "Threat Intel DB"
                ((matches++))
            fi
            ;;
        "crypto")
            # Check against known crypto scam addresses
            if [[ -v "KNOWN_CRYPTO_SCAM_ADDRESSES[$ioc]" ]] && [[ -n "${KNOWN_CRYPTO_SCAM_ADDRESSES[$ioc]}" ]]; then
                log_forensic_detection 100 \
                    "KNOWN CRYPTO SCAM ADDRESS" \
                    "crypto:$ioc" \
                    "Crypto Scam Database" \
                    "QR decoded content - cryptocurrency" \
                    "DO NOT SEND - Known cryptocurrency scam address" \
                    "Crypto Scam DB"
                ((matches++))
            fi
            
            # Check against hardcoded scam crypto addresses
            for scam_addr in "${HARDCODED_SCAM_CRYPTO[@]}"; do
                if [[ "$ioc" == "$scam_addr" ]]; then
                    log_forensic_detection 100 \
                        "HARDCODED CRYPTO SCAM ADDRESS" \
                        "crypto:$ioc" \
                        "Built-in Scam Database" \
                        "QR decoded content - cryptocurrency" \
                        "DO NOT SEND - Known scam address in hardcoded database" \
                        "Internal Scam DB"
                    ((matches++))
                    break
                fi
            done
            ;;
    esac
    
    # =========================================================================
    # SECOND: Check against downloaded threat intelligence feeds
    # =========================================================================
    
    case "$ioc_type" in
        "url")
            # OpenPhish
            if [ -f "${TEMP_DIR}/threat_intel/openphish.txt" ]; then
                if grep -qF "$ioc" "${TEMP_DIR}/threat_intel/openphish.txt" 2>/dev/null; then
                    log_forensic_detection 100 \
                        "PHISHING URL DETECTED" \
                        "$ioc" \
                        "OpenPhish Feed (active $(date +%Y-%m-%d))" \
                        "QR decoded content" \
                        "DO NOT VISIT - Known phishing site" \
                        "https://openphish.com"
                    ((matches++))
                fi
            fi
            
            # URLhaus
            if [ -f "${TEMP_DIR}/threat_intel/urlhaus.txt" ]; then
                if grep -qF "$ioc" "${TEMP_DIR}/threat_intel/urlhaus.txt" 2>/dev/null; then
                    log_forensic_detection 100 \
                        "MALWARE URL DETECTED" \
                        "$ioc" \
                        "URLhaus Feed (Abuse.ch)" \
                        "QR decoded content" \
                        "DO NOT VISIT - Known malware distribution" \
                        "https://urlhaus.abuse.ch"
                    ((matches++))
                fi
            fi
            
            # PhishTank
            if [ -f "${TEMP_DIR}/threat_intel/phishtank.json" ]; then
                if jq -e ".[] | select(.url == \"$ioc\")" "${TEMP_DIR}/threat_intel/phishtank.json" > /dev/null 2>&1; then
                    log_forensic_detection 100 \
                        "VERIFIED PHISHING URL" \
                        "$ioc" \
                        "PhishTank (Community Verified)" \
                        "QR decoded content" \
                        "DO NOT VISIT - Community verified phishing" \
                        "https://phishtank.org"
                    ((matches++))
                fi
            fi
            ;;
        "domain")
            # Ransomware domains
            if [ -f "${TEMP_DIR}/threat_intel/ransomware_domains.txt" ]; then
                if grep -qiF "$ioc" "${TEMP_DIR}/threat_intel/ransomware_domains.txt" 2>/dev/null; then
                    log_forensic_detection 100 \
                        "RANSOMWARE DOMAIN DETECTED" \
                        "domain:$ioc" \
                        "Ransomware Tracker Feed" \
                        "QR decoded content - domain" \
                        "BLOCK IMMEDIATELY - Associated with ransomware operations" \
                        "https://ransomwaretracker.abuse.ch"
                    record_ioc "ransomware_domain" "$ioc" "Ransomware tracker match"
                    ((matches++))
                fi
            fi
            
            # OTX IOCs
            if [ -f "${TEMP_DIR}/threat_intel/otx_iocs.txt" ]; then
                if grep -qiF "$ioc" "${TEMP_DIR}/threat_intel/otx_iocs.txt" 2>/dev/null; then
                    log_forensic_detection 80 \
                        "Threat Intelligence Match - OTX" \
                        "domain:$ioc" \
                        "OTX AlienVault Feed" \
                        "QR decoded content - domain" \
                        "Investigate - Known threat indicator in OTX database" \
                        "https://otx.alienvault.com"
                    record_ioc "otx_ioc" "$ioc" "OTX AlienVault match"
                    ((matches++))
                fi
            fi
            ;;
        "ip")
            # Spamhaus DROP
            if [ -f "${TEMP_DIR}/threat_intel/spamhaus_drop.txt" ]; then
                if grep -qF "$ioc" "${TEMP_DIR}/threat_intel/spamhaus_drop.txt" 2>/dev/null; then
                    log_forensic_detection 100 \
                        "BLOCKED IP DETECTED - Spamhaus DROP" \
                        "ip:$ioc" \
                        "Spamhaus DROP List" \
                        "QR decoded content - IP address" \
                        "BLOCK AT FIREWALL - Known malicious infrastructure on Spamhaus blocklist" \
                        "https://www.spamhaus.org/drop/"
                    record_ioc "blocked_ip" "$ioc" "Spamhaus DROP match"
                    ((matches++))
                fi
            fi
            
            # Feodo Tracker
            if [ -f "${TEMP_DIR}/threat_intel/feodo_ips.txt" ]; then
                if grep -qF "$ioc" "${TEMP_DIR}/threat_intel/feodo_ips.txt" 2>/dev/null; then
                    log_forensic_detection 100 \
                        "BANKING TROJAN C2 DETECTED" \
                        "ip:$ioc, type:banking_trojan_c2" \
                        "Feodo Tracker (Abuse.ch)" \
                        "QR decoded content - IP address" \
                        "BLOCK IMMEDIATELY - Banking trojan command & control server" \
                        "https://feodotracker.abuse.ch"
                    record_ioc "c2_ip" "$ioc" "Feodo Tracker match"
                    ((matches++))
                fi
            fi
            
            # ET Compromised
            if [ -f "${TEMP_DIR}/threat_intel/et_compromised.txt" ]; then
                if grep -qF "$ioc" "${TEMP_DIR}/threat_intel/et_compromised.txt" 2>/dev/null; then
                    log_forensic_detection 80 \
                        "Compromised IP Detected" \
                        "ip:$ioc" \
                        "EmergingThreats Compromised IPs" \
                        "QR decoded content - IP address" \
                        "Exercise caution - IP flagged in EmergingThreats compromised list" \
                        "https://rules.emergingthreats.net"
                    ((matches++))
                fi
            fi
            ;;
        "hash")
            # Malware Bazaar
            if [ -f "${TEMP_DIR}/threat_intel/malware_bazaar_md5.txt" ]; then
                if grep -qiF "$ioc" "${TEMP_DIR}/threat_intel/malware_bazaar_md5.txt" 2>/dev/null; then
                    log_forensic_detection 100 \
                        "KNOWN MALWARE HASH DETECTED" \
                        "hash:$ioc" \
                        "Malware Bazaar (Abuse.ch)" \
                        "File hash analysis" \
                        "MALWARE CONFIRMED - Hash matches known malware sample in Malware Bazaar" \
                        "https://bazaar.abuse.ch"
                    ((matches++))
                fi
            fi
            ;;
    esac
    
    return $matches
}

check_virustotal() {
    local target="$1"
    local target_type="$2"  # url, domain, ip, file
    
    # AUDIT: Check for API key without logging it
    if [ -z "${VT_API_KEY:-}" ]; then
        log_warning "VirusTotal API key not configured, skipping VT check"
        return
    fi
    
    if [ "$VT_CHECK" = false ]; then
        return
    fi
    
    # AUDIT: Request user consent before uploading data to external service
    if ! request_upload_consent "VirusTotal" "URL/domain/IP/hash for threat analysis"; then
        log_info "VirusTotal check skipped (no consent)"
        return
    fi
    
    # AUDIT: Validate target input
    if ! validate_string_input "$target" 2048; then
        log_error "Invalid target for VirusTotal check"
        return
    fi
    
    log_info "Checking VirusTotal: $target"
    record_custody_action "EXTERNAL_API_CALL" "VirusTotal lookup for $target_type"
    
    local vt_response=""
    local api_url=""
    
    # AUDIT: All external requests use HTTPS
    case "$target_type" in
        "url")
            # URL scan - need to encode URL
            # FIXED: Use printf and stdin to safely pass URL to Python
            local encoded_url
            encoded_url=$(printf '%s' "$target" | $(get_python_cmd) -c "import sys, base64; print(base64.urlsafe_b64encode(sys.stdin.read().encode()).decode().rstrip('='))" 2>/dev/null)
            api_url="https://www.virustotal.com/api/v3/urls/$encoded_url"
            ;;
        "domain")
            api_url="https://www.virustotal.com/api/v3/domains/$target"
            ;;
        "ip")
            api_url="https://www.virustotal.com/api/v3/ip_addresses/$target"
            ;;
        "file")
            # For file, target is the hash
            api_url="https://www.virustotal.com/api/v3/files/$target"
            ;;
    esac
    
    # AUDIT: API key passed via header, never logged
    vt_response=$(curl -sf --max-time 30 \
        -H "x-apikey: ${VT_API_KEY}" \
        "$api_url" 2>/dev/null)
    
    if [ -n "$vt_response" ]; then
        local malicious=$(echo "$vt_response" | jq -r '.data.attributes.last_analysis_stats.malicious // 0' 2>/dev/null)
        local suspicious=$(echo "$vt_response" | jq -r '.data.attributes.last_analysis_stats.suspicious // 0' 2>/dev/null)
        local total=$(echo "$vt_response" | jq -r '.data.attributes.last_analysis_stats.harmless + .data.attributes.last_analysis_stats.malicious + .data.attributes.last_analysis_stats.suspicious + .data.attributes.last_analysis_stats.undetected // 0' 2>/dev/null)
        
        if [ "$malicious" -gt 0 ]; then
            log_threat $((malicious * 5)) "VirusTotal: $malicious/$total engines flagged as MALICIOUS"
        elif [ "$suspicious" -gt 0 ]; then
            log_threat $((suspicious * 3)) "VirusTotal: $suspicious/$total engines flagged as suspicious"
        else
            log_success "VirusTotal: No detections ($total engines checked)"
        fi
        
        # Save full response (sanitized)
        local response_file="${EVIDENCE_DIR}/vt_${target_type}_$(echo "$target" | md5sum 2>/dev/null | cut -d' ' -f1 || echo "unknown").json"
        echo "$vt_response" > "$response_file"
        chmod 600 "$response_file" 2>/dev/null || true
        add_evidence_item "$response_file" "virustotal_response" "VirusTotal API response"
    else
        log_warning "VirusTotal check failed or returned empty response"
    fi
}

check_urlscan() {
    local url="$1"
    
    # AUDIT: Check API key without logging it
    if [ -z "${URLSCAN_API_KEY:-}" ] || [ "$NETWORK_CHECK" = false ]; then
        return
    fi
    
    # AUDIT: Validate URL format
    if ! validate_url "$url"; then
        log_warning "Invalid URL format for URLScan check"
        return
    fi
    
    # AUDIT: Request user consent before external API call
    if ! request_upload_consent "URLScan.io" "URL for security scanning"; then
        log_info "URLScan check skipped (no consent)"
        return
    fi
    
    log_info "Checking URLScan.io..."
    record_custody_action "EXTERNAL_API_CALL" "URLScan.io lookup"
    
    # AUDIT: All external requests use HTTPS
    # Search for existing scans
    local search_response=$(curl -sf --max-time 30 \
        -H "API-Key: ${URLSCAN_API_KEY}" \
        "https://urlscan.io/api/v1/search/?q=page.url:\"$url\"" 2>/dev/null)
    
    if [ -n "$search_response" ]; then
        local results=$(echo "$search_response" | jq -r '.results | length' 2>/dev/null)
        
        if [ "$results" -gt 0 ]; then
            log_info "URLScan.io: Found $results previous scans"
            
            # Get verdicts from scans
            local verdicts=$(echo "$search_response" | jq -r '.results[].verdicts.overall.malicious' 2>/dev/null)
            if echo "$verdicts" | grep -q "true"; then
                log_threat 70 "URLScan.io: Previous scans flagged as malicious!"
            fi
        fi
    fi
}

check_abuseipdb() {
    local ip="$1"
    
    # AUDIT: Check API key without logging it
    if [ -z "${ABUSEIPDB_API_KEY:-}" ] || [ "$NETWORK_CHECK" = false ]; then
        return
    fi
    
    # AUDIT: Validate IP format
    if ! validate_ip "$ip"; then
        log_warning "Invalid IP format for AbuseIPDB check: $ip"
        return
    fi
    
    # AUDIT: Request user consent before external API call
    if ! request_upload_consent "AbuseIPDB" "IP address for abuse checking"; then
        log_info "AbuseIPDB check skipped (no consent)"
        return
    fi
    
    log_info "Checking AbuseIPDB: $ip"
    record_custody_action "EXTERNAL_API_CALL" "AbuseIPDB lookup for IP"
    
    # AUDIT: All external requests use HTTPS
    local response=$(curl -sf --max-time 30 \
        -H "Key: ${ABUSEIPDB_API_KEY}" \
        -H "Accept: application/json" \
        "https://api.abuseipdb.com/api/v2/check?ipAddress=$ip&maxAgeInDays=90" 2>/dev/null)
    
    if [ -n "$response" ]; then
        local abuse_score=$(echo "$response" | jq -r '.data.abuseConfidenceScore // 0' 2>/dev/null)
        local total_reports=$(echo "$response" | jq -r '.data.totalReports // 0' 2>/dev/null)
        local isp=$(echo "$response" | jq -r '.data.isp // "Unknown"' 2>/dev/null)
        
        if [ "$abuse_score" -gt 50 ]; then
            log_threat $((abuse_score / 2)) "AbuseIPDB: High abuse score ($abuse_score%) - $total_reports reports"
        elif [ "$abuse_score" -gt 0 ]; then
            log_warning "AbuseIPDB: Some reports exist ($abuse_score% confidence, $total_reports reports)"
        else
            log_success "AbuseIPDB: No abuse reports for $ip (ISP: $isp)"
        fi
        
        # AUDIT: Save response with secure permissions
        local response_file="${EVIDENCE_DIR}/abuseipdb_$ip.json"
        echo "$response" > "$response_file"
        chmod 600 "$response_file" 2>/dev/null || true
        add_evidence_item "$response_file" "abuseipdb_response" "AbuseIPDB API response"
    fi
}

################################################################################
# NEW: API-BASED THREAT INTELLIGENCE CHECKS (10 missing feeds)
################################################################################

# Check CISA KEV for CVE references in content
check_cisa_kev() {
    local content="$1"
    
    if [ ! -s "${TEMP_DIR}/threat_intel/cisa_kev.json" ]; then
        return
    fi
    
    # Search for CVE patterns in content
    local cves=$(echo "$content" | safe_grep_oE 'CVE-[0-9]{4}-[0-9]{4,}' | sort -u)
    
    if [ -n "$cves" ]; then
        while IFS= read -r cve; do
            [[ -z "$cve" ]] && continue
            if [[ -v "KNOWN_CVES[$cve]" ]]; then
                log_threat 80 "CISA KEV: Known exploited vulnerability detected - $cve"
                record_ioc "cisa_kev_cve" "$cve" "CISA Known Exploited Vulnerability"
            fi
        done <<< "$cves"
    fi
}

# CrowdStrike Falcon X API-based IOC lookup
check_crowdstrike() {
    local content="$1"
    
    if [ -z "${CROWDSTRIKE_API_KEY:-}" ] || [ "$NETWORK_CHECK" = false ]; then
        return
    fi
    
    # Extract potential IOCs from content
    local domain=$(echo "$content" | safe_grep_oE '[a-zA-Z0-9.-]+\.[a-z]{2,}' | head -1)
    [[ -z "$domain" ]] && return
    
    log_info "Checking CrowdStrike Falcon X..."
    
    local response=$(curl -sf --max-time 30 \
        -H "Authorization: Bearer ${CROWDSTRIKE_API_KEY}" \
        "https://api.crowdstrike.com/intel/combined/indicators/v1?filter=indicator:'$domain'" 2>/dev/null)
    
    if [ -n "$response" ]; then
        local malicious=$(echo "$response" | jq -r '.resources[]? | select(.malicious_confidence == "high") | .indicator' 2>/dev/null)
        if [ -n "$malicious" ]; then
            log_threat 90 "CrowdStrike: High confidence malicious indicator detected"
            record_ioc "crowdstrike_indicator" "$malicious" "CrowdStrike Falcon X"
        fi
    fi
}

# Recorded Future API-based threat intelligence
check_recorded_future() {
    local content="$1"
    
    if [ -z "${RECORDED_FUTURE_API_KEY:-}" ] || [ "$NETWORK_CHECK" = false ]; then
        return
    fi
    
    # Extract potential IOCs from content
    local domain=$(echo "$content" | safe_grep_oE '[a-zA-Z0-9.-]+\.[a-z]{2,}' | head -1)
    [[ -z "$domain" ]] && return
    
    log_info "Checking Recorded Future..."
    
    local response=$(curl -sf --max-time 30 \
        -H "X-RFToken: ${RECORDED_FUTURE_API_KEY}" \
        "https://api.recordedfuture.com/v2/domain/$domain" 2>/dev/null)
    
    if [ -n "$response" ]; then
        local risk_score=$(echo "$response" | jq -r '.data.risk.score // 0' 2>/dev/null)
        if [ "$risk_score" -gt 50 ]; then
            log_threat $((risk_score / 2)) "Recorded Future: High risk score ($risk_score)"
            record_ioc "recorded_future_domain" "$domain" "Recorded Future High Risk"
        fi
    fi
}

# ThreatFox API lookup for specific IOCs
check_threatfox() {
    local content="$1"
    
    if [ "$NETWORK_CHECK" = false ]; then
        return
    fi
    
    # Extract potential IOCs
    local ioc=$(echo "$content" | safe_grep_oE 'https?://[^ ]+' | head -1)
    [[ -z "$ioc" ]] && return
    
    log_info "Checking ThreatFox API..."
    
    # POST request to ThreatFox API
    local response=$(curl -sf --max-time 30 \
        -X POST "https://threatfox-api.abuse.ch/api/v1/" \
        -H "Content-Type: application/json" \
        -d '{"query":"search_ioc","search_term":"'"$ioc"'"}' 2>/dev/null)
    
    if [ -n "$response" ]; then
        local query_status=$(echo "$response" | jq -r '.query_status' 2>/dev/null)
        if [ "$query_status" = "ok" ]; then
            local malware=$(echo "$response" | jq -r '.data[0].malware_printable' 2>/dev/null)
            log_threat 85 "ThreatFox API: IOC found - $malware"
            record_ioc "threatfox_api" "$ioc" "ThreatFox: $malware"
        fi
    fi
}

# MalwareBazaar API hash lookup
check_malwarebazaar() {
    local content="$1"
    
    if [ "$NETWORK_CHECK" = false ]; then
        return
    fi
    
    # Extract potential hashes (MD5, SHA256)
    local hash=$(echo "$content" | safe_grep_oE '\b[a-f0-9]{32}\b|\b[a-f0-9]{64}\b' | head -1)
    [[ -z "$hash" ]] && return
    
    log_info "Checking MalwareBazaar API..."
    
    # POST request to MalwareBazaar API
    local response=$(curl -sf --max-time 30 \
        -X POST "https://mb-api.abuse.ch/api/v1/" \
        -d "query=get_info&hash=$hash" 2>/dev/null)
    
    if [ -n "$response" ]; then
        local query_status=$(echo "$response" | jq -r '.query_status' 2>/dev/null)
        if [ "$query_status" = "ok" ]; then
            local signature=$(echo "$response" | jq -r '.data[0].signature' 2>/dev/null)
            log_threat 95 "MalwareBazaar API: Known malware hash - $signature"
            record_ioc "malwarebazaar_hash" "$hash" "MalwareBazaar: $signature"
        fi
    fi
}

# RiskIQ/PassiveTotal (Microsoft) API
check_riskiq() {
    local content="$1"
    
    if [ -z "${RISKIQ_API_KEY:-}" ] || [ -z "${RISKIQ_API_SECRET:-}" ] || [ "$NETWORK_CHECK" = false ]; then
        return
    fi
    
    # Extract domain from content
    local domain=$(echo "$content" | sed -E 's|^https?://||' | cut -d'/' -f1 | grep -oE '[a-zA-Z0-9.-]+\.[a-z]{2,}' | head -1)
    [[ -z "$domain" ]] && return
    
    log_info "Checking RiskIQ PassiveTotal..."
    
    local response=$(curl -sf --max-time 30 \
        -u "${RISKIQ_API_KEY}:${RISKIQ_API_SECRET}" \
        "https://api.riskiq.net/pt/v2/reputation?query=$domain" 2>/dev/null)
    
    if [ -n "$response" ]; then
        local reputation=$(echo "$response" | jq -r '.reputation // "unknown"' 2>/dev/null)
        if [ "$reputation" = "malicious" ]; then
            log_threat 80 "RiskIQ: Malicious reputation detected"
            record_ioc "riskiq_domain" "$domain" "RiskIQ Malicious"
        fi
    fi
}

# Hybrid Analysis sandbox API
check_hybrid_analysis() {
    local content="$1"
    
    if [ -z "${HYBRID_ANALYSIS_KEY:-}" ] || [ "$NETWORK_CHECK" = false ]; then
        return
    fi
    
    # Extract hash if present
    local hash=$(echo "$content" | safe_grep_oE '\b[a-f0-9]{64}\b' | head -1)
    [[ -z "$hash" ]] && return
    
    log_info "Checking Hybrid Analysis..."
    
    local response=$(curl -sf --max-time 30 \
        -H "api-key: ${HYBRID_ANALYSIS_KEY}" \
        -H "user-agent: Falcon Sandbox" \
        "https://www.hybrid-analysis.com/api/v2/search/hash?hash=$hash" 2>/dev/null)
    
    if [ -n "$response" ]; then
        local verdict=$(echo "$response" | jq -r '.[0].verdict // "unknown"' 2>/dev/null)
        if [ "$verdict" = "malicious" ]; then
            log_threat 90 "Hybrid Analysis: Malicious file detected"
            record_ioc "hybrid_analysis_hash" "$hash" "Hybrid Analysis Malicious"
        fi
    fi
}

# ANY.RUN API lookup
check_anyrun() {
    local content="$1"
    
    if [ -z "${ANYRUN_API_KEY:-}" ] || [ "$NETWORK_CHECK" = false ]; then
        return
    fi
    
    # Extract hash if present
    local hash=$(echo "$content" | safe_grep_oE '\b[a-f0-9]{64}\b' | head -1)
    [[ -z "$hash" ]] && return
    
    log_info "Checking ANY.RUN..."
    
    local response=$(curl -sf --max-time 30 \
        -H "Authorization: API-Key ${ANYRUN_API_KEY}" \
        "https://api.any.run/v1/analysis?hash=$hash" 2>/dev/null)
    
    if [ -n "$response" ]; then
        local verdict=$(echo "$response" | jq -r '.data[0].verdict // "unknown"' 2>/dev/null)
        if [ "$verdict" = "malicious" ]; then
            log_threat 85 "ANY.RUN: Malicious analysis result"
            record_ioc "anyrun_hash" "$hash" "ANY.RUN Malicious"
        fi
    fi
}

# Joe Sandbox Cloud API
check_joesandbox() {
    local content="$1"
    
    if [ -z "${JOESANDBOX_API_KEY:-}" ] || [ "$NETWORK_CHECK" = false ]; then
        return
    fi
    
    # Extract hash if present
    local hash=$(echo "$content" | safe_grep_oE '\b[a-f0-9]{64}\b' | head -1)
    [[ -z "$hash" ]] && return
    
    log_info "Checking Joe Sandbox Cloud..."
    
    local response=$(curl -sf --max-time 30 \
        "https://jbxcloud.joesecurity.org/api/v2/search?apikey=${JOESANDBOX_API_KEY}&q=$hash" 2>/dev/null)
    
    if [ -n "$response" ]; then
        local detection=$(echo "$response" | jq -r '.data[0].detection // "unknown"' 2>/dev/null)
        if [ "$detection" = "malicious" ]; then
            log_threat 85 "Joe Sandbox: Malicious detection"
            record_ioc "joesandbox_hash" "$hash" "Joe Sandbox Malicious"
        fi
    fi
}

# Triage sandbox API
check_triage() {
    local content="$1"
    
    if [ -z "${TRIAGE_API_KEY:-}" ] || [ "$NETWORK_CHECK" = false ]; then
        return
    fi
    
    # Extract hash if present
    local hash=$(echo "$content" | safe_grep_oE '\b[a-f0-9]{64}\b' | head -1)
    [[ -z "$hash" ]] && return
    
    log_info "Checking Triage..."
    
    local response=$(curl -sf --max-time 30 \
        -H "Authorization: Bearer ${TRIAGE_API_KEY}" \
        "https://api.tria.ge/v0/search?query=$hash" 2>/dev/null)
    
    if [ -n "$response" ]; then
        local score=$(echo "$response" | jq -r '.data[0].score // 0' 2>/dev/null)
        if [ "$score" -gt 5 ]; then
            log_threat $((score * 10)) "Triage: High maliciousness score ($score/10)"
            record_ioc "triage_hash" "$hash" "Triage Score: $score"
        fi
    fi
}

check_qr_code_threat_iocs() {
    local qr_source="$1"    # original QR code image/file
    local ioc_list_file="$2" # file containing one IOC per line (urls, domains, ips, hashes)

    log_info "Running QR code threat intelligence checks on: $qr_source"

    # Track this QR code scan in evidence
    scan_record="${EVIDENCE_DIR}/qr_scan_record_$(basename "$qr_source")_$(date +%s).log"
    echo "QR Scan: $qr_source at $(date)" > "$scan_record"

    # For every IOC found in QR code scan:
    while IFS= read -r ioc; do
        # Detect IOC type (cheap: url/domain/ip/hash)
        local ioc_type="unknown"
        if echo "$ioc" | grep -qEi '^https?://'; then ioc_type="url";
        elif echo "$ioc" | grep -qE '^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$'; then ioc_type="ip";
        elif echo "$ioc" | grep -qE '^[0-9a-f]{32,64}$'; then ioc_type="hash";
        elif echo "$ioc" | grep -qE '\.'; then ioc_type="domain";
        fi

        echo "  ✓ Extracted [$ioc_type]: $ioc" >> "$scan_record"
        log_info "Checking QR-extracted IOC ($ioc_type): $ioc"

        local matches=0
        check_against_threat_intel "$ioc" "$ioc_type" && matches=$?

        # Save positive matches with QR scan attribution
        if [ "$matches" -gt 0 ]; then
            log_threat 100 "Threat intelligence detected IOC from QR scan: $ioc ($ioc_type)"
            echo "MATCH: $ioc ($ioc_type)" >> "$scan_record"
            echo "$ioc:$ioc_type:QR_SCAN:$qr_source:$matches" >> "${EVIDENCE_DIR}/qr_code_hits.log"
        fi

    done < "$ioc_list_file"

    # Chain of custody output
    log_success "QR scan threat intelligence processed: $scan_record"
    add_evidence_item "$scan_record" "qr_scan_record" "QR scan chain-of-custody record"
}

enrich_qr_ioc_context() {
    local ioc="$1"
    local context="$2" # e.g., "malicious_url", "phishing_domain", etc
    local qr_source="$3"

    local ctx_file="${EVIDENCE_DIR}/qr_enrichment_$(md5sum <<<"$ioc" | cut -d' ' -f1)_$(date +%s).log"
    echo "IOC: $ioc" > "$ctx_file"
    echo "Context: $context" >> "$ctx_file"
    echo "QR Source: $qr_source" >> "$ctx_file"
    echo "Timestamp: $(date)" >> "$ctx_file"
    add_evidence_item "$ctx_file" "qr_ioc_context" "Enriched QR code IOC context"
}

################################################################################
# APT ATTRIBUTION ENGINE
################################################################################

analyze_apt_indicators() {
    set +u
    local content="${1:-}"
    set -u
    
    if [ "$APT_ATTRIBUTION" = false ]; then
        return
    fi
    
    log_apt "Analyzing for APT indicators..."
    
    local apt_matches=()
    
    # Check against known APT indicators
    for apt_group in "${!APT_INDICATORS[@]}"; do
        local group_name=$(echo "$apt_group" | cut -d'_' -f1)
        local indicator_type=$(echo "$apt_group" | cut -d'_' -f2-)
        local indicators="${APT_INDICATORS[$apt_group]}"
        
        IFS=',' read -ra indicator_array <<< "$indicators"
        for indicator in "${indicator_array[@]}"; do
            if echo "$content" | safe_grep_qi "$indicator"; then
                apt_matches+=("$group_name:$indicator_type:$indicator")
                log_apt "Potential $group_name indicator: $indicator ($indicator_type)"
            fi
        done
    done
    
    # Check against malware family signatures
    for family in "${!MALWARE_SIGNATURES[@]}"; do
        local family_name=$(echo "$family" | cut -d'_' -f1)
        local sig_type=$(echo "$family" | cut -d'_' -f2-)
        local signatures="${MALWARE_SIGNATURES[$family]}"
        
        IFS=',' read -ra sig_array <<< "$signatures"
        for sig in "${sig_array[@]}"; do
            if echo "$content" | safe_grep_qiE "$sig"; then
                apt_matches+=("malware:$family_name:$sig")
                log_apt "Potential malware family signature: $family_name - $sig"
            fi
        done
    done
    
    # Check against ransomware indicators
    for ransomware in "${!RANSOMWARE_INDICATORS[@]}"; do
        local ransom_name=$(echo "$ransomware" | cut -d'_' -f1)
        local ind_type=$(echo "$ransomware" | cut -d'_' -f2-)
        local indicators="${RANSOMWARE_INDICATORS[$ransomware]}"
        
        IFS=',' read -ra ind_array <<< "$indicators"
        for ind in "${ind_array[@]}"; do
            if echo "$content" | safe_grep_qiE "$ind"; then
                apt_matches+=("ransomware:$ransom_name:$ind")
                log_threat 80 "Ransomware indicator detected: $ransom_name - $ind"
            fi
        done
    done
    
    # Check against APT TTP indicators
    for apt_ttp in "${!APT_TTP_INDICATORS[@]}"; do
        local aptttp_name=$(echo "$aptttp" | cut -d'_' -f1)
        local aptttp_type=$(echo "$aptttp" | cut -d'_' -f2-)
        local indicators="${APT_TTP_INDICATORS[$ttp]}"
        
        IFS=',' read -ra ind_array <<< "$indicators"
        for ind in "${ind_array[@]}"; do
            if echo "$content" | safe_grep_qiE "$ind"; then
                apt_matches+=("APT_TTP:$aptttp_name:$ind")
                log_threat 80 "APT_TTP indicator detected: $aptttp_name - $ind"
            fi
        done
    done
    
    # Generate APT report if matches found
    if [ ${#apt_matches[@]} -gt 0 ]; then
        {
            echo "═══════════════════════════════════════════════"
            echo "APT/MALWARE ATTRIBUTION ANALYSIS"
            echo "═══════════════════════════════════════════════"
            echo "Timestamp: $(date -Iseconds)"
            echo ""
            echo "Detected Indicators:"
            for match in "${apt_matches[@]}"; do
                echo "  - $match"
            done
            echo ""
            echo "Attribution Confidence: $(calculate_apt_confidence "${apt_matches[@]}")"
            echo ""
        } >> "$APT_REPORT"
        
        analysis_success_found "APT-ANALYSIS" "${#apt_matches[@]}" "Matched indicators found" "$(IFS=', '; echo "${apt_matches[*]}")"
    else
        analysis_success_none "APT-ANALYSIS"
    fi
}

calculate_apt_confidence() {
    local matches=("$@")
    local unique_groups=()
    
    for match in "${matches[@]}"; do
        local group=$(echo "$match" | cut -d':' -f1-2)
        if [[ ! " ${unique_groups[*]} " =~ " ${group} " ]]; then
            unique_groups+=("$group")
        fi
    done
    
    local group_count=${#unique_groups[@]}
    local match_count=${#matches[@]}
    
    if [ $group_count -eq 1 ] && [ $match_count -ge 3 ]; then
        echo "HIGH (multiple indicators from single threat actor)"
    elif [ $group_count -ge 2 ]; then
        echo "MEDIUM (indicators from multiple sources - possible overlap)"
    elif [ $match_count -ge 2 ]; then
        echo "MEDIUM (multiple indicators detected)"
    else
        echo "LOW (single indicator match)"
    fi
}

################################################################################
# BEHAVIORAL ANALYSIS ENGINE
################################################################################

perform_behavioral_analysis() {
    local content="$1"
    
    if [ "$BEHAVIORAL_ANALYSIS" = false ]; then
        return
    fi
    
    log_info "Performing behavioral analysis..."
    
    local behaviors=()
    local risk_score=0
    
    # Check for evasion techniques
    check_sandbox_evasion "$content"
    check_anti_vm_techniques "$content"
    check_anti_debug_techniques "$content"
    check_time_based_evasion "$content"
    
    # Check for persistence mechanisms
    check_persistence_techniques "$content"
    
    # Check for lateral movement indicators
    check_lateral_movement "$content"
    
    # Check for data exfiltration patterns
    check_exfiltration_patterns "$content"
    
    # Check for privilege escalation
    check_privilege_escalation "$content"
    
    # Check for defense evasion
    check_defense_evasion "$content"
    
    # Check for command and control patterns
    check_c2_patterns "$content"
    
    # Check for credential access
    check_credential_access "$content"
    
    # Check for discovery techniques
    check_discovery_techniques "$content"
    
    # Check for impact techniques
    check_impact_techniques "$content"
}

check_sandbox_evasion() {
    local content="$1"
    
    local evasion_techniques=(
        "mouse_move" "cursor_pos" "GetCursorPos"
        "sleep.*[0-9]{4,}" "Sleep.*[0-9]{4,}"
        "tick.*count" "GetTickCount"
        "username.*sandbox\|malware\|virus\|sample"
        "processor.*count" "NumberOfProcessors"
        "memory.*[0-9].*GB" "GlobalMemoryStatus"
        "disk.*size" "GetDiskFreeSpace"
        "recent.*files" "GetRecentFiles"
        "screen.*resolution" "GetSystemMetrics"
        "uptime" "GetTickCount64"
    )
    
    local found_techniques=()
    for technique in "${evasion_techniques[@]}"; do
        if echo "$content" | safe_grep_qiE "$technique"; then
            found_techniques+=("$technique")
        fi
    done
    
    if [ ${#found_techniques[@]} -gt 0 ]; then
        local techniques_str=$(IFS=', '; echo "${found_techniques[*]}")
        log_forensic_detection 55 \
            "Sandbox Evasion Techniques Detected" \
            "techniques:$techniques_str, count:${#found_techniques[@]}" \
            "Behavioral sandbox evasion pattern matching" \
            "Decoded content analysis" \
            "MALWARE BEHAVIOR - Content attempts to detect sandbox/analysis environment" \
            "MITRE ATT&CK T1497 - Virtualization/Sandbox Evasion"
    fi
}

check_anti_vm_techniques() {
    local content="$1"
    
    local vm_indicators=(
        "VMware" "VirtualBox" "VBOX" "QEMU" "Xen" "Hyper-V"
        "Parallels" "\.vmx" "\.vbox" "vmtoolsd" "vboxservice"
        "vmmouse" "vmhgfs" "vm3dgl" "vmrawdsk" "vmusbmouse"
        "vmx_svga" "vmxnet" "vmware" "virtualbox" "qemu-ga"
        "sbiedll" "sandboxie" "wine_get_unix_file_name"
        "Bochs" "VPC" "Virtual PC" "anubis" "cuckoo"
        "joebox" "sunbelt" "threatexpert" "virustotal"
    )
    
    local found_indicators=()
    for indicator in "${vm_indicators[@]}"; do
        if echo "$content" | safe_grep_qiE "$indicator"; then
            found_indicators+=("$indicator")
        fi
    done
    
    if [ ${#found_indicators[@]} -gt 0 ]; then
        local indicators_str=$(IFS=', '; echo "${found_indicators[*]}")
        log_forensic_detection 45 \
            "Anti-VM Techniques Detected" \
            "vm_checks:$indicators_str, count:${#found_indicators[@]}" \
            "Virtual machine detection pattern matching" \
            "Decoded content analysis" \
            "MALWARE BEHAVIOR - Content attempts to detect virtual machine environment" \
            "MITRE ATT&CK T1497.001 - System Checks"
    fi
}

check_anti_debug_techniques() {
    local content="$1"
    
    local debug_checks=(
        "IsDebuggerPresent" "CheckRemoteDebuggerPresent"
        "NtQueryInformationProcess" "OutputDebugString"
        "FindWindow.*OLLYDBG" "FindWindow.*WinDbg"
        "FindWindow.*x64dbg" "FindWindow.*IDA"
        "ptrace" "PTRACE_TRACEME"
        "SIGTRAP" "SIGSTOP" "debugger"
        "int 3" "int 0x3" "DebugBreak"
        "NtSetInformationThread" "ThreadHideFromDebugger"
        "RtlQueryProcessDebugInformation"
        "CloseHandle.*invalid" "NtClose"
    )
    
    local found_checks=()
    for check in "${debug_checks[@]}"; do
        if echo "$content" | safe_grep_qiE "$check"; then
            found_checks+=("$check")
        fi
    done
    
    if [ ${#found_checks[@]} -gt 0 ]; then
        local checks_str=$(IFS=', '; echo "${found_checks[*]}")
        log_forensic_detection 50 \
            "Anti-Debug Techniques Detected" \
            "debug_checks:$checks_str, count:${#found_checks[@]}" \
            "Debugger detection pattern matching" \
            "Decoded content analysis" \
            "MALWARE BEHAVIOR - Content attempts to detect debugging/analysis tools" \
            "MITRE ATT&CK T1622 - Debugger Evasion"
    fi
}

check_time_based_evasion() {
    local content="$1"
    
    # Check for time delays
    if echo "$content" | safe_grep_qiE "sleep[[:space:]]*[(\[]?[[:space:]]*[0-9]{4,}|timeout[[:space:]]*[/]?[[:space:]]*t?[[:space:]]*[0-9]{3,}|delay[[:space:]]*[:\(][[:space:]]*[0-9]{4,}"; then
        log_forensic_detection 40 \
            "Time-Based Evasion Detected" \
            "technique:long_sleep/delay" \
            "Time delay pattern matching" \
            "Decoded content analysis" \
            "EVASION TECHNIQUE - Long delay used to evade sandbox analysis timeout" \
            "MITRE ATT&CK T1497.003 - Time Based Evasion"
    fi
    
    # Check for date/time checks
    if echo "$content" | safe_grep_qiE "GetSystemTime|GetLocalTime|QueryPerformanceCounter|timeGetTime"; then
        log_info "Time-related API calls detected (possible time-based evasion)"
    fi
}

check_persistence_techniques() {
    local content="$1"

    local persistence_indicators=(
        # Windows Registry & Boot
        "HKLM.*Run" "HKCU.*Run" "CurrentVersion\\\\Run"
        "Winlogon" "UserInit" "Shell" "Userinit"
        "AppInit_DLLs" "Services\\\\.*\\\\ImagePath"
        "MBR" "VBR" "bootmgr" "winload" "BootExecute"
        # Scheduled Tasks
        "schtasks" "at [0-9]" "Task Scheduler" "schedule.*task"
        # Startup folders
        "Startup" "Start Menu.*Programs.*Startup"
        # Services
        "sc create" "New-Service" "CreateService" "service.exe"
        # WMI
        "WMI.*subscription" "__EventFilter" "__EventConsumer"
        # Office Auto-Load
        "XLSTART" "Word.*Startup" "Outlook.*\\\\VbaProject"
        # Linux/macOS Persist
        "crontab" "/etc/cron" "systemctl enable"
        ".bashrc" ".profile" ".bash_profile"
        "LaunchAgent" "LaunchDaemon" ".plist"
        "init.d" "rc.local" "/etc/init" "systemd"
        "rc.local" "update-rc.d" "chkconfig"
        # Mobile: Android/iOS
        "android.intent" "autostart" "broadcastreceiver" "deviceadmin" "AccessibilityService"
        "com.android.vending" "malicious app" "background service" "BOOT_COMPLETED"
        "PACKAGE_REPLACED" "INSTALL_REFERRER" "AlarmManager" "JobScheduler" "PushService"
        "root exploit" "frida" "xposed" "supersu" "su binary"
        "provisioning profile" "ios enterprise" "plist buddy" "nsuserdefaults"
        "UIApplicationDidFinishLaunchingNotification" "UIApplicationWillEnterForegroundNotification"
        # Supply chain/update
        "update server" "malicious update" "in-app update" "manifest abuse" "appstore"
        # Rogue pentest/maas
        "metasploit persistence" "veil persistence" "empire stager" "rat installer"
    )

    local found_indicators=()
    for indicator in "${persistence_indicators[@]}"; do
        if echo "$content" | safe_grep_qiE "$indicator"; then
            found_indicators+=("$indicator")
        fi
    done

    if [ ${#found_indicators[@]} -gt 0 ]; then
        local indicators_str=$(IFS=', '; echo "${found_indicators[*]}")
        log_forensic_detection 60 \
            "Persistence Techniques Detected (QR/Mobile/Pentest/MaaS)" \
            "persistence_methods:$indicators_str, count:${#found_indicators[@]}" \
            "Autostart/service/persistence pattern matching" \
            "Decoded QR/mobile content analysis" \
            "MALWARE BEHAVIOR - Content aligns with persistence/autostart/implant techniques, cross-platform" \
            "MITRE ATT&CK T1547/T1546/T2500 - Boot/Logon Autostart, OS Initialization, Mobile Persistence"
    fi
}

check_lateral_movement() {
    local content="$1"

    local lateral_indicators=(
        # Windows tools and techniques
        "psexec" "PsExec" "wmic.*process.*call.*create"
        "winrm" "WinRM" "Invoke-Command"
        "Enter-PSSession" "New-PSSession"
        "mstsc" "RDP" "Terminal Services"
        "net use" "\\\\\\\\.*\\\\.*\$" "\\\\\\\\.*\\\\admin\$"
        # Unix, Linux, macOS, Mobile
        "ssh.*@" "scp" "rsync" "rexec" "rsh" "rlogin"
        # Pass-the-hash/tools
        "pass.*the.*hash" "mimikatz.*sekurlsa" "Invoke-Mimikatz" "Invoke-TheHash"
        "smbexec" "dcomexec" "atexec" "wmiexec"
        # PenTest Frameworks, Red Team, C2
        "cobaltstrike" "beacon" "imperium" "empire" "meterpreter"
        "exfiltrate.*via.*ssh" "domain admin"
        "token impersonation" "kerberos ticket" "golden ticket"
        # Cloud & SaaS
        "aws ssm" "aws ec2-instance-connect" "cloud lateral" "office365 lateral" "gcp lateral" "azure connector"
        # Mobile-specific RAT/lateral
        "adb.*connect" "adb.*shell" "mobile lateral" "frida.*remote" "xposed.*remote"
        "sms.*forward" "call.*redirect" "malicious app.*send.*data"
        # Rogue Pentesters, MaaS, support abuse
        "teamviewer" "anydesk" "screenconnect" "logmein"
        "remote support abuse" "malware-as-a-service lateral" "rat lateral"
    )

    local found_indicators=()
    for indicator in "${lateral_indicators[@]}"; do
        if echo "$content" | safe_grep_qiE "$indicator"; then
            found_indicators+=("$indicator")
        fi
    done

    if [ ${#found_indicators[@]} -gt 0 ]; then
        local indicators_str=$(IFS=', '; echo "${found_indicators[*]}")
        log_forensic_detection 65 \
            "Lateral Movement Indicators Detected (QR/Mobile/Pentest/MaaS)" \
            "lateral_techniques:$indicators_str, count:${#found_indicators[@]}" \
            "Network/remote propagation pattern matching" \
            "Decoded QR/mobile content analysis" \
            "MALWARE BEHAVIOR - Content indicates movement to other systems via cross-platform, cloud, mobile, or QR-based techniques" \
            "MITRE ATT&CK T1021/T1550/T1078/T1210 - Remote Services/Lateral Credential Access"
    fi
}

check_exfiltration_patterns() {
    local content="$1"

    local exfil_indicators=(
        # Data staging
        "compress" "7z" "rar" "zip.*-p"
        "tar.*-c" "makecab" "cabarc"
        # Network exfiltration
        "ftp.*put" "scp" "curl.*-T" "wget.*--post" "Invoke-WebRequest.*-Method.*Post"
        "base64.*http" "http.*base64" "http.*gz" "http.*zip"
        "netcat.*-w" "nc.*-w"
        # Cloud exfiltration
        "s3.*cp" "gsutil.*cp" "azcopy" "dropbox" "gdrive" "onedrive.*upload" "box.*upload" "mega"
        "api.dropbox.com" "api.box.com" "api.gdrive.com" "api.onedrive.com"
        # Messaging and C2 exfil channels
        "telegram.*send" "discord.*message" "slack.*post" "whatsapp.*api"
        # DNS exfiltration
        "nslookup.*txt" "dig.*txt" "dns2tcp" "dnscat" "dns-over-https"
        # Email exfiltration
        "smtp" "sendmail" "blat" "outlook.*send"
        # Steganography and covert file transfer
        "stego" "steganography" "lsb" "payload.*png" "payload.*jpg" "exfil.*jpg"
        # Mobile/QR-specific exfiltration
        "sms.*send" "call.*redirect" "exfiltrate.*contact" "backup.*cloud"
        "intent.*sendto" "android.intent.action.SEND" "android.intent.action.MAIL"
        "broadcastreceiver.*exfil"
        "qr code.*upload" "scan.*send"
        # Rogue Pentest/MaaS/Red Team
        "pentest.*exfil" "veil.*exfil" "metasploit.*exfil" "rat.*exfil"
        # SaaS/Cloud indirect
        "gsuite.*export" "export.*calendar" "export.*contacts"
        # SFTP/Remote admin tools
        "sftp.*put" "teamviewer.*file" "anydesk.*file"
        # Social media, webmail, and public-sharing exfil
        "twitter.*update" "facebook.*update" "pastebin.*post"
    )

    local found_indicators=()
    for indicator in "${exfil_indicators[@]}"; do
        if echo "$content" | safe_grep_qiE "$indicator"; then
            found_indicators+=("$indicator")
        fi
    done

    if [ ${#found_indicators[@]} -gt 0 ]; then
        local indicators_str=$(IFS=', '; echo "${found_indicators[*]}")
        log_forensic_detection 55 \
            "Data Exfiltration Patterns Detected (QR/Mobile/Pentest/MaaS)" \
            "exfil_methods:$indicators_str, count:${#found_indicators[@]}" \
            "Data exfiltration pattern matching: mobile, desktop, cloud, covert, QR-initiated channels" \
            "Decoded QR/mobile content analysis" \
            "DATA THEFT - Content shows signs of data collection and exfiltration, cross-platform, QR/mobile aware" \
            "MITRE ATT&CK T1041/T1008/T1048/T1052 - Exfiltration (various)"
    fi
}

check_privilege_escalation() {
    local content="$1"

    local privesc_indicators=(
        # Windows
        "runas" "SeDebugPrivilege" "SeImpersonatePrivilege"
        "getsystem" "potato" "printspoofer"
        "juicy.*potato" "rotten.*potato" "sweet.*potato"
        "Token.*Impersonation" "ImpersonateNamedPipeClient"
        "AlwaysInstallElevated" "dll.*hijack" "trustedinstaller"
        # Linux/UNIX/macOS
        "sudo.*-" "su.*-" "setuid" "setgid"
        "chmod.*s" "chmod.*4" "SUID" "SGID"
        "pkexec" "doas"
        "/etc/passwd" "/etc/shadow"
        "LD_PRELOAD" "LD_LIBRARY_PATH"
        "ptrace" "write.*proc" "dirtycow"
        # Mobile (Android/iOS)
        "root exploit" "frida" "xposed" "supersu" "su binary"
        "com.android.settings" "adb.*root" "magisk" "kingroot"
        "setuid.*app" "malicious app.*device admin" "BOOT_COMPLETED"
        "jailbreak" "unc0ver" "checkra1n" "cydia" "rootfs"
        "provisioning profile.*bypass" "ios enterprise.*exploit"
        # Cloud/SaaS/Pentest/MaaS
        "assume.*role" "access.*token" "cloud privilege" "iam policy"
        "metasploit.*privesc" "veil.*privesc" "empire.*elevate"
        "rat.*privesc" "cobaltstrike.*priv"
        # Exploits and vulns
        "CVE-" "exploit" "poc" "0day"
        "buffer.*overflow" "heap.*spray"
        "use.*after.*free" "race.*condition" "double.*free"
        # Manual/rogue pentest
        "manual escalation" "living off the land" "lolbins" "bypassuac"
    )

    local found_indicators=()
    for indicator in "${privesc_indicators[@]}"; do
        if echo "$content" | safe_grep_qiE "$indicator"; then
            found_indicators+=("$indicator")
        fi
    done

    if [ ${#found_indicators[@]} -gt 0 ]; then
        local indicators_str=$(IFS=', '; echo "${found_indicators[*]}")
        log_forensic_detection 60 \
            "Privilege Escalation Indicators Detected (QR/Mobile/Pentest/MaaS)" \
            "privesc_techniques:$indicators_str, count:${#found_indicators[@]}" \
            "Privilege escalation pattern matching: desktop, mobile, cloud, rogue pentest" \
            "Decoded QR/mobile/MaaS content analysis" \
            "MALWARE BEHAVIOR - Content attempts to gain elevated privileges via multiple vectors" \
            "MITRE ATT&CK T1068/T1548/T1547 - Exploitation for Privilege Escalation/Persistence"
    fi
}

check_defense_evasion() {
    local content="$1"

    local evasion_indicators=(
        # AV/EDR tampering (Windows, cross-platform)
        "disable.*defender" "Set-MpPreference.*-Disable"
        "Stop-Service.*Windows.*Defender" "Uninstall-WindowsFeature.*Windows-Defender"
        "disable.*security" "killav" "EICAR" "amsi.*bypass" "AMSI.*Patch"
        "ETW.*bypass" "EventLog.*Clear" "wevtutil.*cl" "Clear-EventLog"
        "unhook.*etw" "unhook.*amsi"
        "blocklist.*edr" "blacklist.*av"
        "tamper.*protection" "wscsvc"
        # Process manipulation
        "process.*hollow" "process.*inject"
        "RunPE" "reflective.*load" "NtUnmapViewOfSection" "WriteProcessMemory"
        "CreateRemoteThread" "QueueUserAPC" "parent.*spoof"
        # File manipulation
        "attrib.*h" "hidden" "system.*file"
        "alternate.*data.*stream" "ADS" ":.*:.*\$DATA"
        "timestomp" "touch.*-t" "timestamp.*manipulate"
        # Indicator removal
        "wipe" "shred" "srm" "sdelete" "file.*selfdelete"
        "format" "diskpart.*clean" "destroy.*log"
        "eventlog.*delete" "log.*remove"
        # Mobile-specific/Android/iOS
        "root.*cloak" "hide.*app" "obfuscate.*app"
        "disable.*playprotect" "malicious.*provisioning" "hide.*apk"
        # Cloud/SaaS
        "cloudtrail.*delete" "audit.*disable" "monitoring.*off"
        "IAM.*policy.*delete"
        # Anti-analysis/packer/MM
        "anti.*sandbox" "anti.*debug" "packer" "virtualized" "detect.*vmware" "detect.*virtualbox"
        "sleep.*delay" "stall.*analysis"
        # Red team/MaaS/rogue pen test
        "cobaltstrike.*evasion" "veil.*evasion" "empire.*defense" "rat.*defenseevasion"
        "bypass.*firewall" "bypass.*uac" "living off the land"
    )

    local found_indicators=()
    for indicator in "${evasion_indicators[@]}"; do
        if echo "$content" | safe_grep_qiE "$indicator"; then
            found_indicators+=("$indicator")
        fi
    done

    if [ ${#found_indicators[@]} -gt 0 ]; then
        local indicators_str=$(IFS=', '; echo "${found_indicators[*]}")
        log_forensic_detection 55 \
            "Defense Evasion Techniques Detected (QR/Mobile/Pentest/MaaS)" \
            "evasion_methods:$indicators_str, count:${#found_indicators[@]}" \
            "Defense, anti-analysis, and forensic evasion pattern matching: cross-platform & QR-aware" \
            "Decoded QR/mobile/MaaS content analysis" \
            "MALWARE BEHAVIOR - Content attempts to disable, evade, or bypass security controls/logs" \
            "MITRE ATT&CK T1562/T1027/T1070/T1497 - Impair Defenses, Obfuscated Files, Indicator Removal, Anti-Analysis"
    fi
}

check_c2_patterns() {
    local content="$1"

    local found_patterns=()
    # Check against C2 pattern database
    for pattern_name in "${!C2_PATTERNS[@]}"; do
        local pattern="${C2_PATTERNS[$pattern_name]}"
        if echo "$content" | safe_grep_qiE "$pattern"; then
            found_patterns+=("$pattern_name")
        fi
    done

    # Additional hardcoded C2 indicators (QR, mobile, red team, RAT, pentest frameworks, cloud)
    local generic_c2_indicators=(
        "cobaltstrike" "beacon" "meterpreter" "empire" "quasar"
        "remcos" "nanocore" "agenttesla" "asyncrat" "malware-as-a-service"
        "rat control" "command queue" "tasking beacon" "websocket.*connect"
        "telegram.*api" "discord.*token" "forum.*panel" "http.*callback"
        "set.*task" "get.*command" "exe.*download" "powershell.*iwr.*post"
        "mobile.*rat" "android.*rat" "apk.*panel" "intent.*c2"
        "sms.*c2" "push.*command" "gcm.*task" "whatsapp.*c2"
        "slack.*c2" "pastebin.*task" "dynamic.*dns.*c2" "subdomain.*callback"
        "cloud.*c2" "aws.*lambda.*invoke"
    )

    for indicator in "${generic_c2_indicators[@]}"; do
        if echo "$content" | safe_grep_qiE "$indicator"; then
            found_patterns+=("$indicator")
        fi
    done

    if [ ${#found_patterns[@]} -gt 0 ]; then
        local patterns_str=$(IFS=', '; echo "${found_patterns[*]}")
        log_forensic_detection 70 \
            "Command & Control Patterns Detected (QR/Mobile/Pentest/MaaS)" \
            "c2_patterns:$patterns_str, count:${#found_patterns[@]}" \
            "C2 communication pattern matching: desktop, mobile, QR code, commodity malware, RAT, Red Team, cloud" \
            "Decoded QR/mobile content analysis" \
            "ACTIVE THREAT - Content indicates connection to C2 infrastructure or malicious remote operator" \
            "MITRE ATT&CK T1071/T1105/T1095/T1568 - C2 Channels/Protocol/Cloud/Mobile"
    fi
}

check_credential_access() {
    local content="$1"

    local cred_indicators=(
        # Windows password dumping
        "mimikatz" "sekurlsa" "logonpasswords"
        "lsass" "procdump.*lsass" "comsvcs.*MiniDump" "rundll32.*comsvcs"
        "SAM" "SYSTEM.*hive" "SECURITY.*hive"
        "lsadump" "ntds.dit" "credential.*theft" "dpapi" "Vault"
        # Linux/UNIX/MacOS/Local cred files
        "id_rsa" "id_dsa" "\.pem" "\.key" "\.p12" "\.pfx" "\.crt"
        "shadow" "/etc/passwd" "/etc/shadow" "sudo.*-l"
        # Password managers, credential vaults
        "\.kdbx" "KeePass" "lastpass" "1password" "dashlane" "bitwarden" "password.*manager"
        "credentials.*xml" "unattend.*xml" "vault.*json"
        # Browser credentials & cookies
        "Login.*Data" "Cookies.*sqlite" "chrome.*password" "firefox.*password" "edge.*password"
        "stored.*password" "credential.*store" "formhistory.*sqlite"
        # Network sniffing/active relay/phishing
        "tcpdump" "wireshark" "tshark" "responder" "inveigh" "ntlmrelay"
        "man-in-the-middle" "mitmproxy" "proxy.*pass"
        # Mobile credential access & stealer
        "android.*key" "keychain" "ios.*keychain" "mobile.*vault"
        "bankbot" "malicious app.*password" "SMS.*auth" "autofill"
        "rooting.*access" "credential.*dump" "getaccounts"
        # Cloud credential access
        "aws_access_key_id" "aws_secret_access_key" "azure.*token"
        "gcp.*serviceaccount" "cloud.*creds" "iam.*creds"
        # Red team, pentest, MaaS, and commodity stealer
        "theharvester" "creds.*dump" "osint.*creds" "cobaltstrike.*hashdump" "quasar.*stealer"
        "emotet.*password" "lokibot.*creds" "agenttesla.*password"
        # QR/mobile/rogue vectors
        "qr code.*password" "scan.*login" "qr.*authenticator" "qr.*token"
    )

    local found_indicators=()
    for indicator in "${cred_indicators[@]}"; do
        if echo "$content" | safe_grep_qiE "$indicator"; then
            found_indicators+=("$indicator")
        fi
    done

    if [ ${#found_indicators[@]} -gt 0 ]; then
        local indicators_str=$(IFS=', '; echo "${found_indicators[*]}")
        log_forensic_detection 70 \
            "Credential Access Indicators Detected" \
            "credential_techniques:$indicators_str, count:${#found_indicators[@]}" \
            "Credential theft pattern matching: desktop, mobile, cloud, QR/code-based, stealer" \
            "Decoded content analysis" \
            "CREDENTIAL THEFT - Content targets passwords, keys, or authentication data via code, app, malware, rogue ops" \
            "MITRE ATT&CK T1003/T1555/T1056/T1111 - OS Credential Dumping, Credentials from Password Stores, Input Capture, Two-Factor Abuse"
    fi
}

check_discovery_techniques() {
    local content="$1"

    local discovery_indicators=(
        # General system discovery: desktop/server
        "systeminfo" "hostname" "whoami /all" "whoami"
        "uname -a" "env" "wmic.*computersystem" "Get-ComputerInfo"
        "echo \$USER" "Get-WmiObject.*OperatingSystem" "Get-WmiObject.*ComputerSystem"
        "lscpu" "lsblk" "lsusb" "lsdev" "lspci" "df -h"
        # User & privilege enumeration
        "net user" "net localgroup" "net group" "Get-LocalUser" "id" "id -u" "finger"
        "dsquery" "Get-ADUser" "Get-ADDomain" "Get-ADGroup"
        "query user" "query session"
        # Admin/priv escalation preps
        "whoami /priv" "wmic.*useraccount" "findstr.*S-1-5"
        "Get-WmiObject.*Account"
        # Network discovery
        "ipconfig /all" "ifconfig -a" "ip addr" "ip link" "iwconfig"
        "netstat" "ss -an" "arp -a" "route print" "traceroute"
        "nltest" "nslookup" "dig" "host" "Get-NetIPConfiguration" "Get-NetAdapter"
        "nmap" "masscan" "ping.*-n" "ping.*-c" "Get-NetTCPConnection"
        "net view" "net use" "net share" "smbclient" "rpcclient"
        # Service & port discovery
        "services.msc" "Get-Service" "service --status-all" "chkconfig --list"
        "ps -e" "tasklist" "wmic.*process" "Get-Process" "top" "htop"
        "lsof" "ss -tuln" "fuser"
        # File and directory discovery
        "dir /s" "find /" "locate" "ls -laR" "tree"
        "Get-ChildItem.*-Recurse" "search.*file"
        # Business/email/app discovery
        "outlook.exe" "thunderbird" "mail.app" "scanpst" "calendar" "contacts"
        "teams" "slack" "zoom" "office365" "gsuite" "exchange"
        # AD/Domain/LDAP/SaaS enumeration
        "ldapsearch" "adfind" "net group /domain" "Get-ADDomain"
        "Get-ADForest" "Get-ADOrganizationalUnit" "Get-ADComputer"
        "azuread" "gsuite" "Get-AzureADUser" "Get-GSuiteUser" "Get-AzureADDirectoryRole"
        "aws.*describe" "aws.*list" "gcloud.*list" "az.*list" "az.*show"
        # Scheduled tasks, persistence discovery
        "schtasks /query" "at /?" "crontab -l" "systemctl list-timers"
        # Mobile malware/MaaS/rogue pen-tester, app, permissions, contacts, sensors, location
        "android.intent.action.PACKAGE_ADDED" "android.intent.action.BOOT_COMPLETED"
        "pm list packages" "pm list users" "ls /data/data" "ls /sdcard"
        "content query" "content://contacts" "content://sms" "content://call_log"
        "dumpsys" "getprop" "settings get" "adb shell"
        "frida.*list" "objection.*explore" "mobSF.*scan"
        "ios-deploy" "ideviceinfo" "plistbuddy"
        "provisioning profile" "ios-entitlement" "app entitlement"
        "bluetoothctl" "networksetup" "airport -s"
        "magisk" "su binary" "root checker" "device admin"
        # Presence in mobile apps, banking, crypto, social
        "scan.*app" "bankbot" "wallet" "crypto" "session" "telegram" "whatsapp"
        "token discovery"
        # Rogue/red team/MaaS operator enumeration
        "metasploit.*enum" "cobaltstrike.*enum" "empire.*list" "veil.*enum" "theharvester"
        "creds.*dump" "portscan" "osint"
        # QR/stealth/supply chain discovery
        "qr code.*systeminfo" "scan.*contacts" "scan.*calendar" "qr code.*filesystem"
        "scan.*app list" "qr.*enum"
        # Exfil ready flags/patterns
        "exfil.*ready" "discover.*exfil" "collect.*data"
    )

    local found_indicators=()
    for indicator in "${discovery_indicators[@]}"; do
        if echo "$content" | safe_grep_qiE "$indicator"; then
            found_indicators+=("$indicator")
        fi
    done

    if [ ${#found_indicators[@]} -gt 0 ]; then
        local indicators_str=$(IFS=', '; echo "${found_indicators[*]}")
        log_forensic_detection 50 \
            "Discovery Techniques Detected" \
            "discovery_methods:$indicators_str, count:${#found_indicators[@]}" \
            "Host, network, AD, SaaS, mobile, cloud, rogue, exfil, and app enumeration pattern matching" \
            "Decoded QR/mobile/code content analysis" \
            "ACTIVE RECON - Content shows signs of system, network, cloud, SaaS, mobile, or stealth reconnaissance typical of malware, red team, pentest, or rogue operator" \
            "MITRE ATT&CK T1087/T1016/T1049/T1069/T1007/T1124/T1518/T1614 - Discovery (comprehensive)"
    fi
}

check_impact_techniques() {
    local content="$1"

    local impact_indicators=(
        # Ransomware & encryption
        "encrypt" "decrypt" "ransom" "double extortion"
        "bitcoin" "monero" "ethereum" "litecoin" "payment" "wallet"
        "\.locked" "\.encrypted" "\.crypt" "\.payr" "\.paylol" "\.pay2unlock"
        "key.*exchange" "ransomnote" "restore.*key"
        # Data destruction / wiper
        "wipe" "destroy" "delete.*recursive"
        "rm -rf" "format" "cipher /w" "sdelete"
        "overwrite" "shred" "dd.*if=/dev" "bcwipe" "diskpart.*clean"
        "file.*erase" "DoppelPaymer" "NotPetya" "HermeticWiper" "CaddyWiper" "AcidRain"
        # Defacement / hacktivism
        "defaced" "hacked by" "pwned" "rooted by" "we own you" "deface.*index.html"
        "website.*defacement" "system.*defaced"
        # Service disruption (DoS, DDoS)
        "ddos" "flood" "dos attack" "botnet" "mirai"
        "fork.*bomb" ":(){ :|:& };"
        "slowloris" "hping3" "ping.*flood" "LOIC" "HOIC"
        "Attack.*availability" "SYN flood"
        # Resource hijacking (crypto mining, botnet)
        "cryptominer" "xmrig" "minerd" "coinhive" "nicehash"
        "stratum" "mining.*pool" "minerlib" "wallet.*address" "cpu.*mining"
        # Ransomware notes, tor payment page
        "tor.*payment" "onion.*address" "decryptor"
        "restore.*file.*contact"
        # Mobile impact: device wipe, data destroy, fraud, fake payment
        "factory reset" "wipe.*mobile" "delete.*sms" "delete.*contacts" "delete.*photos"
        "malicious app.*wipe" "android.*malware.*destroy" "ios.*malware.*destroy"
        # Rogue pentester/MaaS sabotage/wiper
        "pentest.*wiper" "metasploit.*wiper" "empire.*destroy" "veil.*impact"
        # OT/IOT/ICS
        "plc.*destroy" "scada.*disrupt" "modbus.*clear"
        # Generic impact indicators
        "delete.*database" "drop table" "truncate" "remove.*backup" "clear.*log"
        # Supply chain/installer attacks
        "installer.*destroy" "update.*wipe" "firmware.*corrupt"
        # Extortion
        "data.*exfil.*threat" "extort.*victim"
    )

    local found_indicators=()
    for indicator in "${impact_indicators[@]}"; do
        if echo "$content" | safe_grep_qiE "$indicator"; then
            found_indicators+=("$indicator")
        fi
    done

    if [ ${#found_indicators[@]} -gt 0 ]; then
        local indicators_str=$(IFS=', '; echo "${found_indicators[*]}")
        log_forensic_detection 80 \
            "Impact Techniques Detected (QR/Mobile/MaaS/Pentest/Advanced)" \
            "impact_methods:$indicators_str, count:${#found_indicators[@]}" \
            "Destructive/impact pattern matching: ransomware, wiper, miner, sabotage, DoS, mobile" \
            "Decoded QR/mobile/cloud/rogue content analysis" \
            "DESTRUCTIVE THREAT - Content may encrypt, destroy, disrupt, deface, mine, or extort systems, files, databases, cloud, or mobile endpoints" \
            "MITRE ATT&CK T1486/T1490/T1499/T1491/T1485/T1489/T1495 - Data Encrypted/Destroyed for Impact, Defacement, Resource Hijack, Service Disruption, OT/IOT/ICS"
    fi
}

analyze_payload_content() {
    set +u
    local content="${1:-}"
    set -u
    log_info "Analyzing payload content..."

    # Encoding, obfuscation, scripts, commands
    analyze_encoding "$content"
    analyze_obfuscation "$content"
    analyze_script_content "$content"
    analyze_command_content "$content"

    # Credentials/secrets, crypto, phone/email, YARA
    analyze_secrets "$content"
    analyze_crypto_addresses "$content"
    analyze_phone_numbers "$content"
    analyze_email_addresses "$content"
    evaluate_all_yara_rules "$content"

    # Payload behavioral/DFIR checks
    analyze_env_fingerprinting "$content"
    analyze_defense_evasion "$content"
    analyze_exploit_payloads "$content"
    check_persistence_techniques "$content"
    check_privilege_escalation "$content"
    check_discovery_techniques "$content"
    check_lateral_movement "$content"
    check_exfiltration_patterns "$content"
    check_credential_access "$content"
    check_c2_patterns "$content"
    check_impact_techniques "$content"
    analyze_qr_specific_iocs "$content"
    analyze_supply_chain_impact "$content"
    analyze_mobile_abuse "$content"
    analyze_cloud_saas_abuse "$content"
    analyze_social_engineering "$content"
    analyze_steganography "$content"
    log_evidence_tags "$content"
}

analyze_encoding() {
    set +u
    local content="${1:-}"
    set -u

    log_info "  Checking for encoded, packed, or hidden content..."

    # === Layered and recursive encoding/packing detection ===

    # Base64 (basic and multiline)
    if echo "$content" | safe_grep_qE "^[A-Za-z0-9+/]{40,}={0,2}$"; then
        log_warning "Potential Base64 encoded content detected"
        local decoded=$(echo "$content" | base64 -d 2>/dev/null)
        if [ -n "$decoded" ]; then
            log_forensic "Base64 decoded: ${decoded:0:200}"
            analyze_payload_content "$decoded"
        fi
    fi

    # Hex encoding (with/without 0x prefix, even-length only)
    if echo "$content" | safe_grep_qE "^([0-9a-fA-F]{40,}|(0x)?[0-9a-fA-F]{40,})$"; then
        log_warning "Potential hex encoded content detected"
        local decoded=$(echo "$content" | sed 's/^0x//' | xxd -r -p 2>/dev/null)
        if [ -n "$decoded" ]; then
            log_forensic "Hex decoded: ${decoded:0:200}"
            analyze_payload_content "$decoded"
        fi
    fi

    # URL encoding, layered
    if echo "$content" | safe_grep_qE "(%[0-9A-Fa-f]{2}){5,}"; then
        log_warning "Heavy URL encoding detected"
        # FIXED: Use printf and stdin to safely pass content to Python
        local decoded
        decoded=$(printf '%s' "$content" | $(get_python_cmd) -c "import sys, urllib.parse; print(urllib.parse.unquote(sys.stdin.read()))" 2>/dev/null)
        if [ -n "$decoded" ] && [ "$decoded" != "$content" ]; then
            log_forensic "URL decoded: ${decoded:0:200}"
            analyze_payload_content "$decoded"
        fi
    fi

    # Unicode escapes
    if echo "$content" | safe_grep_qE "(\\\\u[0-9a-fA-F]{4}){2,}"; then
        log_warning "Unicode escape sequences detected"
        # FIXED: Use printf and stdin to safely pass content to Python
        local decoded
        decoded=$(printf '%s' "$content" | $(get_python_cmd) -c "import sys; print(sys.stdin.read().encode().decode('unicode_escape'))" 2>/dev/null)
        if [ -n "$decoded" ]; then
            log_forensic "Unicode decoded: ${decoded:0:200}"
            analyze_payload_content "$decoded"
        fi
    fi

    # Compressed archive signatures (gzip, zlib, zip, tar, bzip2, lzma/xz)
    if echo "$content" | xxd 2>/dev/null | head -1 | grep -qE "1f8b|789c"; then
        log_warning "Compressed content detected (gzip/zlib signature)"
        log_threat 30 "Compressed payload - potential detection evasion or data staging"
    fi
    if echo "$content" | xxd 2>/dev/null | head -1 | grep -qE "504b0304"; then
        log_warning "ZIP archive detected in content"
        log_threat 40 "ZIP payload or archive staging"
    fi
    if echo "$content" | xxd 2>/dev/null | head -1 | grep -qE "425a68"; then
        log_warning "BZIP2 archive detected in content"
    fi
    if echo "$content" | xxd 2>/dev/null | head -1 | grep -qE "fd377a58"; then
        log_warning "XZ/LZMA archive detected"
    fi
    if echo "$content" | xxd 2>/dev/null | head -1 | grep -qE "7575656e63"; then
        log_warning "Uuencoded payload detected"
    fi

    # ROT13/simple obfuscation detection
    if echo "$content" | safe_grep_qE "[A-Za-z]{30,}"; then
        local rot=$(echo "$content" | tr 'A-Za-z' 'N-ZA-Mn-za-m')
        if ! grep -qE "^[A-Za-z0-9+/=]{40,}$" <<<"$rot" && grep -qE "(password|cmd|exec|powershell|curl|wget)" <<<"$rot"; then
            log_warning "ROT13-obfuscated snippet detected"
            log_forensic "ROT13 decoded: ${rot:0:200}"
            analyze_payload_content "$rot"
        fi
    fi

    # XOR pattern hints (often in exploit/MaaS frameworks)
    if echo "$content" | safe_grep_qE "(xor|0x[0-9a-fA-F]{2,})" && echo "$content" | safe_grep_qE "(encrypted|decrypt|decode)"; then
        log_warning "XOR-based obfuscation pattern detected"
        log_threat 30 "Detected XOR pattern in encoded payload (manual review recommended)"
    fi

    # Stego and QR image payload hints
    if echo "$content" | safe_grep_qE "(png|jpg|jpeg|stego|lsb)"; then
        log_warning "Potential steganographic or image-hidden payload detected"
        log_threat 25 "Stego/LSB/image payload channel - common in QR/mobile attacks"
    fi

    # Mobile intent and provisioning/base64 manipulations via QR
    if echo "$content" | safe_grep_qiE "intent://|market://|android.intent.action.|provisioning profile|base64.*manifest"; then
        log_warning "Mobile QR/app encoding or sideload techniques detected"
    fi

    # Layered recursive (base64-encoded zip/archive or stego, e.g. mobile dropper in b64)
    if echo "$content" | safe_grep_qE "^[A-Za-z0-9+/]{100,}={0,2}$"; then
        local decoded=$(echo "$content" | base64 -d 2>/dev/null)
        if [ -n "$decoded" ] && echo "$decoded" | xxd 2>/dev/null | head -1 | grep -qE "(504b0304|1f8b|789c|7575656e63|425a68|fd377a58)"; then
            log_warning "Base64-encoded archive/stego payload detected after decode"
            log_forensic "Recursive decode archive: ${decoded:0:200}"
            analyze_payload_content "$decoded"
        fi
    fi
}

analyze_obfuscation() {
    set +u
    local content="${1:-}"
    local depth="${2:-0}"
    set -u
    
    # AUDIT FIX: Prevent infinite recursion - max depth 3
    if [ "$depth" -ge 3 ]; then
        log_info "  Maximum recursion depth reached for obfuscation analysis"
        return
    fi

    log_info "  Checking for advanced obfuscation techniques..."

    # Detect known and advanced obfuscation techniques via patterns (from OBFUSCATION_PATTERNS db)
    for pattern_name in "${!OBFUSCATION_PATTERNS[@]}"; do
        local pattern="${OBFUSCATION_PATTERNS[$pattern_name]}"
        # AUDIT FIX: Wrap grep in error handling to prevent crashes
        if echo "$content" | safe_grep_qE "$pattern" 2>/dev/null; then
            log_threat 35 "Obfuscation technique detected: $pattern_name"
            log_forensic "Matched obfuscation pattern: $pattern_name ($pattern)"
        fi
    done

    # Mobile app packing & script obfuscators
    if echo "$content" | safe_grep_qiE "dexguard|proguard|ilex|protect.dex|mogua|jiagu|secneo|appguard|tampermonkey|packer|deepsea|mobisec"; then
        log_threat 40 "Mobile app packer/obfuscator detected"
    fi

    # Typical Red Team/RAT/MaaS obfuscation toolchains
    if echo "$content" | safe_grep_qiE "ConfuserEx|obfuscar|powersploit|invoke-obfuscation|veil|empire|meterpreter|cobaltstrike|base64.*exec|xor"; then
        log_threat 45 "Red Team/MaaS/Commodity toolkit obfuscation detected"
    fi

    # PowerShell, VBA, JavaScript, Bash obfuscators
    if echo "$content" | safe_grep_qiE "(IEX|Invoke-Expression|MSH|FromBase64String|new-object|unescape|String\.fromCharCode|eval|obfuscated)"; then
        log_threat 35 "Script/command obfuscation detected"
    fi

    # Crypto, encoding, and payload concatenation
    if echo "$content" | safe_grep_qiE "(aes|rsa|des|rc4|xor|base64|rot13|hex|GzipStream|zlib)"; then
        log_warning "Possible cryptographic or encoding obfuscation detected"
    fi

    # String entropy analysis (detecting encryption, packing, binary payloads)
    local entropy=$(calculate_string_entropy "$content")
    if float_gt "$entropy" "5.5"; then
        log_warning "High string entropy ($entropy) - possible packing/encryption/obfuscation"
        log_forensic "String entropy: $entropy"
        # Optionally, recursive decoding for high entropy blocks if base64/hex detected
        # AUDIT FIX: Pass depth parameter and add error handling
        if echo "$content" | safe_grep_qE "^[A-Za-z0-9+/]{40,}$"; then
            local decoded=$(echo "$content" | base64 -d 2>/dev/null || true)
            if [ -n "$decoded" ] && [ "$depth" -lt 2 ]; then
                log_info "Recursively analyzing high-entropy base64 block (depth: $((depth + 1)))"
                analyze_obfuscation "$decoded" "$((depth + 1))"
            fi
        fi
        if echo "$content" | safe_grep_qE "^[0-9a-fA-F]{40,}$"; then
            local decoded=$(echo "$content" | xxd -r -p 2>/dev/null || true)
            if [ -n "$decoded" ] && [ "$depth" -lt 2 ]; then
                log_info "Recursively analyzing high-entropy hex block (depth: $((depth + 1)))"
                analyze_obfuscation "$decoded" "$((depth + 1))"
            fi
        fi
    fi

    # Character frequency anomaly analysis
    analyze_char_frequency "$content"
    detect_unicode_homoglyphs "$content"

    # Layered/junk/substring obfuscation
    if echo "$content" | safe_grep_qE "(concat|substr|split|replace|reverse|junk code|dead code|no-op|nop sled|padding)"; then
        log_warning "Substring/junk/no-op/padding obfuscation detected"
    fi

    # Mobile/QR/Supply Chain (intent, manifest, provisioning)
    if echo "$content" | safe_grep_qiE "(intent://|manifest|provisioning profile|base64.*permission|obfuscated app|hidden activity|stealth receiver)"; then
        log_warning "Mobile QR app obfuscation/stealth techniques detected"
    fi

    # Evidence chain logging (optional: keep audit trail)
    log_forensic "Obfuscation check completed (${#content} bytes analyzed)"
}

calculate_string_entropy() {
    local str="$1"

    # Validate input
    [[ -z "$str" ]] && { echo "0.0"; return; }

    # Limit input length to avoid abuse/resource exhaustion (tune as needed!)
    local maxlen=10000
    if [ "${#str}" -gt "$maxlen" ]; then
        str="${str:0:$maxlen}"
        log_info "Entropy calculation limited to first $maxlen characters (truncated for safety)"
    fi

local encoded_str
encoded_str=$(printf '%s' "$str" | base64 2>/dev/null) || { echo "0.0"; return; }

# AUDIT FIX: Return only the numeric entropy value, not formatted output
# Pass encoded string as argument instead of pipe
python3 - "$encoded_str" 2>/dev/null <<'EOF'
import sys
import math
import base64
from collections import Counter

def entropy(s):
    # Shannon entropy in bits per char
    probs = [v / len(s) for v in Counter(s).values()]
    return -sum(p * math.log2(p) for p in probs if p > 0)

try:
    s = base64.b64decode(sys.argv[1] if len(sys.argv) > 1 else '').decode('utf-8', errors='ignore')
    s = s.strip()
    if not s:
        print('0.0')
    else:
        # Handle repetitive, binary, or non-printable input
        printable = ''.join(c for c in s if 32 <= ord(c) <= 126)
        if len(printable) < len(s)/4:    # >75% non-printable
            print('0.0')
        else:
            # Calculate and return only the entropy value
            H = entropy(s)
            print(f'{H:.4f}')
except Exception:
    print('0.0')
EOF
}

analyze_char_frequency() {
    set +u
    local content="${1:-}"
    set -u

    # Skip very short strings, but allow longer non-ASCII blocks
    if [ "${#content}" -lt 50 ]; then
        return
    fi

    # FIXED: Use base64 encoding to safely pass content to Python
    local encoded_content
    encoded_content=$(printf '%s' "$content" | base64 2>/dev/null) || return

    # Pass encoded content as argument instead of pipe (heredoc conflicts with pipe)
    python3 - "$encoded_content" 2>/dev/null <<'EOF'
import sys
import base64
from collections import Counter

try:
    content = base64.b64decode(sys.argv[1] if len(sys.argv) > 1 else '').decode('utf-8', errors='ignore')
    if not content or len(content) < 50:
        exit(0)

    counter = Counter(content.lower())
    total = sum(counter.values())

    # Expected frequencies for English text (top chars)
    expected = {
        'e': 0.127, 't': 0.091, 'a': 0.082, 'o': 0.075, 'i': 0.070,
        'n': 0.067, 's': 0.063, 'h': 0.061, 'r': 0.060, 'd': 0.043,
        'l': 0.040, 'c': 0.027, 'u': 0.028, 'm': 0.024, 'w': 0.024,
        'f': 0.023, 'g': 0.020, 'y': 0.020, 'p': 0.019, 'b': 0.015,
        'v': 0.010, 'k': 0.008, 'x': 0.002, 'j': 0.002, 'q': 0.001, 'z': 0.001
    }

    # Reference frequencies for base64/hex (used in encoding/stego/anomaly checks)
    b64_expected = {c: 1/64 for c in 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'}
    hex_expected = {c: 1/16 for c in '0123456789abcdef'}

    # Calculate deviation from English
    deviation_eng = 0
    for char, expected_freq in expected.items():
        actual_freq = counter.get(char, 0) / total
        deviation_eng += abs(actual_freq - expected_freq)

    # Calculate deviation for base64/hex profiles
    deviation_b64 = 0
    for char, expected_freq in b64_expected.items():
        actual_freq = counter.get(char, 0) / total
        deviation_b64 += abs(actual_freq - expected_freq)

    deviation_hex = 0
    for char, expected_freq in hex_expected.items():
        actual_freq = counter.get(char, 0) / total
        deviation_hex += abs(actual_freq - expected_freq)

    # Print anomaly if any deviation is high
    threshold_eng = 0.3
    threshold_b64 = 0.25
    threshold_hex = 0.15

    if deviation_eng > threshold_eng and deviation_b64 > threshold_b64 and deviation_hex > threshold_hex:
        print(f'CHAR_FREQ_ANOMALY: High deviation from English/base64/hex frequencies (English={deviation_eng:.3f}, B64={deviation_b64:.3f}, Hex={deviation_hex:.3f})')
        most_common = counter.most_common(10)
        print('Freq Histogram (top 10 chars): ' + ', '.join(f'{c}:{n}' for c,n in most_common))
    elif deviation_b64 < threshold_b64:
        print(f'BASE64_PROFILE_DETECTED: Char frequency matches base64 profile ({deviation_b64:.3f})')
    elif deviation_hex < threshold_hex:
        print(f'HEX_PROFILE_DETECTED: Char frequency matches hex profile ({deviation_hex:.3f})')
except Exception:
    pass
EOF
}

analyze_script_content() {
    set +u
    local content="${1:-}"
    set -u
    
    log_info "  Checking for script content..."
    
    # PowerShell
    if echo "$content" | safe_grep_qiE "powershell|pwsh|\$\{|\$\(|Invoke-|IEX|New-Object|System\."; then
        log_threat 50 "PowerShell content detected"
        analyze_powershell_payload "$content"
    fi
    
    # Bash/Shell
    if echo "$content" | safe_grep_qiE "^#!/|bash|/bin/sh|wget|curl|chmod|sudo|eval|exec"; then
        log_threat 45 "Shell script content detected"
        analyze_shell_payload "$content"
    fi
    
    # JavaScript
    if echo "$content" | safe_grep_qiE "javascript:|<script|document\.|window\.|eval\(|Function\("; then
        log_threat 40 "JavaScript content detected"
        analyze_javascript_payload "$content"
    fi
    
    # Python
    if echo "$content" | safe_grep_qiE "python|import[[:space:]]\+|from[[:space:]]\+.*[[:space:]]+import|exec\(|eval\(|__import__"; then
        log_threat 40 "Python content detected"
        analyze_python_payload "$content"
    fi
    
    # VBScript
    if echo "$content" | safe_grep_qiE "vbscript:|CreateObject|WScript|Scripting\."; then
        log_threat 50 "VBScript content detected"
    fi
    
    # Batch
    if echo "$content" | safe_grep_qiE "@echo|%.*%|set /|goto|cmd\.exe|command\.com"; then
        log_threat 45 "Windows Batch content detected"
    fi
    
    # AppleScript/macOS/iOS
    if echo "$content" | safe_grep_qiE "osascript|tell application|AppleScript|do shell script"; then
        log_threat 38 "macOS/iOS AppleScript detected"
    fi

    # Android/ADB
    if echo "$content" | safe_grep_qiE "adb shell|pm install|am start|am broadcast|am force-stop|logcat|dumpsys|getprop"; then
        log_threat 39 "Android ADB/mobile automation/script detected"
    fi

    # Ruby (Metasploit, Red Team, MaaS)
    if echo "$content" | safe_grep_qiE "ruby|require |def |end |Metasploit|msfconsole|msfvenom"; then
        log_threat 39 "Ruby/Metasploit/MaaS script detected"
    fi

    # Perl
    if echo "$content" | safe_grep_qiE "perl|use [A-Za-z]|sub |print |binmode|open\(.*\)"; then
        log_threat 36 "Perl script detected"
    fi

    # Lua (RAT, Game mods, threat tooling)
    if echo "$content" | safe_grep_qiE "lua|require\(|function |local |end"; then
        log_threat 35 "Lua script detected"
    fi

    # HTML/Hybrid
    if echo "$content" | safe_grep_qiE "<html>|<head>|<body>|<iframe|<object|<embed|document\.cookie|document\.location"; then
        log_threat 32 "HTML/Hybrid payload detected"
    fi
    
    # MQTT/automation (IoT, mobile abuse)
    if echo "$content" | safe_grep_qiE "mqtt|mosquitto_pub|mosquitto_sub|topic|payload|client\.publish"; then
        log_threat 32 "MQTT/IoT automation detected"
    fi

    # Living-off-the-Land/dual-use/LOLBAS
    if echo "$content" | safe_grep_qiE "certutil|mshta|wmic|cscript|wscript|regsvr32|rundll32|powershell|\$\{|\$\(|python|curl|wget|Invoke-|IEX|New-Object|systemctl|service|netcat|nc"; then
        log_threat 44 "Living-off-the-land binary/script/automation detected"
    fi
    
    # RAT/stealer C2 logic (Python, JS, PowerShell, Bash)
    if echo "$content" | safe_grep_qiE "quasar|empire|meterpreter|cobaltstrike|beacon|rat|async|reverse_shell|bind_shell|websocket|token|api.*post|discord|telegram|slack"; then
        log_threat 44 "RAT/stealer or C2 logic detected"
    fi

    # Mobile intent/app/QR hybrid payloads
    if echo "$content" | safe_grep_qiE "intent://|market://|android\.intent\.action|startActivity|sendBroadcast|content://|provisioning profile|coreml|ios.*UniversalLink|deepLink"; then
        log_threat 41 "Mobile QR/app/intent/abuse script detected"
    fi
    
    # Messaging/SMS/Email automation scripts for fraud/social engineering
    if echo "$content" | safe_grep_qiE "smsManager|twilio|sendTextMessage|email\.send|smtp|android\.telephony|message\.send|telegram\.send|discord\.send|slack\.send"; then
        log_threat 35 "Messaging/email/social/automation detected"
    fi

    # Supply chain/builder/provisioning/packer
    if echo "$content" | safe_grep_qiE "builder\.exe|packer|obfuscator|manifest|provisioning|signapk|signipa|shellter|veil|drozer|mobisec|mobSF"; then
        log_threat 40 "Supply chain/packer/provisioning script detected"
    fi

    # Data exfiltration/compression/staging
    if echo "$content" | safe_grep_qiE "base64|zipfile|gzip|tarfile|curl.*-T|wget.*--post|ftp|scp|sftp|nc.*-w|aws s3 cp|gsutil cp|azcopy|dropbox|gdrive"; then
        log_threat 38 "Exfiltration/packing/staging script detected"
    fi

    # Stego/encoded/hybrid
    if echo "$content" | safe_grep_qiE "stego|lsb|steganography|encode.*image|decode.*image"; then
        log_threat 35 "Steganography or image-encoded script detected"
    fi

    # Misc common office macro
    if echo "$content" | safe_grep_qiE "autoopen|document_open|ThisDocument|ActiveDocument|macro|Sub Auto_Open|Sub Workbook_Open"; then
        log_threat 50 "Office macro/VBA automation detected"
    fi
}

analyze_powershell_payload() {
    set +u
    local content="${1:-}"
    set -u
    
    log_forensic "Analyzing PowerShell payload..."
    
    # Dangerous cmdlets
    local dangerous_cmdlets=(
        "Invoke-Expression" "IEX" "Invoke-Command"
        "Invoke-WebRequest" "Invoke-RestMethod"
        "New-Object.*Net\.WebClient" "DownloadString"
        "DownloadFile" "Start-Process" "Invoke-Item"
        "Invoke-WmiMethod" "Invoke-CimMethod"
        "Add-Type" "Reflection\.Assembly"
        "ConvertTo-SecureString" "Get-Credential"
        "Invoke-Mimikatz" "Invoke-Shellcode"
        "Set-MpPreference" "Disable-WindowsOptionalFeature"
    )
    
    for cmdlet in "${dangerous_cmdlets[@]}"; do
        if echo "$content" | safe_grep_qiE "$cmdlet"; then
            log_threat 60 "Dangerous PowerShell cmdlet: $cmdlet"
        fi
    done
    
    # Encoded commands
    if echo "$content" | safe_grep_qiE "\-enc|\-encodedcommand|\-e[[:space:]]+[A-Za-z0-9+/=]{20,}"; then
        log_threat 70 "Encoded PowerShell command detected"
        
        # Try to decode
        local encoded=$(echo "$content" | safe_grep_oE "[A-Za-z0-9+/=]{50,}" | head -1)
        if [ -n "$encoded" ]; then
            local decoded=$(echo "$encoded" | base64 -d 2>/dev/null | iconv -f UTF-16LE -t UTF-8 2>/dev/null)
            if [ -n "$decoded" ]; then
                log_forensic "Decoded PowerShell: $decoded"
                analyze_powershell_payload "$decoded"
            fi
        fi
    fi
    
    # Bypass techniques
    if echo "$content" | safe_grep_qiE "\-ExecutionPolicy[[:space:]]\+Bypass|\-ep[[:space:]]\+bypass|\-nop|\-windowstyle[[:space:]]\+hidden|\-w[[:space:]]+hidden"; then
        log_threat 55 "PowerShell bypass/evasion flags detected"
    fi

    # Advanced AMSI, ETW, Defender bypass & scripting evasion
    if echo "$content" | safe_grep_qiE "amsi.*bypass|patch.*amsi|etw.*bypass|defender.*disable|Set-MpPreference.*-Disable|Clear-EventLog|wevtutil.*cl|log.*clear|bypassuac|Invoke-NinjaCopy"; then
        log_threat 65 "PowerShell AMSI/ETW/Defender/Log bypass detected"
    fi

    # Credential access and dumping
    if echo "$content" | safe_grep_qiE "Invoke-CredentialPrompt|Invoke-Kerberoast|Invoke-DCSync|Invoke-PowerDump|Invoke-TokenManipulation"; then
        log_threat 65 "PowerShell credential stealing/dumping technique detected"
    fi

    # Lateral movement (WinRM/PSRemoting)
    if echo "$content" | safe_grep_qiE "New-PSSession|Enter-PSSession|Invoke-Command|Invoke-WmiMethod|Invoke-CimMethod|PsExec"; then
        log_threat 62 "Lateral movement (PowerShell Remoting/WMI/CIM) detected"
    fi

    # RAT/C2/Red Team/MaaS payloads
    if echo "$content" | safe_grep_qiE "Empire|CobaltStrike|beacon|reverse_tcp|Invoke-RAT|Meterpreter|websocket|Invoke-DomainBackdoor"; then
        log_threat 68 "PowerShell RAT/C2/Red Team/MaaS payload detected"
    fi

    # Data exfiltration, staging, and compression
    if echo "$content" | safe_grep_qiE "compress.*archive|base64|zipfile|Invoke-FileTransfer|Upload-File|Invoke-FtpUpload|Invoke-SMBExec|Invoke-Shellcode|DropBox.*API|OneDrive.*API"; then
        log_threat 61 "PowerShell exfil/compression/staging technique detected"
    fi

    # Living-off-the-land, LOLBAS, dual-use binaries
    if echo "$content" | safe_grep_qiE "certutil|mshta|regsvr32|rundll32|Add-MpPreference|Invoke-ReflectivePEInjection|Invoke-Obfuscation"; then
        log_threat 60 "PowerShell LOLBAS dual-use binary/script detected"
    fi

    # Mobile, cloud/SaaS, and cross-platform integration
    if echo "$content" | safe_grep_qiE "Invoke-Android|Invoke-Ios|Invoke-MobilePayload|Invoke-GoogleDrive|Invoke-AwsS3|Invoke-AzureBlob|Invoke-TeamsMessage|Invoke-SlackMessage|Invoke-DiscordMessage"; then
        log_threat 54 "Mobile SaaS/cloud integration/script detected"
    fi

    # Office macro or document abuse
    if echo "$content" | safe_grep_qiE "ActiveDocument|ThisDocument|AutoOpen|Macro|Document_Open|Excel\.Application"; then
        log_threat 60 "PowerShell Office macro/abuse detected"
    fi

    # Stego/hybrid/obfuscated script
    if echo "$content" | safe_grep_qiE "stego|lsb|obfuscated|encode.*image|decode.*image"; then
        log_threat 60 "Steganography or heavily obfuscated PowerShell detected"
    fi

    # Audit/evidence chain logging
    log_forensic "PowerShell payload check complete (${#content} bytes analyzed)"
}

analyze_shell_payload() {
    set +u
    local content="${1:-}"
    set -u
    
    log_forensic "Analyzing shell payload..."
    
    # Dangerous commands
    local dangerous_commands=(
        "wget.*\|.*sh" "curl.*\|.*bash" "curl.*\|.*sh"
        "wget.*-O.*&&.*chmod" "curl.*-o.*&&.*chmod"
        "nc[[:space:]]\+-e" "ncat[[:space:]]\+-e" "/dev/tcp/"
        "bash[[:space:]]\+-i" "python.*-c.*socket"
        "perl.*-e.*socket" "ruby.*-rsocket"
        "mkfifo" "mknod" "telnet.*\|.*bash"
        "rm[[:space:]]\+-rf[[:space:]]\+/" "dd[[:space:]]\+if=/dev/zero"
        "chmod[[:space:]]\+777" "chmod[[:space:]]\+u\+s"
        "crontab" "/etc/passwd" "/etc/shadow"
        "useradd" "adduser" "usermod"
        "iptables[[:space:]]\+-F" "ufw[[:space:]]\+disable"
    )
    
    for cmd in "${dangerous_commands[@]}"; do
        if echo "$content" | safe_grep_qiE "$cmd"; then
            log_threat 65 "Dangerous shell command: $cmd"
        fi
    done
    
    # Reverse shell patterns
    if echo "$content" | safe_grep_qiE "bash.*-i.*>&.*/dev/tcp|nc.*-e.*/bin|python.*socket.*connect|php.*fsockopen"; then
        log_threat 80 "Reverse shell pattern detected!"
    fi

    # Supply chain, dropper, packer logic
    if echo "$content" | safe_grep_qiE "tar.*-x|unzip|rpm|dpkg|apt install|yum install|apk add|pip install|npm install|curl .*get.*sh|bash <(curl|wget)"; then
        log_threat 54 "Supply chain/downloader/installer/packer logic detected"
    fi

    # Living-off-the-land binaries & dual-use abuse (LOLBAS, LOLBins)
    if echo "$content" | safe_grep_qiE "curl|wget|nc|ncat|socat|perl|python|php|ruby|openssl|base64|iconv|awk|sed|dd|mkfifo|mknod|crontab|sshd|telnet|ftp|scp|find|locate|su|sudo"; then
        log_threat 62 "Living-off-the-land script or binary detected"
    fi

    # Data exfiltration and staging
    if echo "$content" | safe_grep_qiE "ftp .*put|scp|sftp|curl.*-T|wget.*--post|nc.*<|tar.*-c|gzip|base64|openssl enc|aws s3 cp|gsutil cp|azcopy|dropbox|gdrive"; then
        log_threat 59 "Data exfiltration/staging script or command detected"
    fi

    # RAT, C2 beacon, malware automation
    if echo "$content" | safe_grep_qiE "quasar|rat|meterpreter|cobaltstrike|empire|reverse_shell|bind_shell|websocket|tor|onion|discord|telegram"; then
        log_threat 77 "Malware/RAT/C2 automation logic detected"
    fi

    # Persistence techniques
    if echo "$content" | safe_grep_qiE "rc.local|init.d|systemctl enable|service --add|update-rc.d|cron|crontab -e|at -f|nohup|background"; then
        log_threat 68 "Persistence mechanism detected"
    fi

    # Privilege escalation, user/group/policy/elevation
    if echo "$content" | safe_grep_qiE "sudo|su |chmod [0-7]{3}|pkexec|setuid|setgid|useradd|passwd|adduser|usermod|visudo|groupadd|chown|chmod .*s"; then
        log_threat 70 "Privilege escalation attempt detected"
    fi

    # Destructive/impact (wiper/ransom/data destroy)
    if echo "$content" | safe_grep_qiE "rm -rf|wipe|shred|dd if=|format|mkfs|fsck|diskutil erase|cryptsetup|dd if=/dev/zero of=/dev/sd"; then
        log_threat 75 "Destructive or wiper logic detected"
    fi

    # Mobile/Android/ADB/smart device script
    if echo "$content" | safe_grep_qiE "adb shell|pm install|am start|am broadcast|am force-stop|content://|dumpsys|getprop|settings get|intent://|market://"; then
        log_threat 55 "Android/ADB/mobile automation logic detected"
    fi

    # Cloud/SaaS automation/exfil/script
    if echo "$content" | safe_grep_qiE "aws|gcloud|azcopy|azure|gsutil|slack|discord|office365|teams"; then
        log_threat 52 "Cloud/SaaS automation/exfiltration logic detected"
    fi

    # IoT/OT/ICS/SCADA device scripts
    if echo "$content" | safe_grep_qiE "modbus|mqtt|plc|rtu|scada|industrial|s7comm|dnp3|bacnet|mosquitto_pub|mosquitto_sub"; then
        log_threat 49 "IoT/OT/ICS/SCADA automation script detected"
    fi

    # Stego/hybrid/encoded/packer magic
    if echo "$content" | safe_grep_qiE "stego|lsb|steganography|encode.*image|decode.*image|exiftool|pngcheck|ffmpeg|imagemagick"; then
        log_threat 46 "Image/stego/encoded payload script detected"
    fi

    # Evidence chain logging (forensic trail, can add more here if desired)
    log_forensic "Shell payload check complete (${#content} bytes analyzed)"
}

analyze_javascript_payload() {
    set +u
    local content="${1:-}"
    set -u
    
    log_forensic "Analyzing JavaScript payload..."
    
    # Dangerous patterns
    local dangerous_patterns=(
        "eval[[:space:]]*\(" "Function[[:space:]]*\(" "setTimeout[[:space:]]*\(.*eval"
        "document\.write[[:space:]]*\(.*unescape" "document\.write[[:space:]]*\(.*String\.fromCharCode"
        "createElement[[:space:]]*\(.*script" "appendChild[[:space:]]*\("
        "XMLHttpRequest" "fetch[[:space:]]*\(" "ActiveXObject"
        "WScript\.Shell" "WScript\.CreateObject"
        "location[[:space:]]*=" "location\.href[[:space:]]*=" "location\.replace"
        "window\.open[[:space:]]*\(" "document\.cookie"
        "localStorage" "sessionStorage"
        "navigator\.sendBeacon" "WebSocket"
    )
    
    for pattern in "${dangerous_patterns[@]}"; do
        if echo "$content" | safe_grep_qiE "$pattern"; then
            log_threat 45 "Dangerous JavaScript pattern: $pattern"
        fi
    done
    
    # Check for heavily obfuscated code
    local bracket_count=$(echo "$content" | safe_grep_o '\[' | wc -l)
    local paren_count=$(echo "$content" | safe_grep_o '(' | wc -l)
    if [ "$bracket_count" -gt 50 ] || [ "$paren_count" -gt 50 ]; then
        log_threat 35 "Heavily obfuscated JavaScript detected"
    fi

    # Credential theft (phishing, stealer, autofill abuse)
    if echo "$content" | safe_grep_qiE "input type=[\"']password[\"']|document\.getElementById.*password|chrome\.runtime\.sendMessage.*password|navigator\.credentials|getUserMedia|getElementsByName.*password"; then
        log_threat 52 "JavaScript credential theft/phishing logic detected"
    fi

    # Keylogger, input/DOM abuse, event sniffer
    if echo "$content" | safe_grep_qiE "addEventListener[[:space:]]*\(.*key|onkeypress|onkeydown|onkeyup|keypress|keydown|keyup|logkeys|user_input|capture_input"; then
        log_threat 48 "JavaScript keylogger/event sniffer logic detected"
    fi

    # Mobile HTML5/QR/intent/app abuse
    if echo "$content" | safe_grep_qiE "intent:\/\/|market:\/\/|android\.intent\.action|cordova|phonegap|window\.cordova|coreml.*scan|navigator\.contacts|navigator\.camera|navigator\.mediaDevices"; then
        log_threat 41 "Mobile/QR/app/intent/abuse script detected"
    fi

    # RAT, C2, beacon, post-ex tools
    if echo "$content" | safe_grep_qiE "websocket|sockjs|reverse_shell|evilginx|beef\.hook|beef\.api|malicious\.js|rat\.js|c2_server|token_stealer"; then
        log_threat 54 "RAT/C2/post-exploitation JavaScript detected"
    fi

    # Data exfil, beacon, pastebin, cloud APIs
    if echo "$content" | safe_grep_qiE "sendBeacon|postMessage|fetch.*post|$.ajax|pastebin\.com|dropbox\.api|gdrive\.api|discord\.api|telegram\.api"; then
        log_threat 46 "Data exfiltration/beacon/cloud API logic detected"
    fi

    # Persistence (localStorage, cookie abuse, scheduled reload, push)
    if echo "$content" | safe_grep_qiE "localStorage\.setItem|sessionStorage\.setItem|document\.cookie=.*;|setInterval|setTimeout.*reload|addEventListener.*push"; then
        log_threat 44 "Persistence/reload/cookie abuse logic detected"
    fi

    # Stego, encoding, packing
    if echo "$content" | safe_grep_qiE "steganography|imageData|canvas\.toDataURL|encodeURIComponent|Base64|btoa|atob|encode|decode"; then
        log_threat 43 "JavaScript stego/packing/encoding logic detected"
    fi

    # Malicious browser extension/abuse
    if echo "$content" | safe_grep_qiE "chrome\.runtime|chrome\.extension|browser\.extension|browser_action|onInstalled|webRequest|background\.js|manifest\.json"; then
        log_threat 36 "Browser extension abuse logic detected"
    fi

    # Supply chain, loader, packer, code injection
    if echo "$content" | safe_grep_qiE "webpack|parcel|rollup|electron|nw\.js|loadExternalScript|importDynamic|injectScript|self\.postMessage"; then
        log_threat 37 "Supply chain/packer/loader/injection logic detected"
    fi

    # Living-off-the-land, LOLBins JS/HTML hybrid threats
    if echo "$content" | safe_grep_qiE "mshta|activex|HTA:Application|rundll32|certutil|powershell|wscript\.shell"; then
        log_threat 42 "Living-off-the-land hybrid JS/HTML/command content detected"
    fi

    # Advanced obfuscators or layered encoding
    if echo "$content" | safe_grep_qiE "javascript-obfuscator|packer|obfuscated|eval\(function\(p,a,c,k,e,d"; then
        log_threat 52 "Advanced JavaScript obfuscator/packer detected"
    fi

    # Evidence chain logging (can add more if desired)
    log_forensic "JavaScript payload check complete (${#content} bytes analyzed)"
}

analyze_python_payload() {
    set +u
    local content="${1:-}"
    set -u
    
    log_forensic "Analyzing Python payload..."
    
    # Dangerous patterns
    local dangerous_patterns=(
        "__import__[[:space:]]*\(" "importlib" "exec[[:space:]]*\(" "eval[[:space:]]*\("
        "subprocess" "os\.system" "os\.popen" "commands\."
        "socket\.socket" "urllib\.request" "requests\."
        "paramiko" "fabric" "invoke"
        "pickle\.load" "marshal\.load" "shelve"
        "pty\.spawn" "os\.dup2"
        "compile[[:space:]]*\(" "code\.interact"
        "ctypes" "cffi"
    )
    
    for pattern in "${dangerous_patterns[@]}"; do
        if echo "$content" | safe_grep_qiE "$pattern"; then
            log_threat 50 "Dangerous Python pattern: $pattern"
        fi
    done

    # File, system, and credential access
    if echo "$content" | safe_grep_qiE "open[[:space:]]*\(|os\.remove|os\.unlink|shutil\.move|shutil\.copy|os\.chmod|getpass|getuser|getlogin|keyring|creds|password|token"; then
        log_threat 52 "Python system/file/credential access detected"
    fi

    # Persistence techniques & privilege escalation
    if echo "$content" | safe_grep_qiE "crontab|systemctl enable|at\.open|startup|autostart|chmod\s+[247]{3}|useradd|adduser|sudo|su[[:space:]]"; then
        log_threat 56 "Python persistence or privilege escalation logic detected"
    fi

    # Exfiltration, cloud, SaaS, data staging
    if echo "$content" | safe_grep_qiE "requests\.post|socket\.send|ftplib|smtplib|dropbox|gdrive|boto3|azure|google\.cloud|aws|s3|upload|scp|paramiko\.SFTPClient|pypastebin"; then
        log_threat 54 "Python exfiltration/cloud/SaaS/script detected"
    fi

    # RAT, C2, beacon/post-exploit
    if echo "$content" | safe_grep_qiE "quasar|rat|c2|reverse_shell|bind_shell|websocket|botnet|discord|telegram|slack|beacon|meterpreter|empire|cobaltstrike"; then
        log_threat 60 "Python RAT/C2/post-exploitation code detected"
    fi

    # Living-off-the-land, dual-use, LOLBAS
    if echo "$content" | safe_grep_qiE "curl|wget|nc|netcat|ncat|socat|perl|php|rundll32|certutil|mshta|os\.system|shutil|ftplib|powershell|wscript"; then
        log_threat 57 "Python Living-off-the-land binary/script detected"
    fi

    # Impact, destructive, encryption/wiper/ransom
    if echo "$content" | safe_grep_qiE "encrypt|decrypt|rsa|aes|fernet|pycryptodome|pycrypto|ransom|shred|os\.remove|os\.unlink|rm.*-rf|wipe|destroy|delete|crypto|bitcoin|monero|wallet"; then
        log_threat 70 "Python impact/destructive/ransom/crypto logic detected"
    fi

    # Stego, packing, encoding, obfuscation, image abuse
    if echo "$content" | safe_grep_qiE "base64|binascii|zlib|gzip|tarfile|zipfile|lzma|xxd|stego|lsb|jpeg|png|imageio|opencv|PIL|canvas|encode|decode|xor|rot13"; then
        log_threat 61 "Python stego/packing/encoding/obfuscation detected"
    fi

    # Supply chain, mobile, builder/provisioning, sideload
    if echo "$content" | safe_grep_qiE "PyInstaller|cx_Freeze|pip install|setup\.py|requirements\.txt|signapk|signipa|apktool|androguard|frida|drozer|mobisec|mobSF|adb|ios-deploy|provision|manifest"; then
        log_threat 53 "Python supply chain/mobile/provisioning script detected"
    fi

    # IoT, OT/ICS/SCADA device scripts
    if echo "$content" | safe_grep_qiE "modbus|mqtt|plc|rtu|scada|industrial|s7comm|dnp3|bacnet|mosquitto_pub|mosquitto_sub|python-automation"; then
        log_threat 49 "Python IoT/OT/ICS/SCADA automation script detected"
    fi

    # Browser/extension/MITM/credential intercept
    if echo "$content" | safe_grep_qiE "selenium|chromedriver|firefox|mitmproxy|scapy|pychrome|webbrowser|get_cookie|get_token|get_credentials"; then
        log_threat 47 "Python browser automation/MITM/credential intercept detected"
    fi

    # Advanced obfuscators, code packers/loaders
    if echo "$content" | safe_grep_qiE "pyarmor|pyminifier|obfuscator|marshal|exec|compile|codecs|eval\(function"; then
        log_threat 52 "Python obfuscator/codepacker/loader detected"
    fi

    # Evidence chain logging (can add more or extract hits)
    log_forensic "Python payload check complete (${#content} bytes analyzed)"
}

analyze_command_content() {
    set +u
    local content="${1:-}"
    set -u
    
    log_info "  Checking for command patterns..."
    
    # Windows commands
    local win_commands=(
        "cmd\.exe" "powershell\.exe" "wscript\.exe" "cscript\.exe"
        "mshta\.exe" "regsvr32" "rundll32" "certutil"
        "bitsadmin" "msiexec" "installutil" "regasm"
        "msbuild" "cmstp" "control\.exe" "eventvwr"
        "fodhelper" "computerdefaults" "sdclt"
        "wmic" "net[[:space:]]\+user" "net[[:space:]]\+localgroup" "schtasks"
        "reg[[:space:]]\+add" "reg[[:space:]]\+delete" "bcdedit"
        "vssadmin" "wbadmin" "icacls" "takeown"
    )
    
    for cmd in "${win_commands[@]}"; do
        if echo "$content" | safe_grep_qiE "$cmd"; then
            log_threat 40 "Windows command detected: $cmd"
        fi
    done
    
    # LOLBAS/LOLBIN patterns
    local lolbins=(
        "certutil.*-urlcache" "certutil.*-decode"
        "bitsadmin.*/transfer" "mshta.*javascript"
        "mshta.*vbscript" "regsvr32.*/s.*/n.*/u"
        "rundll32.*javascript" "rundll32.*shell32"
        "cmstp.*/ni.*/s" "msiexec.*/q.*http"
        "installutil.*/logfile" "regasm.*/u"
        "msbuild.*inline" "csc.*/out"
    )
    
    for lolbin in "${lolbins[@]}"; do
        if echo "$content" | safe_grep_qiE "$lolbin"; then
            log_threat 70 "LOLBIN/LOLBAS technique: $lolbin"
        fi
    done

    # Linux/macOS/UNIX commands (persistence, impact, exfil, priv-esc, lateral, etc.)
    local unix_commands=(
        # Shells & Interpreters
        "\\bsh\\b" "\\bbash\\b" "/bin/sh" "/bin/bash" "\\bzsh\\b" "\\bksh\\b" "\\bcsh\\b" "\\btcsh\\b" "\\bfish\\b"
        "/bin/zsh" "/bin/ksh" "/bin/csh" "/usr/bin/env" "\\bdash\\b" "\\bash\\b" "\\brbash\\b"
        
        # Command Injection Patterns
        "cmd_injection" "\`" "\\$\\(" ";[[:space:]]*" "\\|\\|" "&&" "\\|" ">>" ">"
        
        # Remote Access & Data Transfer
        "\\bwget\\b" "\\bcurl\\b" "\\bnc\\b" "\\bncat\\b" "\\bnetcat\\b" "\\bsocat\\b" "\\btelnet\\b" "\\brsh\\b" "\\brlogin\\b"
        "\\bscp\\b" "\\bsftp\\b" "\\bftp\\b" "\\btftp\\b" "\\brsync\\b" "\\brcp\\b" "\\bssh\\b" "\\bsshpass\\b"
        "\\baria2c\\b" "\\baxel\\b" "\\bfetch\\b" "lwp-download" "\\blynx\\b" "\\blinks\\b" "\\belinks\\b" "\\bw3m\\b"
        
        # Scripting Languages & Interpreters
        "\\bperl\\b" "\\bpython\\b" "\\bpython2\\b" "\\bpython3\\b" "\\bruby\\b" "\\bphp\\b" "\\blua\\b" "\\bnode\\b" "\\bnodejs\\b"
        "\\bjava\\b" "\\bjavac\\b" "\\bgroovy\\b" "\\bscala\\b" "\\bawk\\b" "\\bgawk\\b" "\\bmawk\\b" "\\bnawk\\b" "\\bsed\\b"
        "\\bexpect\\b" "\\btclsh\\b" "\\bwish\\b" "\\birb\\b" "\\bjrunscript\\b" "\\bjjs\\b"
        
        # Destructive Commands
        "\\brm[[:space: ]]+-rf" "\\brm[[:space:]]+-fr" "\\brm[[:space:]]+--no-preserve-root"
        "\\bdd[[:space:]]+if=" "\\bshred\\b" "\\bwipe\\b" "\\bsrm\\b" "\\btruncate\\b"
        "\\bmkfs\\b" "\\bmke2fs\\b" "mkfs\\.ext" "mkfs\\.xfs" "mkfs\\.btrfs" "\\bmkswap\\b" "\\bfdisk\\b" "\\bparted\\b"
        "\\bmount\\b" "\\bumount\\b" "\\blosetup\\b" "\\bcryptsetup\\b"
        
        # User & Permission Management
        "\\buseradd\\b" "\\badduser\\b" "\\busermod\\b" "\\buserdel\\b" "\\bdeluser\\b" "\\bgroupadd\\b" "\\bgroupmod\\b" "\\bgroupdel\\b"
        "\\bpasswd\\b" "\\bchpasswd\\b" "\\bnewusers\\b" "\\bvipw\\b" "\\bvigr\\b"
        "\\bsudo\\b" "\\bsu[[:space: ]]" "\\bdoas\\b" "\\brunuser\\b" "\\bruncon\\b"
        "\\bchmod[[:space:]]+[0247][0-7][0-7]" "\\bchmod[[:space:]]+[ugoa]*[+-=]" "\\bchmod[[:space:]]+-R"
        "\\bchown\\b" "\\bchgrp\\b" "\\bsetuid\\b" "\\bsetgid\\b" "\\bsetcap\\b" "\\bgetcap\\b"
        "\\bpkexec\\b" "\\bgksudo\\b" "\\bkdesudo\\b" "\\bbeesu\\b"
        
        # Scheduled Tasks & Services
        "\\bcrontab\\b" "\\banacron\\b" "\\bfcron\\b"
        "\\bsystemctl\\b" "\\bservice\\b" "init\\.d" "rc\\.local" "update-rc\\.d" "\\bchkconfig\\b" "\\binsserv\\b"
        "\\bsystemd\\b" "\\bjournalctl\\b" "\\btimedatectl\\b" "\\bhostnamectl\\b" "\\bloginctl\\b"
        
        # Process Control & Job Management
        "\\bat\\b" "\\batq\\b" "\\batrm\\b" "\\bbatch\\b" "\\bnohup\\b" "\\bdisown\\b" "\\bsetsid\\b"
        "\\bscreen\\b" "\\btmux\\b" "\\bbyobu\\b" "\\bdtach\\b" "\\babduco\\b"
        "\\bkill\\b" "\\bkillall\\b" "\\bpkill\\b" "\\bskill\\b" "\\bxkill\\b" "\\bfuser[[:space:]]+-k"
        "\\bnice\\b" "\\brenice\\b" "\\bionice\\b" "\\bchrt\\b" "\\btaskset\\b"
        
        # System Reconnaissance
        "\\bls\\b" "\\bdir\\b" "\\bvdir\\b" "\\blocate\\b" "\\bfind\\b" "\\btree\\b" "\\bwhereis\\b" "\\bwhich\\b" "\\btype\\b"
        "\\bcat\\b" "\\bhead\\b" "\\btail\\b" "\\bmore\\b" "\\bless\\b" "\\bstrings\\b" "\\bxxd\\b" "\\bhexdump\\b" "\\bod\\b"
        "\\bgrep\\b" "\\begrep\\b" "\\bfgrep\\b" "\\brgrep\\b" "\\bzgrep\\b" "\\bpgrep\\b"
        "\\bfile\\b" "\\bstat\\b" "\\breadlink\\b" "\\brealpath\\b" "\\bbasename\\b" "\\bdirname\\b"
        
        # Process & System Monitoring
        "\\bps\\b" "\\btop\\b" "\\bhtop\\b" "\\batop\\b" "\\bbtop\\b" "\\bglances\\b" "\\bnmon\\b"
        "\\blsof\\b" "\\bfuser\\b" "\\bstrace\\b" "\\bltrace\\b" "\\bptrace\\b" "\\bdtrace\\b" "\\bperf\\b"
        "\\bdmesg\\b" "\\blast\\b" "\\blastlog\\b" "\\blastb\\b" "\\bwho\\b" "\\bw\\b" "\\busers\\b" "\\bfinger\\b" "\\bpinky\\b"
        "\\buptime\\b" "\\bvmstat\\b" "\\biostat\\b" "\\bmpstat\\b" "\\bsar\\b" "\\bfree\\b" "\\bdf\\b" "\\bdu\\b"
        
        # Network Reconnaissance & Tools
        "\\bnetstat\\b" "\\bss\\b" "\\barp\\b" "\\barping\\b" "\\broute\\b" "\\bip[[:space:]]" "\\bifconfig\\b" "\\biwconfig\\b" "\\biwlist\\b"
        "\\bping\\b" "\\bping6\\b" "\\btraceroute\\b" "\\btracepath\\b" "\\bmtr\\b" "\\btcptraceroute\\b"
        "\\bnmap\\b" "\\bmasscan\\b" "\\bzmap\\b" "\\bunicornscan\\b" "\\bhping\\b" "\\bhping3\\b" "\\barpscan\\b" "arp-scan"
        "\\bdig\\b" "\\bnslookup\\b" "\\bhost\\b" "\\bwhois\\b" "\\bdnsrecon\\b" "\\bdnsenum\\b"
        "\\btcpdump\\b" "\\btshark\\b" "\\bwireshark\\b" "\\bettercap\\b" "\\bbettercap\\b" "\\bdsniff\\b" "\\barpspoof\\b"
        "\\biptables\\b" "\\bip6tables\\b" "\\bnftables\\b" "\\bnft\\b" "firewall-cmd" "\\bufw\\b" "\\bpfctl\\b"
        "\\bethtool\\b" "mii-tool" "\\bnmcli\\b" "\\bnetworkctl\\b" "\\bbrctl\\b" "\\btunctl\\b" "\\bvconfig\\b"
        
        # Reverse Shell & Backdoor Patterns
        "/dev/tcp/" "/dev/udp/" "\\bmkfifo\\b" "\\bmknod\\b"
        "\\bopenssl[[:space:]]+s_client" "\\bcryptcat\\b" "\\bsbd\\b"
        "\\bxterm[[:space:]]+-display" "DISPLAY="
        
        # Encoding & Obfuscation
        "\\bbase64\\b" "\\bbase32\\b" "\\bbase58\\b" "\\bbasenc\\b" "\\buuencode\\b" "\\buudecode\\b"
        "\\bxxd\\b" "\\brev\\b" "\\btr[[:space:]]" "\\bprintf\\b" "\\becho[[:space:]]+-e"
        "\\bgzip\\b" "\\bgunzip\\b" "\\bbzip2\\b" "\\bbunzip2\\b" "\\bxz\\b" "\\bunxz\\b" "\\blzma\\b" "\\bunlzma\\b"
        "\\bzip\\b" "\\bunzip\\b" "\\btar\\b" "\\bcpio\\b" "\\bar\\b" "\\b7z\\b" "\\b7za\\b" "\\brar\\b" "\\bunrar\\b"
        
        # Privilege Escalation & Exploitation
        "\\bcapsh\\b" "\\bsetpriv\\b" "\\bchroot\\b" "\\bpivot_root\\b" "\\bunshare\\b" "\\bnsenter\\b"
        "\\bld\\.so\\b" "\\bldconfig\\b" "\\bldd\\b" "/lib/ld" "/lib64/ld"
        "/etc/passwd" "/etc/shadow" "/etc/sudoers" "\\bvisudo\\b"
        "\\bSUID\\b" "\\bSGID\\b" "\\bcapabilities\\b"
        
        # Kernel & Module Manipulation
        "\\binsmod\\b" "\\brmmod\\b" "\\bmodprobe\\b" "\\blsmod\\b" "\\bmodinfo\\b" "\\bdepmod\\b"
        "\\bsysctl\\b" "/proc/" "/sys/" "/dev/"
        "\\bkexec\\b" "\\breboot\\b" "\\bshutdown\\b" "\\bhalt\\b" "\\bpoweroff\\b" "\\binit[[:space:]]+[0-6]"
        
        # Container & Virtualization Escape
        "\\bdocker\\b" "\\bpodman\\b" "\\bkubectl\\b" "\\bcrictl\\b" "\\brunc\\b" "\\bcontainerd\\b"
        "\\blxc\\b" "\\blxd\\b" "\\bvirsh\\b" "\\bqemu\\b" "\\bkvm\\b" "\\bvirt-" "\\blibvirt\\b"
        "\\bnsenter\\b" "\\bunshare\\b" "\\bsetns\\b"
        
        # Compilers & Binary Tools
        "\\bgcc\\b" "\\bg\\+\\+\\b" "\\bcc\\b" "\\bclang\\b" "\\bmake\\b" "\\bcmake\\b" "\\bas\\b" "\\bld\\b" "\\bstrip\\b"
        "\\bobjdump\\b" "\\breadelf\\b" "\\bnm\\b" "\\bobjcopy\\b" "\\bgdb\\b" "\\blldb\\b" "\\bradare2\\b" "\\br2\\b"
        
        # Credential & Secret Access
        "\\.bash_history" "\\.ssh/" "id_rsa" "id_dsa" "id_ecdsa" "id_ed25519"
        "authorized_keys" "known_hosts" "\\.netrc" "\\.pgpass"
        "\\baws[[:space:]]" "\\bgcloud\\b" "\\baz[[:space:]]" "\\bkubectl\\b" "\\bvault\\b"
        "/etc/krb5" "\\bkinit\\b" "\\bklist\\b" "\\bkdestroy\\b"
        
        # Misc Dangerous Operations
        "\\beval\\b" "\\bexec\\b" "\\bsource\\b" "\\.[[:space:]]+" "\\bxargs\\b" "\\bparallel\\b"
        "\\benv\\b" "\\bprintenv\\b" "\\bexport\\b" "\\bset[[:space:]]" "\\bunset\\b"
        "\\balias\\b" "\\bunalias\\b" "\\bbuiltin\\b" "\\bcommand\\b" "\\benable\\b"
        "\\btimeout\\b" "\\btime\\b" "\\bwatch\\b" "\\byes\\b" "\\bseq\\b"
        "\\btee\\b" "\\bscript\\b" "\\bscriptreplay\\b" "\\bcol\\b" "\\bcolrm\\b"
        "\\bwall\\b" "\\bwrite\\b" "\\bmesg\\b" "\\btalk\\b" "\\bytalk\\b"
    )

    for cmd in "${unix_commands[@]}"; do
        if echo "$content" | safe_grep_qiE "$cmd"; then
            log_threat 45 "Unix/Linux/macOS command detected: $cmd"
        fi
    done

    # Cloud/SaaS/automation/exfil commands
    local cloud_commands=(
        "aws " "gcloud " "azcopy" "gsutil" "azure" "dropbox" "gdrive" "slack " "discord " "teams " "office365"
        "docker " "kubectl" "helm"
    )
    for cmd in "${cloud_commands[@]}"; do
        if echo "$content" | safe_grep_qiE "$cmd"; then
            log_threat 43 "Cloud/SaaS/automation/exfil command detected: $cmd"
        fi
    done

    # Mobile/Android/ADB/iOS automation/impact/supply chain/rogue ops
    local mobile_commands=(
        "adb shell" "pm install" "am start" "am broadcast" "am force-stop" "intent://" "market://" "dumpsys" "getprop" "content://" "settings get" "ios-deploy" "provisioning"
    )
    for cmd in "${mobile_commands[@]}"; do
        if echo "$content" | safe_grep_qiE "$cmd"; then
            log_threat 41 "Mobile/Android/iOS automation/supply chain command detected: $cmd"
        fi
    done

    # IoT/OT/ICS/SCADA/industrial/automation commands
    local iot_commands=(
        "modbus" "mqtt" "plc" "rtu" "scada" "industrial" "mosquitto_pub" "mosquitto_sub" "iot"
    )
    for cmd in "${iot_commands[@]}"; do
        if echo "$content" | safe_grep_qiE "$cmd"; then
            log_threat 39 "IoT/OT/ICS/SCADA command/automation detected: $cmd"
        fi
    done

    # Stego/image hybrid/packer/offsec/supply chain commands
    local stego_commands=(
        "stego" "lsb" "exiftool" "pngcheck" "convert" "imagemagick" "ffmpeg" "jpegoptim" "zip" "tar" "gzip" "binascii" "b64" "xxd"
    )
    for cmd in "${stego_commands[@]}"; do
        if echo "$content" | safe_grep_qiE "$cmd"; then
            log_threat 35 "Stego/image/packing/supply chain command detected: $cmd"
        fi
    done

    # Ransomware/wiper/data destroy/impact
    local impact_commands=(
        "ransom" "encrypt" "decrypt" "wipe" "shred" "destroy" "mkfs" "format" "diskutil" "cryptsetup" "bitcoin" "monero" "wallet"
    )
    for cmd in "${impact_commands[@]}"; do
        if echo "$content" | safe_grep_qiE "$cmd"; then
            log_threat 80 "Ransomware/wiper/impact/crypto command detected: $cmd"
        fi
    done

    # Forensic evidence chain log
    log_forensic "Command content check complete (${#content} bytes analyzed)"
}

analyze_secrets() {
    set +u
    local content="${1:-}"
    set -u
    
    log_info "  Checking for exposed secrets..."
    
    # Check against API key patterns
    for key_type in "${!API_KEY_PATTERNS[@]}"; do
        local pattern="${API_KEY_PATTERNS[$key_type]}"
        if echo "$content" | safe_grep_qE "$pattern"; then
            log_threat 60 "Potential $key_type exposed!"
            
            # Record IOC
            local matched=$(echo "$content" | safe_grep_oE "$pattern" | head -1)
            record_ioc "api_key" "$key_type:${matched:0:20}..." "Secret exposure"
        fi
    done
    
    # Check for credential patterns
    for pattern in "${CREDENTIAL_PATTERNS[@]}"; do
        if echo "$content" | safe_grep_qiE "$pattern"; then
            log_threat 50 "Credential pattern detected: $pattern"
        fi
    done
    
    # Private keys
    if echo "$content" | safe_grep_qE "-----BEGIN.*(PRIVATE|RSA|EC|DSA|OPENSSH).*-----"; then
        log_threat 80 "Private key detected!"
    fi
    
    # Connection strings
    if echo "$content" | safe_grep_qiE "password=|pwd=|passwd=|secret="; then
        log_threat 55 "Connection string with credentials detected"
    fi

    # OAuth tokens, session keys, JWT, SSO, cookie secrets
    if echo "$content" | safe_grep_qiE "eyJ[a-zA-Z0-9_-]{10,}\.[a-zA-Z0-9_-]{10,}\.[a-zA-Z0-9_-]{10,}|oauth_token|access_token|refresh_token|sessionid|xsrf-token|csrftoken|sso_token"; then
        log_threat 65 "Session/JWT/OAuth/SSO token exposed"
    fi

    # Cloud/SaaS/DevOps secrets (AWS, Azure, GCP, Google, Dropbox, etc)
    if echo "$content" | safe_grep_qiE "AKIA[0-9A-Z]{16}|ASIA[0-9A-Z]{16}|A3T[A-Z0-9]{13}|AIza[0-9A-Za-z-_]{35}|ya29\.[0-9A-Za-z-_]+|firebaseio|S3_BUCKET|gcp_token|AZURE_KEY|storageAccountKey|google_secret|dropbox_token|gdrive_token"; then
        log_threat 75 "Cloud/SaaS/DevOps secret detected"
    fi

    # Mobile/QR app secrets & provisioning keys
    if echo "$content" | safe_grep_qiE "api_key.*android|client_secret.*mobile|provisioning_profile|mobiletoken|push_key|firebase_secret|app_secret|intent://|market://"; then
        log_threat 55 "Mobile/QR app secret/provisioning key detected"
    fi

    # Payment, credit card, SCA, FIDO, bank data
    if echo "$content" | safe_grep_qE "[0-9]{12,19}|CVC|CVV|expiry|expiration|bank_account|routing_no|iban|swift|fido_key|secure_2fa|authy"; then
        log_threat 78 "Payment/card/bank/SCA/FIDO secret detected"
    fi

    # Social media & messaging secrets/tokens
    if echo "$content" | safe_grep_qiE "discord_token|telegram_token|slack_token|teams_token|facebook_access_token|twitter_api_secret|twilio_account_sid|twilio_auth_token"; then
        log_threat 62 "Social/messaging secret/token detected"
    fi

    # Business, enterprise, private/config/secrets
    if echo "$content" | safe_grep_qiE "client_secret|company_secret|internal_secret|admin_password|root_password|backup_key|business_key|enterprise_key|db_root_password|dba_secret"; then
        log_threat 59 "Business/enterprise secret detected"
    fi

    # IoT/SCADA/config secrets
    if echo "$content" | safe_grep_qiE "plc_key|iot_token|mqtt_password|scada_secret|sensor_key|device_key|industrial_secret"; then
        log_threat 50 "IoT/OT/SCADA secret/config detected"
    fi

    # Misc encoded secrets, compress, packer, stego
    if echo "$content" | safe_grep_qiE "base64[[:space:]]+\w{40,}|stego|encode|decode"; then
        log_threat 45 "Encoded or steganographic secret detected"
    fi

    # Forensics/evidence log
    log_forensic "Secrets check complete (${#content} bytes analyzed)"
}

analyze_crypto_addresses() {
    set +u
    local content="${1:-}"
    set -u
    
    log_info "  Checking for cryptocurrency addresses..."
    
    local crypto_found=false
    
    for pattern in "${CRYPTO_PATTERNS[@]}"; do
        local matches=$(echo "$content" | safe_grep_oE "$pattern")
        if [ -n "$matches" ]; then
            crypto_found=true
            for addr in $matches; do
                log_warning "Cryptocurrency address found: $addr"
                record_ioc "crypto_address" "$addr" "Cryptocurrency address"
                
                # Determine type (expanded for L2 chains)
                case "$addr" in
                    bc1*) log_info "    Type: Bitcoin Bech32" ;;
                    bc1p*) log_info "    Type: Bitcoin Taproot" ;;
                    1*|3*) log_info "    Type: Bitcoin Legacy/SegWit" ;;
                    0x0[a-fA-F0-9]{63}) log_info "    Type: StarkNet" ;;
                    0x[a-fA-F0-9]{64}) log_info "    Type: Aptos/Sui" ;;
                    0x*) log_info "    Type: Ethereum/EVM (ETH/BSC/Polygon/Arbitrum/Optimism/Base/zkSync)" ;;
                    4*) log_info "    Type: Monero" ;;
                    L*|M*|ltc1*) log_info "    Type: Litecoin" ;;
                    D*) log_info "    Type: Dogecoin" ;;
                    r*) log_info "    Type: Ripple/XRP" ;;
                    addr1*) log_info "    Type: Cardano Shelley" ;;
                    DdzFF*) log_info "    Type: Cardano Byron" ;;
                    T*) log_info "    Type: Tron" ;;
                    cosmos1*) log_info "    Type: Cosmos" ;;
                    osmo1*) log_info "    Type: Osmosis" ;;
                    secret1*) log_info "    Type: Secret Network" ;;
                    inj1*) log_info "    Type: Injective" ;;
                    kava1*) log_info "    Type: Kava" ;;
                    cro1*) log_info "    Type: Cronos" ;;
                    tz[1-3]*) log_info "    Type: Tezos" ;;
                    erd1*) log_info "    Type: MultiversX/Elrond" ;;
                    EQ*|UQ*) log_info "    Type: TON (Telegram)" ;;
                    *.near) log_info "    Type: NEAR Protocol" ;;
                    X-avax*|P-avax*|C-avax*|avax1*) log_info "    Type: Avalanche" ;;
                    iota1*) log_info "    Type: IOTA" ;;
                    f0*|f1*|f2*|f3*) log_info "    Type: Filecoin" ;;
                    G*) log_info "    Type: Stellar" ;;
                esac
            done
        fi
    done
    
    if [ "$crypto_found" = true ]; then
        log_threat 40 "Cryptocurrency addresses detected - possible scam/ransom"
    fi

    # Added detection: Layer 2, bridges, and new chains
    local extra_patterns=(
        "xmr[a-zA-Z0-9]{93}"                    # Monero (alternate pattern)
        "[13][a-km-zA-HJ-NP-Z0-9]{25,34}"       # Bitcoin (legacy/alt)
        "[a-zA-Z0-9]{42}"                       # ETH/ERC20/BNB/Defi
        "nano_[a-zA-Z0-9]{60}"                  # Nano
        "bch[a-zA-Z0-9]{42,}"                   # Bitcoin Cash
        "qc[a-zA-Z0-9]+"                        # Qtum
        "[0-9A-Fa-f]{40,}"                      # General hexadecimal wallet
        "0:[a-fA-F0-9]{64}"                     # TON raw format
        "ton://transfer/[a-zA-Z0-9_-]+"         # TON deeplink
        "zksync:[a-zA-Z0-9]+"                   # zkSync payment link
        "[a-z0-9_-]{2,64}\.near"                # NEAR named accounts
    )

    for pattern in "${extra_patterns[@]}"; do
        local matches=$(echo "$content" | safe_grep_oE "$pattern")
        if [ -n "$matches" ]; then
            for addr in $matches; do
                log_warning "Additional cryptocurrency address found: $addr"
                record_ioc "crypto_address" "$addr" "Crypto/DeFi/L2 address"
            done
            crypto_found=true
        fi
    done

    # DEX, mixing, scam/pay/QR payment processors
    if echo "$content" | safe_grep_qiE "shapeshift|mixer\.io|tornado\.cash|wasabi\.wallet|samourai\.wallet|binance\.com|coinbase\.com|kraken\.com|trustwallet|metamask|blockchain\.info"; then
        log_threat 45 "Crypto exchange/DEX/mixing/payment processor address/payment detected"
    fi
    
    # L2 Bridge and DEX detection
    if echo "$content" | safe_grep_qiE "bridge\.arbitrum|app\.optimism|bridge\.zksync|starkgate|bridge\.base|hop\.exchange|across\.to|stargate\.finance"; then
        log_threat 40 "Layer 2 bridge interaction detected"
    fi
    
    # TON/Telegram wallet detection
    if echo "$content" | safe_grep_qiE "tonkeeper|tonhub|ton\.org/wallets|fragment\.com|getgems\.io|ton\.place"; then
        log_threat 38 "TON ecosystem wallet/service detected"
    fi

    # Possible QR/mobile payment or scam context
    if echo "$content" | safe_grep_qiE "qr code.*bitcoin|qr code.*eth|scan.*wallet|address=.*btc|address=.*eth|mobile.*crypto.*wallet"; then
        log_threat 47 "QR/mobile/crypto wallet/payment pattern detected"
    fi

    # DeFi/NFT/contract abuse/wallet drainers - Extended
    if echo "$content" | safe_grep_qiE "contractAddress|erc721|erc1155|tokenID|mintNFT|signTransaction|walletConnect|drainer|setApprovalForAll|increaseAllowance|permit2|seaport"; then
        log_threat 50 "DeFi/NFT/contract/wallet drainer pattern detected"
    fi
    
    # Check against EXTENDED_CRYPTO_IOCS
    for key in "${!EXTENDED_CRYPTO_IOCS[@]}"; do
        local pattern="${EXTENDED_CRYPTO_IOCS[$key]}"
        if echo "$content" | safe_grep_qiE "$pattern"; then
            log_threat 45 "Extended crypto threat: $key"
            record_ioc "crypto_threat" "$key" "Extended crypto IOC match"
        fi
    done

    # IoT/SCADA/industrial theft via crypto
    if echo "$content" | safe_grep_qiE "iot.*wallet|plc.*wallet|industrial.*key.*eth|modbus.*token"; then
        log_threat 41 "IoT/SCADA/industrial crypto address detected"
    fi

    # Forensics/evidence chain log
    log_forensic "Crypto address check complete (${#content} bytes analyzed)"
}

analyze_phone_numbers() {
    set +u
    local content="${1:-}"
    set -u
    
    # International phone patterns
    local phone_patterns=(
        "\+[0-9]{1,3}[-.[:space:]]?[0-9]{3,4}[-.[:space:]]?[0-9]{3,4}[-.[:space:]]?[0-9]{3,4}"
        "[0-9]{3}[-.[:space:]]?[0-9]{3}[-.[:space:]]?[0-9]{4}"
        "\([0-9]{3}\)[-.[:space:]]?[0-9]{3}[-.[:space:]]?[0-9]{4}"
        "1-[0-9]{3}-[0-9]{3}-[0-9]{4}"
        "1-800-[0-9]{3}-[0-9]{4}"
        "1-888-[0-9]{3}-[0-9]{4}"
        "1-877-[0-9]{3}-[0-9]{4}"
        "1-866-[0-9]{3}-[0-9]{4}"
    )
    
    for pattern in "${phone_patterns[@]}"; do
        local matches=$(echo "$content" | safe_grep_oE "$pattern")
        if [ -n "$matches" ]; then
            for phone in $matches; do
                log_info "Phone number found: $phone"
                record_ioc "phone" "$phone" "Phone number in QR"
                
                # Toll-free numbers are often used in tech support scams
                if echo "$phone" | grep -qE "1-8(00|88|77|66)"; then
                    log_threat 30 "Toll-free number detected - possible tech support scam"
                fi
            done
        fi
    done
}

analyze_email_addresses() {
    set +u
    local content="${1:-}"
    set -u
    
    local email_pattern="[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}"
    local emails=$(echo "$content" | safe_grep_oE "$email_pattern")
    
    if [ -n "$emails" ]; then
        for email in $emails; do
            log_info "Email address found: $email"
            record_ioc "email" "$email" "Email in QR"
            
            # Check for suspicious domains
            local domain=$(echo "$email" | cut -d'@' -f2)
            
            # Temporary email services
            local temp_domains="tempmail|guerrillamail|mailinator|10minutemail|throwaway|yopmail|fake|temp"
            if echo "$domain" | grep -qiE "$temp_domains"; then
                log_threat 35 "Temporary/disposable email service detected: $domain"
            fi
            
            # Suspicious TLDs
            for tld in "${SUSPICIOUS_TLDS[@]}"; do
                if echo "$domain" | grep -qE "$tld\$"; then
                    log_threat 25 "Email uses suspicious TLD: $tld"
                fi
            done
        done
    fi

    # Look for mass phishing targets or dropboxes
    local phishing_indicators="submit.*@|report.*@|phish.*@|spam.*@|target.*@|victim.*@|compromis|breach|accountrecov|resetpwd|leak.*@"
    if echo "$content" | safe_grep_qiE "$phishing_indicators"; then
        log_threat 53 "Potential phishing/malware dropbox email pattern detected"
    fi

    # Mobile/QR/email abuse
    if echo "$content" | safe_grep_qiE "mailto:|intent://email|android\.intent\.action\.SENDTO|email\.send|smsManager|twilio"; then
        log_threat 41 "Mobile/QR/email abuse or fraud automation detected"
    fi

    # C2/ransom/extortion email dropboxes
    if echo "$content" | safe_grep_qiE "ransom|bitcoin|crypt|pay|decrypt|restore|contact.*@|extort|malwarehelp@|helpdecrypt@"; then
        log_threat 51 "Ransomware/extortion email contact detected"
    fi

    # PII, business email compromise, sensitive data leaks
    if echo "$content" | safe_grep_qiE "ssn|passport|taxid|personaldata|addressbook|pii|payroll|wire|bank|account|hr@|admin@|root@"; then
        log_threat 57 "Possible PII/BEC/sensitive email leak detected"
    fi

    # API/mail gateway abuse
    if echo "$content" | safe_grep_qiE "sendgrid|mailgun|smtp2go|amazonses|mandrill|zoho|office365|outlook|gmail"; then
        log_threat 35 "API/mail gateway detected in email context"
    fi

    # Social media platform/IM/email bridge
    if echo "$content" | safe_grep_qiE "facebook\.com|twitter\.com|discord\.com|telegram\.me|t\.me|signal\.org"; then
        log_threat 33 "IM/social platform or email bridge detected"
    fi

    # Forensics/evidence chain log
    log_forensic "Email address check complete (${#content} bytes analyzed)"
}

evaluate_all_yara_rules() {
    local content="$1"
    
    log_info "  Evaluating YARA-like rules..."
    
    for rule_name in "${!YARA_RULES[@]}"; do
        local matched_patterns=""
        matched_patterns=$(evaluate_yara_rule "$content" "$rule_name")
        
        if [ -n "$matched_patterns" ]; then
            # Extract severity from rule
            local severity=$(echo "${YARA_RULES[$rule_name]}" | grep -oE "severity:[[:space:]]*\w+" | cut -d: -f2 | tr -d ' ')
            
            # Build detailed log message showing what patterns matched
            local detail_msg="YARA rule '$rule_name' matched - Patterns found: $matched_patterns"
            
            case "$severity" in
                "CRITICAL")
                    log_forensic_detection 80 \
                        "YARA Rule Match: $rule_name (CRITICAL)" \
                        "$matched_patterns" \
                        "YARA-like pattern: $rule_name - matched strings in content" \
                        "QR decoded content" \
                        "CRITICAL - Immediate investigation required" \
                        "Custom YARA rule detection"
                    ;;
                "HIGH")
                    log_forensic_detection 60 \
                        "YARA Rule Match: $rule_name (HIGH)" \
                        "$matched_patterns" \
                        "YARA-like pattern: $rule_name - matched strings in content" \
                        "QR decoded content" \
                        "HIGH priority review required" \
                        "Custom YARA rule detection"
                    ;;
                "MEDIUM")
                    log_forensic_detection 40 \
                        "YARA Rule Match: $rule_name (MEDIUM)" \
                        "$matched_patterns" \
                        "YARA-like pattern: $rule_name - matched strings in content" \
                        "QR decoded content" \
                        "Review and assess risk" \
                        "Custom YARA rule detection"
                    ;;
                "LOW")
                    log_forensic_detection 20 \
                        "YARA Rule Match: $rule_name (LOW)" \
                        "$matched_patterns" \
                        "YARA-like pattern: $rule_name - matched strings in content" \
                        "QR decoded content" \
                        "Monitor and log" \
                        "Custom YARA rule detection"
                    ;;
                *)
                    log_forensic_detection 30 \
                        "YARA Rule Match: $rule_name" \
                        "$matched_patterns" \
                        "YARA-like pattern: $rule_name - matched strings in content" \
                        "QR decoded content" \
                        "Review and investigate" \
                        "Custom YARA rule detection"
                    ;;
            esac
            
            echo "$rule_name,$(date -Iseconds),$matched_patterns" >> "$YARA_MATCHES"
        fi
    done

    # Behavioral and cross-platform rule sources
    local extra_yara_sources=(
        "$YARA_BEHAVIORAL_RULES"
        "$YARA_MOBILE_RULES"
        "$YARA_CLOUD_RULES"
        "$YARA_SUPPLYCHAIN_RULES"
        "$YARA_IMPACT_RULES"
        "$YARA_STEGO_RULES"
        "$YARA_IOT_RULES"
        "$YARA_IAM_RULES"
    )
    for src in "${extra_yara_sources[@]}"; do
        if [ -f "$src" ]; then
            while read -r rule; do
                local rule_name=$(echo "$rule" | cut -d':' -f1)
                local rule_pattern=$(echo "$rule" | cut -d':' -f2-)
                if echo "$content" | safe_grep_qE "$rule_pattern"; then
                    log_forensic_detection 60 \
                        "External YARA-like Rule Match: $rule_name" \
                        "$rule_pattern" \
                        "External rule: $rule_name ($src) matched" \
                        "QR decoded content" \
                        "EXTENDED THREAT - review for cross-environment linkage" \
                        "External YARA rule detection"
                    echo "$rule_name,$(date -Iseconds),$rule_pattern" >> "$YARA_MATCHES"
                fi
            done < "$src"
        fi
    done

    # Dynamic rule update (if enabled)
    if [ "$YARA_AUTOUPDATE" = "true" ] && command -v update_yara_rules >/dev/null; then
        update_yara_rules
        log_info "YARA rules auto-updated from remote sources"
    fi

    # Attribution/evidence chain tagging
    log_forensic "YARA rule evaluation complete (${#content} bytes analyzed)"
}

evaluate_yara_rule() {
    local content="$1"
    local rule_name="$2"
    local matched_patterns=""

    case "$rule_name" in
        "phishing_url")
            local login_match urgent_match
            login_match=$(echo "$content" | safe_grep_oiE "login|signin|verify" | head -1)
            urgent_match=$(echo "$content" | safe_grep_oiE "urgent|suspended|action|required" | head -1)
            if [ -n "$login_match" ] && [ -n "$urgent_match" ]; then
                matched_patterns="login_keyword:$login_match, urgency_keyword:$urgent_match"
            fi
            ;;
        "malware_distribution")
            local ext_match action_match
            ext_match=$(echo "$content" | safe_grep_oiE "\.(exe|dll|scr|bat|cmd|ps1|vbs|js|jar|apk|msi|dmg|pkg)" | head -1)
            action_match=$(echo "$content" | safe_grep_oiE "download|install|update|patch|setup" | head -1)
            if [ -n "$ext_match" ] && [ -n "$action_match" ]; then
                matched_patterns="executable_extension:$ext_match, action:$action_match"
            fi
            ;;
        "crypto_scam")
            local crypto_match scam_match
            crypto_match=$(echo "$content" | safe_grep_oE "bc1[a-z0-9]{39,59}|1[a-km-zA-HJ-NP-Z1-9]{25,34}|0x[a-fA-F0-9]{40}" | head -1)
            scam_match=$(echo "$content" | safe_grep_oiE "limited|exclusive|invest|double|giveaway|airdrop" | head -1)
            if [ -n "$crypto_match" ] && [ -n "$scam_match" ]; then
                matched_patterns="crypto_address:${crypto_match:0:20}..., scam_keyword:$scam_match"
            fi
            ;;
        "powershell_malware")
            local ps_match
            ps_match=$(echo "$content" | safe_grep_oiE "IEX|Invoke-Expression|downloadstring|Net\.WebClient|Invoke-WebRequest|\-enc|\-encodedcommand" | head -3 | tr '\n' ',' | sed 's/,$//')
            if [ -n "$ps_match" ]; then
                matched_patterns="powershell_indicators:$ps_match"
            fi
            ;;
        "ransomware")
            local matches=""
            echo "$content" | safe_grep_qiE "decrypt" && matches="${matches}decrypt,"
            echo "$content" | safe_grep_qiE "encrypted|encrypt" && matches="${matches}encrypt,"
            echo "$content" | safe_grep_qiE "ransom" && matches="${matches}ransom,"
            echo "$content" | safe_grep_qiE "bitcoin|monero" && matches="${matches}crypto_payment,"
            echo "$content" | safe_grep_qiE "\.onion" && matches="${matches}tor_address,"
            local match_count=$(echo "$matches" | tr ',' '\n' | grep -c .)
            [ "$match_count" -ge 2 ] && matched_patterns="ransomware_indicators:${matches%,}"
            ;;
        "c2_communication")
            local c2_match
            c2_match=$(echo "$content" | safe_grep_oiE "beacon|checkin|callback|pastebin\.com/raw|raw\.githubusercontent" | head -1)
            [ -z "$c2_match" ] && c2_match=$(echo "$content" | safe_grep_oE "http://[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+" | head -1)
            [ -n "$c2_match" ] && matched_patterns="c2_indicator:$c2_match"
            ;;
        "data_exfil")
            local exfil_match
            # AUDIT FIX: Replace greedy .* with more controlled [[:space:]]+ to prevent catastrophic backtracking
            exfil_match=$(echo "$content" | safe_grep_oiE "POST[[:space:]](password|credential)|upload[[:space:]](zip|rar|7z)|(base64|encode)[[:space:]]http" | head -1)
            [ -n "$exfil_match" ] && matched_patterns="exfiltration_pattern:${exfil_match:0:50}"
            ;;
        "obfuscation")
            local obf_match
            obf_match=$(echo "$content" | safe_grep_oiE "eval\(atob\(|String\.fromCharCode|unescape\(%|Function\(" | head -1)
            [ -n "$obf_match" ] && matched_patterns="obfuscation_technique:$obf_match"
            ;;
        "keylogger")
            local kl_match
            kl_match=$(echo "$content" | safe_grep_oiE "keylog|keystroke|GetAsyncKeyState|SetWindowsHookEx|pynput|keyboard\.hook" | head -1)
            [ -n "$kl_match" ] && matched_patterns="keylogger_indicator:$kl_match"
            ;;
        "remote_access")
            local rat_match
            rat_match=$(echo "$content" | safe_grep_oiE "njrat|darkcomet|remcos|asyncrat|quasar|reverse.shell|bind.shell" | head -1)
            [ -n "$rat_match" ] && matched_patterns="rat_indicator:$rat_match"
            ;;
        "credential_theft")
            local cred_match
            cred_match=$(echo "$content" | safe_grep_oiE "mimikatz|lsass|SAM|sekurlsa|credential.dump" | head -1)
            # AUDIT FIX: Replace greedy .* with [[:space:]] to prevent catastrophic backtracking
            [ -z "$cred_match" ] && cred_match=$(echo "$content" | safe_grep_oiE "browser[[:space:]](password|cookie)|(password|cookie)[[:space:]]browser" | head -1)
            [ -n "$cred_match" ] && matched_patterns="credential_theft_indicator:${cred_match:0:30}"
            ;;
        "banking_trojan")
            local bt_match
            bt_match=$(echo "$content" | safe_grep_oiE "webinject|formgrabber|zeus|dridex|trickbot|emotet" | head -1)
            [ -n "$bt_match" ] && matched_patterns="banking_trojan:$bt_match"
            ;;

        # Apex: Add ALL other evaluate_yara_rule behaviors, but with detailed extraction!
        "mobile_malware")
            local mob_match
            # AUDIT FIX: Replace greedy .* with [[:space:]] to prevent catastrophic backtracking
            mob_match=$(echo "$content" | safe_grep_oiE "READ_SMS[[:space:]]SEND_SMS|SEND_SMS[[:space:]]READ_SMS|android\.permission\.CALL_PHONE|\.apk[[:space:]](payload|dropper)" | head -1)
            [ -n "$mob_match" ] && matched_patterns="mobile_malware_indicator:${mob_match:0:40}"
            ;;
        "iot_malware")
            local iot_match
            # AUDIT FIX: Replace greedy .* with [[:space:]] to prevent catastrophic backtracking
            iot_match=$(echo "$content" | safe_grep_oiE "mirai|bashlite|gafgyt|/dev/watchdog|telnet[[:space:]]default[[:space:]]password" | head -2 | tr '\n' ',' | sed 's/,$//')
            [ -n "$iot_match" ] && matched_patterns="iot_malware_indicator:$iot_match"
            ;;
        "cryptominer")
            local cm_match
            # AUDIT FIX: Replace greedy .* with [[:space:]] to prevent catastrophic backtracking
            cm_match=$(echo "$content" | safe_grep_oiE "stratum\+tcp://|xmrig|cpuminer|minergate|\.nanopool\.|monero[[:space:]]wallet" | head -2 | tr '\n' ',' | sed 's/,$//')
            [ -n "$cm_match" ] && matched_patterns="crypto_miner_indicator:$cm_match"
            ;;
        "exploit_kit")
            local ek_match
            ek_match=$(echo "$content" | safe_grep_oiE "FlashVars|deployJava|application/pdf|<iframe[[:space:]]src=[[:space:]]http|eval\(function\(p,a,c,k,e|\\\\x[0-9a-f]{2}" | head -3 | tr '\n' ',' | sed 's/,$//')
            [ -n "$ek_match" ] && matched_patterns="exploit_kit_indicator:$ek_match"
            ;;
        "phishing_kit")
            local pk_match
            pk_match=$(echo "$content" | safe_grep_oiE "<form.*action=.*\.php|<input[[:space:]]type=.password|(paypal|amazon|google|microsoft|apple|facebook).*\.(png|jpg|svg)" | head -2 | tr '\n' ',' | sed 's/,$//')
            [ -n "$pk_match" ] && matched_patterns="phishing_kit_indicator:$pk_match"
            ;;
        "session_hijack")
            local sh_match
            sh_match=$(echo "$content" | safe_grep_oiE "(session|token|cookie)[[:space:]](steal|capture|intercept)" | head -1)
            [ -n "$sh_match" ] && matched_patterns="session_hijack_indicator:$sh_match"
            ;;
        "webshell")
            local ws_match
            ws_match=$(echo "$content" | safe_grep_oiE "eval[[:space:]]*\([[:space:]]*\$_(GET|POST|REQUEST|COOKIE)|system[[:space:]]*\([[:space:]]*\$_(GET|POST)|c99shell|r57shell|wso.shell|b374k" | head -2 | tr '\n' ',' | sed 's/,$//')
            [ -n "$ws_match" ] && matched_patterns="webshell_indicator:$ws_match"
            ;;
        "sql_injection")
            local sql_match
            sql_match=$(echo "$content" | safe_grep_oiE "UNION[[:space:]]\+SELECT|OR[[:space:]]\+1=1|AND[[:space:]]\+1=1|DROP[[:space:]]+TABLE|SLEEP\(|BENCHMARK\(" | head -2 | tr '\n' ',' | sed 's/,$//')
            [ -n "$sql_match" ] && matched_patterns="sql_injection_indicator:$sql_match"
            ;;
        "xss_attack")
            local xss_match
            xss_match=$(echo "$content" | safe_grep_oiE "<script|onerror[[:space:]]*=|onload[[:space:]]*=|javascript:" | head -2 | tr '\n' ',' | sed 's/,$//')
            [ -n "$xss_match" ] && matched_patterns="xss_attack_indicator:$xss_match"
            ;;
        "privilege_escalation")
            local pe_match
            pe_match=$(echo "$content" | safe_grep_oiE "(sudo|setuid|SUID|runas)[[:space:]](escalate|privilege)|potato|printspoofer|getsystem" | head -2 | tr '\n' ',' | sed 's/,$//')
            [ -n "$pe_match" ] && matched_patterns="privilege_escalation_indicator:$pe_match"
            ;;
        "persistence")
            local pers_match
            pers_match=$(echo "$content" | safe_grep_oiE "HKLM[^\\]+Run|HKCU[^\\]+Run|CurrentVersion\\\\Run|schtasks|crontab|LaunchAgent|systemctl.enable" | head -2 | tr '\n' ',' | sed 's/,$//')
            [ -n "$pers_match" ] && matched_patterns="persistence_indicator:$pers_match"
            ;;
        "defense_evasion")
            local de_match
            de_match=$(echo "$content" | safe_grep_oiE "disable[[:space:]]defender|AMSI[[:space:]]bypass|ETW[[:space:]]bypass|process[[:space:]]hollow|reflective[[:space:]]load" | head -2 | tr '\n' ',' | sed 's/,$//')
            [ -n "$de_match" ] && matched_patterns="defense_evasion_indicator:$de_match"
            ;;
        "lateral_movement")
            local lm_match
            lm_match=$(echo "$content" | safe_grep_oiE "psexec|wmic[[:space:]]process[[:space:]]create|winrm|pass.the.hash" | head -2 | tr '\n' ',' | sed 's/,$//')
            [ -n "$lm_match" ] && matched_patterns="lateral_movement_indicator:$lm_match"
            ;;
        "data_collection")
            local dc_matches=""
            echo "$content" | safe_grep_oiE "screenshot" | grep -q . && dc_matches="${dc_matches}screenshot,"
            echo "$content" | safe_grep_oiE "keylog" | grep -q . && dc_matches="${dc_matches}keylog,"
            echo "$content" | safe_grep_oiE "clipboard" | grep -q . && dc_matches="${dc_matches}clipboard,"
            echo "$content" | safe_grep_oiE "webcam|camera" | grep -q . && dc_matches="${dc_matches}webcam,"
            echo "$content" | safe_grep_oiE "microphone|audio" | grep -q . && dc_matches="${dc_matches}microphone,"
            local dc_count=$(echo "$dc_matches" | tr ',' '\n' | grep -c .)
            [ "$dc_count" -ge 2 ] && matched_patterns="data_collection:${dc_matches%,}"
            ;;

        "qr_malware")
            local qr_match
            qr_match=$(echo "$content" | safe_grep_oiE "qr[[:space:]]code[[:space:]]payload|scan[[:space:]]intent://|market://|provisioning[[:space:]]profile|mobile[[:space:]]dropper|android\.intent\.action|ios.*UniversalLink" | head -2 | tr '\n' ',' | sed 's/,$//')
            [ -n "$qr_match" ] && matched_patterns="qr_mobile_indicator:$qr_match"
            ;;
        "cloud_impact")
            local cloud_match
            cloud_match=$(echo "$content" | safe_grep_oiE "aws_access_key_id|gcp_token|azure[[:space:]]secret|s3://|gs://|cloudtrail|auditlog|iam:DeleteUser|iam:DeleteRole" | head -2 | tr '\n' ',' | sed 's/,$//')
            [ -n "$cloud_match" ] && matched_patterns="cloud_impact_indicator:$cloud_match"
            ;;
        "supplychain_malware")
            local supply_match
            supply_match=$(echo "$content" | safe_grep_oiE "setup\.py|requirements\.txt|signapk|signipa|manifest\.json|npm install|apktool|androguard|build.gradle" | head -2 | tr '\n' ',' | sed 's/,$//')
            [ -n "$supply_match" ] && matched_patterns="supplychain_indicator:$supply_match"
            ;;
        "business_social_compromise")
            local biz_match
            biz_match=$(echo "$content" | safe_grep_oiE "account_manager|dashboard|wire transfer|ceo fraud|payroll|hoax|business_email_compromise|social_engineering" | head -2 | tr '\n' ',' | sed 's/,$//')
            [ -n "$biz_match" ] && matched_patterns="business_social_compromise:$biz_match"
            ;;
        "stego_data_exfil")
            local stego_match
            stego_match=$(echo "$content" | safe_grep_oiE "steganography|hidden[[:space:]]data|lsb|encode[[:space:]]image|decode[[:space:]]image|exiftool|imageIO|ffmpeg" | head -2 | tr '\n' ',' | sed 's/,$//')
            [ -n "$stego_match" ] && matched_patterns="stego_exfil_indicator:$stego_match"
            ;;
        "rat_framework")
            local ratfw_match
            ratfw_match=$(echo "$content" | safe_grep_oiE "quasar|empire|cobaltstrike|meterpreter|reverse-shell|websocket|beacon|command queue|tasking|rat|async" | head -2 | tr '\n' ',' | sed 's/,$//')
            [ -n "$ratfw_match" ] && matched_patterns="rat_framework_indicator:$ratfw_match"
            ;;
        "iot_attack_framework")
            local iotfw_match
            iotfw_match=$(echo "$content" | safe_grep_oiE "mqtt|modbus|plc|iot_token|industrial[[:space:]]key|mosquitto_pub|mosquitto_sub" | head -2 | tr '\n' ',' | sed 's/,$//')
            [ -n "$iotfw_match" ] && matched_patterns="iot_attack_framework_indicator:$iotfw_match"
            ;;
        "impact_destruction")
            local impact_match
            impact_match=$(echo "$content" | safe_grep_oiE "wipe|shred|destroy|diskutil erase|cryptsetup|mkfs|factory reset|android.*delete|ios.*erase" | head -2 | tr '\n' ',' | sed 's/,$//')
            [ -n "$impact_match" ] && matched_patterns="impact_destruction_indicator:$impact_match"
            ;;
        "impersonation_abuse")
            local imp_match
            imp_match=$(echo "$content" | safe_grep_oiE "impersonat(e|ion)|fakesender|spoofed|phish(S|ing)|forged|scan.*passport" | head -2 | tr '\n' ',' | sed 's/,$//')
            [ -n "$imp_match" ] && matched_patterns="impersonation_abuse_indicator:$imp_match"
            ;;
        
        # =========================================================================
        # NEW AUDIT-COMPLIANT YARA RULE EVALUATIONS
        # =========================================================================
        
        "webshell_indicators")
            local ws_match
            ws_match=$(echo "$content" | safe_grep_oiE "\\\$_(GET|POST|REQUEST|COOKIE)|eval\s*\(\s*\\\$|system\s*\(\s*\\\$|passthru|shell_exec|c99shell|r57shell|b374k|WSO|AlfaShell|weevely|antsword|godzilla|behinder" | head -3 | tr '\n' ',' | sed 's/,$//')
            [ -n "$ws_match" ] && matched_patterns="webshell_indicator:$ws_match"
            ;;
        "rootkit_signatures")
            local rk_match
            rk_match=$(echo "$content" | safe_grep_oiE "init_module|sys_call_table|kallsyms|__NR_|hide_process|hide_file|LD_PRELOAD|azazel|jynx2|diamorphine|reptile|beurk" | head -3 | tr '\n' ',' | sed 's/,$//')
            [ -n "$rk_match" ] && matched_patterns="rootkit_indicator:$rk_match"
            ;;
        "bootkit_patterns")
            local bk_match
            bk_match=$(echo "$content" | safe_grep_oiE "MBR|VBR|bootkit|bootsector|bootmgr|winload|UEFI|bootx64|\.efi|TDL4|TDSS|mebromi|rovnix|PhysicalDrive0|/dev/sda" | head -3 | tr '\n' ',' | sed 's/,$//')
            [ -n "$bk_match" ] && matched_patterns="bootkit_indicator:$bk_match"
            ;;
        "firmware_implants")
            local fw_match
            fw_match=$(echo "$content" | safe_grep_oiE "DXE_DRIVER|EFI_BOOT_SERVICES|EFI_RUNTIME|SPI Flash|SMM|firmware|flashrom|LoJax|MosaicRegressor|MoonBounce|CosmicStrand|ESPecter|SecureBoot" | head -3 | tr '\n' ',' | sed 's/,$//')
            [ -n "$fw_match" ] && matched_patterns="firmware_implant_indicator:$fw_match"
            ;;
        "kernel_exploit")
            local ke_match
            ke_match=$(echo "$content" | safe_grep_oiE "/proc/kallsyms|/proc/modules|/dev/mem|/dev/kmem|commit_creds|prepare_kernel_cred|dirty_cow|dirty_pipe|CVE-20|setuid\(0\)|setgid\(0\)|ROP chain|gadget" | head -3 | tr '\n' ',' | sed 's/,$//')
            [ -n "$ke_match" ] && matched_patterns="kernel_exploit_indicator:$ke_match"
            ;;
        "container_escape")
            local ce_match
            ce_match=$(echo "$content" | safe_grep_oiE "/var/run/docker\.sock|docker\.sock|privileged:true|--privileged|CAP_SYS_ADMIN|nsenter|unshare|serviceaccount|/var/run/secrets/kubernetes|kubectl|kubelet|etcd|release_agent|169\.254\.169\.254|/proc/1/root" | head -3 | tr '\n' ',' | sed 's/,$//')
            [ -n "$ce_match" ] && matched_patterns="container_escape_indicator:$ce_match"
            ;;
        "serverless_abuse")
            local sl_match
            sl_match=$(echo "$content" | safe_grep_oiE "AWS_LAMBDA|lambda\.amazonaws|invoke-function|update-function-code|LAMBDA_TASK_ROOT|azure\.functions|AzureWebJobsStorage|cloudfunctions\.net|AWS_ACCESS_KEY|AWS_SECRET_ACCESS|iam:PassRole|sts:AssumeRole" | head -3 | tr '\n' ',' | sed 's/,$//')
            [ -n "$sl_match" ] && matched_patterns="serverless_abuse_indicator:$sl_match"
            ;;
        "ci_cd_poisoning")
            local ci_match
            ci_match=$(echo "$content" | safe_grep_oiE "workflow_dispatch|GITHUB_TOKEN|secrets\.|@master|@main|Jenkinsfile|withCredentials|\.gitlab-ci\.yml|CI_JOB_TOKEN|circleci|CIRCLE_TOKEN|\.travis\.yml|curl.*\|.*sh|wget.*\|.*bash" | head -3 | tr '\n' ',' | sed 's/,$//')
            [ -n "$ci_match" ] && matched_patterns="ci_cd_poisoning_indicator:$ci_match"
            ;;
        "git_hooks_abuse")
            local gh_match
            gh_match=$(echo "$content" | safe_grep_oiE "\.git/hooks|pre-commit|post-commit|pre-push|post-receive|pre-receive|/dev/tcp/|reverse|nc |netcat" | head -3 | tr '\n' ',' | sed 's/,$//')
            [ -n "$gh_match" ] && matched_patterns="git_hooks_abuse_indicator:$gh_match"
            ;;
        "ide_extension_abuse")
            local ide_match
            ide_match=$(echo "$content" | safe_grep_oiE "\.vscode/extensions|vscode:extension|\.idea|intellij|plugin\.xml|child_process|spawn|execSync|keytar|vscode\.workspace" | head -3 | tr '\n' ',' | sed 's/,$//')
            [ -n "$ide_match" ] && matched_patterns="ide_extension_abuse_indicator:$ide_match"
            ;;
        "browser_extension_abuse")
            local be_match
            be_match=$(echo "$content" | safe_grep_oiE "manifest\.json|content_scripts|background|permissions|<all_urls>|webRequest|clipboardRead|keylogger|form grabber|cryptominer|coinhive" | head -3 | tr '\n' ',' | sed 's/,$//')
            [ -n "$be_match" ] && matched_patterns="browser_extension_abuse_indicator:$be_match"
            ;;
        "electron_app_abuse")
            local el_match
            el_match=$(echo "$content" | safe_grep_oiE "electron|nodeIntegration|contextIsolation|webPreferences|BrowserWindow|nodeIntegration: true|contextIsolation: false|webSecurity: false|shell\.openExternal|remote\.require|executeJavaScript" | head -3 | tr '\n' ',' | sed 's/,$//')
            [ -n "$el_match" ] && matched_patterns="electron_app_abuse_indicator:$el_match"
            ;;
        "wasm_malware")
            local wm_match
            wm_match=$(echo "$content" | safe_grep_oiE "WebAssembly|\.wasm|wasm-bindgen|cryptonight|randomx|mining|hashrate|emscripten|assemblyscript" | head -3 | tr '\n' ',' | sed 's/,$//')
            [ -n "$wm_match" ] && matched_patterns="wasm_malware_indicator:$wm_match"
            ;;
        "oauth_abuse")
            local oa_match
            oa_match=$(echo "$content" | safe_grep_oiE "oauth|access_token|refresh_token|authorization_code|client_id|client_secret|redirect_uri|token theft|open redirect|state parameter" | head -3 | tr '\n' ',' | sed 's/,$//')
            [ -n "$oa_match" ] && matched_patterns="oauth_abuse_indicator:$oa_match"
            ;;
        "saml_injection")
            local sm_match
            sm_match=$(echo "$content" | safe_grep_oiE "SAMLResponse|SAMLRequest|Assertion|urn:oasis:names:tc:SAML|saml2|signature wrapping|golden SAML|forged assertion|<!ENTITY|saml-raider" | head -3 | tr '\n' ',' | sed 's/,$//')
            [ -n "$sm_match" ] && matched_patterns="saml_injection_indicator:$sm_match"
            ;;
        "jwt_attacks")
            local jw_match
            jw_match=$(echo "$content" | safe_grep_oiE "eyJ|JWT|Bearer|jsonwebtoken|alg.*none|algorithm confusion|kid injection|jku manipulation|jwk injection|signature bypass|jwt_tool" | head -3 | tr '\n' ',' | sed 's/,$//')
            [ -n "$jw_match" ] && matched_patterns="jwt_attack_indicator:$jw_match"
            ;;
        "ssrf_patterns")
            local sr_match
            sr_match=$(echo "$content" | safe_grep_oiE "169\.254\.169\.254|metadata\.google\.internal|100\.100\.100\.200|/latest/meta-data|/computeMetadata|localhost|127\.0\.0\.1|0\.0\.0\.0|\[::1\]|file://|gopher://|dict://|SSRF|server-side request" | head -3 | tr '\n' ',' | sed 's/,$//')
            [ -n "$sr_match" ] && matched_patterns="ssrf_indicator:$sr_match"
            ;;
        "ssti_patterns")
            local st_match
            st_match=$(echo "$content" | safe_grep_oiE "\{\{|__class__|__mro__|__subclasses__|__globals__|__builtins__|<#|th:|#set|#foreach|os\.popen|subprocess|SSTI|template injection" | head -3 | tr '\n' ',' | sed 's/,$//')
            [ -n "$st_match" ] && matched_patterns="ssti_indicator:$st_match"
            ;;
        "deserialization_attacks")
            local ds_match
            ds_match=$(echo "$content" | safe_grep_oiE "ObjectInputStream|readObject|Serializable|ysoserial|CommonsCollections|InvokerTransformer|unserialize|__wakeup|__destruct|pickle|cPickle|yaml\.load|marshal|BinaryFormatter|ObjectStateFormatter|TypeNameHandling|Marshal\.load|deserialization|gadget chain" | head -3 | tr '\n' ',' | sed 's/,$//')
            [ -n "$ds_match" ] && matched_patterns="deserialization_indicator:$ds_match"
            ;;
        "xxe_patterns")
            local xe_match
            xe_match=$(echo "$content" | safe_grep_oiE "<!DOCTYPE|<!ENTITY|SYSTEM|PUBLIC|file://|expect://|php://|data://|gopher://|external entity|XXE|CDATA" | head -3 | tr '\n' ',' | sed 's/,$//')
            [ -n "$xe_match" ] && matched_patterns="xxe_indicator:$xe_match"
            ;;
        "prototype_pollution")
            local pp_match
            pp_match=$(echo "$content" | safe_grep_oiE "__proto__|constructor\.prototype|Object\.prototype|prototype|merge|extend|clone|deepCopy|pollution|pollute|gadget|\{\"__proto__\"|constructor\.prototype" | head -3 | tr '\n' ',' | sed 's/,$//')
            [ -n "$pp_match" ] && matched_patterns="prototype_pollution_indicator:$pp_match"
            ;;
        "supply_chain_attack")
            local sc_match
            sc_match=$(echo "$content" | safe_grep_oiE "npm install|package\.json|postinstall|preinstall|pip install|setup\.py|requirements\.txt|typosquatting|dependency confusion|event-stream|flatmap-stream|ua-parser-js|child_process|subprocess" | head -3 | tr '\n' ',' | sed 's/,$//')
            [ -n "$sc_match" ] && matched_patterns="supply_chain_indicator:$sc_match"
            ;;
        "api_abuse")
            local api_match
            api_match=$(echo "$content" | safe_grep_oE "AKIA[0-9A-Z]{16}|AIza[0-9A-Za-z_-]{35}|sk_live_[0-9a-zA-Z]{24}|ghp_[0-9a-zA-Z]{36}|xoxb-[0-9]{11,13}|private_key|BEGIN RSA PRIVATE|BEGIN EC PRIVATE" | head -2)
            [ -n "$api_match" ] && matched_patterns="api_credential_exposure:${api_match:0:30}..."
            ;;
        *)
            # Fallback to boolean matching for any custom/unlisted rule
            local old_result=$(evaluate_yara_rule "$content" "$rule_name")
            [ "$old_result" = "true" ] && matched_patterns="rule_$rule_name:match"
            ;;
    esac

    echo "$matched_patterns"
}

analyze_env_fingerprinting() {
    set +u
    local content="${1:-}"
    set -u
    # Evasion, fingerprinting, sandbox, VM, emulator, defense check
    if echo "$content" | safe_grep_qiE "VBox|vmware|qemu|parallels|sandboxie|testrun|whoami|systeminfo|uname|getprop|android\.os\.Build|frida|emulator|checkvm|check_sandbox"; then
        log_forensic_detection 55 \
            "Env/Sandbox Fingerprinting" \
            "Matched: VM/Emu/Sandbox/Info indicator" \
            "Fingerprinting/Env awareness" \
            "Behavioral pattern in payload" \
            "ENVIRONMENT FINGERPRINTING - Sandbox or evasion" \
            "MITRE ATT&CK T1497"
    fi
}

analyze_defense_evasion() {
    set +u
    local content="${1:-}"
    set -u
    # Defense evasion, tampering, AMSI, AV, log/cleaner
    if echo "$content" | safe_grep_qiE "amsi.*bypass|Defender.*disable|antivirus.*off|clear-log|wevtutil|attrib.*hidden|powershell.*-nop|set-mppreference.*disable|tamper|bypass"; then
        log_forensic_detection 65 \
            "Defense Evasion" \
            "Matched: AV/EDR/Log tampering" \
            "Evasion/Tampering" \
            "Payload analysis" \
            "DEFENSE EVASION" \
            "MITRE ATT&CK T1562"
    fi
}

analyze_exploit_payloads() {
    set +u
    local content="${1:-}"
    set -u
    # Exploits, shellcode, CVEs, heap spray, buffer overflow
    if echo "$content" | safe_grep_qiE "0x[0-9a-fA-F]{8,}|stage1_shellcode|exploit|rop_chain|buffer overflow|metasploit|cve-|heap_spray|dll_inject|overflow"; then
        log_forensic_detection 77 \
            "Exploit/ROP Payload" \
            "Matched: Exploit pattern/CVE/shellcode" \
            "Exploit attempt" \
            "Behavioral code" \
            "EXPLOIT LAUNCH" \
            "MITRE ATT&CK T1203"
    fi
}

check_persistence_techniques() {
    local content="$1"
    # Persistence: autorun, crontab, scheduled task
    if echo "$content" | safe_grep_qiE "HKLM.*Run|LaunchAgent|systemctl.*enable|chmod.*777|crontab|schtasks|rc\.local"; then
        log_forensic_detection 45 \
            "Persistence" \
            "Matched: Persistence artifact" \
            "Scheduled tasks/startup abuse" \
            "Payload" \
            "PERSISTENCE FOUND" \
            "MITRE ATT&CK T1547"
    fi
}

check_privilege_escalation() {
    local content="$1"
    # Privilege escalation/local root/admin
    if echo "$content" | safe_grep_qiE "sudo|su |runas|setuid|potato|printspoofer|getsystem|escalate"; then
        log_forensic_detection 58 \
            "Privilege Escalation" \
            "Matched: Priv esc technique" \
            "Privesc pattern" \
            "Payload logic" \
            "PRIV ESC DETECTED" \
            "MITRE ATT&CK T1068"
    fi
}

check_discovery_techniques() {
    local content="$1"
    # Discovery: host, network, user, cloud, AD, mobile/MaaS recon
    if echo "$content" | safe_grep_qiE "systeminfo|hostname|whoami|wmic|Get-ComputerInfo|ipconfig|ifconfig|ip addr|netstat|nslookup|nltest|Get-ADDomain|net view|ps aux|Get-Process|tasklist|dir /s|ls -laR|find /|Get-ChildItem.*Recurse|tree|android\.intent\.action|pm list packages|dumpsys|getprop"; then
        log_forensic_detection 47 \
            "Discovery/Recon" \
            "Matched: Reconnaissance/discovery methods" \
            "Enumeration: host/user/cloud/mobile/AD supply chain" \
            "Discovery pattern in payload" \
            "ACTIVE DISCOVERY" \
            "MITRE ATT&CK T1087, T1016, T1049, T1069, T1518"
    fi
}

check_lateral_movement() {
    local content="$1"
    # Lateral: pass-the-hash, PsExec, WinRM, SSH, RDP, SMB, mobile/QR handoff
    if echo "$content" | safe_grep_qiE "psexec|wmic.*process.*create|pass.the.hash|winrm|smbclient|net use|net rpc|rdesktop|mstsc|ssh |scp |adb connect|intent://" ; then
        log_forensic_detection 63 \
            "Lateral Movement" \
            "Matched: Lateral movement/remote exec method" \
            "Remote Code Execution/Lateral movement pattern" \
            "Lateral movement in payload" \
            "LATERAL MOVEMENT" \
            "MITRE ATT&CK T1021, T1077, T1021.001, T1021.002"
    fi
}

check_exfiltration_patterns() {
    local content="$1"
    # Exfil: upload, cloud/drive/pastebin, base64/FTP/email/QR/mobile exfil
    if echo "$content" | safe_grep_qiE "upload|ftp|get.*password|scp|sftp|aws s3 cp|gsutil cp|azcopy|curl.*--upload|-T|wget.*--post|dropbox|gdrive|sendBeacon|base64|encode|mail\.send|sendTextMessage|pastebin\.com|telegram\.api|intent://" ; then
        log_forensic_detection 67 \
            "Exfiltration" \
            "Matched: Data exfil/cloud/SaaS/mobile" \
            "Exfiltration/upload/encoding pattern" \
            "Exfiltration logic" \
            "EXFILTRATION ACTIVITY" \
            "MITRE ATT&CK T1041, T1567, T1537"
    fi
}

check_credential_access() {
    local content="$1"
    # Credential access: Mimikatz, lsass, browser dump, token stealers, mobile/QR abuse
    if echo "$content" | safe_grep_qiE "mimikatz|lsass|sekurlsa|credential.dump|password|keychain|SAM|GetCredential|browser.*password|getpass|get_token|keyring|android\.permission.GET_ACCOUNTS"; then
        log_forensic_detection 60 \
            "Credential Access" \
            "Matched: Credential/cookie/token extractor" \
            "Credential access/theft pattern" \
            "Credential access logic" \
            "CREDENTIAL ACCESS" \
            "MITRE ATT&CK T1003, T1555, T1557, T1110"
    fi
}

check_c2_patterns() {
    local content="$1"
    # C2: beacon, checkin, reverse shell, RATs, QR/mobile C2 patterns, cloud
    if echo "$content" | safe_grep_qiE "beacon|checkin|callback|pastebin\.com/raw|raw\.githubusercontent|reverse.shell|bind.shell|websocket|rat|quasar|empire|meterpreter|cobaltstrike|ngrok|tunnel|discord\.api|telegram\.api"; then
        log_forensic_detection 66 \
            "C2/Remote Operator" \
            "Matched: Beacon/RAT/C2/comm" \
            "C2/RAT/remote operator pattern" \
            "C2/remote logic" \
            "COMMAND AND CONTROL" \
            "MITRE ATT&CK T1071, T1095, T1105"
    fi
}

check_impact_techniques() {
    local content="$1"
    # Impact: ransomware, wipe, destroy, wiper, sabotage, DDoS, mining
    if echo "$content" | safe_grep_qiE "encrypt|ransom|decrypt|bitcoin|monero|\.onion|\.locked|\.encrypted|wipe|destroy|shred|rm -rf|format|cipher /w|disable|shutdown|ddos|xmrig|minergate|minerd|stratum"; then
        log_forensic_detection 80 \
            "Impact Techniques" \
            "Matched: Impact/ransom/wiper pattern" \
            "Ransomware/wiper/impact logic" \
            "Impact logic" \
            "IMPACT/DESTRUCTION THREAT" \
            "MITRE ATT&CK T1486, T1490, T1499"
    fi
}

analyze_qr_specific_iocs() {
    set +u
    local content="${1:-}"
    set -u
    # QR-specific: intent abuse, instant QR malware, QR mobilizer, app provisioning
    if echo "$content" | safe_grep_qiE "qr code.*payload|scan.*intent://|market://|mobile.*dropper|provisioning.*profile|android\.intent\.action|ios.*UniversalLink|scan.*app list"; then
        log_forensic_detection 64 \
            "QR/Mobile IOC" \
            "Matched: QR/intent/mobile/abuse" \
            "QR-specific logic" \
            "QR/mobile compromise logic" \
            "QR/INTENT ABUSE" \
            "Custom (QR, mobile, hybrid attack)"
    fi
}

analyze_supply_chain_impact() {
    set +u
    local content="${1:-}"
    set -u
    # Supply chain: installer, script, app builder/packer/provisioning, SDK injection
    if echo "$content" | safe_grep_qiE "setup\.py|requirements\.txt|signapk|signipa|manifest\.json|provisioning profile|npm install|apktool|drozer|build.gradle|PyInstaller|shellter|veil|obfuscator|packer"; then
        log_forensic_detection 72 \
            "Supply Chain Impact" \
            "Matched: Builder/packer/install" \
            "Supply chain manipulation" \
            "Payload logic" \
            "SUPPLY CHAIN RISK" \
            "MITRE ATT&CK T1195, T1584, T1608, T1642"
    fi
}

analyze_mobile_abuse() {
    set +u
    local content="${1:-}"
    set -u
    # Mobile-specific: SMS abuse, ADB, overlay, permissions, QR, fraud
    if echo "$content" | safe_grep_qiE "READ_SMS|SEND_SMS|CALL_PHONE|adb shell|pm install|am start|content://contacts|MMS|overlay|draw over|packageinstaller|deepLink|qr code.*sms|fido_key|gcm|push_key|twilio|whatsapp"; then
        log_forensic_detection 59 \
            "Mobile Abuse/Abuse of Mobile APIs" \
            "Matched: Mobile abuse/permission/QR/fraud" \
            "Abused mobile logic" \
            "Mobile/QR fraud/abuse logic" \
            "MOBILE ABUSE DETECTED" \
            "MITRE ATT&CK T1409, T1410, T1454, T1515"
    fi
}

analyze_cloud_saas_abuse() {
    set +u
    local content="${1:-}"
    set -u
    # Cloud/SaaS: data exfil, API tokens, shadow IT, risky SaaS operations
    if echo "$content" | safe_grep_qiE "aws_access_key_id|gcp_token|azure|cloudtrail|gs://|s3://|bucket|slack_token|discord_token|teams_token|office365|dropbox|gdrive|zapier|automation anywhere"; then
        log_forensic_detection 62 \
            "Cloud/SaaS Abuse" \
            "Matched: Cloud API/data exfil/abuse" \
            "Cloud/SaaS/Tokens" \
            "Cloud/SaaS abuse logic" \
            "CLOUD/SaaS ABUSE" \
            "MITRE ATT&CK T1537, T1567, T1529"
    fi
}

analyze_social_engineering() {
    set +u
    local content="${1:-}"
    set -u
    # Phishing, fraud, vishing, QR-induced scam, social/impersonation/SEO/smishing/fake popups
    if echo "$content" | safe_grep_qiE "phish|fake login|urgent action|required|confirm account|security alert|vishing|smishing|qr code.*phish|reset password|verify.*identity|impersonat(e|ion)|fakesender|spoofed"; then
        log_forensic_detection 65 \
            "Social Engineering/Phishing" \
            "Matched: Social/Fraud/SEO tactics" \
            "Socially engineered payload" \
            "SocialEng/Phish logic" \
            "SOCIAL ENGINEERING ATTACK" \
            "MITRE ATT&CK T1566, T1189"
    fi
}

analyze_steganography() {
    set +u
    local content="${1:-}"
    set -u
    # Stego/hidden: Data hidden in images, files, LSB, QR, packers
    if echo "$content" | safe_grep_qiE "steganography|jpeg|png|lsb|hidden.*data|imageData|canvas\.toDataURL|exiftool|encode.*image|decode.*image|Stego|qr code.*steg"; then
        log_forensic_detection 50 \
            "Steganography/Obfuscation" \
            "Matched: Stego/hidden/packer/image abuse" \
            "Stego/data hiding" \
            "Hidden in payload" \
            "STEGANOGRAPHY/OBFUSCATION" \
            "MITRE ATT&CK T1027, T1036"
    fi
}

log_evidence_tags() {
    local content="$1"
    # Evidence/forensic chain tagging; log source/time/context
    log_forensic_detection 10 \
        "Evidence Chain Tag" \
        "Artifact hash, timestamp, env, context" \
        "Evidence/forensic chain" \
        "Full pipeline" \
        "EVIDENCE TAG" \
        "Audit"
}


################################################################################
# IOC RECORDING AND MANAGEMENT
################################################################################

record_ioc() {
    local ioc_type="$1"
    local indicator="$2"
    local context="$3"
    
    local timestamp=$(date -Iseconds)
    
    # Escape commas in indicator and context
    indicator=$(echo "$indicator" | sed 's/,/;/g')
    context=$(echo "$context" | sed 's/,/;/g')
    
    echo "$ioc_type,$indicator,$timestamp,$context" >> "$IOC_REPORT"
    
    # Track IOC count globally
    ((IOC_COUNT++)) || true
}

generate_ioc_summary() {
    log_info "Generating IOC summary..."
    
    if [ ! -s "$IOC_REPORT" ]; then
        log_info "No IOCs recorded"
        return
    fi
    
    {
        echo "═══════════════════════════════════════════════"
        echo "INDICATORS OF COMPROMISE SUMMARY"
        echo "═══════════════════════════════════════════════"
        echo ""
        echo "Total IOCs: $(wc -l < "$IOC_REPORT")"
        echo ""
        echo "By Type:"
        awk -F, 'NR>1 {print $1}' "$IOC_REPORT" | sort | uniq -c | sort -rn
        echo ""
        echo "Detailed IOCs:"
        echo ""
        cat "$IOC_REPORT"
    } >> "$REPORT_FILE"
}

################################################################################
# MAIN QR IMAGE ANALYSIS FUNCTION
################################################################################

analyze_qr_image() {
    set +u
    local image="${1:-}"
    set -u
    
    # AUDIT: Validate and sanitize image path
    image=$(sanitize_path "$image") || {
        log_error "Invalid image path"
        return 1
    }
    
    local image_name=$(basename "$image")
    local image_report="${EVIDENCE_DIR}/${image_name}_report.txt"
    
    # Set global for use by advanced engines
    INPUT_IMAGE="$image"
    
    echo ""
    log_info "════════════════════════════════════════════════════════════"
    log_info "Analyzing: $image"
    log_info "════════════════════════════════════════════════════════════"
    
    # Verify file exists and is readable
    if [ ! -f "$image" ]; then
        log_error "File not found: $image"
        return 1
    fi
    
    if [ ! -r "$image" ]; then
        log_error "File not readable: $image"
        return 1
    fi
    
    # AUDIT: Validate image integrity before processing to prevent crashes
    log_info "Validating image integrity..."
    if ! validate_image_safety "$image"; then
        log_warning "Image failed safety validation - using cautious processing mode"
        # Continue but with extra protection - individual functions will handle errors
    fi
    
    # Get file info
    local file_type=$(file -b "$image")
    local file_size=$(stat -f%z "$image" 2>/dev/null || stat -c%s "$image" 2>/dev/null)
    local file_hash_md5=$(md5sum "$image" 2>/dev/null | cut -d' ' -f1 || md5 -q "$image" 2>/dev/null)
    local file_hash_sha256=$(sha256sum "$image" 2>/dev/null | cut -d' ' -f1 || shasum -a 256 "$image" 2>/dev/null | cut -d' ' -f1)
    
    log_info "File type: $file_type"
    log_info "File size: $file_size bytes"
    log_info "MD5: $file_hash_md5"
    log_info "SHA256: $file_hash_sha256"
    
    # AUDIT: Add to chain of custody
    add_evidence_item "$image" "qr_image" "QR code image submitted for analysis"
    record_custody_action "FILE_ANALYZED" "Analysis started for $image_name" "$image" "$file_hash_sha256"
    
    # Record file IOCs
    record_ioc "file_hash_md5" "$file_hash_md5" "$image_name"
    record_ioc "file_hash_sha256" "$file_hash_sha256" "$image_name"
    
    # Check hash against threat intel
    check_against_threat_intel "$file_hash_md5" "hash"
    check_against_threat_intel "$file_hash_sha256" "hash"
    
    # Set forensic context for detections
    CURRENT_ARTIFACT="$image"
    CURRENT_ARTIFACT_HASH="$file_hash_sha256"
    
    # Start image report
    {
        echo "═══════════════════════════════════════════════"
        echo "QR CODE ANALYSIS REPORT"
        echo "═══════════════════════════════════════════════"
        echo "File: $image"
        echo "Analysis Time: $(date -Iseconds)"
        echo ""
        echo "FILE PROPERTIES:"
        echo "  Type: $file_type"
        echo "  Size: $file_size bytes"
        echo "  MD5: $file_hash_md5"
        echo "  SHA256: $file_hash_sha256"
        echo ""
    } > "$image_report"
    
    # Validate image format
    validate_image_format "$image"
    
    # Analyze image metadata
    analyze_image_metadata "$image"
    
    # Check for steganography
    if [ "$STEGANOGRAPHY_CHECK" = true ]; then
        analyze_steganography "$image"
    fi
    
    # =========================================================================
    # FORENSIC IMAGE ANALYSIS (8 Modules)
    # =========================================================================
    
    # Forensic 1: Timestamp Anomaly Detection
    analyze_timestamp_anomalies "$image" 2>/dev/null
    
    # Forensic 2: Camera Sensor Fingerprinting
    analyze_camera_fingerprint "$image" 2>/dev/null
    
    # Forensic 3: Printer Tracking Dots (MIC)
    analyze_printer_dots "$image" 2>/dev/null
    
    # Forensic 4: Screenshot Artifact Detection
    analyze_screenshot_artifacts "$image" 2>/dev/null
    
    # Forensic 5: Compression Artifact Analysis
    analyze_compression_artifacts "$image" 2>/dev/null
    
    # Forensic 6: Image Cropping History
    analyze_crop_history "$image" 2>/dev/null
    
    # Forensic 7: AI-Generated Image Detection
    analyze_ai_generated_images "$image" 2>/dev/null
    
    # Forensic 8: Deepfake Indicator Detection
    analyze_deepfake_indicators "$image" 2>/dev/null
    
    # Perform OCR analysis
    perform_ocr_analysis "$image"
    
    # Multi-decoder QR analysis
    local decode_output="${TEMP_DIR}/${image_name}_decoded"
    mkdir -p "$(dirname "$decode_output")"
    
    if multi_decoder_analysis "$image" "$decode_output"; then
        # Read and clean decoded content - remove null bytes, newlines, and trim whitespace
        local merged_content=$(cat "${decode_output}_merged.txt" 2>/dev/null | tr -d '\0\n\r' | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
        CURRENT_DECODED_CONTENT="$merged_content"
        
        if [ -n "$merged_content" ]; then
            log_success "QR code decoded successfully"
            
            # AUDIT: Check content length and truncate if needed
            local content_length=${#merged_content}
            if [[ $content_length -gt 65536 ]]; then
                log_warning "Decoded content exceeds maximum length ($content_length chars) - truncating for analysis"
                merged_content="${merged_content:0:65536}"
            fi
            
            log_info "Content preview: ${merged_content:0:200}..."
            
            {
                echo "QR CODE CONTENT:"
                echo "─────────────────"
                echo "$merged_content"
                echo ""
            } >> "$image_report"
            
            # AUDIT: Check against additional IOC databases
            check_against_additional_iocs "$merged_content" "decoded_qr_content"
            
            # Analyze the decoded content
            analyze_decoded_qr_content "$merged_content" "$image_report"
            
            # AUDIT: Record content analysis in chain of custody
            record_custody_action "CONTENT_DECODED" "QR content decoded and analyzed" "$image" "$file_hash_sha256"
        fi
    else
        log_warning "Failed to decode QR code from image"
        echo "QR CODE: Unable to decode" >> "$image_report"
    fi
    
    # Calculate entropy analysis
    if [ "$ENTROPY_ANALYSIS" = true ]; then
        local file_entropy=$(analyze_file_entropy "$image")
        log_info "File entropy: $file_entropy"
        echo "File Entropy: $file_entropy" >> "$image_report"
        
        {
            echo ""
            echo "ENTROPY ANALYSIS:"
            echo "  File entropy: $file_entropy"
            if float_gt "$file_entropy" "7.9"; then
                echo "  WARNING: High entropy - possible encrypted/compressed hidden data"
            fi
        } >> "$image_report"
    fi
    
    # Final threat assessment for this image
    {
        echo ""
        echo "═══════════════════════════════════════════════"
        echo "THREAT ASSESSMENT"
        echo "═══════════════════════════════════════════════"
        echo "Current Threat Score: $THREAT_SCORE"
        if [ $THREAT_SCORE -ge $CRITICAL_THRESHOLD ]; then
            echo "Risk Level: CRITICAL"
        elif [ $THREAT_SCORE -ge $HIGH_THRESHOLD ]; then
            echo "Risk Level: HIGH"
        elif [ $THREAT_SCORE -ge $MEDIUM_THRESHOLD ]; then
            echo "Risk Level: MEDIUM"
        elif [ $THREAT_SCORE -ge $LOW_THRESHOLD ]; then
            echo "Risk Level: LOW"
        else
            echo "Risk Level: MINIMAL"
        fi
    } >> "$image_report"
    
    # Copy report to main report
    cat "$image_report" >> "$REPORT_FILE"
}

validate_image_format() {
    local image="$1"
    local file_type=$(file -b "$image")
    
    # Check for valid image formats
    if ! echo "$file_type" | grep -qiE "PNG|JPEG|GIF|BMP|TIFF|WebP"; then
        log_warning "Unusual file type for QR image: $file_type"
        log_threat 15 "Non-standard image format"
    fi
    
    # Check for polyglot files (files that are valid as multiple types)
    local magic_bytes=$(xxd -l 16 "$image" 2>/dev/null | head -1)
    
    # PNG magic: 89 50 4E 47
    # JPEG magic: FF D8 FF
    # GIF magic: 47 49 46 38
    # PDF magic: 25 50 44 46
    # ZIP magic: 50 4B
    # PE magic: 4D 5A
    
    if echo "$magic_bytes" | grep -qiE "4d5a|4d 5a"; then
        log_threat 60 "PE executable signature detected in image!"
    fi
    
    if echo "$magic_bytes" | grep -qiE "2550 4446|25 50 44 46"; then
        log_threat 40 "PDF signature detected in image - potential polyglot"
    fi
    
    if echo "$magic_bytes" | grep -qiE "504b|50 4b"; then
        log_threat 35 "ZIP signature detected - potential polyglot/embedded archive"
    fi
    
    # [CRITICAL Output – legacy]
    if [[ "${THREAT_SCORE:-0}" -ge 1000 ]]; then
        echo -e "${RED}[CRITICAL]${NC} ⚠️  CRITICAL THREAT LEVEL - Immediate action required!"
    fi
    
    # Check file size anomalies
    local file_size=$(stat -f%z "$image" 2>/dev/null || stat -c%s "$image" 2>/dev/null || echo 0)
    
    if [ "$file_size" -gt 10000000 ]; then
        log_warning "Unusually large QR image: $file_size bytes"
        log_threat 20 "Large file size may indicate hidden data"
    fi
}


################################################################################
# EXTENDED ANALYSIS MODULES
################################################################################

################################################################################
# CLOUD SERVICE ABUSE DETECTION ENGINE
################################################################################

analyze_cloud_service_abuse() {
    set +u
    local content="${1:-}"
    set -u
    
    if [ "$CLOUD_ABUSE_CHECK" = false ]; then
        return
    fi
    
    log_info "Analyzing for cloud service abuse patterns..."
    
    local cloud_findings=()
    local cloud_score=0
    
    # Check cloud storage abuse patterns
    for pattern in "${CLOUD_STORAGE_ABUSE_PATTERNS[@]}"; do
        if echo "$content" | safe_grep_qiE "$pattern"; then
            local matched=$(echo "$content" | safe_grep_oiE "$pattern" 2>/dev/null | head -1)
            cloud_findings+=("cloud_storage:$matched")
            ((cloud_score += 25))
            log_warning "Cloud storage abuse pattern detected: $matched"
        fi
    done
    
    # Check code hosting abuse patterns
    for pattern in "${CODE_HOSTING_ABUSE_PATTERNS[@]}"; do
        if echo "$content" | safe_grep_qiE "$pattern"; then
            local matched=$(echo "$content" | safe_grep_oiE "$pattern" 2>/dev/null | head -1)
            cloud_findings+=("code_hosting:$matched")
            ((cloud_score += 30))
            log_warning "Code hosting abuse pattern detected: $matched"
        fi
    done
    
    # Specific high-risk combinations
    if echo "$content" | safe_grep_qiE "discord.*cdn.*\.(exe|dll|bat|ps1|vbs)"; then
        log_threat 60 "Discord CDN hosting executable - common malware distribution"
        cloud_findings+=("discord_malware_distribution")
        ((cloud_score += 35))
    fi
    
    if echo "$content" | safe_grep_qiE "raw\.githubusercontent.*\.(ps1|bat|exe|sh|py)"; then
        log_threat 55 "GitHub raw hosting script/executable - potential payload delivery"
        cloud_findings+=("github_payload_delivery")
        ((cloud_score += 30))
    fi
    
    if echo "$content" | safe_grep_qiE "drive\.google\.com.*(download|export).*\.(exe|dll|msi|dmg)"; then
        log_threat 50 "Google Drive executable download link detected"
        cloud_findings+=("gdrive_executable")
        ((cloud_score += 30))
    fi
    
    if echo "$content" | safe_grep_qiE "dropbox.*\.(exe|dll|scr|bat|cmd|ps1|vbs)"; then
        log_threat 50 "Dropbox hosting executable/script"
        cloud_findings+=("dropbox_executable")
        ((cloud_score += 30))
    fi
    
    if echo "$content" | safe_grep_qiE "s3\.amazonaws\.com.*/.*\.(exe|dll|msi)"; then
        log_threat 45 "AWS S3 hosting executable"
        cloud_findings+=("s3_executable")
        ((cloud_score += 25))
    fi
    
    if echo "$content" | safe_grep_qiE "blob\.core\.windows\.net.*/.*\.(exe|dll|msi)"; then
        log_threat 45 "Azure Blob hosting executable"
        cloud_findings+=("azure_executable")
        ((cloud_score += 25))
    fi
    
    if echo "$content" | safe_grep_qiE "workers\.dev"; then
        log_warning "Cloudflare Workers URL - frequently used for phishing/redirects"
        cloud_findings+=("cloudflare_workers")
        ((cloud_score += 20))
    fi
    
    if echo "$content" | safe_grep_qiE "pages\.dev"; then
        log_warning "Cloudflare Pages URL - check for phishing content"
        cloud_findings+=("cloudflare_pages")
        ((cloud_score += 15))
    fi
    
    # Pastebin with potential encoded payload
    if echo "$content" | safe_grep_qiE "pastebin\.com/raw"; then
        log_threat 40 "Pastebin raw content link - common payload hosting"
        cloud_findings+=("pastebin_raw")
        ((cloud_score += 25))
        
        # Try to fetch and analyze if network enabled
        if [ "$NETWORK_CHECK" = true ]; then
            analyze_pastebin_content "$content"
        fi
    fi
    
    # File sharing services analysis
    for service in "transfer.sh" "file.io" "gofile.io" "anonfiles" "mega.nz" "wetransfer"; do
        if echo "$content" | safe_grep_qi "$service"; then
            log_warning "File sharing service detected: $service"
            cloud_findings+=("fileshare:$service")
            ((cloud_score += 20))
        fi
    done
    
    # Generate cloud abuse report
    if [ ${#cloud_findings[@]} -gt 0 ]; then
        {
            echo "═══════════════════════════════════════════════"
            echo "CLOUD SERVICE ABUSE ANALYSIS"
            echo "═══════════════════════════════════════════════"
            echo "Timestamp: $(date -Iseconds)"
            echo "Cloud Abuse Score: $cloud_score"
            echo ""
            echo "Findings:"
            for finding in "${cloud_findings[@]}"; do
                echo "  - $finding"
            done
            echo ""
            echo "Risk Assessment:"
            if [ $cloud_score -ge 100 ]; then
                echo "  CRITICAL: Multiple cloud abuse indicators detected"
            elif [ $cloud_score -ge 50 ]; then
                echo "  HIGH: Significant cloud abuse risk"
            elif [ $cloud_score -ge 25 ]; then
                echo "  MEDIUM: Cloud service usage requires investigation"
            else
                echo "  LOW: Minor cloud service indicators"
            fi
            echo ""
        } >> "$CLOUD_ABUSE_REPORT"
        
        if [ $cloud_score -ge 50 ]; then
            log_threat $((cloud_score / 2)) "Cloud service abuse indicators detected"
        fi
        
        analysis_success_found "CLOUD-ABUSE" "${#cloud_findings[@]}" "Score: $cloud_score" "$(IFS=', '; echo "${cloud_findings[*]}")"
    else
        analysis_success_none "CLOUD-ABUSE"
    fi
    
    # === AUDIT ADDITIONS: Extended Cloud Provider Checks ===
    # Check against EXTENDED_CLOUD_IOCS database
    for key in "${!EXTENDED_CLOUD_IOCS[@]}"; do
        local pattern="${EXTENDED_CLOUD_IOCS[$key]}"
        if echo "$content" | safe_grep_qiE "$pattern"; then
            local matched=$(echo "$content" | safe_grep_oiE "$pattern" 2>/dev/null | head -1)
            log_warning "Extended cloud IOC detected ($key): $matched"
            record_ioc "cloud_abuse" "$key:$matched" "Extended cloud provider abuse"
            ((cloud_score += 20))
        fi
    done
    
    # Check against DEV_PLATFORM_ABUSE_IOCS database
    for key in "${!DEV_PLATFORM_ABUSE_IOCS[@]}"; do
        local pattern="${DEV_PLATFORM_ABUSE_IOCS[$key]}"
        if echo "$content" | safe_grep_qiE "$pattern"; then
            local matched=$(echo "$content" | safe_grep_oiE "$pattern" 2>/dev/null | head -1)
            log_warning "Developer platform abuse detected ($key): $matched"
            record_ioc "dev_platform" "$key:$matched" "Developer platform abuse"
            ((cloud_score += 25))
        fi
    done
    
    # Check messaging platform abuse
    for key in "${!MESSAGING_PLATFORM_IOCS[@]}"; do
        local pattern="${MESSAGING_PLATFORM_IOCS[$key]}"
        if echo "$content" | safe_grep_qiE "$pattern"; then
            local matched=$(echo "$content" | safe_grep_oiE "$pattern" 2>/dev/null | head -1)
            log_warning "Messaging platform abuse detected ($key): $matched"
            record_ioc "messaging_abuse" "$key:$matched" "Messaging platform C2/abuse"
            ((cloud_score += 30))
        fi
    done
}

################################################################################
# MESSAGING PLATFORM ABUSE ANALYZER (Audit Compliance)
################################################################################

analyze_messaging_platform_abuse() {
    set +u
    local content="${1:-}"
    set -u
    local msg_report="${OUTPUT_DIR}/messaging_abuse_analysis.txt"
    
    log_info "Analyzing for messaging platform abuse..."
    
    local msg_findings=()
    local msg_score=0
    
    # Check Slack webhooks
    if echo "$content" | safe_grep_qiE "hooks\.slack\.com/services/T[A-Z0-9]+/B[A-Z0-9]+"; then
        local matched=$(echo "$content" | safe_grep_oiE "hooks\.slack\.com/services/[A-Za-z0-9/]+" | head -1)
        msg_findings+=("slack_webhook:$matched")
        ((msg_score += 40))
        log_threat 45 "Slack webhook URL detected - potential C2 channel"
        record_ioc "slack_webhook" "$matched" "Slack webhook for C2/exfil"
    fi
    
    # Check Discord webhooks
    if echo "$content" | safe_grep_qiE "discord(app)?\.com/api/webhooks/[0-9]+"; then
        local matched=$(echo "$content" | safe_grep_oiE "discord(app)?\.com/api/webhooks/[0-9]+/[a-zA-Z0-9_-]+" | head -1)
        msg_findings+=("discord_webhook:$matched")
        ((msg_score += 45))
        log_threat 50 "Discord webhook URL detected - common malware C2"
        record_ioc "discord_webhook" "$matched" "Discord webhook for C2/exfil"
    fi
    
    # Check Microsoft Teams webhooks
    if echo "$content" | safe_grep_qiE "\.webhook\.office\.com"; then
        local matched=$(echo "$content" | safe_grep_oiE "[a-z0-9-]+\.webhook\.office\.com[^\s]*" | head -1)
        msg_findings+=("teams_webhook:$matched")
        ((msg_score += 40))
        log_warning "Microsoft Teams webhook detected"
        record_ioc "teams_webhook" "$matched" "Teams webhook"
    fi
    
    # Check Telegram bot API
    if echo "$content" | safe_grep_qiE "api\.telegram\.org/bot[0-9]+:"; then
        local matched=$(echo "$content" | safe_grep_oiE "api\.telegram\.org/bot[0-9]+:[a-zA-Z0-9_-]+" | head -1)
        msg_findings+=("telegram_bot:$matched")
        ((msg_score += 50))
        log_threat 55 "Telegram bot API endpoint - common stealer/C2 exfil"
        record_ioc "telegram_bot" "$matched" "Telegram bot C2"
    fi
    
    # Check Telegram links
    if echo "$content" | safe_grep_qiE "t\.me/[a-zA-Z0-9_]+"; then
        local matched=$(echo "$content" | safe_grep_oiE "t\.me/[a-zA-Z0-9_]+" | head -1)
        msg_findings+=("telegram_link:$matched")
        ((msg_score += 20))
        log_info "Telegram link detected: $matched"
    fi
    
    # Check WhatsApp API abuse
    if echo "$content" | safe_grep_qiE "api\.whatsapp\.com/send|wa\.me/[0-9]+\?text="; then
        local matched=$(echo "$content" | safe_grep_oiE "(api\.whatsapp\.com/send|wa\.me/[0-9]+)[^\s]*" | head -1)
        msg_findings+=("whatsapp_link:$matched")
        ((msg_score += 25))
        log_warning "WhatsApp API/link detected"
    fi
    
    # Check Signal links
    if echo "$content" | safe_grep_qiE "signal\.me/#p/|signal\.group/#"; then
        local matched=$(echo "$content" | safe_grep_oiE "signal\.(me|group)/#[a-zA-Z0-9_-]+" | head -1)
        msg_findings+=("signal_link:$matched")
        ((msg_score += 20))
        log_info "Signal link detected: $matched"
    fi
    
    # Check Matrix/Element
    if echo "$content" | safe_grep_qiE "matrix\.to/#/|app\.element\.io/#/room"; then
        local matched=$(echo "$content" | safe_grep_oiE "(matrix\.to|app\.element\.io)/#[^\s]+" | head -1)
        msg_findings+=("matrix_link:$matched")
        ((msg_score += 20))
        log_info "Matrix/Element room link detected"
    fi
    
    # Check Mattermost
    if echo "$content" | safe_grep_qiE "mattermost\.(com|cloud)/hooks/"; then
        local matched=$(echo "$content" | safe_grep_oiE "[a-z0-9-]+\.mattermost\.[a-z]+/hooks/[a-z0-9]+" | head -1)
        msg_findings+=("mattermost_webhook:$matched")
        ((msg_score += 35))
        log_warning "Mattermost webhook detected"
    fi
    
    # Check Rocket.Chat
    if echo "$content" | safe_grep_qiE "rocket\.chat/(hooks|api)/"; then
        local matched=$(echo "$content" | safe_grep_oiE "[a-z0-9-]+\.rocket\.chat/(hooks|api)[^\s]*" | head -1)
        msg_findings+=("rocketchat:$matched")
        ((msg_score += 30))
        log_warning "Rocket.Chat API/webhook detected"
    fi
    
    # Check Zulip
    if echo "$content" | safe_grep_qiE "zulipchat\.com/api"; then
        local matched=$(echo "$content" | safe_grep_oiE "[a-z0-9-]+\.zulipchat\.com/api[^\s]*" | head -1)
        msg_findings+=("zulip:$matched")
        ((msg_score += 30))
        log_warning "Zulip API detected"
    fi
    
    # Check Keybase
    if echo "$content" | safe_grep_qiE "keybase\.io/(team|_/api)"; then
        local matched=$(echo "$content" | safe_grep_oiE "keybase\.io/(team|_/api)[^\s]*" | head -1)
        msg_findings+=("keybase:$matched")
        ((msg_score += 25))
        log_info "Keybase endpoint detected"
    fi
    
    if [ ${#msg_findings[@]} -gt 0 ]; then
        {
            echo "═══════════════════════════════════════════════"
            echo "MESSAGING PLATFORM ABUSE ANALYSIS"
            echo "═══════════════════════════════════════════════"
            echo "Timestamp: $(date -Iseconds)"
            echo "Threat Score: $msg_score"
            echo ""
            echo "Findings:"
            for finding in "${msg_findings[@]}"; do
                echo "  - $finding"
            done
            echo ""
            echo "MITRE ATT&CK: T1102 - Web Service"
            echo "MITRE ATT&CK: T1567 - Exfiltration Over Web Service"
        } >> "$msg_report"
        
        if [ $msg_score -ge 40 ]; then
            log_threat $((msg_score / 2)) "Messaging platform abuse detected"
        fi
    fi
}

################################################################################
# URL SHORTENER ANALYSIS (Extended - Audit Compliance)
################################################################################

analyze_url_shortener_extended() {
    set +u
    local content="${1:-}"
    set -u
    local shortener_report="${OUTPUT_DIR}/url_shortener_analysis.txt"
    
    log_info "Analyzing for URL shortener abuse..."
    
    local shortener_findings=()
    local shortener_score=0
    
    # Check against extended URL shortener patterns
    for shortener in "${URL_SHORTENERS[@]}"; do
        if echo "$content" | safe_grep_qiE "$shortener"; then
            local matched=$(echo "$content" | safe_grep_oiE "https?://[^\s]*$shortener[^\s]*" | head -1)
            [ -z "$matched" ] && matched=$(echo "$content" | safe_grep_oiE "$shortener[^\s]*" | head -1)
            shortener_findings+=("shortener:$matched")
            ((shortener_score += 15))
        fi
    done
    
    # Check against URL_SHORTENER_EXTENDED_IOCS
    for key in "${!URL_SHORTENER_EXTENDED_IOCS[@]}"; do
        local pattern="${URL_SHORTENER_EXTENDED_IOCS[$key]}"
        if echo "$content" | safe_grep_qiE "$pattern"; then
            local matched=$(echo "$content" | safe_grep_oiE "$pattern" | head -1)
            shortener_findings+=("$key:$matched")
            ((shortener_score += 20))
        fi
    done
    
    # High-risk shorteners (known malware distribution)
    if echo "$content" | safe_grep_qiE "ouo\.io|adf\.ly|shorte\.st|bc\.vc"; then
        shortener_findings+=("high_risk_shortener")
        ((shortener_score += 35))
        log_threat 40 "High-risk URL shortener detected (known malware distribution)"
    fi
    
    # Link-in-bio services (used for phishing)
    if echo "$content" | safe_grep_qiE "linktr\.ee|beacons\.ai|lnk\.bio|taplink\.cc"; then
        shortener_findings+=("link_in_bio")
        ((shortener_score += 20))
        log_warning "Link-in-bio service detected - verify destination"
    fi
    
    # QR-specific shorteners
    if echo "$content" | safe_grep_qiE "qrco\.de|qrfy\.com|qrtag\.net|qrs\.ly"; then
        shortener_findings+=("qr_shortener")
        ((shortener_score += 15))
        log_info "QR-specific shortener detected"
    fi
    
    if [ ${#shortener_findings[@]} -gt 0 ]; then
        {
            echo "═══════════════════════════════════════════════"
            echo "URL SHORTENER ANALYSIS"
            echo "═══════════════════════════════════════════════"
            echo "Timestamp: $(date -Iseconds)"
            echo "Score: $shortener_score"
            echo "Shorteners Found: ${#shortener_findings[@]}"
            echo ""
            echo "Findings:"
            for finding in "${shortener_findings[@]}"; do
                echo "  - $finding"
            done
            echo ""
            echo "Recommendation: Expand shortened URLs to verify destination"
        } >> "$shortener_report"
        
        if [ $shortener_score -ge 30 ]; then
            log_warning "Multiple URL shorteners detected - possible obfuscation"
        fi
    fi
}

analyze_offensive_tools() {
    set +u
    local content="${1:-}"
    set -u
    
    log_info "Analyzing for offensive security tools and indicators..."
    
    local offensive_findings=()
    local offensive_score=0
    
    # Check for known offensive tools patterns
    for pattern in "${OFFENSIVE_TOOLS_PATTERNS[@]}"; do
        [ -z "$pattern" ] && continue
        if echo "$content" | safe_grep_qiE "$pattern" 2>/dev/null; then
            local matched=$(echo "$content" | safe_grep_oiE "$pattern" 2>/dev/null | head -1)
            offensive_findings+=("offensive_tool:$matched")
            ((offensive_score += 50))
            log_threat 60 "🔴 OFFENSIVE TOOL DETECTED: $matched"
            log_error "    ├─ Category: Pentesting/Red Team Tool"
            log_error "    ├─ Pattern: $pattern"
            log_error "    └─ Risk: HIGH - Often used in attacks"
        fi
    done
    
    # Check for offensive file patterns
    for pattern in "${OFFENSIVE_FILE_PATTERNS[@]}"; do
        [ -z "$pattern" ] && continue
        if echo "$content" | safe_grep_qiE "$pattern" 2>/dev/null; then
            local matched=$(echo "$content" | safe_grep_oiE "$pattern" 2>/dev/null | head -1)
            offensive_findings+=("offensive_file:$matched")
            ((offensive_score += 40))
            log_threat 50 "🔴 OFFENSIVE FILE SIGNATURE: $matched"
            log_error "    ├─ Type: Known malicious file pattern"
            log_error "    └─ Risk: HIGH - Webshell or exploit payload"
        fi
    done
    
    # Check for offensive infrastructure patterns
    for pattern in "${OFFENSIVE_INFRA_PATTERNS[@]}"; do
        [ -z "$pattern" ] && continue
        if echo "$content" | safe_grep_qiE "$pattern" 2>/dev/null; then
            local matched=$(echo "$content" | safe_grep_oiE "$pattern" 2>/dev/null | head -1)
            offensive_findings+=("offensive_infra:$matched")
            ((offensive_score += 35))
            log_threat 45 "⚠️  OFFENSIVE INFRASTRUCTURE INDICATOR: $matched"
            log_warning "    ├─ Type: C2/Attack infrastructure pattern"
            log_warning "    └─ Risk: MEDIUM-HIGH - Possible attack setup"
        fi
    done
    
    # Specific high-confidence detections with detailed output
    if echo "$content" | safe_grep_qiE "cobalt.*strike|cobaltstrike|beacon\.(dll|exe)" 2>/dev/null; then
        log_critical "════════════════════════════════════════════════════════"
        log_critical "🚨 COBALT STRIKE DETECTED!"
        log_critical "════════════════════════════════════════════════════════"
        log_error "    ├─ Tool: Cobalt Strike (Commercial Red Team Tool)"
        log_error "    ├─ Usage: Commonly abused by ransomware groups"
        log_error "    ├─ Threat Actors: APT29, APT41, FIN7, Conti, LockBit"
        log_error "    └─ Action: BLOCK IMMEDIATELY - Report to security team"
        offensive_findings+=("COBALT_STRIKE_CONFIRMED")
        ((offensive_score += 200))
    fi
    
    if echo "$content" | safe_grep_qiE "meterpreter|msfvenom|metasploit" 2>/dev/null; then
        log_critical "════════════════════════════════════════════════════════"
        log_critical "🚨 METASPLOIT FRAMEWORK DETECTED!"
        log_critical "════════════════════════════════════════════════════════"
        log_error "    ├─ Tool: Metasploit Framework"
        log_error "    ├─ Usage: Popular exploitation framework"
        log_error "    ├─ Risk: Active exploitation attempt"
        log_error "    └─ Action: Investigate source and block"
        offensive_findings+=("METASPLOIT_CONFIRMED")
        ((offensive_score += 150))
    fi
    
    if echo "$content" | safe_grep_qiE "mimikatz|sekurlsa|lsadump" 2>/dev/null; then
        log_critical "════════════════════════════════════════════════════════"
        log_critical "🚨 MIMIKATZ CREDENTIAL THEFT TOOL DETECTED!"
        log_critical "════════════════════════════════════════════════════════"
        log_error "    ├─ Tool: Mimikatz"
        log_error "    ├─ Purpose: Windows credential extraction"
        log_error "    ├─ Risk: CRITICAL - Password/hash theft"
        log_error "    └─ Action: Assume credentials compromised"
        offensive_findings+=("MIMIKATZ_CONFIRMED")
        ((offensive_score += 200))
    fi
    
    if echo "$content" | safe_grep_qiE "bloodhound|sharphound" 2>/dev/null; then
        log_threat 80 "🔴 BLOODHOUND/SHARPHOUND DETECTED!"
        log_error "    ├─ Tool: BloodHound Active Directory reconnaissance"
        log_error "    ├─ Purpose: AD privilege escalation path discovery"
        log_error "    └─ Risk: HIGH - Attack reconnaissance phase"
        offensive_findings+=("BLOODHOUND_RECON")
        ((offensive_score += 100))
    fi
    
    if echo "$content" | safe_grep_qiE "rubeus|kerberoast|asreproast" 2>/dev/null; then
        log_threat 80 "🔴 KERBEROS ATTACK TOOL DETECTED!"
        log_error "    ├─ Tool: Rubeus/Kerberoasting toolkit"
        log_error "    ├─ Purpose: Kerberos ticket attacks"
        log_error "    └─ Risk: HIGH - Credential compromise"
        offensive_findings+=("KERBEROS_ATTACK")
        ((offensive_score += 100))
    fi
    
    if echo "$content" | safe_grep_qiE "empire.*agent|powershell.*empire" 2>/dev/null; then
        log_threat 90 "🔴 POWERSHELL EMPIRE DETECTED!"
        log_error "    ├─ Tool: PowerShell Empire C2 Framework"
        log_error "    ├─ Purpose: Post-exploitation & C2"
        log_error "    └─ Risk: HIGH - Active compromise"
        offensive_findings+=("POWERSHELL_EMPIRE")
        ((offensive_score += 120))
    fi
    
    # Check for webshell indicators
    if echo "$content" | safe_grep_qiE "c99|r57|wso.*shell|b374k|antsword|behinder|godzilla|china.*chopper" 2>/dev/null; then
        log_critical "════════════════════════════════════════════════════════"
        log_critical "🚨 WEBSHELL DETECTED!"
        log_critical "════════════════════════════════════════════════════════"
        local shell_name=$(echo "$content" | safe_grep_oiE "c99|r57|wso|b374k|antsword|behinder|godzilla|china.*chopper" | head -1)
        log_error "    ├─ Type: $shell_name webshell"
        log_error "    ├─ Purpose: Remote server control"
        log_error "    ├─ Risk: CRITICAL - Server compromised"
        log_error "    └─ Action: Immediate incident response required"
        offensive_findings+=("WEBSHELL:$shell_name")
        ((offensive_score += 200))
    fi
    
    # Check for RAT indicators
    if echo "$content" | safe_grep_qiE "asyncrat|quasar.*rat|nanocore|njrat|remcos|darkcomet|agent.*tesla|netwire" 2>/dev/null; then
        local rat_name=$(echo "$content" | safe_grep_oiE "asyncrat|quasar|nanocore|njrat|remcos|darkcomet|agent.*tesla|netwire" | head -1)
        log_critical "════════════════════════════════════════════════════════"
        log_critical "🚨 REMOTE ACCESS TROJAN (RAT) DETECTED!"
        log_critical "════════════════════════════════════════════════════════"
        log_error "    ├─ RAT Family: $rat_name"
        log_error "    ├─ Capabilities: Remote control, keylogging, screen capture"
        log_error "    ├─ Risk: CRITICAL - Full system compromise"
        log_error "    └─ Action: Isolate system, begin IR procedures"
        offensive_findings+=("RAT:$rat_name")
        ((offensive_score += 200))
    fi
    
    # Check for info stealers
    if echo "$content" | safe_grep_qiE "redline.*stealer|vidar|raccoon.*stealer|mars.*stealer|erbium|aurora.*stealer|formbook" 2>/dev/null; then
        local stealer_name=$(echo "$content" | safe_grep_oiE "redline|vidar|raccoon|mars|erbium|aurora|formbook" | head -1)
        log_critical "════════════════════════════════════════════════════════"
        log_critical "🚨 INFO STEALER MALWARE DETECTED!"
        log_critical "════════════════════════════════════════════════════════"
        log_error "    ├─ Stealer Family: $stealer_name"
        log_error "    ├─ Target: Browser data, crypto wallets, credentials"
        log_error "    ├─ Risk: CRITICAL - Data exfiltration"
        log_error "    └─ Action: Change all passwords, check crypto wallets"
        offensive_findings+=("INFOSTEALER:$stealer_name")
        ((offensive_score += 200))
    fi
    
    # Report findings
    if [ ${#offensive_findings[@]} -gt 0 ]; then
        {
            echo "═══════════════════════════════════════════════"
            echo "OFFENSIVE SECURITY TOOLS ANALYSIS"
            echo "═══════════════════════════════════════════════"
            echo "Timestamp: $(date -Iseconds)"
            echo "Offensive Tool Score: $offensive_score"
            echo ""
            echo "Detected Tools/Indicators:"
            for finding in "${offensive_findings[@]}"; do
                echo "  ⚠ $finding"
            done
            echo ""
            if [ $offensive_score -ge 200 ]; then
                echo "VERDICT: CRITICAL - Confirmed malicious tooling"
            elif [ $offensive_score -ge 100 ]; then
                echo "VERDICT: HIGH - Strong offensive tool indicators"
            elif [ $offensive_score -ge 50 ]; then
                echo "VERDICT: MEDIUM - Suspicious tool references"
            fi
            echo ""
        } >> "${OUTPUT_DIR}/offensive_tools_analysis.txt"
        
        log_threat $((offensive_score / 3)) "Offensive security tools detected"
        analysis_success_found "OFFENSIVE-TOOLS" "${#offensive_findings[@]}" "Score: $offensive_score" "$(IFS=', '; echo "${offensive_findings[*]}")"
    else
        analysis_success_none "OFFENSIVE-TOOLS"
    fi
}

analyze_service_abuse() {
    set +u
    local content="${1:-}"
    set -u
    
    log_info "Analyzing for legitimate service abuse patterns..."
    
    local abuse_findings=()
    local abuse_score=0
    
    # Check each service abuse indicator
    for key in "${!SERVICE_ABUSE_INDICATORS[@]}"; do
        local pattern="${SERVICE_ABUSE_INDICATORS[$key]}"
        [ -z "$pattern" ] && continue
        if echo "$content" | safe_grep_qiE "$pattern" 2>/dev/null; then
            local matched=$(echo "$content" | safe_grep_oiE "$pattern" 2>/dev/null | head -1)
            abuse_findings+=("$key:$matched")
            ((abuse_score += 25))
            
            # Categorize and provide detailed output
            case "$key" in
                *_c2|*_webhook*)
                    log_threat 50 "🔴 C2 CHANNEL ABUSE: $key"
                    log_error "    ├─ Service: $matched"
                    log_error "    ├─ Abuse Type: Command & Control communication"
                    log_error "    └─ Risk: HIGH - Active malware communication"
                    ((abuse_score += 25))
                    ;;
                *_malware|*_payload|*_raw)
                    log_threat 45 "🔴 PAYLOAD HOSTING: $key"
                    log_warning "    ├─ Service: $matched"
                    log_warning "    ├─ Abuse Type: Malware/payload hosting"
                    log_warning "    └─ Risk: HIGH - Malware delivery"
                    ((abuse_score += 20))
                    ;;
                *_ddns|*_tunnel|*ngrok*)
                    log_threat 40 "⚠️  DYNAMIC/TUNNEL SERVICE: $key"
                    log_warning "    ├─ Service: $matched"
                    log_warning "    ├─ Abuse Type: Dynamic DNS or tunneling"
                    log_warning "    └─ Risk: MEDIUM-HIGH - Evasion/C2 callback"
                    ((abuse_score += 15))
                    ;;
                *_short*)
                    log_warning "⚠️  URL SHORTENER: $key"
                    log_info "    ├─ Service: $matched"
                    log_info "    ├─ Abuse Type: URL obfuscation"
                    log_info "    └─ Risk: MEDIUM - Hiding destination"
                    ;;
                *_exec|*_func)
                    log_threat 35 "⚠️  SERVERLESS EXECUTION: $key"
                    log_warning "    ├─ Service: $matched"
                    log_warning "    ├─ Abuse Type: Serverless function abuse"
                    log_warning "    └─ Risk: MEDIUM - Ephemeral malicious code"
                    ((abuse_score += 10))
                    ;;
                *)
                    log_warning "⚠️  SERVICE ABUSE: $key"
                    log_info "    ├─ Service: $matched"
                    log_info "    └─ Risk: Review required"
                    ;;
            esac
        fi
    done
    
    # Check callback patterns
    for pattern in "${CALLBACK_PATTERNS[@]}"; do
        [ -z "$pattern" ] && continue
        if echo "$content" | safe_grep_qiE "$pattern" 2>/dev/null; then
            local matched=$(echo "$content" | safe_grep_oiE "$pattern" 2>/dev/null | head -1)
            log_threat 55 "🔴 C2 CALLBACK PATH DETECTED: $matched"
            log_error "    ├─ Pattern: Known C2/malware callback endpoint"
            log_error "    ├─ Examples: Cobalt Strike beacons, webshells"
            log_error "    └─ Risk: HIGH - Active C2 communication"
            abuse_findings+=("c2_callback:$matched")
            ((abuse_score += 40))
        fi
    done
    
    # Report findings
    if [ ${#abuse_findings[@]} -gt 0 ]; then
        {
            echo "═══════════════════════════════════════════════"
            echo "LEGITIMATE SERVICE ABUSE ANALYSIS"
            echo "═══════════════════════════════════════════════"
            echo "Timestamp: $(date -Iseconds)"
            echo "Service Abuse Score: $abuse_score"
            echo ""
            echo "Detected Abuse Patterns:"
            for finding in "${abuse_findings[@]}"; do
                echo "  ⚠ $finding"
            done
            echo ""
        } >> "${OUTPUT_DIR}/service_abuse_analysis.txt"
        
        if [ $abuse_score -ge 50 ]; then
            log_threat $((abuse_score / 2)) "Legitimate service abuse detected"
        fi
        
        analysis_success_found "SERVICE-ABUSE" "${#abuse_findings[@]}" "Score: $abuse_score" "$(IFS=', '; echo "${abuse_findings[*]}")"
    else
        analysis_success_none "SERVICE-ABUSE"
    fi
}

analyze_pastebin_content() {
    set +u
    local url="${1:-}"
    set -u
    
    # Extract pastebin URL
    local paste_url=$(echo "$url" | grep -oiE "pastebin\.com/raw/[a-zA-Z0-9]+" | head -1)
    
    if [ -n "$paste_url" ]; then
        log_info "Fetching pastebin content for analysis..."
        
        local paste_content=$(curl -sfL --max-time 10 "https://$paste_url" 2>/dev/null)
        
        if [ -n "$paste_content" ]; then
            # Check for encoded content
            if echo "$paste_content" | grep -qE "^[A-Za-z0-9+/=]{50,}$"; then
                log_threat 50 "Pastebin contains Base64 encoded content"
                
                # Try to decode
                local decoded=$(echo "$paste_content" | base64 -d 2>/dev/null)
                if [ -n "$decoded" ]; then
                    log_forensic "Decoded pastebin content preview: ${decoded:0:200}"
                    
                    # Recursively analyze decoded content
                    analyze_decoded_content_threats "$decoded"
                fi
            fi
            
            # Check for PowerShell
            if echo "$paste_content" | grep -qiE "powershell|IEX|Invoke-|downloadstring"; then
                log_threat 70 "Pastebin contains PowerShell content"
            fi
            
            # Check for shell commands
            if echo "$paste_content" | grep -qiE "#!/bin|bash -|curl.*\\|.*sh|wget.*\\|.*sh"; then
                log_threat 65 "Pastebin contains shell script content"
            fi
            
            # Save as evidence
            echo "$paste_content" > "${EVIDENCE_DIR}/pastebin_content_$(date +%s).txt"
        fi
    fi
}

################################################################################
# MOBILE DEEP LINK AND APP SCHEME DETECTION
################################################################################

analyze_mobile_deeplinks() {
    set +u
    local content="${1:-}"
    set -u
    
    if [ "$MOBILE_DEEPLINK_CHECK" = false ]; then
        return
    fi
    
    log_info "Analyzing for mobile deep link threats..."
    
    local mobile_findings=()
    local mobile_score=0
    
    # iOS Deep Link Analysis
    for pattern in "${IOS_DEEPLINK_PATTERNS[@]}"; do
        if echo "$content" | safe_grep_qiE "$pattern"; then
            local matched=$(echo "$content" | safe_grep_oiE "$pattern" 2>/dev/null | head -1)
            mobile_findings+=("ios_deeplink:$matched")
            
            # Critical iOS threats
            if echo "$pattern" | grep -qiE "itms-services|mobileconfig|profile"; then
                log_threat 80 "CRITICAL iOS app/profile installation link: $matched"
                ((mobile_score += 50))
            else
                log_warning "iOS deep link detected: $matched"
                ((mobile_score += 10))
            fi
        fi
    done
    
    # Android Deep Link Analysis
    for pattern in "${ANDROID_DEEPLINK_PATTERNS[@]}"; do
        if echo "$content" | safe_grep_qiE "$pattern"; then
            local matched=$(echo "$content" | safe_grep_oiE "$pattern" 2>/dev/null | head -1)
            mobile_findings+=("android_deeplink:$matched")
            
            # Critical Android threats
            if echo "$pattern" | grep -qiE "intent://|\.apk|\.xapk"; then
                log_threat 75 "CRITICAL Android app installation intent: $matched"
                ((mobile_score += 45))
            else
                log_warning "Android deep link detected: $matched"
                ((mobile_score += 10))
            fi
        fi
    done
    
    # Specific mobile threat analysis
    
    # iOS Enterprise App Distribution (HIGHLY DANGEROUS)
    if echo "$content" | safe_grep_qiE "itms-services://.*action=download-manifest"; then
        log_threat 90 "iOS Enterprise App Distribution link detected - HIGH RISK"
        log_forensic "This type of link bypasses App Store and can install untrusted apps"
        mobile_findings+=("ios_enterprise_distribution")
        ((mobile_score += 60))
        
        # Try to extract manifest URL
        local manifest_url=$(echo "$content" | safe_grep_oiE "url=https?://[^&\"']+" | head -1)
        if [ -n "$manifest_url" ]; then
            log_forensic "Manifest URL: $manifest_url"
            record_ioc "ios_manifest" "$manifest_url" "iOS enterprise distribution manifest"
        fi
    fi
    
    # iOS Configuration Profile (MDM/Malicious Profile)
    if echo "$content" | safe_grep_qiE "\.mobileconfig"; then
        log_threat 85 "iOS Configuration Profile link detected - CRITICAL"
        log_forensic "Mobileconfig files can install certificates, VPNs, and modify device settings"
        mobile_findings+=("ios_mobileconfig")
        ((mobile_score += 55))
    fi
    
    # Android APK direct download
    if echo "$content" | safe_grep_qiE "https?://.*\.apk($|\?)"; then
        log_threat 70 "Direct APK download link detected"
        mobile_findings+=("android_apk_direct")
        ((mobile_score += 40))
        
        local apk_url=$(echo "$content" | safe_grep_oiE "https?://[^[[:space:]]\"']+\.apk" | head -1)
        record_ioc "apk_url" "$apk_url" "Direct APK download"
    fi
    
    # Android Intent with suspicious components
    if echo "$content" | safe_grep_qiE "intent://.*#Intent.*component="; then
        log_threat 75 "Android Intent with explicit component - potential app exploitation"
        mobile_findings+=("android_intent_component")
        ((mobile_score += 45))
    fi
    
    # Check for sideloading indicators
    if echo "$content" | safe_grep_qiE "enable.*unknown.*sources|settings.*security|sideload"; then
        log_threat 60 "Sideloading instruction indicators detected"
        mobile_findings+=("sideloading_instructions")
        ((mobile_score += 35))
    fi
    
    # PWA/WebApp installation
    if echo "$content" | safe_grep_qiE "manifest\.json|service-worker|add.*to.*home.*screen"; then
        log_warning "Progressive Web App indicators detected"
        mobile_findings+=("pwa_indicators")
        ((mobile_score += 15))
    fi
    
    # Generate mobile threat report
    if [ ${#mobile_findings[@]} -gt 0 ]; then
        {
            echo "═══════════════════════════════════════════════"
            echo "MOBILE THREAT ANALYSIS"
            echo "═══════════════════════════════════════════════"
            echo "Timestamp: $(date -Iseconds)"
            echo "Mobile Threat Score: $mobile_score"
            echo ""
            echo "Findings:"
            for finding in "${mobile_findings[@]}"; do
                echo "  - $finding"
            done
            echo ""
            echo "Platform Analysis:"
            echo "  iOS Threats: $(echo "${mobile_findings[@]}" | grep -o "ios_" | wc -l)"
            echo "  Android Threats: $(echo "${mobile_findings[@]}" | grep -o "android_" | wc -l)"
            echo ""
            echo "Risk Assessment:"
            if [ $mobile_score -ge 80 ]; then
                echo "  CRITICAL: High-risk mobile app/profile installation detected"
                echo "  RECOMMENDATION: Do not scan this QR code on mobile devices"
            elif [ $mobile_score -ge 50 ]; then
                echo "  HIGH: Significant mobile threat indicators"
            elif [ $mobile_score -ge 25 ]; then
                echo "  MEDIUM: Mobile deep links present - verify destination"
            else
                echo "  LOW: Minor mobile link indicators"
            fi
            echo ""
        } >> "$MOBILE_THREAT_REPORT"
        
        if [ $mobile_score -ge 40 ]; then
            log_threat $((mobile_score / 2)) "Mobile platform threats detected"
        fi
        
        analysis_success_found "MOBILE-DEEPLINKS" "${#mobile_findings[@]}" "Score: $mobile_score" "$(IFS=', '; echo "${mobile_findings[*]}")"
    else
        analysis_success_none "MOBILE-DEEPLINKS"
    fi
}

################################################################################
# BLUETOOTH / NFC / WIRELESS ATTACK DETECTION
################################################################################

analyze_wireless_attacks() {
    set +u
    local content="${1:-}"
    set -u
    
    if [ "$BLUETOOTH_NFC_CHECK" = false ]; then
        return
    fi
    
    log_info "Analyzing for wireless (BT/NFC/WiFi) attack patterns..."
    
    local wireless_findings=()
    local wireless_score=0
    
    # Bluetooth Pattern Analysis
    for pattern in "${BLUETOOTH_PATTERNS[@]}"; do
        if echo "$content" | safe_grep_qiE "$pattern"; then
            local matched=$(echo "$content" | safe_grep_oiE "$pattern" 2>/dev/null | head -1)
            wireless_findings+=("bluetooth:$matched")
            ((wireless_score += 30))
            log_forensic_detection 35 \
                "WIRELESS Bluetooth Pattern" \
                "pattern:$matched" \
                "Bluetooth URI/protocol detection" \
                "QR decoded content" \
                "Verify Bluetooth pairing request legitimacy before accepting" \
                "Bluetooth Security Advisory"
        fi
    done
    
    # NFC Pattern Analysis
    for pattern in "${NFC_PATTERNS[@]}"; do
        if echo "$content" | safe_grep_qiE "$pattern"; then
            local matched=$(echo "$content" | safe_grep_oiE "$pattern" 2>/dev/null | head -1)
            wireless_findings+=("nfc:$matched")
            ((wireless_score += 25))
            log_forensic_detection 30 \
                "WIRELESS NFC Pattern" \
                "pattern:$matched" \
                "NFC URI/NDEF detection" \
                "QR decoded content" \
                "NFC commands detected - verify source before allowing NFC actions" \
                "NFC Forum Security Guidelines"
        fi
    done
    
    # WiFi Configuration Analysis
    for pattern in "${WIFI_PATTERNS[@]}"; do
        if echo "$content" | safe_grep_qiE "$pattern"; then
            local matched=$(echo "$content" | safe_grep_oiE "$pattern" 2>/dev/null | head -1)
            wireless_findings+=("wifi:$matched")
            
            # WiFi QR codes are common but analyze for risks
            if echo "$content" | safe_grep_qiE "WIFI:.*WEP"; then
                log_forensic_detection 45 \
                    "WIRELESS Insecure WiFi (WEP)" \
                    "encryption:WEP" \
                    "WiFi QR with WEP encryption" \
                    "QR decoded content - WiFi config" \
                    "WEP is broken - do NOT connect. This may be a rogue access point." \
                    "WEP Deprecation - IEEE 802.11i"
                ((wireless_score += 30))
            elif echo "$content" | safe_grep_qiE "WIFI:.*T:nopass"; then
                log_forensic_detection 35 \
                    "WIRELESS Open WiFi Network" \
                    "encryption:none" \
                    "WiFi QR with no password" \
                    "QR decoded content - WiFi config" \
                    "Open network - traffic can be intercepted. Use VPN if connecting." \
                    "Open WiFi Security Risk"
                ((wireless_score += 20))
            else
                log_forensic_detection 10 \
                    "WIRELESS WiFi Configuration" \
                    "type:wifi_qr" \
                    "Standard WiFi QR code" \
                    "QR decoded content - WiFi config" \
                    "Standard use case - verify network name before connecting" \
                    "" \
                    "INFO"
                ((wireless_score += 5))
            fi
        fi
    done
    
    # Bluetooth MAC address analysis
    local bt_mac=$(echo "$content" | safe_grep_oiE "[0-9A-Fa-f]{2}:[0-9A-Fa-f]{2}:[0-9A-Fa-f]{2}:[0-9A-Fa-f]{2}:[0-9A-Fa-f]{2}:[0-9A-Fa-f]{2}" | head -1)
    if [ -n "$bt_mac" ]; then
        wireless_findings+=("mac_address:$bt_mac")
        log_forensic_detection 15 \
            "WIRELESS MAC Address Detected" \
            "mac:$bt_mac" \
            "MAC address pattern matching" \
            "QR decoded content" \
            "Device MAC address found - may be used for device tracking/pairing" \
            "" \
            "INFO"
        record_ioc "mac_address" "$bt_mac" "Device MAC address in QR"
        
        # Check OUI for suspicious manufacturers
        analyze_mac_oui "$bt_mac"
    fi
    
    # Check for device pairing payloads
    if echo "$content" | safe_grep_qiE "pair|bond|connect.*device"; then
        local pair_cmd=$(echo "$content" | safe_grep_oiE "pair|bond|connect.*device" | head -1)
        wireless_findings+=("device_pairing:$pair_cmd")
        ((wireless_score += 15))
        log_forensic_detection 25 \
            "WIRELESS Device Pairing Request" \
            "command:$pair_cmd" \
            "Pairing keyword detection" \
            "QR decoded content" \
            "Device pairing request - verify source before accepting pairing" \
            "Bluetooth Pairing Security"
    fi
    
    # Check for RFID/smartcard patterns
    if echo "$content" | safe_grep_qiE "mifare|desfire|felica|nfc.*tag|rfid|smartcard"; then
        local rfid_type=$(echo "$content" | safe_grep_oiE "mifare|desfire|felica|nfc.*tag|rfid|smartcard" | head -1)
        wireless_findings+=("rfid_smartcard:$rfid_type")
        ((wireless_score += 20))
        log_forensic_detection 30 \
            "WIRELESS RFID/Smartcard Reference" \
            "type:$rfid_type" \
            "RFID/Smartcard technology detection" \
            "QR decoded content" \
            "RFID/Smartcard technology referenced - may target access control systems" \
            "RFID Security Guidelines"
    fi
    
    # Generate wireless analysis report
    if [ ${#wireless_findings[@]} -gt 0 ]; then
        {
            echo "═══════════════════════════════════════════════"
            echo "WIRELESS ATTACK ANALYSIS"
            echo "═══════════════════════════════════════════════"
            echo "Timestamp: $(date -Iseconds)"
            echo "Wireless Threat Score: $wireless_score"
            echo ""
            echo "Findings:"
            for finding in "${wireless_findings[@]}"; do
                echo "  - $finding"
            done
            echo ""
            echo "Technology Breakdown:"
            echo "  Bluetooth: $(echo "${wireless_findings[@]}" | grep -o "bluetooth:" | wc -l || echo 0)"
            echo "  NFC: $(echo "${wireless_findings[@]}" | grep -o "nfc:" | wc -l || echo 0)"
            echo "  WiFi: $(echo "${wireless_findings[@]}" | grep -o "wifi:" | wc -l || echo 0)"
            echo ""
        } >> "${OUTPUT_DIR}/wireless_analysis.txt"
        
        analysis_success_found "WIRELESS" "${#wireless_findings[@]}" "Score: $wireless_score" "$(IFS=', '; echo "${wireless_findings[*]}")"
    else
        analysis_success_none "WIRELESS"
    fi
}

analyze_mac_oui() {
    set +u
    local mac="${1:-}"
    set -u
    local oui="${mac:0:8}"
    
    # Convert to uppercase and replace colons
    oui=$(echo "$oui" | tr '[:lower:]' '[:upper:]' | tr ':' '-')
    
    # Known suspicious OUIs (would be expanded with full database)
    declare -A SUSPICIOUS_OUIS=(
        ["00-00-00"]="Unknown/Invalid"
        ["FF-FF-FF"]="Broadcast address"
        ["00-0C-29"]="VMware"
        ["00-50-56"]="VMware"
        ["08-00-27"]="VirtualBox"
        ["52-54-00"]="QEMU/KVM"
        ["00-16-3E"]="Xen"
        ["00-1C-14"]="VMware"
        ["00-15-5D"]="Hyper-V"
    )
    
    # Safe array lookup
    if [[ -v "SUSPICIOUS_OUIS[$oui]" ]] && [[ -n "${SUSPICIOUS_OUIS[$oui]}" ]]; then
        log_forensic_detection 20 \
            "WIRELESS Suspicious MAC OUI" \
            "oui:$oui, vendor:${SUSPICIOUS_OUIS[$oui]}" \
            "MAC OUI vendor lookup" \
            "Bluetooth/WiFi MAC address" \
            "MAC address belongs to ${SUSPICIOUS_OUIS[$oui]} - verify device legitimacy" \
            "" \
            "INFO"
    fi
}

################################################################################
# USSD / TELEPHONY ATTACK DETECTION
################################################################################

analyze_telephony_attacks() {
    set +u
    local content="${1:-}"
    set -u
    
    log_info "Analyzing for telephony/USSD attacks..."
    
    local telephony_findings=()
    local telephony_score=0
    
    # Check for USSD codes
    for pattern in "${USSD_PATTERNS[@]}"; do
        if echo "$content" | safe_grep_qE "$pattern"; then
            local matched=$(echo "$content" | safe_grep_oE "$pattern" | head -1)
            telephony_findings+=("ussd:$matched")
            ((telephony_score += 40))
            log_forensic_detection 50 \
                "TELEPHONY USSD Code Detected" \
                "code:$matched" \
                "USSD pattern matching" \
                "QR decoded content" \
                "CRITICAL - USSD codes can factory reset, wipe data, or modify device settings" \
                "Mobile Device Attack Vector"
        fi
    done
    
    # Check for tel: URI with suspicious patterns
    if echo "$content" | safe_grep_qiE "tel:[+*#0-9]{5,}"; then
        local tel_uri=$(echo "$content" | safe_grep_oiE "tel:[+*#0-9]{5,}" | head -1)
        telephony_findings+=("tel_uri:$tel_uri")
        
        # Check for premium rate numbers
        if echo "$tel_uri" | grep -qE "tel:(\+?1)?900|tel:(\+?1)?976|tel:(\+44)?9"; then
            log_forensic_detection 60 \
                "TELEPHONY Premium Rate Number" \
                "number:$tel_uri" \
                "Premium rate prefix detection" \
                "Telephone URI" \
                "HIGH COST RISK - Premium rate numbers charge significant fees per call/minute" \
                "FTC Premium Rate Fraud"
            ((telephony_score += 45))
        else
            log_forensic_detection 10 \
                "TELEPHONY Phone Number URI" \
                "number:$tel_uri" \
                "tel: URI detection" \
                "QR decoded content" \
                "Verify phone number legitimacy before calling" \
                "" \
                "INFO"
        fi
        
        # Check for international fraud hotspots
        if echo "$tel_uri" | grep -qE "tel:\+?(232|234|242|243|244|245|246|247|248|249|251|252|253|254|255|256|257|258|260|261|262|263|264|265|266|267|268|269)"; then
            log_forensic_detection 35 \
                "TELEPHONY High-Fraud Region Number" \
                "number:$tel_uri" \
                "Country code fraud hotspot detection" \
                "Telephone URI" \
                "International number to region frequently associated with toll fraud" \
                "Wangiri/Callback Fraud"
            ((telephony_score += 30))
        fi
    fi
    
    # Check for SMS URI with suspicious content
    if echo "$content" | safe_grep_qiE "sms:[+0-9]{5,}"; then
        local sms_uri=$(echo "$content" | safe_grep_oiE "sms:[^?&[[:space:]]]+" | head -1)
        telephony_findings+=("sms_uri:$sms_uri")
        ((telephony_score += 10))
        
        # Check for SMS body with suspicious keywords
        if echo "$content" | safe_grep_qiE "sms:.*body=.*(subscribe|stop|yes|confirm|verify|code)"; then
            log_forensic_detection 30 \
                "TELEPHONY SMS Subscription Scam" \
                "uri:$sms_uri" \
                "SMS action keyword detection" \
                "SMS URI body parameter" \
                "Potential premium subscription scam - do not send this SMS" \
                "SMS Fraud Pattern"
            ((telephony_score += 25))
        else
            log_forensic_detection 10 \
                "TELEPHONY SMS URI Detected" \
                "uri:$sms_uri" \
                "sms: URI detection" \
                "QR decoded content" \
                "Verify SMS recipient and content before sending" \
                "" \
                "INFO"
        fi
    fi
    
    # Check for FaceTime/VoIP schemes
    if echo "$content" | safe_grep_qiE "facetime://|facetime-audio://|sip:|sips:"; then
        local voip_uri=$(echo "$content" | safe_grep_oiE "(facetime://|facetime-audio://|sips?:)[^[:space:]]+" | head -1)
        log_forensic_detection 10 \
            "TELEPHONY VoIP/FaceTime Link" \
            "uri:$voip_uri" \
            "VoIP protocol detection" \
            "QR decoded content" \
            "VoIP/video call link detected - verify recipient identity" \
            "" \
            "INFO"
        telephony_findings+=("voip_link:$voip_uri")
        ((telephony_score += 5))
    fi
    
    # Report findings
    if [ ${#telephony_findings[@]} -gt 0 ]; then
        {
            echo "═══════════════════════════════════════════════"
            echo "TELEPHONY/USSD ATTACK ANALYSIS"
            echo "═══════════════════════════════════════════════"
            echo "Timestamp: $(date -Iseconds)"
            echo "Telephony Threat Score: $telephony_score"
            echo ""
            echo "Findings:"
            for finding in "${telephony_findings[@]}"; do
                echo "  - $finding"
            done
            echo ""
            if [ $telephony_score -ge 40 ]; then
                echo "WARNING: High-risk telephony threats detected!"
                echo "USSD codes can factory reset devices or modify settings"
            fi
            echo ""
        } >> "${OUTPUT_DIR}/telephony_analysis.txt"
        
        analysis_success_found "TELEPHONY" "${#telephony_findings[@]}" "Score: $telephony_score" "$(IFS=', '; echo "${telephony_findings[*]}")"
    else
        analysis_success_none "TELEPHONY"
    fi
}

################################################################################
# HARDWARE / IOT EXPLOIT DETECTION
################################################################################

analyze_hardware_exploits() {
    set +u
    local content="${1:-}"
    set -u
    
    if [ "$HARDWARE_EXPLOIT_CHECK" = false ]; then
        return
    fi
    
    log_info "Analyzing for hardware/IoT exploit patterns..."
    
    local hardware_findings=()
    local hardware_score=0
    
    # Check hardware exploit patterns
    for pattern in "${HARDWARE_EXPLOIT_PATTERNS[@]}"; do
        # Skip empty patterns
        [ -z "$pattern" ] && continue
        if echo "$content" | safe_grep_qiE "$pattern" 2>/dev/null; then
            local matched=$(echo "$content" | safe_grep_oiE "$pattern" 2>/dev/null | head -1)
            hardware_findings+=("hardware_exploit:$matched")
            ((hardware_score += 35))
            log_forensic_detection 45 \
                "HARDWARE-IOT Exploit Pattern" \
                "pattern:$matched" \
                "Hardware exploit pattern matching" \
                "QR decoded content" \
                "Review for IoT/embedded device targeting - may indicate hardware attack vector" \
                "MITRE ATT&CK T1200 - Hardware Additions"
        fi
    done
    
    # Buffer overflow attempt detection
    local long_strings=$(echo "$content" | safe_grep_oE "[A-Za-z0-9]{200,}" | head -1)
    if [ -n "$long_strings" ]; then
        hardware_findings+=("buffer_overflow_attempt")
        ((hardware_score += 40))
        log_forensic_detection 55 \
            "HARDWARE-IOT Buffer Overflow Attempt" \
            "payload_length:${#long_strings}" \
            "Long repeated string detection (>200 chars)" \
            "QR decoded content" \
            "CRITICAL - Potential buffer overflow payload targeting embedded systems" \
            "CWE-120 Buffer Overflow"
    fi
    
    # Format string attack detection
    if echo "$content" | safe_grep_qE "%[nxsp]{5,}|%[0-9]*\$n"; then
        local format_pattern=$(echo "$content" | safe_grep_oE "%[nxsp]{5,}|%[0-9]*\$n" | head -1)
        hardware_findings+=("format_string_attack")
        ((hardware_score += 45))
        log_forensic_detection 60 \
            "HARDWARE-IOT Format String Attack" \
            "pattern:$format_pattern" \
            "Format string vulnerability pattern" \
            "QR decoded content" \
            "CRITICAL - Format string attack targeting embedded systems" \
            "CWE-134 Format String Vulnerability"
    fi
    
    # Null byte injection
    if echo "$content" | safe_grep_qE "%00|\\x00"; then
        hardware_findings+=("null_byte_injection")
        ((hardware_score += 25))
        log_forensic_detection 40 \
            "HARDWARE-IOT Null Byte Injection" \
            "technique:null_byte" \
            "Null byte pattern detection" \
            "QR decoded content" \
            "Null byte injection may bypass input validation on embedded systems" \
            "CWE-626 Null Byte Interaction"
    fi
    
    # POS terminal specific
    if echo "$content" | safe_grep_qiE "verifone|ingenico|pax.*terminal|magtek|id.*tech"; then
        local pos_brand=$(echo "$content" | safe_grep_oiE "verifone|ingenico|pax.*terminal|magtek|id.*tech" | head -1)
        hardware_findings+=("pos_terminal_reference:$pos_brand")
        ((hardware_score += 35))
        log_forensic_detection 50 \
            "HARDWARE-IOT POS Terminal Target" \
            "brand:$pos_brand" \
            "POS terminal brand detection" \
            "QR decoded content" \
            "HIGH RISK - QR targets Point-of-Sale terminal - potential card skimming/fraud" \
            "PCI-DSS Compliance Risk"
    fi
    
    # IoT device specific
    if echo "$content" | safe_grep_qiE "hikvision|dahua|foscam|axis.*camera|ubiquiti|mikrotik|tp-link"; then
        local iot_brand=$(echo "$content" | safe_grep_oiE "hikvision|dahua|foscam|axis.*camera|ubiquiti|mikrotik|tp-link" | head -1)
        hardware_findings+=("iot_device_brand:$iot_brand")
        ((hardware_score += 20))
        log_forensic_detection 35 \
            "HARDWARE-IOT Device Brand Detected" \
            "brand:$iot_brand" \
            "IoT device brand detection" \
            "QR decoded content" \
            "Check for default credentials - IoT devices frequently targeted" \
            "MITRE ATT&CK T1078 - Valid Accounts"
    fi
    
    # RTSP stream hijacking
    if echo "$content" | safe_grep_qiE "rtsp://"; then
        local rtsp_url=$(echo "$content" | safe_grep_oiE "rtsp://[^[[:space:]]\"']+" | head -1)
        hardware_findings+=("rtsp_stream:$rtsp_url")
        ((hardware_score += 30))
        log_forensic_detection 45 \
            "HARDWARE-IOT RTSP Stream Access" \
            "url:$rtsp_url" \
            "RTSP protocol URL detection" \
            "QR decoded content - URL" \
            "Potential unauthorized camera/video stream access" \
            "MITRE ATT&CK T1125 - Video Capture"
        record_ioc "rtsp_url" "$rtsp_url" "RTSP streaming URL"
    fi
    
    # Printer exploit patterns
    if echo "$content" | safe_grep_qiE "@PJL|%-12345X|PostScript"; then
        local printer_cmd=$(echo "$content" | safe_grep_oiE "@PJL|%-12345X|PostScript" | head -1)
        hardware_findings+=("pjl_commands:$printer_cmd")
        ((hardware_score += 35))
        log_forensic_detection 45 \
            "HARDWARE-IOT Printer Exploit" \
            "command:$printer_cmd" \
            "Printer Job Language (PJL) detection" \
            "QR decoded content" \
            "Printer exploitation attempt - may execute arbitrary commands on network printers" \
            "MITRE ATT&CK T1565 - Data Manipulation"
    fi
    
    # Generate hardware exploit report
    if [ ${#hardware_findings[@]} -gt 0 ]; then
        {
            echo "═══════════════════════════════════════════════"
            echo "HARDWARE/IOT EXPLOIT ANALYSIS"
            echo "═══════════════════════════════════════════════"
            echo "Timestamp: $(date -Iseconds)"
            echo "Hardware Threat Score: $hardware_score"
            echo ""
            echo "Findings:"
            for finding in "${hardware_findings[@]}"; do
                echo "  - $finding"
            done
            echo ""
            echo "Risk Categories:"
            echo "  Buffer Overflow: $(echo "${hardware_findings[@]}" | grep -c "buffer" || echo 0)"
            echo "  POS Terminals: $(echo "${hardware_findings[@]}" | grep -c "pos" || echo 0)"
            echo "  IoT Devices: $(echo "${hardware_findings[@]}" | grep -c "iot" || echo 0)"
            echo "  Cameras/RTSP: $(echo "${hardware_findings[@]}" | grep -c "rtsp\|camera" || echo 0)"
            echo ""
        } >> "$HARDWARE_EXPLOIT_REPORT"
        
        analysis_success_found "HARDWARE-IOT" "${#hardware_findings[@]}" "Score: $hardware_score" "$(IFS=', '; echo "${hardware_findings[*]}")"
    else
        analysis_success_none "HARDWARE-IOT"
    fi
}

################################################################################
# GEOFENCING AND CLOAKING DETECTION
################################################################################

analyze_geofencing_cloaking() {
    set +u
    local content="${1:-}"
    set -u
    
    if [ "$GEOFENCING_CHECK" = false ]; then
        return
    fi
    
    log_info "Analyzing for geofencing and cloaking patterns..."
    
    local geo_findings=()
    local geo_score=0
    
    # Check geofencing patterns
    for pattern in "${GEOFENCING_PATTERNS[@]}"; do
        if echo "$content" | safe_grep_qiE "$pattern"; then
            local matched=$(echo "$content" | safe_grep_oiE "$pattern" 2>/dev/null | head -1)
            geo_findings+=("geofencing:$matched")
            ((geo_score += 15))
            log_info "Geofencing indicator: $matched"
        fi
    done
    
    # Check cloaking patterns
    for pattern in "${CLOAKING_PATTERNS[@]}"; do
        if echo "$content" | safe_grep_qiE "$pattern"; then
            local matched=$(echo "$content" | safe_grep_oiE "$pattern" 2>/dev/null | head -1)
            geo_findings+=("cloaking:$matched")
            ((geo_score += 20))
            log_warning "Cloaking technique indicator: $matched"
        fi
    done
    
    # Canvas fingerprinting detection
    if echo "$content" | safe_grep_qiE "toDataURL.*canvas|getImageData|measureText"; then
        log_threat 35 "Canvas fingerprinting detected"
        geo_findings+=("canvas_fingerprinting")
        ((geo_score += 25))
    fi
    
    # WebGL fingerprinting
    if echo "$content" | safe_grep_qiE "WEBGL.*renderer|getExtension.*WEBGL|getParameter"; then
        log_warning "WebGL fingerprinting indicators"
        geo_findings+=("webgl_fingerprinting")
        ((geo_score += 20))
    fi
    
    # Audio fingerprinting
    if echo "$content" | safe_grep_qiE "AudioContext.*createOscillator|OfflineAudioContext"; then
        log_warning "Audio fingerprinting indicators"
        geo_findings+=("audio_fingerprinting")
        ((geo_score += 20))
    fi
    
    # User-Agent based cloaking
    if echo "$content" | safe_grep_qiE "Googlebot|Bingbot|facebookexternalhit|Twitterbot.*redirect"; then
        log_threat 40 "Bot detection with redirect - likely cloaking"
        geo_findings+=("bot_cloaking")
        ((geo_score += 30))
    fi
    
    # Time-based delivery
    if echo "$content" | safe_grep_qiE "setTimeout.*redirect|setInterval.*location|delay.*href"; then
        log_warning "Time-delayed redirect - potential cloaking"
        geo_findings+=("time_delayed_redirect")
        ((geo_score += 20))
    fi
    
    # Generate cloaking report
    if [ ${#geo_findings[@]} -gt 0 ]; then
        {
            echo "═══════════════════════════════════════════════"
            echo "GEOFENCING AND CLOAKING ANALYSIS"
            echo "═══════════════════════════════════════════════"
            echo "Timestamp: $(date -Iseconds)"
            echo "Cloaking Score: $geo_score"
            echo ""
            echo "Findings:"
            for finding in "${geo_findings[@]}"; do
                echo "  - $finding"
            done
            echo ""
            echo "Detection Techniques Found:"
            echo "  Geolocation: $(echo "${geo_findings[@]}" | grep -c "geofencing")"
            echo "  Fingerprinting: $(echo "${geo_findings[@]}" | grep -c "fingerprint")"
            echo "  Bot Cloaking: $(echo "${geo_findings[@]}" | grep -c "cloak\|bot")"
            echo ""
            if [ $geo_score -ge 40 ]; then
                echo "WARNING: Content may serve different payloads based on visitor"
                echo "Analysis may not reflect what end users see"
            fi
            echo ""
        } >> "$GEOFENCING_REPORT"
        
        if [ $geo_score -ge 30 ]; then
            log_threat $((geo_score / 3)) "Geofencing/Cloaking detected"
        fi
        
        analysis_success_found "GEOFENCING" "${#geo_findings[@]}" "Score: $geo_score" "$(IFS=', '; echo "${geo_findings[*]}")"
    else
        analysis_success_none "GEOFENCING"
    fi
}


################################################################################
# FILELESS MALWARE / LIVING-OFF-THE-LAND DETECTION
################################################################################

analyze_fileless_malware() {
    set +u
    local content="${1:-}"
    set -u
    
    if [ "$FILELESS_MALWARE_CHECK" = false ]; then
        return
    fi
    
    log_info "Analyzing for fileless malware and LOTL techniques..."
    
    local fileless_findings=()
    local fileless_score=0
    
    # Helper function to safely grep patterns
    safe_pattern_grep() {
        local pattern="$1"
        local text="$2"
        local mode="$3"  # "quiet" or "output"
        
        if [ "$mode" = "quiet" ]; then
            printf '%s' "$text" | grep -qiE -- "$pattern" 2>/dev/null
            return $?
        else
            printf '%s' "$text" | grep -oiE -- "$pattern" 2>/dev/null | head -1
        fi
    }
    
    # LOLBAS Pattern Analysis (Windows)
    local i=0
    while [ $i -lt ${#LOLBAS_PATTERNS[@]} ]; do
        pattern="${LOLBAS_PATTERNS[$i]}"
        if [ -n "$pattern" ] && safe_pattern_grep "$pattern" "$content" "quiet"; then
            local matched
            matched=$(safe_pattern_grep "$pattern" "$content" "output")
            if [ -n "$matched" ]; then
                fileless_findings+=("lolbas: $matched")
                ((fileless_score += 40))
                log_forensic_detection 50 \
                    "FILELESS LOLBAS Technique" \
                    "binary: $matched" \
                    "Living Off The Land Binary pattern" \
                    "QR decoded content" \
                    "Windows LOLBin abuse - legitimate binary used for malicious purposes" \
                    "MITRE ATT&CK T1218 - Signed Binary Proxy Execution"
            fi
        fi
        ((i++))
    done
    
    # GTFOBins Pattern Analysis (Linux)
    i=0
    while [ $i -lt ${#GTFOBINS_PATTERNS[@]} ]; do
        pattern="${GTFOBINS_PATTERNS[$i]}"
        if [ -n "$pattern" ] && safe_pattern_grep "$pattern" "$content" "quiet"; then
            local matched
            matched=$(safe_pattern_grep "$pattern" "$content" "output")
            if [ -n "$matched" ]; then
                fileless_findings+=("gtfobins:$matched")
                ((fileless_score += 35))
                log_forensic_detection 45 \
                    "FILELESS GTFOBins Technique" \
                    "binary:$matched" \
                    "GTFOBins Unix binary abuse pattern" \
                    "QR decoded content" \
                    "Unix binary abuse for privilege escalation or code execution" \
                    "MITRE ATT&CK T1059.004 - Unix Shell"
            fi
        fi
        ((i++))
    done
    
    # AMSI Bypass Detection
    i=0
    while [ $i -lt ${#AMSI_BYPASS_PATTERNS[@]} ]; do
        pattern="${AMSI_BYPASS_PATTERNS[$i]}"
        if [ -n "$pattern" ] && safe_pattern_grep "$pattern" "$content" "quiet"; then
            local matched
            matched=$(safe_pattern_grep "$pattern" "$content" "output")
            if [ -n "$matched" ]; then
                fileless_findings+=("amsi_bypass:$matched")
                ((fileless_score += 50))
                log_forensic_detection 60 \
                    "FILELESS AMSI Bypass" \
                    "technique: $matched" \
                    "Antimalware Scan Interface bypass pattern" \
                    "QR decoded content" \
                    "AMSI bypass allows malware to evade Windows Defender and security tools" \
                    "MITRE ATT&CK T1562.001 - Disable Security Tools"
            fi
        fi
        ((i++))
    done
    
    # Office Macro Analysis
    i=0
    while [ $i -lt ${#OFFICE_MACRO_PATTERNS[@]} ]; do
        pattern="${OFFICE_MACRO_PATTERNS[$i]}"
        if [ -n "$pattern" ] && safe_pattern_grep "$pattern" "$content" "quiet"; then
            local matched
            matched=$(safe_pattern_grep "$pattern" "$content" "output")
            if [ -n "$matched" ]; then
                fileless_findings+=("office_macro:$matched")
                ((fileless_score += 35))
                log_forensic_detection 45 \
                    "FILELESS Office Macro Indicator" \
                    "indicator:$matched" \
                    "Office macro pattern detection" \
                    "QR decoded content" \
                    "Office macro code detected - common malware delivery vector" \
                    "MITRE ATT&CK T1566.001 - Spearphishing Attachment"
            fi
        fi
        ((i++))
    done
    
    # Follina/MSDT Detection
    i=0
    while [ $i -lt ${#FOLLINA_PATTERNS[@]} ]; do
        pattern="${FOLLINA_PATTERNS[$i]}"
        if [ -n "$pattern" ] && safe_pattern_grep "$pattern" "$content" "quiet"; then
            local matched
            matched=$(safe_pattern_grep "$pattern" "$content" "output")
            if [ -n "$matched" ]; then
                fileless_findings+=("follina:$matched")
                ((fileless_score += 60))
                log_forensic_detection 80 \
                    "FILELESS Follina/MSDT Exploit" \
                    "pattern:$matched" \
                    "CVE-2022-30190 Follina pattern" \
                    "QR decoded content" \
                    "CRITICAL - Follina exploit allows remote code execution via MSDT" \
                    "CVE-2022-30190"
            fi
        fi
        ((i++))
    done
    
    # OLE Object Abuse
    i=0
    while [ $i -lt ${#OLE_PATTERNS[@]} ]; do
        pattern="${OLE_PATTERNS[$i]}"
        if [ -n "$pattern" ] && safe_pattern_grep "$pattern" "$content" "quiet"; then
            local matched
            matched=$(safe_pattern_grep "$pattern" "$content" "output")
            if [ -n "$matched" ]; then
                fileless_findings+=("ole_abuse: $matched")
                ((fileless_score += 40))
                log_forensic_detection 50 \
                    "FILELESS OLE Object Abuse" \
                    "pattern: $matched" \
                    "OLE/COM object pattern detection" \
                    "QR decoded content" \
                    "OLE object abuse for malware execution" \
                    "MITRE ATT&CK T1559.001 - Component Object Model"
            fi
        fi
        ((i++))
    done
    
    # PowerShell Download Cradles
    if printf '%s' "$content" | grep -qiE -- 'IEX[[:space:]]*\([[:space:]]*New-Object[[:space:]]+Net\.WebClient[[:space:]]*\)[[:space:]]*\.DownloadString' 2>/dev/null; then
        log_forensic_detection 70 \
            "FILELESS PowerShell Download Cradle" \
            "technique:IEX+WebClient+DownloadString" \
            "Classic download cradle pattern" \
            "QR decoded content" \
            "PowerShell downloading and executing remote code in memory" \
            "MITRE ATT&CK T1059.001 - PowerShell"
        fileless_findings+=("ps_download_cradle")
        ((fileless_score += 55))
    fi
    
    if printf '%s' "$content" | grep -qiE -- 'Invoke-Expression.*Invoke-WebRequest' 2>/dev/null; then
        log_forensic_detection 65 \
            "FILELESS PowerShell IEX+IWR" \
            "technique:IEX+IWR" \
            "PowerShell download and execute pattern" \
            "QR decoded content" \
            "PowerShell fetching and executing remote script" \
            "MITRE ATT&CK T1059.001 - PowerShell"
        fileless_findings+=("ps_iex_iwr")
        ((fileless_score += 50))
    fi
    
    # Encoded PowerShell - fixed pattern without problematic quantifier
    if printf '%s' "$content" | grep -qiE -- 'powershell.*-[eE][nN][cC].*[A-Za-z0-9+/=][A-Za-z0-9+/=][A-Za-z0-9+/=][A-Za-z0-9+/=][A-Za-z0-9+/=][A-Za-z0-9+/=][A-Za-z0-9+/=][A-Za-z0-9+/=][A-Za-z0-9+/=][A-Za-z0-9+/=]' 2>/dev/null; then
        log_forensic_detection 75 \
            "FILELESS Encoded PowerShell" \
            "technique:Base64_EncodedCommand" \
            "PowerShell -EncodedCommand detection" \
            "QR decoded content" \
            "Base64 encoded PowerShell - common evasion technique" \
            "MITRE ATT&CK T1027 - Obfuscated Files"
        fileless_findings+=("encoded_powershell")
        ((fileless_score += 55))
        
        # Try to extract and decode - fixed pattern
        local encoded_cmd
        encoded_cmd=$(printf '%s' "$content" | grep -oiE -- '[A-Za-z0-9+/=]{50,}' 2>/dev/null | head -1)
        if [ -n "$encoded_cmd" ]; then
            local decoded
            decoded=$(printf '%s' "$encoded_cmd" | base64 -d 2>/dev/null | iconv -f UTF-16LE -t UTF-8 2>/dev/null)
            if [ -n "$decoded" ]; then
                log_forensic "Decoded PowerShell: ${decoded: 0:200}"
                echo "Decoded PowerShell: $decoded" >> "$FILELESS_REPORT"
                
                # Recursively analyze decoded content
                analyze_decoded_content_threats "$decoded"
            fi
        fi
    fi
    
    # WMIC process creation
    if printf '%s' "$content" | grep -qiE -- 'wmic.*process.*call.*create' 2>/dev/null; then
        log_forensic_detection 55 \
            "FILELESS WMIC Process Creation" \
            "technique: WMIC_process_create" \
            "WMI process spawn pattern" \
            "QR decoded content" \
            "WMIC used to spawn processes - bypasses traditional execution logging" \
            "MITRE ATT&CK T1047 - WMI"
        fileless_findings+=("wmic_process_create")
        ((fileless_score += 40))
    fi
    
    # Certutil abuse
    if printf '%s' "$content" | grep -qiE -- 'certutil.*-urlcache.*-f.*http' 2>/dev/null; then
        log_forensic_detection 65 \
            "FILELESS Certutil Download" \
            "technique:certutil_urlcache" \
            "Certutil download abuse pattern" \
            "QR decoded content" \
            "Certutil abused to download files - legitimate Windows tool" \
            "MITRE ATT&CK T1105 - Ingress Tool Transfer"
        fileless_findings+=("certutil_download")
        ((fileless_score += 50))
    fi
    
    if printf '%s' "$content" | grep -qiE -- 'certutil.*-decode' 2>/dev/null; then
        log_forensic_detection 50 \
            "FILELESS Certutil Decode" \
            "technique: certutil_decode" \
            "Certutil base64 decode pattern" \
            "QR decoded content" \
            "Certutil decode operation - may extract hidden payload" \
            "MITRE ATT&CK T1140 - Deobfuscate/Decode"
        fileless_findings+=("certutil_decode")
        ((fileless_score += 35))
    fi
    
    # BITSAdmin abuse
    if printf '%s' "$content" | grep -qiE -- 'bitsadmin.*/transfer|bitsadmin.*/addfile' 2>/dev/null; then
        log_forensic_detection 55 \
            "FILELESS BITSAdmin Transfer" \
            "technique:bitsadmin_transfer" \
            "BITS service download abuse" \
            "QR decoded content" \
            "BITSAdmin used for stealthy file download" \
            "MITRE ATT&CK T1197 - BITS Jobs"
        fileless_findings+=("bitsadmin_abuse")
        ((fileless_score += 40))
    fi
    
    # MSHTA abuse
    if printf '%s' "$content" | grep -qiE -- 'mshta.*(vbscript|javascript|http)' 2>/dev/null; then
        log_forensic_detection 70 \
            "FILELESS MSHTA Execution" \
            "technique:mshta_script" \
            "MSHTA script execution pattern" \
            "QR decoded content" \
            "MSHTA executing script - bypasses application whitelisting" \
            "MITRE ATT&CK T1218.005 - MSHTA"
        fileless_findings+=("mshta_abuse")
        ((fileless_score += 55))
    fi
    
    # Regsvr32 scriptlet
    if printf '%s' "$content" | grep -qiE -- 'regsvr32.*/s.*/n.*/u.*/i:' 2>/dev/null; then
        log_forensic_detection 65 \
            "FILELESS Regsvr32 Scriptlet" \
            "technique:regsvr32_sct" \
            "Regsvr32 COM scriptlet execution" \
            "QR decoded content" \
            "Regsvr32 Squiblydoo attack - executes remote scriptlet" \
            "MITRE ATT&CK T1218.010 - Regsvr32"
        fileless_findings+=("regsvr32_scriptlet")
        ((fileless_score += 50))
    fi
    
    # WMI Event Subscription
    if printf '%s' "$content" | grep -qiE -- '__EventFilter|__EventConsumer|CommandLineEventConsumer' 2>/dev/null; then
        log_forensic_detection 70 \
            "FILELESS WMI Persistence" \
            "technique:WMI_event_subscription" \
            "WMI event consumer pattern" \
            "QR decoded content" \
            "WMI event subscription persistence - survives reboots" \
            "MITRE ATT&CK T1546.003 - WMI Event Subscription"
        fileless_findings+=("wmi_persistence")
        ((fileless_score += 55))
    fi
    
    # Generate fileless malware report
    if [ ${#fileless_findings[@]} -gt 0 ]; then
        {
            echo "═══════════════════════════════════════════════"
            echo "FILELESS MALWARE / LOTL ANALYSIS"
            echo "═══════════════════════════════════════════════"
            echo "Timestamp: $(date -Iseconds)"
            echo "Fileless Threat Score: $fileless_score"
            echo ""
            echo "Findings:"
            for finding in "${fileless_findings[@]}"; do
                echo "  - $finding"
            done
            echo ""
            echo "Technique Categories:"
            echo "  LOLBAS (Windows): $(printf '%s\n' "${fileless_findings[@]}" | grep -c "lolbas" || echo 0)"
            echo "  GTFOBins (Linux): $(printf '%s\n' "${fileless_findings[@]}" | grep -c "gtfobins" || echo 0)"
            echo "  AMSI Bypass: $(printf '%s\n' "${fileless_findings[@]}" | grep -c "amsi" || echo 0)"
            echo "  Office Macros: $(printf '%s\n' "${fileless_findings[@]}" | grep -c -E "office|ole" || echo 0)"
            echo "  PowerShell: $(printf '%s\n' "${fileless_findings[@]}" | grep -c -E "ps_|powershell" || echo 0)"
            echo ""
            echo "MITRE ATT&CK Mapping:"
            echo "  T1059 - Command and Scripting Interpreter"
            echo "  T1218 - Signed Binary Proxy Execution"
            echo "  T1546 - Event Triggered Execution"
            echo "  T1047 - Windows Management Instrumentation"
            echo "  T1140 - Deobfuscate/Decode Files"
            echo ""
        } >> "$FILELESS_REPORT"
        
        if [ $fileless_score -ge 40 ]; then
            log_threat $((fileless_score / 2)) "Fileless malware techniques detected"
        fi
        
        analysis_success_found "FILELESS" "${#fileless_findings[@]}" "Score: $fileless_score" "$(IFS=', '; echo "${fileless_findings[*]}")"
    else
        analysis_success_none "FILELESS"
    fi
}

################################################################################
# EMERGING ATTACK TECHNIQUES DETECTION
################################################################################

# 1. QRLJacking - QR Login Jacking attacks
detect_qrljacking() {
    local content="$1"
    
    log_info "Analyzing for QRLJacking attacks..."
    
    local qrlj_findings=()
    local qrlj_score=0
    
    # WhatsApp Web QR login patterns
    if echo "$content" | safe_grep_qiE "web\.whatsapp\.com|wa\.me.*qr"; then
        qrlj_findings+=("whatsapp_web_qr")
        ((qrlj_score += 60))
        log_forensic_detection 60 \
            "QRLJacking - WhatsApp Web" \
            "service:WhatsApp Web QR login" \
            "WhatsApp Web QR code pattern detected" \
            "QR decoded content" \
            "Potential session hijacking via QR code - attacker can intercept WhatsApp session" \
            "MITRE ATT&CK T1539 - Steal Web Session Cookie"
    fi
    
    # WeChat QR login patterns
    if echo "$content" | safe_grep_qiE "wx\.qq\.com|wechat.*login.*qr"; then
        qrlj_findings+=("wechat_qr_login")
        ((qrlj_score += 55))
        log_forensic_detection 55 \
            "QRLJacking - WeChat" \
            "service:WeChat QR login" \
            "WeChat QR login pattern detected" \
            "QR decoded content" \
            "Potential QR-based session hijacking attack" \
            "MITRE ATT&CK T1539 - Steal Web Session Cookie"
    fi
    
    # Generic QR login session patterns
    if echo "$content" | safe_grep_qiE "qr.*login|login.*qr.*session|scan.*authenticate"; then
        qrlj_findings+=("generic_qr_login")
        ((qrlj_score += 40))
        log_forensic_detection 40 \
            "QRLJacking - Generic QR Login" \
            "pattern:QR login session" \
            "Generic QR-based authentication pattern" \
            "QR decoded content" \
            "QR code may facilitate session hijacking if scanned by victim" \
            "MITRE ATT&CK T1539 - Steal Web Session Cookie"
    fi
    
    # QR authentication token patterns
    if echo "$content" | safe_grep_qiE "auth.*token.*qr|qr.*session.*token"; then
        qrlj_findings+=("qr_auth_token")
        ((qrlj_score += 50))
        log_forensic_detection 50 \
            "QRLJacking - Authentication Token" \
            "pattern:QR authentication token" \
            "QR-embedded authentication token detected" \
            "QR decoded content" \
            "Authentication token in QR - may enable unauthorized access" \
            "MITRE ATT&CK T1528 - Steal Application Access Token"
    fi
    
    if [ ${#qrlj_findings[@]} -gt 0 ]; then
        log_threat $((qrlj_score / 2)) "QRLJacking attack indicators detected: ${qrlj_findings[*]}"
        analysis_success_found "QRLJacking" "${#qrlj_findings[@]}" "Score: $qrlj_score" "${qrlj_findings[*]}"
    else
        analysis_success_none "QRLJacking"
    fi
}

# 2. Quishing Kits - Known QR phishing kit signatures
detect_quishing_kits() {
    local content="$1"
    
    log_info "Analyzing for quishing kit signatures..."
    
    local quish_findings=()
    local quish_score=0
    
    # Known phishing kit URL patterns
    local phishing_kit_patterns=(
        "phishkit"
        "scampage"
        "panel.*phish"
        "admin.*login.*fake"
        "credential.*harvester"
        "x-mailer.*phishkit"
        "phisherman"
        "blackeye"
        "setoolkit"
        "socialfish"
    )
    
    for pattern in "${phishing_kit_patterns[@]}"; do
        if echo "$content" | safe_grep_qiE "$pattern"; then
            quish_findings+=("kit_signature:$pattern")
            ((quish_score += 70))
            log_forensic_detection 70 \
                "Quishing Kit Detected" \
                "signature:$pattern" \
                "Known phishing kit signature in QR content" \
                "QR decoded content" \
                "QR code contains known phishing kit indicators - likely credential theft operation" \
                "MITRE ATT&CK T1566.002 - Phishing: Spearphishing Link"
        fi
    done
    
    # QR-specific phishing indicators
    if echo "$content" | safe_grep_qiE "qr.*phish|phish.*qr|quishing"; then
        quish_findings+=("qr_phishing_term")
        ((quish_score += 80))
        log_forensic_detection 80 \
            "Quishing Term Detected" \
            "pattern:QR phishing terminology" \
            "QR phishing (quishing) related terms found" \
            "QR decoded content" \
            "Content explicitly references QR phishing - high confidence attack" \
            "MITRE ATT&CK T1566.002 - Phishing: Spearphishing Link"
    fi
    
    # Multi-factor bypass indicators
    if echo "$content" | safe_grep_qiE "bypass.*2fa|mfa.*bypass|otp.*bypass"; then
        quish_findings+=("mfa_bypass")
        ((quish_score += 75))
        log_forensic_detection 75 \
            "MFA Bypass Indicator" \
            "pattern:2FA/MFA bypass" \
            "Multi-factor authentication bypass indicators" \
            "QR decoded content" \
            "QR may be used to bypass MFA protections" \
            "MITRE ATT&CK T1556 - Modify Authentication Process"
    fi
    
    if [ ${#quish_findings[@]} -gt 0 ]; then
        log_threat $((quish_score / 2)) "Quishing kit signatures detected: ${quish_findings[*]}"
        analysis_success_found "Quishing Kits" "${#quish_findings[@]}" "Score: $quish_score" "${quish_findings[*]}"
    else
        analysis_success_none "Quishing Kits"
    fi
}

# 3. QR Overlay Malware - QR overlay attack indicators
detect_qr_overlay_malware() {
    local content="$1"
    
    log_info "Analyzing for QR overlay malware..."
    
    local overlay_score=0
    local overlay_findings=()
    
    # Check against OVERLAY_ATTACK_PATTERNS array
    for pattern in "${OVERLAY_ATTACK_PATTERNS[@]}"; do
        if echo "$content" | safe_grep_qiE "$pattern"; then
            overlay_findings+=("overlay_pattern:$pattern")
            ((overlay_score += 50))
            log_forensic_detection 50 \
                "QR Overlay Malware Pattern" \
                "pattern:$pattern" \
                "Screen overlay attack pattern detected" \
                "QR decoded content" \
                "QR may trigger overlay malware - intercepts user input" \
                "MITRE ATT&CK T1056.002 - Input Capture: GUI Input Capture"
        fi
    done
    
    # JavaScript-based overlay patterns
    if echo "$content" | safe_grep_qiE "createElement.*overlay|appendChild.*overlay|z-index.*9999"; then
        overlay_findings+=("js_overlay_injection")
        ((overlay_score += 65))
        log_forensic_detection 65 \
            "JavaScript Overlay Injection" \
            "technique:DOM overlay manipulation" \
            "JavaScript overlay injection pattern" \
            "QR decoded content" \
            "Malicious overlay injection via JavaScript - credential theft vector" \
            "MITRE ATT&CK T1189 - Drive-by Compromise"
    fi
    
    # CSS-based overlay/clickjacking
    if echo "$content" | safe_grep_qiE "opacity:.*0|visibility:.*hidden.*position:.*absolute"; then
        overlay_findings+=("css_clickjacking")
        ((overlay_score += 55))
        log_forensic_detection 55 \
            "CSS Clickjacking Pattern" \
            "technique:CSS opacity manipulation" \
            "CSS-based clickjacking indicators" \
            "QR decoded content" \
            "Invisible overlay for clickjacking attack" \
            "MITRE ATT&CK T1656 - Impersonation"
    fi
    
    if [ ${#overlay_findings[@]} -gt 0 ]; then
        log_threat $((overlay_score / 2)) "QR overlay malware indicators: ${overlay_findings[*]}"
        analysis_success_found "QR Overlay Malware" "${#overlay_findings[@]}" "Score: $overlay_score" "${overlay_findings[*]}"
    else
        analysis_success_none "QR Overlay"
    fi
}

# 4. QR Replacement - Physical QR replacement indicators
detect_qr_replacement() {
    local content="$1"
    
    log_info "Analyzing for QR replacement attack indicators..."
    
    local replacement_score=0
    local replacement_findings=()
    
    # Payment redirection indicators
    if echo "$content" | safe_grep_qiE "payment.*redirect|bitcoin.*address.*change|wallet.*modified"; then
        replacement_findings+=("payment_redirection")
        ((replacement_score += 80))
        log_forensic_detection 80 \
            "QR Replacement - Payment Redirect" \
            "indicator:Payment redirection" \
            "Payment redirection pattern in QR" \
            "QR decoded content" \
            "QR may replace legitimate payment destination - financial fraud" \
            "MITRE ATT&CK T1498 - Network Denial of Service"
    fi
    
    # Parking/toll payment QR indicators (common replacement target)
    if echo "$content" | safe_grep_qiE "parking.*payment|toll.*payment|meter.*payment|fine.*payment"; then
        replacement_findings+=("parking_payment")
        ((replacement_score += 70))
        log_forensic_detection 70 \
            "QR Replacement - Parking/Toll Payment" \
            "indicator:Parking/toll payment QR" \
            "Parking or toll payment QR detected" \
            "QR decoded content" \
            "Common physical QR replacement attack vector - verify QR authenticity" \
            "MITRE ATT&CK T1656 - Impersonation"
    fi
    
    # Restaurant/menu QR replacement indicators
    if echo "$content" | safe_grep_qiE "menu.*order|restaurant.*payment|table.*service"; then
        replacement_findings+=("restaurant_qr")
        ((replacement_score += 60))
        log_forensic_detection 60 \
            "QR Replacement - Restaurant Menu" \
            "indicator:Restaurant/menu QR" \
            "Restaurant menu QR pattern" \
            "QR decoded content" \
            "Restaurant QR codes frequently targeted for replacement attacks" \
            "MITRE ATT&CK T1656 - Impersonation"
    fi
    
    # Generic replacement indicators
    if echo "$content" | safe_grep_qiE "scan.*instead|updated.*qr|new.*qr.*code"; then
        replacement_findings+=("qr_update_notice")
        ((replacement_score += 50))
        log_forensic_detection 50 \
            "QR Replacement Indicator" \
            "pattern:QR update/replacement notice" \
            "QR replacement or update terminology" \
            "QR decoded content" \
            "Content suggests QR replacement - verify authenticity" \
            "MITRE ATT&CK T1656 - Impersonation"
    fi
    
    if [ ${#replacement_findings[@]} -gt 0 ]; then
        log_threat $((replacement_score / 2)) "QR replacement attack indicators: ${replacement_findings[*]}"
        analysis_success_found "QR Replacement" "${#replacement_findings[@]}" "Score: $replacement_score" "${replacement_findings[*]}"
    else
        analysis_success_none "QR Replacement"
    fi
}

# 5. Invisible QR - Near-invisible QR watermarks
detect_invisible_qr() {
    local content="$1"
    
    log_info "Analyzing for invisible QR patterns..."
    
    local invisible_score=0
    local invisible_findings=()
    
    # Steganography indicators
    if echo "$content" | safe_grep_qiE "steg|watermark|hidden.*data|lsb.*embed"; then
        invisible_findings+=("stego_indicator")
        ((invisible_score += 55))
        log_forensic_detection 55 \
            "Invisible QR - Steganography" \
            "technique:Steganographic embedding" \
            "Steganography or watermark indicators" \
            "QR decoded content" \
            "QR may contain hidden steganographic data" \
            "MITRE ATT&CK T1027.003 - Obfuscated Files: Steganography"
    fi
    
    # Near-infrared QR indicators
    if echo "$content" | safe_grep_qiE "infrared|ir.*qr|invisible.*ink|uv.*qr"; then
        invisible_findings+=("invisible_ink")
        ((invisible_score += 60))
        log_forensic_detection 60 \
            "Invisible QR - Special Ink/Spectrum" \
            "technique:Non-visible spectrum QR" \
            "Invisible ink or non-visible QR indicators" \
            "QR decoded content" \
            "QR may use invisible ink or non-visible spectrum encoding" \
            "MITRE ATT&CK T1027 - Obfuscated Files or Information"
    fi
    
    # Micro QR or high-density encoding
    if echo "$content" | safe_grep_qiE "micro.*qr|ultra.*dense|high.*density.*encoding"; then
        invisible_findings+=("micro_dense_qr")
        ((invisible_score += 45))
        log_forensic_detection 45 \
            "Invisible QR - Micro/Dense Encoding" \
            "technique:High-density QR encoding" \
            "Micro or ultra-dense QR encoding" \
            "QR decoded content" \
            "Very small or dense QR - may evade visual inspection" \
            "MITRE ATT&CK T1027 - Obfuscated Files or Information"
    fi
    
    if [ ${#invisible_findings[@]} -gt 0 ]; then
        log_threat $((invisible_score / 2)) "Invisible QR indicators: ${invisible_findings[*]}"
        analysis_success_found "Invisible QR" "${#invisible_findings[@]}" "Score: $invisible_score" "${invisible_findings[*]}"
    else
        analysis_success_none "Invisible QR"
    fi
}

# 6. Animated QR - Animated/video QR abuse
detect_animated_qr() {
    local content="$1"
    
    log_info "Analyzing for animated QR abuse..."
    
    local animated_score=0
    local animated_findings=()
    
    # Animated QR indicators
    if echo "$content" | safe_grep_qiE "animated.*qr|qr.*animation|video.*qr|gif.*qr"; then
        animated_findings+=("animated_qr")
        ((animated_score += 50))
        log_forensic_detection 50 \
            "Animated QR Detected" \
            "technique:Animated QR code" \
            "Animated or video QR pattern" \
            "QR decoded content" \
            "Animated QR can cycle through multiple payloads or evade detection" \
            "MITRE ATT&CK T1027 - Obfuscated Files or Information"
    fi
    
    # Frame-switching QR
    if echo "$content" | safe_grep_qiE "frame.*switch|qr.*sequence|multi.*frame"; then
        animated_findings+=("frame_switching")
        ((animated_score += 55))
        log_forensic_detection 55 \
            "Frame-Switching QR" \
            "technique:Multi-frame QR sequence" \
            "Frame-switching QR pattern detected" \
            "QR decoded content" \
            "Multi-frame QR can deliver different payloads per frame" \
            "MITRE ATT&CK T1027 - Obfuscated Files or Information"
    fi
    
    # Time-based QR rotation
    if echo "$content" | safe_grep_qiE "rotate.*qr|qr.*timer|timed.*qr|expiring.*qr"; then
        animated_findings+=("time_based_rotation")
        ((animated_score += 60))
        log_forensic_detection 60 \
            "Time-Based QR Rotation" \
            "technique:Temporal QR rotation" \
            "Time-based QR rotation pattern" \
            "QR decoded content" \
            "QR rotates over time - may evade static analysis" \
            "MITRE ATT&CK T1562 - Impair Defenses"
    fi
    
    if [ ${#animated_findings[@]} -gt 0 ]; then
        log_threat $((animated_score / 2)) "Animated QR abuse indicators: ${animated_findings[*]}"
        analysis_success_found "Animated QR" "${#animated_findings[@]}" "Score: $animated_score" "${animated_findings[*]}"
    else
        analysis_success_none "Animated QR"
    fi
}

# 7. Multi-QR Chaining - QR-to-QR redirect chains
detect_multi_qr_chaining() {
    local content="$1"
    
    log_info "Analyzing for multi-QR chaining..."
    
    local chain_score=0
    local chain_findings=()
    
    # QR redirect chains
    if echo "$content" | safe_grep_qiE "next.*qr|scan.*another|redirect.*qr|qr.*chain"; then
        chain_findings+=("qr_chain_redirect")
        ((chain_score += 65))
        log_forensic_detection 65 \
            "Multi-QR Chaining Detected" \
            "technique:QR redirect chain" \
            "QR-to-QR redirect chain pattern" \
            "QR decoded content" \
            "QR chains to another QR - evasion technique to bypass scanners" \
            "MITRE ATT&CK T1090 - Proxy"
    fi
    
    # Segmented payload delivery
    if echo "$content" | safe_grep_qiE "part.*[0-9].*of.*[0-9]|segment|fragment.*qr"; then
        chain_findings+=("segmented_payload")
        ((chain_score += 70))
        log_forensic_detection 70 \
            "Segmented QR Payload" \
            "technique:Multi-part QR payload" \
            "Segmented QR payload pattern" \
            "QR decoded content" \
            "Payload split across multiple QRs - advanced evasion" \
            "MITRE ATT&CK T1027 - Obfuscated Files or Information"
    fi
    
    # Progressive QR disclosure
    if echo "$content" | safe_grep_qiE "unlock.*next|complete.*sequence|qr.*puzzle"; then
        chain_findings+=("progressive_disclosure")
        ((chain_score += 60))
        log_forensic_detection 60 \
            "Progressive QR Disclosure" \
            "technique:Progressive QR unlocking" \
            "Progressive QR disclosure pattern" \
            "QR decoded content" \
            "QR requires scanning multiple codes in sequence" \
            "MITRE ATT&CK T1027 - Obfuscated Files or Information"
    fi
    
    if [ ${#chain_findings[@]} -gt 0 ]; then
        log_threat $((chain_score / 2)) "Multi-QR chaining detected: ${chain_findings[*]}"
        analysis_success_found "Multi-QR Chaining" "${#chain_findings[@]}" "Score: $chain_score" "${chain_findings[*]}"
    else
        analysis_success_none "Multi-QR Chaining"
    fi
}

# 8. Conditional Content - Time/geo-conditional payloads
detect_conditional_content() {
    local content="$1"
    
    log_info "Analyzing for conditional payloads..."
    
    local cond_score=0
    local cond_findings=()
    
    # Geo-fencing patterns
    if echo "$content" | safe_grep_qiE "geolocation|geoip|location.*check|country.*block|region.*restrict"; then
        cond_findings+=("geofencing")
        ((cond_score += 55))
        log_forensic_detection 55 \
            "Conditional Content - Geofencing" \
            "technique:Geographic conditional delivery" \
            "Geolocation-based content delivery" \
            "QR decoded content" \
            "Content delivery based on geographic location - evasion technique" \
            "MITRE ATT&CK T1497 - Virtualization/Sandbox Evasion"
    fi
    
    # Time-based conditional delivery
    if echo "$content" | safe_grep_qiE "time.*expire|valid.*until|available.*between|schedule.*delivery"; then
        cond_findings+=("time_conditional")
        ((cond_score += 60))
        log_forensic_detection 60 \
            "Conditional Content - Time-Based" \
            "technique:Temporal conditional delivery" \
            "Time-based conditional content pattern" \
            "QR decoded content" \
            "Content expires or activates at specific time - evasion technique" \
            "MITRE ATT&CK T1497 - Virtualization/Sandbox Evasion"
    fi
    
    # User-agent/device detection
    if echo "$content" | safe_grep_qiE "user.*agent.*detect|device.*fingerprint|browser.*detect|mobile.*only"; then
        cond_findings+=("device_targeting")
        ((cond_score += 50))
        log_forensic_detection 50 \
            "Conditional Content - Device Targeting" \
            "technique:Device-specific delivery" \
            "Device or browser detection pattern" \
            "QR decoded content" \
            "Content tailored to specific devices - targeted attack" \
            "MITRE ATT&CK T1497 - Virtualization/Sandbox Evasion"
    fi
    
    # IP-based filtering
    if echo "$content" | safe_grep_qiE "ip.*whitelist|ip.*blacklist|ip.*filter|allow.*ip"; then
        cond_findings+=("ip_filtering")
        ((cond_score += 55))
        log_forensic_detection 55 \
            "Conditional Content - IP Filtering" \
            "technique:IP-based access control" \
            "IP filtering or whitelist pattern" \
            "QR decoded content" \
            "Content restricted by IP address - targeted delivery" \
            "MITRE ATT&CK T1497 - Virtualization/Sandbox Evasion"
    fi
    
    if [ ${#cond_findings[@]} -gt 0 ]; then
        log_threat $((cond_score / 2)) "Conditional content patterns: ${cond_findings[*]}"
        analysis_success_found "Conditional Content" "${#cond_findings[@]}" "Score: $cond_score" "${cond_findings[*]}"
    else
        analysis_success_none "Conditional Content"
    fi
}

# 9. Browser-in-Browser - BITB phishing indicators
detect_browser_in_browser() {
    local content="$1"
    
    log_info "Analyzing for Browser-in-Browser (BITB) attacks..."
    
    local bitb_score=0
    local bitb_findings=()
    
    # BITB window creation patterns
    if echo "$content" | safe_grep_qiE "window\.open|popup.*window|modal.*browser|fake.*chrome|fake.*address.*bar"; then
        bitb_findings+=("bitb_window")
        ((bitb_score += 70))
        log_forensic_detection 70 \
            "Browser-in-Browser Attack" \
            "technique:Fake browser window" \
            "BITB fake browser window pattern" \
            "QR decoded content" \
            "Creates fake browser window to steal credentials - advanced phishing" \
            "MITRE ATT&CK T1566.002 - Phishing: Spearphishing Link"
    fi
    
    # OAuth/SSO spoofing indicators
    if echo "$content" | safe_grep_qiE "oauth.*popup|sso.*window|sign.*in.*with.*google|login.*microsoft|facebook.*login.*popup"; then
        bitb_findings+=("oauth_spoof")
        ((bitb_score += 75))
        log_forensic_detection 75 \
            "BITB - OAuth/SSO Spoofing" \
            "technique:OAuth popup spoofing" \
            "Fake OAuth/SSO login window" \
            "QR decoded content" \
            "Spoofs OAuth/SSO login popup - credential theft" \
            "MITRE ATT&CK T1539 - Steal Web Session Cookie"
    fi
    
    # CSS-based fake browser chrome
    if echo "$content" | safe_grep_qiE "address.*bar.*css|url.*bar.*fake|browser.*chrome.*div"; then
        bitb_findings+=("css_browser_chrome")
        ((bitb_score += 65))
        log_forensic_detection 65 \
            "BITB - CSS Browser Chrome" \
            "technique:CSS-based browser UI fake" \
            "CSS-rendered fake browser interface" \
            "QR decoded content" \
            "Uses CSS to mimic browser UI - credential harvesting" \
            "MITRE ATT&CK T1656 - Impersonation"
    fi
    
    if [ ${#bitb_findings[@]} -gt 0 ]; then
        log_threat $((bitb_score / 2)) "Browser-in-Browser attack indicators: ${bitb_findings[*]}"
        analysis_success_found "Browser-in-Browser" "${#bitb_findings[@]}" "Score: $bitb_score" "${bitb_findings[*]}"
    fi
}

# 10. Reverse Proxy Phishing - Evilginx/Modlishka patterns
detect_reverse_proxy_phish() {
    local content="$1"
    
    log_info "Analyzing for reverse proxy phishing..."
    
    local proxy_score=0
    local proxy_findings=()
    
    # Evilginx indicators
    if echo "$content" | safe_grep_qiE "evilginx|phishlet|mitm.*proxy|reverse.*proxy.*auth"; then
        proxy_findings+=("evilginx_pattern")
        ((proxy_score += 85))
        log_forensic_detection 85 \
            "Reverse Proxy Phishing - Evilginx" \
            "tool:Evilginx framework" \
            "Evilginx reverse proxy pattern" \
            "QR decoded content" \
            "Evilginx framework detected - bypasses MFA via reverse proxy" \
            "MITRE ATT&CK T1557.002 - Man-in-the-Middle: ARP Cache Poisoning"
    fi
    
    # Modlishka indicators
    if echo "$content" | safe_grep_qiE "modlishka|muraena|necrobrowser"; then
        proxy_findings+=("modlishka_pattern")
        ((proxy_score += 85))
        log_forensic_detection 85 \
            "Reverse Proxy Phishing - Modlishka" \
            "tool:Modlishka framework" \
            "Modlishka reverse proxy pattern" \
            "QR decoded content" \
            "Modlishka/Muraena framework - MFA bypass via MITM" \
            "MITRE ATT&CK T1557 - Man-in-the-Middle"
    fi
    
    # Generic reverse proxy phishing patterns
    if echo "$content" | safe_grep_qiE "mitm.*session|proxy.*intercept|session.*relay|cookie.*replay"; then
        proxy_findings+=("generic_proxy_mitm")
        ((proxy_score += 70))
        log_forensic_detection 70 \
            "Reverse Proxy Phishing Pattern" \
            "technique:Session interception proxy" \
            "Generic reverse proxy MITM pattern" \
            "QR decoded content" \
            "Reverse proxy for session interception - MFA bypass" \
            "MITRE ATT&CK T1557 - Man-in-the-Middle"
    fi
    
    # Real-time phishing indicators
    if echo "$content" | safe_grep_qiE "real.*time.*phish|live.*phish|session.*forward"; then
        proxy_findings+=("realtime_phishing")
        ((proxy_score += 75))
        log_forensic_detection 75 \
            "Real-Time Phishing Pattern" \
            "technique:Real-time credential relay" \
            "Real-time phishing/session relay pattern" \
            "QR decoded content" \
            "Real-time credential relaying to bypass MFA" \
            "MITRE ATT&CK T1539 - Steal Web Session Cookie"
    fi
    
    if [ ${#proxy_findings[@]} -gt 0 ]; then
        log_threat $((proxy_score / 2)) "Reverse proxy phishing indicators: ${proxy_findings[*]}"
        analysis_success_found "Reverse Proxy Phishing" "${#proxy_findings[@]}" "Score: $proxy_score" "${proxy_findings[*]}"
    fi
}

# 11. Adversary-in-the-Middle (AiTM) - AiTM attack indicators
detect_adversary_in_middle() {
    local content="$1"
    
    log_info "Analyzing for Adversary-in-the-Middle attacks..."
    
    local aitm_score=0
    local aitm_findings=()
    
    # Token theft indicators
    if echo "$content" | safe_grep_qiE "token.*theft|steal.*token|session.*hijack|cookie.*theft"; then
        aitm_findings+=("token_theft")
        ((aitm_score += 75))
        log_forensic_detection 75 \
            "AiTM - Token Theft" \
            "technique:Session token theft" \
            "Session token theft pattern" \
            "QR decoded content" \
            "Adversary-in-the-Middle token theft indicators" \
            "MITRE ATT&CK T1539 - Steal Web Session Cookie"
    fi
    
    # MFA interception
    if echo "$content" | safe_grep_qiE "mfa.*intercept|2fa.*bypass.*proxy|otp.*relay"; then
        aitm_findings+=("mfa_intercept")
        ((aitm_score += 80))
        log_forensic_detection 80 \
            "AiTM - MFA Interception" \
            "technique:MFA token interception" \
            "MFA interception pattern" \
            "QR decoded content" \
            "Intercepts MFA tokens in real-time - bypasses 2FA" \
            "MITRE ATT&CK T1556 - Modify Authentication Process"
    fi
    
    # SSL/TLS interception
    if echo "$content" | safe_grep_qiE "ssl.*strip|tls.*downgrade|https.*intercept|certificate.*pin.*bypass"; then
        aitm_findings+=("ssl_intercept")
        ((aitm_score += 70))
        log_forensic_detection 70 \
            "AiTM - SSL/TLS Interception" \
            "technique:SSL/TLS MITM" \
            "SSL/TLS interception pattern" \
            "QR decoded content" \
            "SSL stripping or TLS downgrade attack" \
            "MITRE ATT&CK T1557 - Man-in-the-Middle"
    fi
    
    # Session fixation
    if echo "$content" | safe_grep_qiE "session.*fixation|session.*id.*predict|cookie.*fixation"; then
        aitm_findings+=("session_fixation")
        ((aitm_score += 65))
        log_forensic_detection 65 \
            "AiTM - Session Fixation" \
            "technique:Session fixation attack" \
            "Session fixation pattern" \
            "QR decoded content" \
            "Session fixation attack - forces specific session ID" \
            "MITRE ATT&CK T1539 - Steal Web Session Cookie"
    fi
    
    if [ ${#aitm_findings[@]} -gt 0 ]; then
        log_threat $((aitm_score / 2)) "Adversary-in-the-Middle indicators: ${aitm_findings[*]}"
        analysis_success_found "Adversary-in-the-Middle" "${#aitm_findings[@]}" "Score: $aitm_score" "${aitm_findings[*]}"
    fi
}

################################################################################
# LIVING-OFF-THE-LAND BINARIES (LOLBins) DETECTION
################################################################################

# 12. Windows LOLBin Detection
detect_lolbin_windows() {
    local content="$1"
    
    log_info "Analyzing for Windows LOLBin abuse..."
    
    local win_lolbin_score=0
    local win_lolbin_findings=()
    
    # Check against existing LOLBAS_PATTERNS
    for pattern in "${LOLBAS_PATTERNS[@]}"; do
        if echo "$content" | safe_grep_qiE "$pattern"; then
            win_lolbin_findings+=("lolbas:$pattern")
            ((win_lolbin_score += 45))
            log_forensic_detection 45 \
                "Windows LOLBin - LOLBAS" \
                "binary:$pattern" \
                "Windows LOLBin pattern from LOLBAS" \
                "QR decoded content" \
                "Legitimate Windows binary abused for malicious purposes" \
                "MITRE ATT&CK T1218 - Signed Binary Proxy Execution"
        fi
    done
    
    # Additional Windows-specific LOLBins
    local win_specific=(
        "powershell.*-enc.*-nop"
        "cmd\.exe.*/c.*echo.*>"
        "wmic.*process.*call.*create"
        "schtasks.*/create"
        "net.*user.*/add"
        "reg.*add.*run"
    )
    
    for pattern in "${win_specific[@]}"; do
        if echo "$content" | safe_grep_qiE "$pattern"; then
            win_lolbin_findings+=("windows_native:$pattern")
            ((win_lolbin_score += 50))
            log_forensic_detection 50 \
                "Windows LOLBin - Native Tool" \
                "command:$pattern" \
                "Windows native tool abuse pattern" \
                "QR decoded content" \
                "Windows built-in tool used for malicious activity" \
                "MITRE ATT&CK T1059.001 - PowerShell"
        fi
    done
    
    if [ ${#win_lolbin_findings[@]} -gt 0 ]; then
        log_threat $((win_lolbin_score / 2)) "Windows LOLBin abuse: ${win_lolbin_findings[*]}"
        analysis_success_found "Windows LOLBins" "${#win_lolbin_findings[@]}" "Score: $win_lolbin_score" "${win_lolbin_findings[*]}"
    fi
}

# 13. Linux LOLBin Detection (GTFOBins)
detect_lolbin_linux() {
    local content="$1"
    
    log_info "Analyzing for Linux LOLBin (GTFOBins) abuse..."
    
    local linux_lolbin_score=0
    local linux_lolbin_findings=()
    
    # Check against existing GTFOBINS_PATTERNS if available
    if [ ${#GTFOBINS_PATTERNS[@]} -gt 0 ]; then
        for pattern in "${GTFOBINS_PATTERNS[@]}"; do
            if echo "$content" | safe_grep_qiE "$pattern"; then
                linux_lolbin_findings+=("gtfobins:$pattern")
                ((linux_lolbin_score += 45))
                log_forensic_detection 45 \
                    "Linux LOLBin - GTFOBins" \
                    "binary:$pattern" \
                    "Linux binary from GTFOBins database" \
                    "QR decoded content" \
                    "Unix/Linux binary abuse for privilege escalation or code execution" \
                    "MITRE ATT&CK T1059.004 - Unix Shell"
            fi
        done
    fi
    
    # Common Linux LOLBins
    local linux_specific=(
        "curl.*\|.*bash"
        "wget.*-O.*-.*\|.*sh"
        "bash.*-i.*>.*&"
        "nc.*-e.*/bin/(bash|sh)"
        "python.*-c.*import.*pty"
        "perl.*-e.*exec"
        "awk.*BEGIN.*system"
        "find.*-exec"
        "vi.*:!.*bash"
    )
    
    for pattern in "${linux_specific[@]}"; do
        if echo "$content" | safe_grep_qiE "$pattern"; then
            linux_lolbin_findings+=("linux_native:$pattern")
            ((linux_lolbin_score += 50))
            log_forensic_detection 50 \
                "Linux LOLBin - Native Tool" \
                "command:$pattern" \
                "Linux native tool abuse pattern" \
                "QR decoded content" \
                "Unix/Linux built-in tool used maliciously" \
                "MITRE ATT&CK T1059.004 - Unix Shell"
        fi
    done
    
    if [ ${#linux_lolbin_findings[@]} -gt 0 ]; then
        log_threat $((linux_lolbin_score / 2)) "Linux LOLBin abuse: ${linux_lolbin_findings[*]}"
        analysis_success_found "Linux LOLBins" "${#linux_lolbin_findings[@]}" "Score: $linux_lolbin_score" "${linux_lolbin_findings[*]}"
    fi
}

# 14. macOS LOLBin Detection
detect_lolbin_macos() {
    local content="$1"
    
    log_info "Analyzing for macOS LOLBin abuse..."
    
    local macos_lolbin_score=0
    local macos_lolbin_findings=()
    
    # macOS-specific LOLBins
    local macos_patterns=(
        "osascript.*-e"
        "launchctl.*load"
        "defaults.*write.*com\.apple"
        "security.*add-trusted-cert"
        "spctl.*--add"
        "dscl.*create"
        "sudo.*-s"
        "chmod.*\+x.*&&.*\.\/"
    )
    
    for pattern in "${macos_patterns[@]}"; do
        if echo "$content" | safe_grep_qiE "$pattern"; then
            macos_lolbin_findings+=("macos_native:$pattern")
            ((macos_lolbin_score += 50))
            log_forensic_detection 50 \
                "macOS LOLBin" \
                "command:$pattern" \
                "macOS native tool abuse pattern" \
                "QR decoded content" \
                "macOS built-in tool used for malicious purposes" \
                "MITRE ATT&CK T1059.002 - AppleScript"
        fi
    done
    
    # macOS-specific privilege escalation
    if echo "$content" | safe_grep_qiE "sudo.*-S|osascript.*administrator|applescript.*password"; then
        macos_lolbin_findings+=("macos_privesc")
        ((macos_lolbin_score += 60))
        log_forensic_detection 60 \
            "macOS LOLBin - Privilege Escalation" \
            "technique:macOS privilege escalation" \
            "macOS privilege escalation pattern" \
            "QR decoded content" \
            "Attempts to escalate privileges on macOS" \
            "MITRE ATT&CK T1548 - Abuse Elevation Control Mechanism"
    fi
    
    if [ ${#macos_lolbin_findings[@]} -gt 0 ]; then
        log_threat $((macos_lolbin_score / 2)) "macOS LOLBin abuse: ${macos_lolbin_findings[*]}"
        analysis_success_found "macOS LOLBins" "${#macos_lolbin_findings[@]}" "Score: $macos_lolbin_score" "${macos_lolbin_findings[*]}"
    fi
}

# 15. LOLBas Scripts Detection
detect_lolbas_scripts() {
    local content="$1"
    
    log_info "Analyzing for LOLBas script abuse..."
    
    local script_lolbin_score=0
    local script_lolbin_findings=()
    
    # PowerShell scripts
    if echo "$content" | safe_grep_qiE "\.ps1|powershell.*-file.*\.ps1|import-module"; then
        script_lolbin_findings+=("powershell_script")
        ((script_lolbin_score += 45))
        log_forensic_detection 45 \
            "LOLBas - PowerShell Script" \
            "type:PowerShell script" \
            "PowerShell script execution pattern" \
            "QR decoded content" \
            "PowerShell script execution - common LOLBas technique" \
            "MITRE ATT&CK T1059.001 - PowerShell"
    fi
    
    # VBScript/JScript
    if echo "$content" | safe_grep_qiE "\.vbs|\.js|wscript|cscript|activexobject"; then
        script_lolbin_findings+=("vbscript_jscript")
        ((script_lolbin_score += 50))
        log_forensic_detection 50 \
            "LOLBas - VBScript/JScript" \
            "type:VBScript or JScript" \
            "VBScript/JScript execution pattern" \
            "QR decoded content" \
            "Windows Script Host abuse - LOLBas script execution" \
            "MITRE ATT&CK T1059.005 - Visual Basic"
    fi
    
    # Batch scripts
    if echo "$content" | safe_grep_qiE "\.bat|\.cmd|@echo.*off|cmd\.exe.*/c"; then
        script_lolbin_findings+=("batch_script")
        ((script_lolbin_score += 40))
        log_forensic_detection 40 \
            "LOLBas - Batch Script" \
            "type:Windows batch script" \
            "Batch script execution pattern" \
            "QR decoded content" \
            "Batch script execution - LOLBas technique" \
            "MITRE ATT&CK T1059.003 - Windows Command Shell"
    fi
    
    # Shell scripts
    if echo "$content" | safe_grep_qiE "\.sh|#!/bin/(bash|sh)|bash.*-c|sh.*-c"; then
        script_lolbin_findings+=("shell_script")
        ((script_lolbin_score += 40))
        log_forensic_detection 40 \
            "LOLBas - Shell Script" \
            "type:Unix shell script" \
            "Shell script execution pattern" \
            "QR decoded content" \
            "Shell script execution - Unix LOLBin technique" \
            "MITRE ATT&CK T1059.004 - Unix Shell"
    fi
    
    if [ ${#script_lolbin_findings[@]} -gt 0 ]; then
        log_threat $((script_lolbin_score / 2)) "LOLBas script abuse: ${script_lolbin_findings[*]}"
        analysis_success_found "LOLBas Scripts" "${#script_lolbin_findings[@]}" "Score: $script_lolbin_score" "${script_lolbin_findings[*]}"
    else
        analysis_success_none "LOLBas Scripts"
    fi
}

# 16. Living-off-Cloud Detection
detect_living_off_cloud() {
    local content="$1"
    
    log_info "Analyzing for Living-off-Cloud techniques..."
    
    local cloud_lol_score=0
    local cloud_lol_findings=()
    
    # AWS CLI abuse
    if echo "$content" | safe_grep_qiE "aws.*s3.*cp|aws.*lambda.*invoke|aws.*ec2.*run-instances"; then
        cloud_lol_findings+=("aws_cli_abuse")
        ((cloud_lol_score += 55))
        log_forensic_detection 55 \
            "Living-off-Cloud - AWS CLI" \
            "service:AWS CLI abuse" \
            "AWS CLI command pattern" \
            "QR decoded content" \
            "AWS CLI used for malicious cloud operations" \
            "MITRE ATT&CK T1648 - Serverless Execution"
    fi
    
    # Azure CLI abuse
    if echo "$content" | safe_grep_qiE "az.*vm.*create|az.*storage.*upload|az.*functionapp"; then
        cloud_lol_findings+=("azure_cli_abuse")
        ((cloud_lol_score += 55))
        log_forensic_detection 55 \
            "Living-off-Cloud - Azure CLI" \
            "service:Azure CLI abuse" \
            "Azure CLI command pattern" \
            "QR decoded content" \
            "Azure CLI used for malicious cloud operations" \
            "MITRE ATT&CK T1648 - Serverless Execution"
    fi
    
    # Google Cloud SDK abuse
    if echo "$content" | safe_grep_qiE "gcloud.*compute.*instances.*create|gsutil.*cp.*gs://|gcloud.*functions"; then
        cloud_lol_findings+=("gcp_sdk_abuse")
        ((cloud_lol_score += 55))
        log_forensic_detection 55 \
            "Living-off-Cloud - GCP SDK" \
            "service:Google Cloud SDK abuse" \
            "GCP SDK command pattern" \
            "QR decoded content" \
            "Google Cloud SDK used for malicious operations" \
            "MITRE ATT&CK T1648 - Serverless Execution"
    fi
    
    # Serverless function abuse
    if echo "$content" | safe_grep_qiE "lambda.*function|azure.*function|cloud.*function|serverless.*deploy"; then
        cloud_lol_findings+=("serverless_abuse")
        ((cloud_lol_score += 60))
        log_forensic_detection 60 \
            "Living-off-Cloud - Serverless" \
            "technique:Serverless function abuse" \
            "Serverless function deployment pattern" \
            "QR decoded content" \
            "Serverless functions used for malicious execution" \
            "MITRE ATT&CK T1648 - Serverless Execution"
    fi
    
    # Cloud storage abuse
    if echo "$content" | safe_grep_qiE "s3.*bucket.*public|blob.*storage.*write|cloud.*storage.*upload.*public"; then
        cloud_lol_findings+=("cloud_storage_abuse")
        ((cloud_lol_score += 50))
        log_forensic_detection 50 \
            "Living-off-Cloud - Storage Abuse" \
            "technique:Cloud storage abuse" \
            "Cloud storage manipulation pattern" \
            "QR decoded content" \
            "Cloud storage services abused for data exfiltration or hosting" \
            "MITRE ATT&CK T1567 - Exfiltration Over Web Service"
    fi
    
    if [ ${#cloud_lol_findings[@]} -gt 0 ]; then
        log_threat $((cloud_lol_score / 2)) "Living-off-Cloud techniques: ${cloud_lol_findings[*]}"
        analysis_success_found "Living-off-Cloud" "${#cloud_lol_findings[@]}" "Score: $cloud_lol_score" "${cloud_lol_findings[*]}"
    else
        analysis_success_none "Living-off-Cloud"
    fi
}

analyze_decoded_content_threats() {
    set +u
    local decoded_content="${1:-}"
    set -u
    
    # Check for additional threats in decoded content
    if printf '%s' "$decoded_content" | grep -qiE -- 'IEX|Invoke-Expression|downloadstring' 2>/dev/null; then
        local exec_pattern
        exec_pattern=$(printf '%s' "$decoded_content" | grep -oiE -- 'IEX|Invoke-Expression|downloadstring' 2>/dev/null | head -1)
        log_forensic_detection 35 \
            "Execution Primitive in Decoded Content" \
            "pattern:$exec_pattern" \
            "PowerShell execution pattern detection" \
            "Decoded/extracted content" \
            "Decoded content contains code execution primitives - likely malicious payload" \
            "MITRE ATT&CK T1059.001 - PowerShell"
    fi
    
    if printf '%s' "$decoded_content" | grep -qiE -- 'https?://' 2>/dev/null; then
        local urls
        urls=$(printf '%s' "$decoded_content" | grep -oiE -- 'https?://[^[: space:]"'"'"'<>]+' 2>/dev/null)
        local url
        while IFS= read -r url; do
            [ -z "$url" ] && continue
            log_forensic_detection 15 \
                "URL in Decoded Content" \
                "url:${url: 0:100}" \
                "URL extraction from decoded data" \
                "Decoded/extracted content" \
                "Analyze URL destination - may be C2 server or malicious download" \
                "" \
                "INFO"
            record_ioc "decoded_url" "$url" "URL from decoded content"
        done <<< "$urls"
    fi
    
    # Check for credential access
    if printf '%s' "$decoded_content" | grep -qiE -- 'password|credential|mimikatz|sekurlsa' 2>/dev/null; then
        local cred_pattern
        cred_pattern=$(printf '%s' "$decoded_content" | grep -oiE -- 'password|credential|mimikatz|sekurlsa' 2>/dev/null | head -1)
        log_forensic_detection 50 \
            "Credential Reference in Decoded Content" \
            "pattern:$cred_pattern" \
            "Credential keyword detection" \
            "Decoded/extracted content" \
            "Content references credentials - possible credential theft or harvesting" \
            "MITRE ATT&CK T1003 - OS Credential Dumping"
    fi
}

################################################################################
# RANSOMWARE NOTE DETECTION AND ANALYSIS
################################################################################

analyze_ransomware_notes() {
    set +u
    local content="${1:-}"
    set -u
    
    if [ "$RANSOMWARE_NOTE_CHECK" = false ]; then
        return
    fi
    
    log_info "Analyzing for ransomware note patterns..."
    
    local ransom_findings=()
    local ransom_score=0
    local ransom_family=""
    
    # Check ransomware note patterns
    local pattern_matches=0
    for pattern in "${RANSOMWARE_NOTE_PATTERNS[@]}"; do
        if echo "$content" | safe_grep_qiE "$pattern"; then
            ((pattern_matches++))
            ransom_findings+=("note_pattern:$pattern")
        fi
    done
    
    if [ $pattern_matches -ge 3 ]; then
        log_forensic_detection 80 \
            "RANSOMWARE Multiple Note Patterns" \
            "patterns_matched:$pattern_matches" \
            "Ransomware note keyword analysis" \
            "QR decoded content" \
            "CRITICAL - Multiple ransomware note patterns detected - likely active ransomware communication" \
            "MITRE ATT&CK T1486 - Data Encrypted for Impact"
        ((ransom_score += 60))
    elif [ $pattern_matches -ge 1 ]; then
        log_forensic_detection 35 \
            "RANSOMWARE Language Detected" \
            "patterns_matched:$pattern_matches" \
            "Ransomware keyword analysis" \
            "QR decoded content" \
            "Ransomware-related language detected - investigate further" \
            "MITRE ATT&CK T1486 - Data Encrypted for Impact"
        ((ransom_score += 25))
    fi
    
    # Check for specific ransomware families
    for family in "${!RANSOMWARE_FAMILIES[@]}"; do
        local indicators="${RANSOMWARE_FAMILIES[$family]}"
        IFS=',' read -ra ind_array <<< "$indicators"
        
        for indicator in "${ind_array[@]}"; do
            if echo "$content" | safe_grep_qiE "$indicator"; then
                ransom_family="$family"
                ransom_findings+=("family:$family:$indicator")
                ((ransom_score += 50))
                log_forensic_detection 75 \
                    "RANSOMWARE Family Identified: $family" \
                    "family:$family, indicator:$indicator" \
                    "Ransomware family signature matching" \
                    "QR decoded content" \
                    "CRITICAL - Known ransomware family identified. Report to incident response team." \
                    "Ransomware Family Database"
                break 2
            fi
        done
    done
    
    # Check for ransom payment methods
    if echo "$content" | safe_grep_qiE "bitcoin|btc|monero|xmr|cryptocurrency"; then
        local crypto=$(echo "$content" | safe_grep_oiE "bitcoin|btc|monero|xmr|cryptocurrency" | head -1)
        log_forensic_detection 30 \
            "RANSOMWARE Cryptocurrency Payment Reference" \
            "cryptocurrency:$crypto" \
            "Cryptocurrency keyword detection" \
            "QR decoded content" \
            "Cryptocurrency payment method mentioned - common in ransomware" \
            "MITRE ATT&CK T1486 - Data Encrypted for Impact"
        ransom_findings+=("crypto_payment:$crypto")
        ((ransom_score += 20))
    fi
    
    # Check for .onion contact
    if echo "$content" | safe_grep_qiE "\.onion"; then
        local onion=$(echo "$content" | safe_grep_oiE "[a-z2-7]{16,56}\.onion" | head -1)
        log_forensic_detection 40 \
            "RANSOMWARE Tor Hidden Service" \
            "onion:${onion:-detected}" \
            "Tor .onion domain detection" \
            "QR decoded content" \
            "Tor hidden service reference - typical ransomware payment/contact portal" \
            "MITRE ATT&CK T1090.003 - Multi-hop Proxy"
        ransom_findings+=("onion_contact:${onion:-detected}")
        ((ransom_score += 25))
    fi
    
    # Check for victim ID patterns
    if echo "$content" | safe_grep_qiE "(victim|personal|unique).*id.*[A-Za-z0-9]{8,}"; then
        local victim_id=$(echo "$content" | safe_grep_oiE "(victim|personal|unique).*id.*[A-Za-z0-9]{8,}" | head -1)
        log_forensic_detection 25 \
            "RANSOMWARE Victim ID Pattern" \
            "pattern:victim_id" \
            "Victim identification pattern" \
            "QR decoded content" \
            "Victim ID pattern detected - used by attackers to track individual victims" \
            "Ransomware Victim Tracking"
        ransom_findings+=("victim_id")
        ((ransom_score += 15))
    fi
    
    # Check for encryption algorithm mentions
    if echo "$content" | safe_grep_qiE "RSA-[0-9]{4}|AES-[0-9]{3}|ChaCha20|Salsa20"; then
        local algo=$(echo "$content" | safe_grep_oiE "RSA-[0-9]{4}|AES-[0-9]{3}|ChaCha20|Salsa20" | head -1)
        log_forensic_detection 15 \
            "RANSOMWARE Encryption Algorithm Reference" \
            "algorithm:$algo" \
            "Encryption algorithm detection" \
            "QR decoded content" \
            "Encryption algorithm mentioned - attackers often cite this to intimidate victims" \
            "" \
            "INFO"
        ransom_findings+=("encryption_algo:$algo")
        ((ransom_score += 10))
    fi
    
    # Check for file extension changes
    local extension_pattern=$(echo "$content" | safe_grep_oiE "\.[a-z0-9]{4,8}" | head -5)
    if [ -n "$extension_pattern" ]; then
        # Compare against known ransomware extensions
        for ext in ".lockbit" ".conti" ".revil" ".ryuk" ".maze" ".encrypt" ".locked"; do
            if echo "$extension_pattern" | grep -qi "$ext"; then
                log_forensic_detection 45 \
                    "RANSOMWARE File Extension" \
                    "extension:$ext" \
                    "Known ransomware extension detection" \
                    "QR decoded content" \
                    "Known ransomware file extension detected" \
                    "Ransomware Extension Database"
                ransom_findings+=("ransom_extension:$ext")
                ((ransom_score += 30))
            fi
        done
    fi
    
    # Generate ransomware report
    if [ ${#ransom_findings[@]} -gt 0 ]; then
        {
            echo "═══════════════════════════════════════════════"
            echo "RANSOMWARE NOTE ANALYSIS"
            echo "═══════════════════════════════════════════════"
            echo "Timestamp: $(date -Iseconds)"
            echo "Ransomware Score: $ransom_score"
            echo ""
            if [ -n "$ransom_family" ]; then
                echo "*** IDENTIFIED RANSOMWARE FAMILY: $ransom_family ***"
                echo ""
            fi
            echo "Findings:"
            for finding in "${ransom_findings[@]}"; do
                echo "  - $finding"
            done
            echo ""
            echo "Risk Assessment:"
            if [ $ransom_score -ge 80 ]; then
                echo "  CRITICAL: Strong ransomware indicators detected"
                echo "  This QR likely leads to ransomware payment/contact page"
            elif [ $ransom_score -ge 40 ]; then
                echo "  HIGH: Significant ransomware-related content"
            elif [ $ransom_score -ge 20 ]; then
                echo "  MEDIUM: Some ransomware indicators present"
            else
                echo "  LOW: Minor indicators, may be false positive"
            fi
            echo ""
        } >> "$RANSOMWARE_NOTE_REPORT"
        
        analysis_success_found "RANSOMWARE" "${#ransom_findings[@]}" "Score: $ransom_score" "$(IFS=', '; echo "${ransom_findings[*]}")"
    else
        analysis_success_none "RANSOMWARE"
    fi
}

################################################################################
# TOR / VPN / ANONYMIZATION DETECTION
################################################################################

analyze_tor_vpn() {
    set +u
    local content="${1:-}"
    set -u
    
    if [ "$TOR_VPN_CHECK" = false ]; then
        return
    fi
    
    log_info "Analyzing for Tor/VPN/Anonymization indicators..."
    
    local anon_findings=()
    local anon_score=0
    
    # Check Tor patterns
    for pattern in "${TOR_EXIT_INDICATORS[@]}"; do
        if echo "$content" | safe_grep_qiE "$pattern"; then
            local matched=$(echo "$content" | safe_grep_oiE "$pattern" 2>/dev/null | head -1)
            anon_findings+=("tor:$matched")
            ((anon_score += 35))
            log_warning "Tor/Darknet indicator: $matched"
        fi
    done
    
    # Check VPN/Proxy patterns
    for pattern in "${VPN_PROXY_DOMAINS[@]}"; do
        if echo "$content" | safe_grep_qiE "$pattern"; then
            local matched=$(echo "$content" | safe_grep_oiE "$pattern" 2>/dev/null | head -1)
            anon_findings+=("vpn:$matched")
            ((anon_score += 15))
            log_info "VPN service reference: $matched"
        fi
    done
    
    # Check anonymizing proxy patterns
    for pattern in "${ANONYMIZING_PROXIES[@]}"; do
        if echo "$content" | safe_grep_qiE "$pattern"; then
            local matched=$(echo "$content" | safe_grep_oiE "$pattern" 2>/dev/null | head -1)
            anon_findings+=("proxy:$matched")
            ((anon_score += 25))
            log_warning "Anonymizing proxy reference: $matched"
        fi
    done
    
    # .onion URL extraction
    local onion_urls=$(echo "$content" | safe_grep_oiE "[a-z2-7]{56}\.onion|[a-z2-7]{16}\.onion")
    if [ -n "$onion_urls" ]; then
        for onion_url in $onion_urls; do
            log_threat 50 "Tor hidden service URL: $onion_url"
            anon_findings+=("onion_url:$onion_url")
            record_ioc "onion_url" "$onion_url" "Tor hidden service"
            ((anon_score += 40))
        done
    fi
    
    # Check for tor2web gateways (clearnet access to .onion)
    if echo "$content" | safe_grep_qiE "tor2web|onion\.(to|ws|ly|sh|city|link|direct)"; then
        log_threat 45 "Tor2Web gateway detected - clearnet access to hidden service"
        anon_findings+=("tor2web_gateway")
        ((anon_score += 35))
    fi
    
    # Check for I2P references
    if echo "$content" | safe_grep_qiE "\.i2p|i2p.*router|eepsite"; then
        log_warning "I2P network reference detected"
        anon_findings+=("i2p_network")
        ((anon_score += 30))
    fi
    
    # Check for IP resolution if network enabled
    if [ "$NETWORK_CHECK" = true ]; then
        check_tor_exit_nodes "$content"
    fi
    
    # Generate anonymization report
    if [ ${#anon_findings[@]} -gt 0 ]; then
        {
            echo "═══════════════════════════════════════════════"
            echo "TOR / VPN / ANONYMIZATION ANALYSIS"
            echo "═══════════════════════════════════════════════"
            echo "Timestamp: $(date -Iseconds)"
            echo "Anonymization Score: $anon_score"
            echo ""
            echo "Findings:"
            for finding in "${anon_findings[@]}"; do
                echo "  - $finding"
            done
            echo ""
            echo "Network Type Distribution:"
            echo "  Tor/Darknet: $(echo "${anon_findings[@]}" | grep -c "tor\|onion")"
            echo "  VPN Services: $(echo "${anon_findings[@]}" | grep -c "vpn")"
            echo "  Proxies: $(echo "${anon_findings[@]}" | grep -c "proxy")"
            echo "  I2P: $(echo "${anon_findings[@]}" | grep -c "i2p")"
            echo ""
            if [ $anon_score -ge 40 ]; then
                echo "WARNING: Strong anonymization/darknet indicators"
                echo "Content likely related to criminal infrastructure"
            fi
            echo ""
        } >> "$TOR_VPN_REPORT"
        
        if [ $anon_score -ge 30 ]; then
            log_threat $((anon_score / 2)) "Tor/VPN/Anonymization indicators detected"
        fi
        
        analysis_success_found "TOR-VPN" "${#anon_findings[@]}" "Score: $anon_score" "$(IFS=', '; echo "${anon_findings[*]}")"
    else
        analysis_success_none "TOR-VPN"
    fi
}

check_tor_exit_nodes() {
    local content="$1"
    
    # Extract IPs from content
    local ips=$(echo "$content" | safe_grep_oE "[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}")
    
    if [ -z "$ips" ]; then
        return
    fi
    
    # Download Tor exit node list (cached)
    local tor_list="${TEMP_DIR}/threat_intel/tor_exits.txt"
    
    if [ ! -f "$tor_list" ]; then
        curl -sfL --max-time 15 "https://check.torproject.org/exit-addresses" > "$tor_list" 2>/dev/null
    fi
    
    if [ -s "$tor_list" ]; then
        for ip in $ips; do
            if grep -q "$ip" "$tor_list"; then
                log_threat 60 "IP $ip is a known Tor exit node"
                record_ioc "tor_exit" "$ip" "Known Tor exit node"
            fi
        done
    fi
}

################################################################################
# ADVANCED PROTOCOL & NETWORK ANALYSIS ENGINES
# Comprehensive detection for protocol-level attacks and covert channels
################################################################################

# DNS Tunneling Detection - DNS exfiltration via encoded QR payloads
analyze_dns_tunneling() {
    set +u
    local content="${1:-}"
    set -u
    local dns_report="${OUTPUT_DIR}/dns_tunneling_analysis.txt"
    
    log_info "Analyzing for DNS tunneling indicators..."
    
    local dns_findings=()
    local dns_score=0
    
    # DNS tunneling patterns
    local -a DNS_TUNNEL_PATTERNS=(
        # Long subdomain chains (typical of DNS tunneling)
        "[a-zA-Z0-9]{32,}\.[a-zA-Z0-9-]+\.[a-zA-Z]{2,}"
        # Base64/Base32 encoded subdomains
        "[A-Za-z0-9+/=]{20,}\.[a-zA-Z0-9-]+\.[a-zA-Z]{2,}"
        # Hex-encoded subdomains
        "[0-9a-fA-F]{32,}\.[a-zA-Z0-9-]+\.[a-zA-Z]{2,}"
        # Multiple subdomain levels (>5 levels suspicious)
        "([a-zA-Z0-9-]+\.){6,}[a-zA-Z]{2,}"
        # Known DNS tunneling tools
        "iodine\.|dns2tcp\.|dnscat\.|dnscapy\.|heyoka\."
        # TXT record abuse patterns
        "txt\.[a-zA-Z0-9-]+\.[a-zA-Z]{2,}"
        # CNAME chain abuse
        "cname[0-9]+\.|chain[0-9]+\."
    )
    
    # DNS tunneling tool domains
    local -a DNS_TUNNEL_DOMAINS=(
        "tunnel\..*\.(io|com|net|org)"
        "dns\.tunnel"
        "exfil\.dns"
        "covert\.dns"
        "c2\.dns"
        "beacon\."
    )
    
    for pattern in "${DNS_TUNNEL_PATTERNS[@]}"; do
        if echo "$content" | safe_grep_qiE "$pattern"; then
            local matched=$(echo "$content" | safe_grep_oiE "$pattern" 2>/dev/null | head -3)
            for m in $matched; do
                dns_findings+=("dns_tunnel_pattern:$m")
                ((dns_score += 25))
                log_warning "DNS tunneling pattern: $m"
            done
        fi
    done
    
    for domain in "${DNS_TUNNEL_DOMAINS[@]}"; do
        if echo "$content" | safe_grep_qiE "$domain"; then
            local matched=$(echo "$content" | safe_grep_oiE "$domain" 2>/dev/null | head -1)
            dns_findings+=("dns_tunnel_domain:$matched")
            ((dns_score += 35))
            log_threat 40 "DNS tunnel domain: $matched"
        fi
    done
    
    # Check for excessive subdomain length (entropy check)
    local subdomains=$(echo "$content" | safe_grep_oE "[a-zA-Z0-9-]{40,}\.[a-zA-Z0-9-]+\.[a-zA-Z]{2,}")
    if [ -n "$subdomains" ]; then
        for sub in $subdomains; do
            local sub_len=${#sub}
            if [ $sub_len -gt 60 ]; then
                dns_findings+=("long_subdomain:$sub")
                ((dns_score += 30))
                log_warning "Suspiciously long subdomain (${sub_len} chars): ${sub:0:50}..."
            fi
        done
    fi
    
    # Check for DNS rebinding patterns
    if echo "$content" | safe_grep_qiE "rebind\.|rbndr\.|1u\.ms|nip\.io|sslip\.io|xip\.io"; then
        local rebind=$(echo "$content" | safe_grep_oiE "(rebind|rbndr|1u\.ms|nip\.io|sslip\.io|xip\.io)[^\s]*" | head -1)
        dns_findings+=("dns_rebinding:$rebind")
        ((dns_score += 45))
        log_threat 50 "DNS rebinding service detected: $rebind"
    fi
    
    if [ ${#dns_findings[@]} -gt 0 ]; then
        {
            echo "═══════════════════════════════════════════════"
            echo "DNS TUNNELING ANALYSIS"
            echo "═══════════════════════════════════════════════"
            echo "Timestamp: $(date -Iseconds)"
            echo "Threat Score: $dns_score"
            echo ""
            echo "Findings:"
            for finding in "${dns_findings[@]}"; do
                echo "  - $finding"
            done
            echo ""
            echo "MITRE ATT&CK: T1071.004 - Application Layer Protocol: DNS"
            echo "MITRE ATT&CK: T1048.003 - Exfiltration Over Alternative Protocol"
        } >> "$dns_report"
        
        log_threat $((dns_score / 2)) "DNS tunneling indicators detected"
        record_ioc "dns_tunnel" "${dns_findings[0]}" "DNS exfiltration indicator"
    fi
}

# ICMP Tunneling Detection - ICMP covert channel indicators
analyze_icmp_tunneling() {
    set +u
    local content="${1:-}"
    set -u
    local icmp_report="${OUTPUT_DIR}/icmp_tunneling_analysis.txt"
    
    log_info "Analyzing for ICMP tunneling indicators..."
    
    local icmp_findings=()
    local icmp_score=0
    
    # ICMP tunneling tool references
    local -a ICMP_TUNNEL_PATTERNS=(
        "icmptunnel"
        "ptunnel"
        "icmpsh"
        "icmp_shell"
        "icmpexfil"
        "pingback"
        "icmp.*tunnel"
        "ping.*exfil"
        "icmp.*c2"
        "icmp.*beacon"
        "hans\s+tunnel"  # hans ICMP tunnel
        "icmptx"
        "icmp_command"
    )
    
    # Check for ICMP tool references
    for pattern in "${ICMP_TUNNEL_PATTERNS[@]}"; do
        if echo "$content" | safe_grep_qiE "$pattern"; then
            local matched=$(echo "$content" | safe_grep_oiE "$pattern" 2>/dev/null | head -1)
            icmp_findings+=("icmp_tunnel_tool:$matched")
            ((icmp_score += 40))
            log_threat 45 "ICMP tunneling tool reference: $matched"
        fi
    done
    
    # Check for ping-based exfiltration patterns
    if echo "$content" | safe_grep_qiE "ping\s+-[pc]\s+.*\$\(|ping.*\|.*base64|ping.*data="; then
        icmp_findings+=("ping_exfil_command")
        ((icmp_score += 35))
        log_warning "Ping-based data exfiltration pattern detected"
    fi
    
    # Check for encoded ping payloads
    if echo "$content" | safe_grep_qiE "echo\s+.*\|\s*xxd.*ping|ping.*-p\s+[0-9a-f]{16,}"; then
        icmp_findings+=("encoded_ping_payload")
        ((icmp_score += 30))
        log_warning "Encoded ping payload detected"
    fi
    
    if [ ${#icmp_findings[@]} -gt 0 ]; then
        {
            echo "═══════════════════════════════════════════════"
            echo "ICMP TUNNELING ANALYSIS"
            echo "═══════════════════════════════════════════════"
            echo "Timestamp: $(date -Iseconds)"
            echo "Threat Score: $icmp_score"
            echo ""
            echo "Findings:"
            for finding in "${icmp_findings[@]}"; do
                echo "  - $finding"
            done
            echo ""
            echo "MITRE ATT&CK: T1095 - Non-Application Layer Protocol"
            echo "MITRE ATT&CK: T1572 - Protocol Tunneling"
        } >> "$icmp_report"
        
        log_threat $((icmp_score / 2)) "ICMP tunneling indicators detected"
        record_ioc "icmp_tunnel" "${icmp_findings[0]}" "ICMP covert channel indicator"
    fi
}

# WebSocket Abuse Detection - WebSocket upgrade/hijack patterns
analyze_websocket_abuse() {
    set +u
    local content="${1:-}"
    set -u
    local ws_report="${OUTPUT_DIR}/websocket_abuse_analysis.txt"
    
    log_info "Analyzing for WebSocket abuse patterns..."
    
    local ws_findings=()
    local ws_score=0
    
    # WebSocket abuse patterns
    local -a WS_ABUSE_PATTERNS=(
        # WebSocket URLs
        "wss?://[^\s]+/(shell|cmd|exec|reverse|backdoor)"
        "wss?://[^\s]+/c2"
        "wss?://[^\s]+/beacon"
        # WebSocket hijacking
        "sec-websocket-key.*inject"
        "upgrade:.*websocket.*\x00"
        "websocket.*cross-site"
        # Malicious WebSocket endpoints
        "ws://[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+:[0-9]+"
        "wss?://[^\s]+\.onion"
        # WebSocket C2 frameworks
        "sliver.*ws"
        "cobalt.*websocket"
        "metasploit.*websocket"
    )
    
    # Check WebSocket URL patterns
    if echo "$content" | safe_grep_qiE "wss?://"; then
        local ws_urls=$(echo "$content" | safe_grep_oiE "wss?://[^\s\"'<>]+" | head -5)
        for ws_url in $ws_urls; do
            ws_findings+=("websocket_url:$ws_url")
            ((ws_score += 15))
            
            # Check for suspicious WebSocket endpoints
            if echo "$ws_url" | grep -qiE "(shell|cmd|exec|reverse|c2|beacon|backdoor)"; then
                ((ws_score += 35))
                log_threat 50 "Malicious WebSocket endpoint: $ws_url"
            fi
            
            # Direct IP WebSocket connections
            if echo "$ws_url" | grep -qE "wss?://[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+"; then
                ((ws_score += 25))
                log_warning "Direct IP WebSocket connection: $ws_url"
            fi
        done
    fi
    
    # Check for WebSocket upgrade injection
    if echo "$content" | safe_grep_qiE "upgrade:\s*websocket|connection:\s*upgrade"; then
        ws_findings+=("ws_upgrade_header")
        ((ws_score += 10))
    fi
    
    # Check for WebSocket in data URIs (evasion technique)
    if echo "$content" | safe_grep_qiE "data:.*websocket|javascript:.*WebSocket"; then
        ws_findings+=("ws_in_data_uri")
        ((ws_score += 30))
        log_warning "WebSocket initialization in data URI detected"
    fi
    
    for pattern in "${WS_ABUSE_PATTERNS[@]}"; do
        if echo "$content" | safe_grep_qiE "$pattern"; then
            local matched=$(echo "$content" | safe_grep_oiE "$pattern" 2>/dev/null | head -1)
            ws_findings+=("ws_abuse_pattern:$matched")
            ((ws_score += 25))
        fi
    done
    
    if [ ${#ws_findings[@]} -gt 0 ]; then
        {
            echo "═══════════════════════════════════════════════"
            echo "WEBSOCKET ABUSE ANALYSIS"
            echo "═══════════════════════════════════════════════"
            echo "Timestamp: $(date -Iseconds)"
            echo "Threat Score: $ws_score"
            echo ""
            echo "Findings:"
            for finding in "${ws_findings[@]}"; do
                echo "  - $finding"
            done
            echo ""
            echo "MITRE ATT&CK: T1071.001 - Web Protocols"
            echo "MITRE ATT&CK: T1102 - Web Service"
        } >> "$ws_report"
        
        if [ $ws_score -ge 30 ]; then
            log_threat $((ws_score / 2)) "WebSocket abuse indicators detected"
            record_ioc "websocket_abuse" "${ws_findings[0]}" "WebSocket attack indicator"
        fi
    fi
}

# gRPC Abuse Detection - gRPC endpoint exploitation
analyze_grpc_abuse() {
    set +u
    local content="${1:-}"
    set -u
    local grpc_report="${OUTPUT_DIR}/grpc_abuse_analysis.txt"
    
    log_info "Analyzing for gRPC abuse patterns..."
    
    local grpc_findings=()
    local grpc_score=0
    
    # gRPC abuse patterns
    local -a GRPC_ABUSE_PATTERNS=(
        # gRPC endpoints
        "grpc://[^\s]+"
        "grpcs://[^\s]+"
        # gRPC reflection abuse
        "grpc\.reflection"
        "ServerReflection"
        "ListServices"
        # gRPC C2 indicators
        "grpc.*beacon"
        "grpc.*implant"
        "grpc.*c2"
        # Protocol buffer abuse
        "\.proto.*exec"
        "protobuf.*shell"
        # gRPC web exploitation
        "grpc-web.*inject"
        "application/grpc-web"
    )
    
    # Check for gRPC URLs
    if echo "$content" | safe_grep_qiE "grpcs?://"; then
        local grpc_urls=$(echo "$content" | safe_grep_oiE "grpcs?://[^\s\"'<>]+" | head -5)
        for grpc_url in $grpc_urls; do
            grpc_findings+=("grpc_endpoint:$grpc_url")
            ((grpc_score += 20))
            log_info "gRPC endpoint detected: $grpc_url"
            
            # Check for direct IP gRPC
            if echo "$grpc_url" | grep -qE "grpcs?://[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+"; then
                ((grpc_score += 20))
                log_warning "Direct IP gRPC connection"
            fi
        done
    fi
    
    for pattern in "${GRPC_ABUSE_PATTERNS[@]}"; do
        if echo "$content" | safe_grep_qiE "$pattern"; then
            local matched=$(echo "$content" | safe_grep_oiE "$pattern" 2>/dev/null | head -1)
            grpc_findings+=("grpc_abuse:$matched")
            ((grpc_score += 25))
        fi
    done
    
    # Check for gRPC reflection exploitation
    if echo "$content" | safe_grep_qiE "grpcurl|grpc_cli|evans\s+cli"; then
        grpc_findings+=("grpc_recon_tool")
        ((grpc_score += 30))
        log_warning "gRPC reconnaissance tool reference detected"
    fi
    
    if [ ${#grpc_findings[@]} -gt 0 ]; then
        {
            echo "═══════════════════════════════════════════════"
            echo "gRPC ABUSE ANALYSIS"
            echo "═══════════════════════════════════════════════"
            echo "Timestamp: $(date -Iseconds)"
            echo "Threat Score: $grpc_score"
            echo ""
            echo "Findings:"
            for finding in "${grpc_findings[@]}"; do
                echo "  - $finding"
            done
            echo ""
            echo "MITRE ATT&CK: T1071.001 - Web Protocols"
        } >> "$grpc_report"
        
        if [ $grpc_score -ge 30 ]; then
            log_threat $((grpc_score / 2)) "gRPC abuse indicators detected"
            record_ioc "grpc_abuse" "${grpc_findings[0]}" "gRPC exploitation indicator"
        fi
    fi
}

# GraphQL Injection Detection - GraphQL query injection in URLs
analyze_graphql_injection() {
    set +u
    local content="${1:-}"
    set -u
    local graphql_report="${OUTPUT_DIR}/graphql_injection_analysis.txt"
    
    log_info "Analyzing for GraphQL injection patterns..."
    
    local graphql_findings=()
    local graphql_score=0
    
    # GraphQL injection patterns
    local -a GRAPHQL_INJECTION_PATTERNS=(
        # Introspection queries (often first step in GraphQL attacks)
        "__schema"
        "__type"
        "__typename"
        "introspectionQuery"
        # Batch query abuse
        "\[\s*\{.*query.*\}.*\{.*query.*\}\s*\]"
        # Nested query attacks (DoS)
        "(\{[^}]*){5,}"
        # Field suggestion abuse
        "didYouMean"
        # Alias-based attacks
        "(alias[0-9]+:){3,}"
        # Directive injection
        "@include.*\$|@skip.*\$"
        # Fragment injection
        "fragment.*on.*\{.*__"
        # Mutation injection
        "mutation\s*\{.*delete|mutation\s*\{.*drop|mutation\s*\{.*truncate"
        # SQL injection in GraphQL
        "query.*\"\s*OR\s*\"1\"\s*=\s*\"1"
        "query.*'\s*OR\s*'1'\s*=\s*'1"
        "query.*UNION\s+SELECT"
    )
    
    # Check for GraphQL endpoints
    if echo "$content" | safe_grep_qiE "/graphql|/gql|/query"; then
        local gql_endpoints=$(echo "$content" | safe_grep_oiE "https?://[^\s]+/(graphql|gql|query)[^\s]*" | head -5)
        for endpoint in $gql_endpoints; do
            graphql_findings+=("graphql_endpoint:$endpoint")
            ((graphql_score += 10))
        done
    fi
    
    for pattern in "${GRAPHQL_INJECTION_PATTERNS[@]}"; do
        if echo "$content" | safe_grep_qiE "$pattern"; then
            local matched=$(echo "$content" | safe_grep_oiE "$pattern" 2>/dev/null | head -1)
            graphql_findings+=("graphql_injection:$matched")
            ((graphql_score += 30))
            log_warning "GraphQL injection pattern: ${matched:0:50}"
        fi
    done
    
    # Check for GraphQL batching attacks
    if echo "$content" | safe_grep_qE "\[\s*\{[^]]*query[^]]*\}\s*,\s*\{[^]]*query"; then
        graphql_findings+=("graphql_batch_attack")
        ((graphql_score += 35))
        log_threat 40 "GraphQL batch query attack detected"
    fi
    
    # Check for deeply nested queries (DoS)
    local nesting_depth=$(echo "$content" | safe_grep_oE "\{" | wc -l)
    if [ "$nesting_depth" -gt 10 ]; then
        graphql_findings+=("deep_nesting:$nesting_depth")
        ((graphql_score += 25))
        log_warning "Deep GraphQL nesting detected (depth: $nesting_depth)"
    fi
    
    if [ ${#graphql_findings[@]} -gt 0 ]; then
        {
            echo "═══════════════════════════════════════════════"
            echo "GRAPHQL INJECTION ANALYSIS"
            echo "═══════════════════════════════════════════════"
            echo "Timestamp: $(date -Iseconds)"
            echo "Threat Score: $graphql_score"
            echo ""
            echo "Findings:"
            for finding in "${graphql_findings[@]}"; do
                echo "  - $finding"
            done
            echo ""
            echo "MITRE ATT&CK: T1190 - Exploit Public-Facing Application"
            echo "MITRE ATT&CK: T1059 - Command and Scripting Interpreter"
        } >> "$graphql_report"
        
        if [ $graphql_score -ge 30 ]; then
            log_threat $((graphql_score / 2)) "GraphQL injection indicators detected"
            record_ioc "graphql_injection" "${graphql_findings[0]}" "GraphQL attack indicator"
        fi
    fi
}

# MQTT IoT Abuse Detection - MQTT protocol abuse for IoT attacks
analyze_mqtt_iot_abuse() {
    set +u
    local content="${1:-}"
    set -u
    local mqtt_report="${OUTPUT_DIR}/mqtt_iot_analysis.txt"
    
    log_info "Analyzing for MQTT/IoT abuse patterns..."
    
    local mqtt_findings=()
    local mqtt_score=0
    
    # MQTT abuse patterns
    local -a MQTT_ABUSE_PATTERNS=(
        # MQTT URLs
        "mqtt://[^\s]+"
        "mqtts://[^\s]+"
        "tcp://[^\s]+:1883"
        "ssl://[^\s]+:8883"
        # MQTT wildcards (potential abuse)
        "topic.*#"
        "topic.*\+"
        # MQTT broker indicators
        "mosquitto"
        "emqx"
        "hivemq"
        "vernemq"
        # IoT command topics
        "topic.*/cmd"
        "topic.*/command"
        "topic.*/exec"
        "topic.*/shell"
        # Default credentials
        "mqtt.*guest:guest"
        "mqtt.*admin:admin"
        "mqtt.*test:test"
        # MQTT C2 patterns
        "mqtt.*c2"
        "mqtt.*beacon"
        "mqtt.*implant"
        # IoT firmware update abuse
        "ota.*update.*mqtt"
        "firmware.*mqtt"
    )
    
    # IoT platform abuse
    local -a IOT_PLATFORM_ABUSE=(
        "aws-iot.*exec"
        "azure-iot.*cmd"
        "google-iot.*shell"
        "thingsboard.*script"
        "home-assistant.*exec"
        "openhab.*shell"
        "domoticz.*cmd"
        "tasmota.*backlog"
    )
    
    # Check for MQTT URLs
    if echo "$content" | safe_grep_qiE "mqtts?://|tcp://[^\s]+:1883"; then
        local mqtt_urls=$(echo "$content" | safe_grep_oiE "(mqtts?://|tcp://)[^\s\"'<>]+" | head -5)
        for mqtt_url in $mqtt_urls; do
            mqtt_findings+=("mqtt_endpoint:$mqtt_url")
            ((mqtt_score += 20))
            log_info "MQTT endpoint detected: $mqtt_url"
        done
    fi
    
    for pattern in "${MQTT_ABUSE_PATTERNS[@]}"; do
        if echo "$content" | safe_grep_qiE "$pattern"; then
            local matched=$(echo "$content" | safe_grep_oiE "$pattern" 2>/dev/null | head -1)
            mqtt_findings+=("mqtt_abuse:$matched")
            ((mqtt_score += 25))
        fi
    done
    
    for pattern in "${IOT_PLATFORM_ABUSE[@]}"; do
        if echo "$content" | safe_grep_qiE "$pattern"; then
            local matched=$(echo "$content" | safe_grep_oiE "$pattern" 2>/dev/null | head -1)
            mqtt_findings+=("iot_platform_abuse:$matched")
            ((mqtt_score += 35))
            log_threat 40 "IoT platform abuse detected: $matched"
        fi
    done
    
    # Check for Shodan/Censys IoT queries
    if echo "$content" | safe_grep_qiE "shodan.*mqtt|censys.*1883|shodan.*iot"; then
        mqtt_findings+=("iot_recon_query")
        ((mqtt_score += 30))
        log_warning "IoT reconnaissance query detected"
    fi
    
    if [ ${#mqtt_findings[@]} -gt 0 ]; then
        {
            echo "═══════════════════════════════════════════════"
            echo "MQTT/IoT ABUSE ANALYSIS"
            echo "═══════════════════════════════════════════════"
            echo "Timestamp: $(date -Iseconds)"
            echo "Threat Score: $mqtt_score"
            echo ""
            echo "Findings:"
            for finding in "${mqtt_findings[@]}"; do
                echo "  - $finding"
            done
            echo ""
            echo "MITRE ATT&CK: T1071.001 - Web Protocols"
            echo "MITRE ATT&CK: T1021 - Remote Services"
        } >> "$mqtt_report"
        
        if [ $mqtt_score -ge 30 ]; then
            log_threat $((mqtt_score / 2)) "MQTT/IoT abuse indicators detected"
            record_ioc "mqtt_abuse" "${mqtt_findings[0]}" "MQTT/IoT attack indicator"
        fi
    fi
}

# CoAP Attack Detection - Constrained Application Protocol abuse
analyze_coap_attacks() {
    set +u
    local content="${1:-}"
    set -u
    local coap_report="${OUTPUT_DIR}/coap_attack_analysis.txt"
    
    log_info "Analyzing for CoAP attack patterns..."
    
    local coap_findings=()
    local coap_score=0
    
    # CoAP abuse patterns
    local -a COAP_ABUSE_PATTERNS=(
        # CoAP URLs
        "coaps?://[^\s]+"
        "coap\+tcp://[^\s]+"
        # CoAP amplification patterns
        "coap.*\.well-known/core"
        "coap.*block[12]"
        # CoAP observe abuse
        "coap.*observe"
        # CoAP resource discovery
        "coap.*rt=.*\*"
        # Port 5683/5684
        ":[56]68[34]/"
        # CoAP proxy abuse
        "coap.*proxy"
        "coap-gateway"
    )
    
    for pattern in "${COAP_ABUSE_PATTERNS[@]}"; do
        if echo "$content" | safe_grep_qiE "$pattern"; then
            local matched=$(echo "$content" | safe_grep_oiE "$pattern" 2>/dev/null | head -1)
            coap_findings+=("coap_pattern:$matched")
            ((coap_score += 25))
        fi
    done
    
    # Check for CoAP URLs
    if echo "$content" | safe_grep_qiE "coaps?://"; then
        local coap_urls=$(echo "$content" | safe_grep_oiE "coaps?://[^\s\"'<>]+" | head -5)
        for coap_url in $coap_urls; do
            coap_findings+=("coap_endpoint:$coap_url")
            ((coap_score += 20))
            log_info "CoAP endpoint detected: $coap_url"
        done
    fi
    
    # Check for CoAP amplification attack indicators
    if echo "$content" | safe_grep_qiE "coap.*amplif|coap.*ddos|coap.*reflect"; then
        coap_findings+=("coap_amplification")
        ((coap_score += 40))
        log_threat 45 "CoAP amplification attack indicator"
    fi
    
    if [ ${#coap_findings[@]} -gt 0 ]; then
        {
            echo "═══════════════════════════════════════════════"
            echo "CoAP ATTACK ANALYSIS"
            echo "═══════════════════════════════════════════════"
            echo "Timestamp: $(date -Iseconds)"
            echo "Threat Score: $coap_score"
            echo ""
            echo "Findings:"
            for finding in "${coap_findings[@]}"; do
                echo "  - $finding"
            done
            echo ""
            echo "MITRE ATT&CK: T1498 - Network Denial of Service"
        } >> "$coap_report"
        
        if [ $coap_score -ge 25 ]; then
            log_threat $((coap_score / 2)) "CoAP attack indicators detected"
            record_ioc "coap_abuse" "${coap_findings[0]}" "CoAP attack indicator"
        fi
    fi
}

# QUIC Protocol Tunneling Detection
analyze_quic_tunneling() {
    set +u
    local content="${1:-}"
    set -u
    local quic_report="${OUTPUT_DIR}/quic_tunneling_analysis.txt"
    
    log_info "Analyzing for QUIC tunneling patterns..."
    
    local quic_findings=()
    local quic_score=0
    
    # QUIC abuse patterns
    local -a QUIC_ABUSE_PATTERNS=(
        # QUIC URLs
        "quic://[^\s]+"
        # UDP port 443 abuse
        "udp.*:443"
        "udp/443"
        # QUIC tunneling indicators
        "quic.*tunnel"
        "quic.*proxy"
        "quic.*vpn"
        # Masque protocol
        "masque"
        "connect-udp"
        # QUIC C2 indicators
        "quic.*c2"
        "quic.*beacon"
        # HTTP/3 exploitation
        "h3.*tunnel"
        "alt-svc.*h3"
    )
    
    for pattern in "${QUIC_ABUSE_PATTERNS[@]}"; do
        if echo "$content" | safe_grep_qiE "$pattern"; then
            local matched=$(echo "$content" | safe_grep_oiE "$pattern" 2>/dev/null | head -1)
            quic_findings+=("quic_pattern:$matched")
            ((quic_score += 25))
        fi
    done
    
    # Check for QUIC protocol references
    if echo "$content" | safe_grep_qiE "quic://"; then
        local quic_urls=$(echo "$content" | safe_grep_oiE "quic://[^\s\"'<>]+" | head -5)
        for quic_url in $quic_urls; do
            quic_findings+=("quic_endpoint:$quic_url")
            ((quic_score += 20))
        done
    fi
    
    # Check for HTTP/3 indicators
    if echo "$content" | safe_grep_qiE "h3-[0-9]+|:protocol=.*h3"; then
        quic_findings+=("http3_indicator")
        ((quic_score += 15))
    fi
    
    if [ ${#quic_findings[@]} -gt 0 ]; then
        {
            echo "═══════════════════════════════════════════════"
            echo "QUIC TUNNELING ANALYSIS"
            echo "═══════════════════════════════════════════════"
            echo "Timestamp: $(date -Iseconds)"
            echo "Threat Score: $quic_score"
            echo ""
            echo "Findings:"
            for finding in "${quic_findings[@]}"; do
                echo "  - $finding"
            done
            echo ""
            echo "MITRE ATT&CK: T1572 - Protocol Tunneling"
        } >> "$quic_report"
        
        if [ $quic_score -ge 25 ]; then
            log_threat $((quic_score / 2)) "QUIC tunneling indicators detected"
            record_ioc "quic_tunnel" "${quic_findings[0]}" "QUIC abuse indicator"
        fi
    fi
}

# HTTP/3 Fingerprinting Evasion Detection
analyze_http3_fingerprinting() {
    set +u
    local content="${1:-}"
    set -u
    local http3_report="${OUTPUT_DIR}/http3_fingerprinting_analysis.txt"
    
    log_info "Analyzing for HTTP/3 fingerprinting evasion..."
    
    local http3_findings=()
    local http3_score=0
    
    # HTTP/3 evasion patterns
    local -a HTTP3_EVASION_PATTERNS=(
        # Alt-Svc header abuse
        "alt-svc:.*h3"
        "alt-svc:.*clear"
        # QPACK header compression abuse
        "qpack"
        # HTTP/3 priority abuse
        ":priority"
        "priority:.*u="
        # Connection coalescing abuse
        "origin.*frame"
        # HTTP/3 frame type abuse
        "cancel_push"
        "goaway"
        "max_push_id"
        # Early hints abuse
        "103.*early.*hints"
    )
    
    for pattern in "${HTTP3_EVASION_PATTERNS[@]}"; do
        if echo "$content" | safe_grep_qiE "$pattern"; then
            local matched=$(echo "$content" | safe_grep_oiE "$pattern" 2>/dev/null | head -1)
            http3_findings+=("http3_pattern:$matched")
            ((http3_score += 20))
        fi
    done
    
    # Check for HTTP/3 server fingerprinting
    if echo "$content" | safe_grep_qiE "ja3.*quic|quic.*fingerprint"; then
        http3_findings+=("http3_fingerprinting")
        ((http3_score += 30))
        log_warning "HTTP/3 fingerprinting technique detected"
    fi
    
    if [ ${#http3_findings[@]} -gt 0 ]; then
        {
            echo "═══════════════════════════════════════════════"
            echo "HTTP/3 FINGERPRINTING ANALYSIS"
            echo "═══════════════════════════════════════════════"
            echo "Timestamp: $(date -Iseconds)"
            echo "Threat Score: $http3_score"
            echo ""
            echo "Findings:"
            for finding in "${http3_findings[@]}"; do
                echo "  - $finding"
            done
        } >> "$http3_report"
        
        if [ $http3_score -ge 25 ]; then
            log_threat $((http3_score / 2)) "HTTP/3 fingerprinting evasion detected"
        fi
    fi
}

# IPFS/Distributed Storage Threat Detection
analyze_ipfs_threats() {
    set +u
    local content="${1:-}"
    set -u
    local ipfs_report="${OUTPUT_DIR}/ipfs_threat_analysis.txt"
    
    log_info "Analyzing for IPFS/distributed storage threats..."
    
    local ipfs_findings=()
    local ipfs_score=0
    
    # IPFS threat patterns
    local -a IPFS_THREAT_PATTERNS=(
        # IPFS URLs
        "ipfs://[^\s]+"
        "ipns://[^\s]+"
        "dweb:/[^\s]+"
        # IPFS gateways
        "ipfs\.io/ipfs/"
        "gateway\.pinata\.cloud"
        "cloudflare-ipfs\.com"
        "gateway\.ipfs\.io"
        "infura-ipfs\.io"
        "w3s\.link"
        "nftstorage\.link"
        # IPFS CIDs (Content Identifiers)
        "Qm[1-9A-HJ-NP-Za-km-z]{44}"
        "bafy[a-z0-9]{50,}"
        "bafk[a-z0-9]{50,}"
        # Filecoin
        "filecoin"
        "fil://[^\s]+"
        # Arweave
        "arweave\.net"
        "ar://[^\s]+"
        # Storj
        "storj"
        "link\.storjshare\.io"
    )
    
    # Known malicious IPFS content patterns
    local -a IPFS_MALWARE_PATTERNS=(
        "ipfs.*malware"
        "ipfs.*phish"
        "ipfs.*stealer"
        "ipfs.*dropper"
        "ipfs.*loader"
        "dweb.*exec"
        "ipfs.*ransomware"
    )
    
    for pattern in "${IPFS_THREAT_PATTERNS[@]}"; do
        if echo "$content" | safe_grep_qiE "$pattern"; then
            local matched=$(echo "$content" | safe_grep_oiE "$pattern" 2>/dev/null | head -1)
            ipfs_findings+=("ipfs_resource:$matched")
            ((ipfs_score += 15))
        fi
    done
    
    # Check for IPFS CIDs
    local ipfs_cids=$(echo "$content" | safe_grep_oE "Qm[1-9A-HJ-NP-Za-km-z]{44}|bafy[a-z0-9]{50,}")
    if [ -n "$ipfs_cids" ]; then
        for cid in $ipfs_cids; do
            ipfs_findings+=("ipfs_cid:$cid")
            ((ipfs_score += 20))
            log_info "IPFS CID detected: ${cid:0:20}..."
        done
    fi
    
    for pattern in "${IPFS_MALWARE_PATTERNS[@]}"; do
        if echo "$content" | safe_grep_qiE "$pattern"; then
            local matched=$(echo "$content" | safe_grep_oiE "$pattern" 2>/dev/null | head -1)
            ipfs_findings+=("ipfs_malware:$matched")
            ((ipfs_score += 40))
            log_threat 50 "IPFS malware indicator: $matched"
        fi
    done
    
    # Check for decentralized hosting abuse
    if echo "$content" | safe_grep_qiE "(fleek|netlify|vercel).*ipfs|(ipfs|dweb)\.link.*\.(exe|dll|scr|bat|ps1)"; then
        ipfs_findings+=("decentralized_hosting_abuse")
        ((ipfs_score += 35))
        log_threat 45 "Decentralized hosting abuse detected"
    fi
    
    if [ ${#ipfs_findings[@]} -gt 0 ]; then
        {
            echo "═══════════════════════════════════════════════"
            echo "IPFS/DISTRIBUTED STORAGE THREAT ANALYSIS"
            echo "═══════════════════════════════════════════════"
            echo "Timestamp: $(date -Iseconds)"
            echo "Threat Score: $ipfs_score"
            echo ""
            echo "Findings:"
            for finding in "${ipfs_findings[@]}"; do
                echo "  - $finding"
            done
            echo ""
            echo "MITRE ATT&CK: T1102.002 - Bidirectional Communication"
            echo "MITRE ATT&CK: T1567 - Exfiltration Over Web Service"
        } >> "$ipfs_report"
        
        if [ $ipfs_score -ge 25 ]; then
            log_threat $((ipfs_score / 2)) "IPFS/distributed storage threat indicators detected"
            record_ioc "ipfs_threat" "${ipfs_findings[0]}" "IPFS/decentralized threat indicator"
        fi
    fi
}

# SSE (Server-Sent Events) Abuse Detection
analyze_sse_abuse() {
    set +u
    local content="${1:-}"
    set -u
    
    log_info "Analyzing for SSE abuse patterns..."
    
    local sse_findings=()
    local sse_score=0
    
    # SSE abuse patterns
    local -a SSE_ABUSE_PATTERNS=(
        "text/event-stream"
        "EventSource\("
        "eventsource.*shell"
        "sse.*c2"
        "sse.*beacon"
        "event-stream.*exec"
    )
    
    for pattern in "${SSE_ABUSE_PATTERNS[@]}"; do
        if echo "$content" | safe_grep_qiE "$pattern"; then
            local matched=$(echo "$content" | safe_grep_oiE "$pattern" 2>/dev/null | head -1)
            sse_findings+=("sse_abuse:$matched")
            ((sse_score += 25))
        fi
    done
    
    if [ ${#sse_findings[@]} -gt 0 ] && [ $sse_score -ge 25 ]; then
        log_threat $((sse_score / 2)) "SSE abuse indicators detected"
        record_ioc "sse_abuse" "${sse_findings[0]}" "SSE attack indicator"
    fi
}

# WebRTC Abuse Detection
analyze_webrtc_abuse() {
    set +u
    local content="${1:-}"
    set -u
    local webrtc_report="${OUTPUT_DIR}/webrtc_abuse_analysis.txt"
    
    log_info "Analyzing for WebRTC abuse patterns..."
    
    local webrtc_findings=()
    local webrtc_score=0
    
    # WebRTC abuse patterns
    local -a WEBRTC_ABUSE_PATTERNS=(
        # WebRTC fingerprinting
        "RTCPeerConnection"
        "webrtc.*fingerprint"
        "webrtc.*leak"
        # STUN/TURN abuse
        "stun:[^\s]+"
        "turn:[^\s]+"
        "turns:[^\s]+"
        # ICE candidate harvesting
        "icecandidate"
        "icegatheringstate"
        # WebRTC data channel abuse
        "datachannel.*exec"
        "rtcdatachannel.*shell"
        # IP leak detection
        "localDescription.*candidate"
        "srflx.*candidate"
        "relay.*candidate"
    )
    
    for pattern in "${WEBRTC_ABUSE_PATTERNS[@]}"; do
        if echo "$content" | safe_grep_qiE "$pattern"; then
            local matched=$(echo "$content" | safe_grep_oiE "$pattern" 2>/dev/null | head -1)
            webrtc_findings+=("webrtc_pattern:$matched")
            ((webrtc_score += 20))
        fi
    done
    
    # Check for STUN/TURN server URLs
    if echo "$content" | safe_grep_qiE "stun:|turn:"; then
        local stun_urls=$(echo "$content" | safe_grep_oiE "(stun|turn)s?:[^\s\"'<>]+" | head -5)
        for stun_url in $stun_urls; do
            webrtc_findings+=("stun_turn_server:$stun_url")
            ((webrtc_score += 15))
        done
    fi
    
    # WebRTC IP leak exploitation
    if echo "$content" | safe_grep_qiE "webrtc.*ip.*leak|rtc.*local.*ip|getusermedia.*deny"; then
        webrtc_findings+=("webrtc_ip_leak")
        ((webrtc_score += 35))
        log_warning "WebRTC IP leak exploitation detected"
    fi
    
    if [ ${#webrtc_findings[@]} -gt 0 ]; then
        {
            echo "═══════════════════════════════════════════════"
            echo "WebRTC ABUSE ANALYSIS"
            echo "═══════════════════════════════════════════════"
            echo "Timestamp: $(date -Iseconds)"
            echo "Threat Score: $webrtc_score"
            echo ""
            echo "Findings:"
            for finding in "${webrtc_findings[@]}"; do
                echo "  - $finding"
            done
            echo ""
            echo "MITRE ATT&CK: T1592 - Gather Victim Host Information"
        } >> "$webrtc_report"
        
        if [ $webrtc_score -ge 25 ]; then
            log_threat $((webrtc_score / 2)) "WebRTC abuse indicators detected"
            record_ioc "webrtc_abuse" "${webrtc_findings[0]}" "WebRTC attack indicator"
        fi
    fi
}

# Blockchain/Web3 Attack Detection
analyze_blockchain_attacks() {
    set +u
    local content="${1:-}"
    set -u
    local blockchain_report="${OUTPUT_DIR}/blockchain_attack_analysis.txt"
    
    log_info "Analyzing for blockchain/Web3 attack patterns..."
    
    local blockchain_findings=()
    local blockchain_score=0
    
    # Blockchain attack patterns
    local -a BLOCKCHAIN_ATTACK_PATTERNS=(
        # Wallet drainer patterns
        "setApprovalForAll"
        "approve.*unlimited"
        "transferFrom.*max"
        "permit.*signature"
        "signTypedData"
        # Malicious contract calls
        "eth_sendTransaction"
        "eth_signTransaction"
        "personal_sign"
        "eth_sign"
        # Phishing domains
        "metamask.*connect"
        "wallet.*connect.*phish"
        "claim.*airdrop"
        "free.*nft.*mint"
        # Rug pull indicators
        "liquidity.*remove"
        "honeypot"
        "renounce.*ownership"
        # Flash loan attack
        "flashloan"
        "flash.*arbitrage"
        # MEV/sandwich attacks
        "frontrun"
        "sandwich.*attack"
        "mev.*bot"
    )
    
    # Malicious contract addresses (examples)
    local -a KNOWN_SCAM_CONTRACTS=(
        "0x0000.*dead"
        "0xdead.*beef"
    )
    
    for pattern in "${BLOCKCHAIN_ATTACK_PATTERNS[@]}"; do
        if echo "$content" | safe_grep_qiE "$pattern"; then
            local matched=$(echo "$content" | safe_grep_oiE "$pattern" 2>/dev/null | head -1)
            blockchain_findings+=("blockchain_attack:$matched")
            ((blockchain_score += 30))
            log_warning "Blockchain attack pattern: $matched"
        fi
    done
    
    # Check for Ethereum addresses
    local eth_addresses=$(echo "$content" | safe_grep_oiE "0x[a-fA-F0-9]{40}")
    if [ -n "$eth_addresses" ]; then
        for addr in $eth_addresses; do
            blockchain_findings+=("eth_address:$addr")
            ((blockchain_score += 10))
        done
    fi
    
    # Check for wallet connection phishing
    if echo "$content" | safe_grep_qiE "connect.*wallet|sign.*message|approve.*token"; then
        blockchain_findings+=("wallet_phishing")
        ((blockchain_score += 35))
        log_threat 40 "Wallet phishing attempt detected"
    fi
    
    # Check for seed phrase phishing
    if echo "$content" | safe_grep_qiE "seed.*phrase|recovery.*phrase|mnemonic|12.*words|24.*words"; then
        blockchain_findings+=("seed_phrase_phishing")
        ((blockchain_score += 50))
        log_threat 60 "Seed phrase phishing attempt detected"
    fi
    
    if [ ${#blockchain_findings[@]} -gt 0 ]; then
        {
            echo "═══════════════════════════════════════════════"
            echo "BLOCKCHAIN/WEB3 ATTACK ANALYSIS"
            echo "═══════════════════════════════════════════════"
            echo "Timestamp: $(date -Iseconds)"
            echo "Threat Score: $blockchain_score"
            echo ""
            echo "Findings:"
            for finding in "${blockchain_findings[@]}"; do
                echo "  - $finding"
            done
            echo ""
            echo "Attack Categories:"
            echo "  - Wallet Drainer"
            echo "  - Phishing"
            echo "  - Smart Contract Exploitation"
        } >> "$blockchain_report"
        
        if [ $blockchain_score -ge 30 ]; then
            log_threat $((blockchain_score / 2)) "Blockchain/Web3 attack indicators detected"
            record_ioc "blockchain_attack" "${blockchain_findings[0]}" "Web3 attack indicator"
        fi
    fi
}

# OAuth/OIDC Attack Detection
analyze_oauth_attacks() {
    set +u
    local content="${1:-}"
    set -u
    local oauth_report="${OUTPUT_DIR}/oauth_attack_analysis.txt"
    
    log_info "Analyzing for OAuth/OIDC attack patterns..."
    
    local oauth_findings=()
    local oauth_score=0
    
    # OAuth attack patterns
    local -a OAUTH_ATTACK_PATTERNS=(
        # Authorization code injection
        "redirect_uri.*javascript:"
        "redirect_uri.*data:"
        "redirect_uri=.*@"
        # Token theft patterns
        "access_token=.*&"
        "id_token=.*\."
        "refresh_token=.*"
        # Open redirect abuse
        "redirect_uri=https?://[^/]*@"
        "redirect_uri=.*%2F%2F"
        "redirect_uri=.*\\\\/"
        # Scope manipulation
        "scope=.*admin"
        "scope=.*openid.*profile.*email.*all"
        # State parameter manipulation
        "state=.*\.\."
        "state=.*;.*"
        # PKCE bypass attempts
        "code_challenge.*none"
        "code_verifier.*bypass"
        # JWT attacks
        "alg.*none"
        "kid.*\.\."
        "jku.*evil"
    )
    
    for pattern in "${OAUTH_ATTACK_PATTERNS[@]}"; do
        if echo "$content" | safe_grep_qiE "$pattern"; then
            local matched=$(echo "$content" | safe_grep_oiE "$pattern" 2>/dev/null | head -1)
            oauth_findings+=("oauth_attack:$matched")
            ((oauth_score += 35))
            log_warning "OAuth attack pattern: ${matched:0:50}"
        fi
    done
    
    # Check for OAuth URLs
    if echo "$content" | safe_grep_qiE "oauth|authorize|token"; then
        local oauth_urls=$(echo "$content" | safe_grep_oiE "https?://[^\s]*/(oauth|authorize|token)[^\s]*" | head -5)
        for oauth_url in $oauth_urls; do
            oauth_findings+=("oauth_endpoint:$oauth_url")
            ((oauth_score += 10))
            
            # Check for suspicious redirect_uri
            if echo "$oauth_url" | grep -qiE "redirect_uri=.*localhost|redirect_uri=.*127\.0\.0\.1"; then
                ((oauth_score += 15))
            fi
        done
    fi
    
    if [ ${#oauth_findings[@]} -gt 0 ]; then
        {
            echo "═══════════════════════════════════════════════"
            echo "OAUTH/OIDC ATTACK ANALYSIS"
            echo "═══════════════════════════════════════════════"
            echo "Timestamp: $(date -Iseconds)"
            echo "Threat Score: $oauth_score"
            echo ""
            echo "Findings:"
            for finding in "${oauth_findings[@]}"; do
                echo "  - $finding"
            done
            echo ""
            echo "MITRE ATT&CK: T1550.001 - Application Access Token"
        } >> "$oauth_report"
        
        if [ $oauth_score -ge 30 ]; then
            log_threat $((oauth_score / 2)) "OAuth/OIDC attack indicators detected"
            record_ioc "oauth_attack" "${oauth_findings[0]}" "OAuth exploitation indicator"
        fi
    fi
}

# SAML Attack Detection
analyze_saml_attacks() {
    set +u
    local content="${1:-}"
    set -u
    local saml_report="${OUTPUT_DIR}/saml_attack_analysis.txt"
    
    log_info "Analyzing for SAML attack patterns..."
    
    local saml_findings=()
    local saml_score=0
    
    # SAML attack patterns
    local -a SAML_ATTACK_PATTERNS=(
        # XML Signature Wrapping
        "saml.*signature.*wrapping"
        "SignatureValue.*duplicate"
        # SAML assertion manipulation
        "Assertion.*modify"
        "saml:Issuer.*spoof"
        # Comment injection in XML
        "<!--.*-->"
        # SAML replay
        "saml.*replay"
        "assertion.*replay"
        # Golden SAML
        "golden.*saml"
        "forge.*saml"
        # SAML token theft
        "SAMLResponse.*steal"
        "saml.*token.*exfil"
        # XXE in SAML
        "<!ENTITY.*SAML"
        "<!DOCTYPE.*SAML"
    )
    
    for pattern in "${SAML_ATTACK_PATTERNS[@]}"; do
        if echo "$content" | safe_grep_qiE "$pattern"; then
            local matched=$(echo "$content" | safe_grep_oiE "$pattern" 2>/dev/null | head -1)
            saml_findings+=("saml_attack:$matched")
            ((saml_score += 40))
            log_warning "SAML attack pattern: $matched"
        fi
    done
    
    # Check for SAML endpoints
    if echo "$content" | safe_grep_qiE "SAMLRequest|SAMLResponse|saml2|SingleSignOn"; then
        saml_findings+=("saml_endpoint")
        ((saml_score += 15))
        
        # Check for base64 SAML assertions
        if echo "$content" | safe_grep_qiE "SAMLResponse=[A-Za-z0-9+/=]{100,}"; then
            saml_findings+=("saml_assertion")
            ((saml_score += 20))
        fi
    fi
    
    if [ ${#saml_findings[@]} -gt 0 ]; then
        {
            echo "═══════════════════════════════════════════════"
            echo "SAML ATTACK ANALYSIS"
            echo "═══════════════════════════════════════════════"
            echo "Timestamp: $(date -Iseconds)"
            echo "Threat Score: $saml_score"
            echo ""
            echo "Findings:"
            for finding in "${saml_findings[@]}"; do
                echo "  - $finding"
            done
            echo ""
            echo "MITRE ATT&CK: T1606.002 - SAML Tokens"
        } >> "$saml_report"
        
        if [ $saml_score -ge 30 ]; then
            log_threat $((saml_score / 2)) "SAML attack indicators detected"
            record_ioc "saml_attack" "${saml_findings[0]}" "SAML exploitation indicator"
        fi
    fi
}

# Container/Kubernetes Attack Detection
analyze_container_attacks() {
    set +u
    local content="${1:-}"
    set -u
    local container_report="${OUTPUT_DIR}/container_attack_analysis.txt"
    
    log_info "Analyzing for container/Kubernetes attack patterns..."
    
    local container_findings=()
    local container_score=0
    
    # Container attack patterns
    local -a CONTAINER_ATTACK_PATTERNS=(
        # Kubernetes API abuse
        "kubectl.*exec"
        "kubectl.*proxy"
        "kubernetes.*api.*secret"
        "/api/v1/namespaces/.*/pods/.*/exec"
        # Container escape
        "docker.*escape"
        "container.*breakout"
        "nsenter"
        "cgroup.*release_agent"
        "privileged.*true"
        # Image poisoning
        "docker.*pull.*:latest"
        "FROM.*malicious"
        # Registry abuse
        "docker.*login.*password"
        "registry.*auth"
        # Service account token theft
        "/var/run/secrets/kubernetes.io"
        "serviceaccount.*token"
        # Helm chart exploitation
        "helm.*install.*untrusted"
        # kubelet exploitation
        "kubelet.*10250"
        "kubelet.*10255"
        # etcd exposure
        "etcd.*2379"
        "etcdctl.*get"
    )
    
    for pattern in "${CONTAINER_ATTACK_PATTERNS[@]}"; do
        if echo "$content" | safe_grep_qiE "$pattern"; then
            local matched=$(echo "$content" | safe_grep_oiE "$pattern" 2>/dev/null | head -1)
            container_findings+=("container_attack:$matched")
            ((container_score += 35))
            log_warning "Container attack pattern: $matched"
        fi
    done
    
    # Check for Docker Hub malicious images
    if echo "$content" | safe_grep_qiE "docker\.io/[^\s]+:(latest|dev|test|crypto|miner)"; then
        container_findings+=("suspicious_image")
        ((container_score += 25))
    fi
    
    # Check for container runtime socket exposure
    if echo "$content" | safe_grep_qiE "/var/run/docker\.sock|/var/run/containerd/containerd\.sock"; then
        container_findings+=("socket_exposure")
        ((container_score += 40))
        log_threat 50 "Container runtime socket exposure detected"
    fi
    
    if [ ${#container_findings[@]} -gt 0 ]; then
        {
            echo "═══════════════════════════════════════════════"
            echo "CONTAINER/KUBERNETES ATTACK ANALYSIS"
            echo "═══════════════════════════════════════════════"
            echo "Timestamp: $(date -Iseconds)"
            echo "Threat Score: $container_score"
            echo ""
            echo "Findings:"
            for finding in "${container_findings[@]}"; do
                echo "  - $finding"
            done
            echo ""
            echo "MITRE ATT&CK: T1610 - Deploy Container"
            echo "MITRE ATT&CK: T1611 - Escape to Host"
        } >> "$container_report"
        
        if [ $container_score -ge 30 ]; then
            log_threat $((container_score / 2)) "Container/Kubernetes attack indicators detected"
            record_ioc "container_attack" "${container_findings[0]}" "Container attack indicator"
        fi
    fi
}

# Serverless/Function Attack Detection
analyze_serverless_attacks() {
    set +u
    local content="${1:-}"
    set -u
    local serverless_report="${OUTPUT_DIR}/serverless_attack_analysis.txt"
    
    log_info "Analyzing for serverless/function attack patterns..."
    
    local serverless_findings=()
    local serverless_score=0
    
    # Serverless attack patterns
    local -a SERVERLESS_ATTACK_PATTERNS=(
        # Lambda abuse
        "lambda.*invoke.*malicious"
        "aws.*lambda.*update-function"
        "lambda.*exec.*cmd"
        # Function URL abuse
        "lambda-url.*execute-api"
        "cloudfunctions\.net/.*exec"
        # Event injection
        "lambda.*event.*injection"
        "trigger.*poison"
        # IAM role abuse
        "sts.*assume-role"
        "lambda.*role.*escalate"
        # Cold start abuse
        "cold.*start.*exfil"
        # Layer poisoning
        "lambda.*layer.*malicious"
        # Function as C2
        "function.*c2"
        "serverless.*beacon"
        # Azure Functions
        "azurewebsites\.net/api/.*exec"
        "functions\.azure\.com.*cmd"
        # GCP Functions
        "cloudfunctions\.net.*shell"
        "run\.app.*exec"
    )
    
    for pattern in "${SERVERLESS_ATTACK_PATTERNS[@]}"; do
        if echo "$content" | safe_grep_qiE "$pattern"; then
            local matched=$(echo "$content" | safe_grep_oiE "$pattern" 2>/dev/null | head -1)
            serverless_findings+=("serverless_attack:$matched")
            ((serverless_score += 30))
        fi
    done
    
    # Check for serverless function URLs
    if echo "$content" | safe_grep_qiE "lambda-url\..*\.on\.aws|execute-api\..*\.amazonaws\.com|cloudfunctions\.net|azurewebsites\.net/api"; then
        local func_urls=$(echo "$content" | safe_grep_oiE "https?://[^\s]*(lambda-url|execute-api|cloudfunctions|azurewebsites)[^\s]*" | head -5)
        for func_url in $func_urls; do
            serverless_findings+=("serverless_url:$func_url")
            ((serverless_score += 15))
        done
    fi
    
    if [ ${#serverless_findings[@]} -gt 0 ]; then
        {
            echo "═══════════════════════════════════════════════"
            echo "SERVERLESS ATTACK ANALYSIS"
            echo "═══════════════════════════════════════════════"
            echo "Timestamp: $(date -Iseconds)"
            echo "Threat Score: $serverless_score"
            echo ""
            echo "Findings:"
            for finding in "${serverless_findings[@]}"; do
                echo "  - $finding"
            done
            echo ""
            echo "MITRE ATT&CK: T1648 - Serverless Execution"
        } >> "$serverless_report"
        
        if [ $serverless_score -ge 25 ]; then
            log_threat $((serverless_score / 2)) "Serverless attack indicators detected"
            record_ioc "serverless_attack" "${serverless_findings[0]}" "Serverless attack indicator"
        fi
    fi
}

################################################################################
# ADVANCED EVASION DETECTION ENGINES
# Comprehensive detection for sophisticated network evasion techniques
################################################################################

# Fast-Flux DNS Network Detection
# Detects rapidly changing DNS records used by botnets and malware C2
analyze_fast_flux() {
    set +u
    local content="${1:-}"
    set -u
    local fastflux_report="${OUTPUT_DIR}/fast_flux_analysis.txt"
    
    log_info "Analyzing for Fast-Flux DNS indicators..."
    
    local ff_findings=()
    local ff_score=0
    
    # Fast-flux indicators
    local -a FAST_FLUX_PATTERNS=(
        # Known fast-flux domains patterns
        "flux.*dns"
        "fast.*flux"
        "double.*flux"
        # Short TTL indicators in content
        "ttl[=:]\s*[0-9]{1,2}[^0-9]"
        "ttl[=:]\s*(60|30|120|180|300)\b"
        # Multiple A record patterns
        "round.*robin.*dns"
        "dns.*load.*balance"
        # Fast-flux service indicators
        "bulletproof.*host"
        "offshore.*dns"
        # Known fast-flux networks
        "avalanche"
        "kelihos"
        "waledac"
        "storm.*worm"
        "conficker"
    )
    
    # Fast-flux NS patterns
    local -a FF_NS_PATTERNS=(
        # Suspicious nameserver patterns
        "ns[0-9]+\.[a-z]{2,4}\.[a-z]{2,3}"
        "dns[0-9]+\.[a-z]{2,4}\.[a-z]{2,3}"
        # Geographic distribution indicators
        "ns\.(ru|cn|ua|ro|bg|md)\."
    )
    
    for pattern in "${FAST_FLUX_PATTERNS[@]}"; do
        if echo "$content" | safe_grep_qiE "$pattern"; then
            local matched=$(echo "$content" | safe_grep_oiE "$pattern" 2>/dev/null | head -1)
            ff_findings+=("fast_flux:$matched")
            ((ff_score += 30))
            log_warning "Fast-flux indicator: $matched"
        fi
    done
    
    for pattern in "${FF_NS_PATTERNS[@]}"; do
        if echo "$content" | safe_grep_qiE "$pattern"; then
            local matched=$(echo "$content" | safe_grep_oiE "$pattern" 2>/dev/null | head -1)
            ff_findings+=("suspicious_ns:$matched")
            ((ff_score += 20))
        fi
    done
    
    # Check for multiple IP addresses in content (potential flux indicators)
    local ip_count=$(echo "$content" | safe_grep_oE "[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}" | sort -u | wc -l)
    if [ "$ip_count" -gt 5 ]; then
        ff_findings+=("multiple_ips:$ip_count")
        ((ff_score += 25))
        log_warning "Multiple unique IPs detected ($ip_count) - possible fast-flux"
    fi
    
    # Check for domain age indicators (new domains are suspicious)
    if echo "$content" | safe_grep_qiE "registered.*today|created.*[0-9]{4}-[0-9]{2}-[0-9]{2}|whois.*new"; then
        ff_findings+=("new_domain")
        ((ff_score += 20))
    fi
    
    if [ ${#ff_findings[@]} -gt 0 ]; then
        {
            echo "═══════════════════════════════════════════════"
            echo "FAST-FLUX DNS ANALYSIS"
            echo "═══════════════════════════════════════════════"
            echo "Timestamp: $(date -Iseconds)"
            echo "Threat Score: $ff_score"
            echo ""
            echo "Findings:"
            for finding in "${ff_findings[@]}"; do
                echo "  - $finding"
            done
            echo ""
            echo "Analysis Notes:"
            echo "  - Fast-flux networks rapidly rotate IP addresses"
            echo "  - Often use compromised hosts as proxies"
            echo "  - Associated with botnets and bulletproof hosting"
            echo ""
            echo "MITRE ATT&CK: T1568.001 - Fast Flux DNS"
        } >> "$fastflux_report"
        
        if [ $ff_score -ge 30 ]; then
            log_threat $((ff_score / 2)) "Fast-flux DNS indicators detected"
            record_ioc "fast_flux" "${ff_findings[0]}" "Fast-flux network indicator"
        fi
    fi
}

# Domain Fronting Detection
# Detects technique of routing traffic through legitimate CDN domains
analyze_domain_fronting() {
    set +u
    local content="${1:-}"
    set -u
    local df_report="${OUTPUT_DIR}/domain_fronting_analysis.txt"
    
    log_info "Analyzing for domain fronting indicators..."
    
    local df_findings=()
    local df_score=0
    
    # Domain fronting indicators
    local -a DOMAIN_FRONTING_PATTERNS=(
        # CDN abuse patterns
        "cloudfront\.net.*host:"
        "azureedge\.net.*host:"
        "cloudflare\.com.*host:"
        "fastly\.net.*host:"
        "akamai\.net.*host:"
        "googleapis\.com.*host:"
        # Host header manipulation
        "host:\s*[^\s]+\s+.*sni"
        "host.*!=.*sni"
        "host.*mismatch"
        # Known fronting domains
        "ajax\.googleapis\.com"
        "www\.google\.com.*beacon"
        "*.appspot.com.*redirect"
        # Fronting tool indicators
        "domain.*front"
        "fronting.*cdn"
        "meek.*transport"
        "meek-azure"
        "meek-amazon"
        "meek-google"
    )
    
    # Known frontable CDN domains
    local -a FRONTABLE_CDNS=(
        "cloudfront\.net"
        "azureedge\.net"
        "cloudflare\.com"
        "fastly\.net"
        "akamaihd\.net"
        "googleapis\.com"
        "appspot\.com"
        "azurewebsites\.net"
        "firebaseapp\.com"
    )
    
    for pattern in "${DOMAIN_FRONTING_PATTERNS[@]}"; do
        if echo "$content" | safe_grep_qiE "$pattern"; then
            local matched=$(echo "$content" | safe_grep_oiE "$pattern" 2>/dev/null | head -1)
            df_findings+=("domain_fronting:$matched")
            ((df_score += 35))
            log_warning "Domain fronting indicator: $matched"
        fi
    done
    
    # Check for frontable CDN with suspicious paths
    for cdn in "${FRONTABLE_CDNS[@]}"; do
        if echo "$content" | safe_grep_qiE "$cdn.*(c2|beacon|shell|cmd|exec)"; then
            local matched=$(echo "$content" | safe_grep_oiE "$cdn[^\s]+" 2>/dev/null | head -1)
            df_findings+=("frontable_cdn_abuse:$matched")
            ((df_score += 40))
            log_threat 50 "Suspicious CDN endpoint: $matched"
        fi
    done
    
    # Check for Tor meek bridges
    if echo "$content" | safe_grep_qiE "meek.*bridge|meek-client|meek.*obfs4"; then
        df_findings+=("tor_meek_fronting")
        ((df_score += 30))
        log_warning "Tor meek bridge (domain fronting) detected"
    fi
    
    if [ ${#df_findings[@]} -gt 0 ]; then
        {
            echo "═══════════════════════════════════════════════"
            echo "DOMAIN FRONTING ANALYSIS"
            echo "═══════════════════════════════════════════════"
            echo "Timestamp: $(date -Iseconds)"
            echo "Threat Score: $df_score"
            echo ""
            echo "Findings:"
            for finding in "${df_findings[@]}"; do
                echo "  - $finding"
            done
            echo ""
            echo "Technique:"
            echo "  - Uses legitimate CDN domains as cover"
            echo "  - SNI shows legitimate domain, Host header differs"
            echo "  - Difficult to block without breaking legitimate traffic"
            echo ""
            echo "MITRE ATT&CK: T1090.004 - Domain Fronting"
        } >> "$df_report"
        
        if [ $df_score -ge 30 ]; then
            log_threat $((df_score / 2)) "Domain fronting indicators detected"
            record_ioc "domain_fronting" "${df_findings[0]}" "Domain fronting technique"
        fi
    fi
}

# DNS over HTTPS (DoH) Abuse Detection
# Detects malicious use of encrypted DNS for C2 communication
analyze_dns_over_https() {
    set +u
    local content="${1:-}"
    set -u
    local doh_report="${OUTPUT_DIR}/doh_abuse_analysis.txt"
    
    log_info "Analyzing for DNS-over-HTTPS abuse..."
    
    local doh_findings=()
    local doh_score=0
    
    # DoH providers and endpoints
    local -a DOH_ENDPOINTS=(
        "cloudflare-dns\.com/dns-query"
        "dns\.google/dns-query"
        "dns\.google/resolve"
        "1\.1\.1\.1/dns-query"
        "8\.8\.8\.8/dns-query"
        "dns\.quad9\.net/dns-query"
        "doh\.opendns\.com/dns-query"
        "dns\.nextdns\.io"
        "doh\.cleanbrowsing\.org"
        "doh\.applied-privacy\.net"
        "dns\.adguard\.com/dns-query"
        "mozilla\.cloudflare-dns\.com"
    )
    
    # DoH abuse patterns
    local -a DOH_ABUSE_PATTERNS=(
        # DoH C2 indicators
        "doh.*c2"
        "doh.*tunnel"
        "doh.*exfil"
        "dns-query.*payload"
        # DoH client tools
        "doh-client"
        "doh-proxy"
        "godoh"
        "dnscat.*doh"
        # Unusual DoH usage
        "application/dns-json"
        "application/dns-message"
        "accept:.*dns"
        # DoH with suspicious parameters
        "dns-query\?.*type=TXT"
        "dns-query\?.*name=[a-z0-9]{32,}"
    )
    
    # Check for DoH endpoints
    for endpoint in "${DOH_ENDPOINTS[@]}"; do
        if echo "$content" | safe_grep_qiE "$endpoint"; then
            local matched=$(echo "$content" | safe_grep_oiE "https?://[^\s]*$endpoint[^\s]*" 2>/dev/null | head -1)
            doh_findings+=("doh_endpoint:$matched")
            ((doh_score += 15))
            
            # Check if combined with suspicious patterns
            if echo "$content" | safe_grep_qiE "$endpoint.*(tunnel|c2|beacon|exfil)"; then
                ((doh_score += 30))
                log_threat 45 "DoH C2 abuse detected"
            fi
        fi
    done
    
    for pattern in "${DOH_ABUSE_PATTERNS[@]}"; do
        if echo "$content" | safe_grep_qiE "$pattern"; then
            local matched=$(echo "$content" | safe_grep_oiE "$pattern" 2>/dev/null | head -1)
            doh_findings+=("doh_abuse:$matched")
            ((doh_score += 25))
        fi
    done
    
    # Check for base64/hex encoded DNS queries
    if echo "$content" | safe_grep_qiE "dns-query\?dns=[A-Za-z0-9+/=]{20,}"; then
        doh_findings+=("encoded_doh_query")
        ((doh_score += 30))
        log_warning "Encoded DoH query detected"
    fi
    
    if [ ${#doh_findings[@]} -gt 0 ]; then
        {
            echo "═══════════════════════════════════════════════"
            echo "DNS-OVER-HTTPS ABUSE ANALYSIS"
            echo "═══════════════════════════════════════════════"
            echo "Timestamp: $(date -Iseconds)"
            echo "Threat Score: $doh_score"
            echo ""
            echo "Findings:"
            for finding in "${doh_findings[@]}"; do
                echo "  - $finding"
            done
            echo ""
            echo "Evasion Technique:"
            echo "  - Encrypts DNS queries to avoid inspection"
            echo "  - Uses legitimate DoH providers for cover"
            echo "  - Can tunnel arbitrary data via DNS queries"
            echo ""
            echo "MITRE ATT&CK: T1071.004 - Application Layer Protocol: DNS"
            echo "MITRE ATT&CK: T1573.001 - Encrypted Channel: Symmetric Cryptography"
        } >> "$doh_report"
        
        if [ $doh_score -ge 25 ]; then
            log_threat $((doh_score / 2)) "DoH abuse indicators detected"
            record_ioc "doh_abuse" "${doh_findings[0]}" "DNS-over-HTTPS abuse"
        fi
    fi
}

# DNS over TLS (DoT) Abuse Detection
analyze_dns_over_tls() {
    set +u
    local content="${1:-}"
    set -u
    local dot_report="${OUTPUT_DIR}/dot_abuse_analysis.txt"
    
    log_info "Analyzing for DNS-over-TLS abuse..."
    
    local dot_findings=()
    local dot_score=0
    
    # DoT indicators
    local -a DOT_PATTERNS=(
        # DoT port
        ":853"
        "port.*853"
        # DoT providers
        "dns\.google:853"
        "1\.1\.1\.1:853"
        "9\.9\.9\.9:853"
        "dns\.quad9\.net:853"
        # DoT tools
        "stubby"
        "knot-resolver"
        "unbound.*tls"
        # DoT abuse
        "dot.*tunnel"
        "dot.*c2"
        "tls.*dns.*exfil"
    )
    
    for pattern in "${DOT_PATTERNS[@]}"; do
        if echo "$content" | safe_grep_qiE "$pattern"; then
            local matched=$(echo "$content" | safe_grep_oiE "$pattern" 2>/dev/null | head -1)
            dot_findings+=("dot_pattern:$matched")
            ((dot_score += 20))
        fi
    done
    
    # Check for DoT combined with suspicious activity
    if echo "$content" | safe_grep_qiE ":853.*(beacon|shell|cmd|exec|tunnel)"; then
        dot_findings+=("dot_abuse")
        ((dot_score += 35))
        log_warning "DoT abuse pattern detected"
    fi
    
    if [ ${#dot_findings[@]} -gt 0 ]; then
        {
            echo "═══════════════════════════════════════════════"
            echo "DNS-OVER-TLS ABUSE ANALYSIS"
            echo "═══════════════════════════════════════════════"
            echo "Timestamp: $(date -Iseconds)"
            echo "Threat Score: $dot_score"
            echo ""
            echo "Findings:"
            for finding in "${dot_findings[@]}"; do
                echo "  - $finding"
            done
            echo ""
            echo "MITRE ATT&CK: T1071.004 - DNS Protocol"
        } >> "$dot_report"
        
        if [ $dot_score -ge 25 ]; then
            log_threat $((dot_score / 2)) "DoT abuse indicators detected"
            record_ioc "dot_abuse" "${dot_findings[0]}" "DNS-over-TLS abuse"
        fi
    fi
}

# Encrypted SNI (ESNI/ECH) Bypass Detection
analyze_esni_sni_bypass() {
    set +u
    local content="${1:-}"
    set -u
    local esni_report="${OUTPUT_DIR}/esni_bypass_analysis.txt"
    
    log_info "Analyzing for ESNI/ECH bypass techniques..."
    
    local esni_findings=()
    local esni_score=0
    
    # ESNI/ECH patterns
    local -a ESNI_PATTERNS=(
        # ESNI indicators
        "encrypted.*sni"
        "esni"
        "ech.*extension"
        "encrypted.*client.*hello"
        # ESNI bypass techniques
        "sni.*bypass"
        "sni.*spoof"
        "sni.*null"
        "sni.*empty"
        # TLS fingerprinting evasion
        "ja3.*spoof"
        "ja3s.*bypass"
        "jarm.*evasion"
        # SNI manipulation
        "servername.*mismatch"
        "sni.*fronting"
        # ECH specific
        "ech.*config"
        "echconfig"
        "_https._tcp.*ech"
    )
    
    for pattern in "${ESNI_PATTERNS[@]}"; do
        if echo "$content" | safe_grep_qiE "$pattern"; then
            local matched=$(echo "$content" | safe_grep_oiE "$pattern" 2>/dev/null | head -1)
            esni_findings+=("esni_technique:$matched")
            ((esni_score += 25))
        fi
    done
    
    # Check for TLS fingerprint evasion
    if echo "$content" | safe_grep_qiE "curl.*cipher|openssl.*s_client.*servername"; then
        esni_findings+=("tls_fingerprint_evasion")
        ((esni_score += 20))
    fi
    
    if [ ${#esni_findings[@]} -gt 0 ]; then
        {
            echo "═══════════════════════════════════════════════"
            echo "ESNI/ECH BYPASS ANALYSIS"
            echo "═══════════════════════════════════════════════"
            echo "Timestamp: $(date -Iseconds)"
            echo "Threat Score: $esni_score"
            echo ""
            echo "Findings:"
            for finding in "${esni_findings[@]}"; do
                echo "  - $finding"
            done
            echo ""
            echo "MITRE ATT&CK: T1573 - Encrypted Channel"
        } >> "$esni_report"
        
        if [ $esni_score -ge 25 ]; then
            log_threat $((esni_score / 2)) "ESNI/ECH bypass techniques detected"
            record_ioc "esni_bypass" "${esni_findings[0]}" "ESNI evasion technique"
        fi
    fi
}

# Traffic Fragmentation Evasion Detection
analyze_traffic_fragmentation() {
    set +u
    local content="${1:-}"
    set -u
    local frag_report="${OUTPUT_DIR}/traffic_fragmentation_analysis.txt"
    
    log_info "Analyzing for traffic fragmentation evasion..."
    
    local frag_findings=()
    local frag_score=0
    
    # Fragmentation patterns
    local -a FRAGMENTATION_PATTERNS=(
        # IP fragmentation
        "fragment.*offset"
        "ip.*fragment"
        "frag.*attack"
        "teardrop"
        "ping.*of.*death"
        # TCP segmentation abuse
        "tcp.*segment"
        "tcp.*split"
        "overlapping.*segment"
        # HTTP chunked abuse
        "chunked.*encoding.*bypass"
        "transfer-encoding.*chunked"
        "chunk.*split"
        # Application layer fragmentation
        "split.*payload"
        "fragment.*reassembl"
        "reassembly.*evasion"
        # Tools
        "fragroute"
        "fragrouter"
        "nmap.*fragment"
        "scapy.*fragment"
    )
    
    for pattern in "${FRAGMENTATION_PATTERNS[@]}"; do
        if echo "$content" | safe_grep_qiE "$pattern"; then
            local matched=$(echo "$content" | safe_grep_oiE "$pattern" 2>/dev/null | head -1)
            frag_findings+=("fragmentation:$matched")
            ((frag_score += 25))
        fi
    done
    
    # Check for MTU manipulation
    if echo "$content" | safe_grep_qiE "mtu[=:]\s*[0-9]+|set.*mtu.*[0-9]+"; then
        frag_findings+=("mtu_manipulation")
        ((frag_score += 20))
    fi
    
    if [ ${#frag_findings[@]} -gt 0 ]; then
        {
            echo "═══════════════════════════════════════════════"
            echo "TRAFFIC FRAGMENTATION ANALYSIS"
            echo "═══════════════════════════════════════════════"
            echo "Timestamp: $(date -Iseconds)"
            echo "Threat Score: $frag_score"
            echo ""
            echo "Findings:"
            for finding in "${frag_findings[@]}"; do
                echo "  - $finding"
            done
            echo ""
            echo "MITRE ATT&CK: T1027.010 - Command Obfuscation"
        } >> "$frag_report"
        
        if [ $frag_score -ge 25 ]; then
            log_threat $((frag_score / 2)) "Traffic fragmentation evasion detected"
            record_ioc "fragmentation" "${frag_findings[0]}" "Fragmentation evasion"
        fi
    fi
}

# Protocol Switching Detection
# Detects mid-session protocol switching for evasion
analyze_protocol_switching() {
    set +u
    local content="${1:-}"
    set -u
    local proto_report="${OUTPUT_DIR}/protocol_switching_analysis.txt"
    
    log_info "Analyzing for protocol switching evasion..."
    
    local proto_findings=()
    local proto_score=0
    
    # Protocol switching patterns
    local -a PROTOCOL_SWITCH_PATTERNS=(
        # HTTP upgrade abuse
        "upgrade:.*websocket"
        "upgrade:.*h2c"
        "upgrade:.*tls"
        "101.*switching.*protocol"
        # Protocol tunneling
        "http.*tunnel.*ssh"
        "ssh.*over.*http"
        "tcp.*over.*http"
        "icmp.*over.*dns"
        # ALPN abuse
        "alpn.*switch"
        "alpn.*h2"
        "alpn.*http/1.1.*then.*h2"
        # Connection upgrade
        "connection:.*upgrade"
        "http.*connect.*method"
        # Protocol multiplexing
        "multiplex.*protocol"
        "yamux"
        "smux"
        "mux.*stream"
    )
    
    for pattern in "${PROTOCOL_SWITCH_PATTERNS[@]}"; do
        if echo "$content" | safe_grep_qiE "$pattern"; then
            local matched=$(echo "$content" | safe_grep_oiE "$pattern" 2>/dev/null | head -1)
            proto_findings+=("protocol_switch:$matched")
            ((proto_score += 25))
        fi
    done
    
    # Check for HTTP CONNECT tunneling
    if echo "$content" | safe_grep_qiE "connect\s+[^\s]+:[0-9]+\s+http"; then
        proto_findings+=("http_connect_tunnel")
        ((proto_score += 30))
        log_warning "HTTP CONNECT tunneling detected"
    fi
    
    # Check for protocol confusion
    if echo "$content" | safe_grep_qiE "sslstrip|ssl.*downgrade|https.*http.*redirect"; then
        proto_findings+=("protocol_downgrade")
        ((proto_score += 35))
        log_threat 40 "Protocol downgrade attack indicator"
    fi
    
    if [ ${#proto_findings[@]} -gt 0 ]; then
        {
            echo "═══════════════════════════════════════════════"
            echo "PROTOCOL SWITCHING ANALYSIS"
            echo "═══════════════════════════════════════════════"
            echo "Timestamp: $(date -Iseconds)"
            echo "Threat Score: $proto_score"
            echo ""
            echo "Findings:"
            for finding in "${proto_findings[@]}"; do
                echo "  - $finding"
            done
            echo ""
            echo "MITRE ATT&CK: T1572 - Protocol Tunneling"
        } >> "$proto_report"
        
        if [ $proto_score -ge 25 ]; then
            log_threat $((proto_score / 2)) "Protocol switching evasion detected"
            record_ioc "protocol_switch" "${proto_findings[0]}" "Protocol switching evasion"
        fi
    fi
}

# Timing Channel Detection
# Detects timing-based covert channels
analyze_timing_channels() {
    set +u
    local content="${1:-}"
    set -u
    local timing_report="${OUTPUT_DIR}/timing_channel_analysis.txt"
    
    log_info "Analyzing for timing-based covert channels..."
    
    local timing_findings=()
    local timing_score=0
    
    # Timing channel patterns
    local -a TIMING_CHANNEL_PATTERNS=(
        # Timing-based exfiltration
        "timing.*channel"
        "covert.*timing"
        "delay.*based.*channel"
        # Sleep/delay patterns for C2
        "sleep\s*\(\s*[0-9]+\s*\)"
        "timeout.*beacon"
        "jitter.*sleep"
        "random.*delay"
        # Ping timing abuse
        "ping.*timing"
        "icmp.*timing"
        # Network timing
        "ttl.*modulation"
        "packet.*timing"
        "inter-packet.*delay"
        # Keystroke timing
        "keystroke.*timing"
        "timing.*attack"
        # CPU timing
        "spectre"
        "meltdown"
        "timing.*side.*channel"
    )
    
    for pattern in "${TIMING_CHANNEL_PATTERNS[@]}"; do
        if echo "$content" | safe_grep_qiE "$pattern"; then
            local matched=$(echo "$content" | safe_grep_oiE "$pattern" 2>/dev/null | head -1)
            timing_findings+=("timing_channel:$matched")
            ((timing_score += 30))
        fi
    done
    
    # Check for C2 jitter/beacon timing
    if echo "$content" | safe_grep_qiE "beacon.*interval|jitter.*[0-9]+%|sleep.*random"; then
        timing_findings+=("c2_timing_pattern")
        ((timing_score += 35))
        log_warning "C2 beacon timing pattern detected"
    fi
    
    if [ ${#timing_findings[@]} -gt 0 ]; then
        {
            echo "═══════════════════════════════════════════════"
            echo "TIMING CHANNEL ANALYSIS"
            echo "═══════════════════════════════════════════════"
            echo "Timestamp: $(date -Iseconds)"
            echo "Threat Score: $timing_score"
            echo ""
            echo "Findings:"
            for finding in "${timing_findings[@]}"; do
                echo "  - $finding"
            done
            echo ""
            echo "MITRE ATT&CK: T1029 - Scheduled Transfer"
            echo "MITRE ATT&CK: T1132 - Data Encoding"
        } >> "$timing_report"
        
        if [ $timing_score -ge 25 ]; then
            log_threat $((timing_score / 2)) "Timing-based covert channel detected"
            record_ioc "timing_channel" "${timing_findings[0]}" "Timing covert channel"
        fi
    fi
}

# Steganographic DNS Detection
# Detects DNS TXT record steganography
analyze_steganographic_dns() {
    set +u
    local content="${1:-}"
    set -u
    local steg_dns_report="${OUTPUT_DIR}/steganographic_dns_analysis.txt"
    
    log_info "Analyzing for DNS steganography..."
    
    local steg_findings=()
    local steg_score=0
    
    # DNS steganography patterns
    local -a DNS_STEG_PATTERNS=(
        # DNS TXT record abuse
        "txt.*record.*encode"
        "dns.*txt.*base64"
        "dns.*txt.*payload"
        "txt.*record.*exfil"
        # DNS record steganography
        "dns.*steg"
        "dns.*covert"
        "dns.*hidden.*data"
        # DNSSEC abuse
        "dnssec.*abuse"
        "dnskey.*payload"
        "rrsig.*hidden"
        # DNS CNAME/MX abuse
        "cname.*encode"
        "mx.*record.*data"
        # Tools
        "iodine"
        "dns2tcp"
        "dnscat"
        "dnscapy"
        "heyoka"
        "ozyman"
        # Encoded subdomain patterns
        "[a-z0-9]{50,}\.[a-z0-9-]+\.[a-z]{2,}"
    )
    
    for pattern in "${DNS_STEG_PATTERNS[@]}"; do
        if echo "$content" | safe_grep_qiE "$pattern"; then
            local matched=$(echo "$content" | safe_grep_oiE "$pattern" 2>/dev/null | head -1)
            steg_findings+=("dns_steg:$matched")
            ((steg_score += 30))
        fi
    done
    
    # Check for base32/base64 in DNS-like patterns
    if echo "$content" | safe_grep_qiE "[A-Z2-7]{32,}\.[a-z]+\.[a-z]+|[A-Za-z0-9+/]{40,}=*\.[a-z]+"; then
        steg_findings+=("encoded_subdomain")
        ((steg_score += 35))
        log_warning "Encoded DNS subdomain detected"
    fi
    
    # Check for NULL byte or unusual characters in DNS
    if echo "$content" | safe_grep_qE "\\x00.*\.[a-z]+|\..*\\x00"; then
        steg_findings+=("dns_null_byte")
        ((steg_score += 25))
    fi
    
    if [ ${#steg_findings[@]} -gt 0 ]; then
        {
            echo "═══════════════════════════════════════════════"
            echo "STEGANOGRAPHIC DNS ANALYSIS"
            echo "═══════════════════════════════════════════════"
            echo "Timestamp: $(date -Iseconds)"
            echo "Threat Score: $steg_score"
            echo ""
            echo "Findings:"
            for finding in "${steg_findings[@]}"; do
                echo "  - $finding"
            done
            echo ""
            echo "Technique:"
            echo "  - Hides data in DNS TXT/CNAME/MX records"
            echo "  - Encodes payloads in subdomain names"
            echo "  - Evades traditional network monitoring"
            echo ""
            echo "MITRE ATT&CK: T1071.004 - DNS Protocol"
            echo "MITRE ATT&CK: T1001.003 - Protocol Impersonation"
        } >> "$steg_dns_report"
        
        if [ $steg_score -ge 25 ]; then
            log_threat $((steg_score / 2)) "DNS steganography detected"
            record_ioc "dns_steganography" "${steg_findings[0]}" "DNS steganography indicator"
        fi
    fi
}

################################################################################
# SUPPLY CHAIN & DEPENDENCY ATTACK DETECTION ENGINES
################################################################################

# Dependency Confusion Attack Detection
# Detects package name confusion attacks (internal vs public packages)
analyze_dependency_confusion() {
    set +u
    local content="${1:-}"
    set -u
    local dc_report="${OUTPUT_DIR}/dependency_confusion_analysis.txt"
    
    log_info "Analyzing for dependency confusion attacks..."
    
    local dc_findings=()
    local dc_score=0
    
    # Dependency confusion patterns
    local -a DEP_CONFUSION_PATTERNS=(
        # npm confusion indicators
        "npm.*install.*--registry"
        "npm.*config.*registry"
        "@[a-z]+/[a-z]+"  # Scoped packages
        "publishConfig.*registry"
        # PyPI confusion
        "pip.*install.*--index-url"
        "pip.*install.*--extra-index-url"
        "--trusted-host.*pypi"
        # Private registry indicators
        "artifactory"
        "nexus.*repository"
        "verdaccio"
        "sinopia"
        # Confusion attack indicators
        "internal.*package"
        "private.*registry"
        "preinstall.*script"
        "postinstall.*curl"
    )
    
    # Known internal package name patterns (that could be targeted)
    local -a INTERNAL_PKG_PATTERNS=(
        "company-.*"
        "internal-.*"
        "@company/"
        "@internal/"
        "@private/"
        "@corp/"
        "corp-.*"
        "priv-.*"
    )
    
    for pattern in "${DEP_CONFUSION_PATTERNS[@]}"; do
        if echo "$content" | safe_grep_qiE -e "$pattern" 2>/dev/null; then
            local matched=$(echo "$content" | safe_grep_oiE -e "$pattern" 2>/dev/null | head -1)
            dc_findings+=("dep_confusion:$matched")
            ((dc_score += 25))
        fi
    done
    
    # Check for package.json with suspicious scripts
    if echo "$content" | safe_grep_qiE '"preinstall".*:.*"curl\|wget\|nc\|bash\|sh\|python"'; then
        dc_findings+=("malicious_install_script")
        ((dc_score += 45))
        log_threat 50 "Malicious package install script detected"
    fi
    
    # Check for setup.py abuse
    if echo "$content" | safe_grep_qiE "setup\.py.*cmdclass\|install.*exec\|os\.system"; then
        dc_findings+=("malicious_setup_py")
        ((dc_score += 45))
        log_threat 50 "Malicious setup.py detected"
    fi
    
    # Check for version number abuse (very high version to override)
    if echo "$content" | safe_grep_qiE '"version".*:.*"[0-9]{3,}\.|version.*=.*[0-9]{3,}\.'; then
        dc_findings+=("version_number_abuse")
        ((dc_score += 30))
        log_warning "Suspicious high version number (dependency confusion)"
    fi
    
    if [ ${#dc_findings[@]} -gt 0 ]; then
        {
            echo "═══════════════════════════════════════════════"
            echo "DEPENDENCY CONFUSION ANALYSIS"
            echo "═══════════════════════════════════════════════"
            echo "Timestamp: $(date -Iseconds)"
            echo "Threat Score: $dc_score"
            echo ""
            echo "Findings:"
            for finding in "${dc_findings[@]}"; do
                echo "  - $finding"
            done
            echo ""
            echo "Attack Description:"
            echo "  - Attacker publishes malicious package with same name as internal pkg"
            echo "  - Uses higher version number to override internal package"
            echo "  - Executes malicious code during install"
            echo ""
            echo "MITRE ATT&CK: T1195.001 - Compromise Software Dependencies"
        } >> "$dc_report"
        
        if [ $dc_score -ge 30 ]; then
            log_threat $((dc_score / 2)) "Dependency confusion attack indicators"
            record_ioc "dependency_confusion" "${dc_findings[0]}" "Dependency confusion attack"
        fi
    fi
}

# Typosquatting Package Detection
# Detects npm/PyPI package typosquatting
analyze_typosquatting_packages() {
    set +u
    local content="${1:-}"
    set -u
    local typo_report="${OUTPUT_DIR}/typosquatting_analysis.txt"
    
    log_info "Analyzing for package typosquatting..."
    
    local typo_findings=()
    local typo_score=0
    
    # Known typosquatting patterns for popular packages
    local -a TYPOSQUAT_PATTERNS=(
        # npm typosquats
        "loadsh"        # lodash
        "lod-ash"
        "loadash"
        "requets"       # requests
        "reqeusts"
        "request-"
        "expresss"      # express
        "expres"
        "reakt"         # react
        "reactjs-"
        "angualr"       # angular
        "angluar"
        "typescirpt"    # typescript
        "typescrpt"
        "webpackk"      # webpack
        "wepack"
        # PyPI typosquats
        "python-dateutil-"
        "requestss"
        "numpyy"
        "pandass"
        "scipyy"
        "djang0"        # django
        "dajngo"
        "flaskk"
        "flaks"
        "pythonn"
        # Character substitution
        "0auth"         # oauth (0 for o)
        "c0lorsama"     # colorama
        "crypt0graphy"  # cryptography
    )
    
    # Typosquatting techniques
    local -a TYPOSQUAT_TECHNIQUES=(
        # Homoglyph attacks
        "[a-z]*[0oO][a-z]*"
        "[a-z]*[1lI][a-z]*"
        # Double letter
        "([a-z])\\1{2,}"
        # Missing letters
        # Adjacent key swaps
    )
    
    for pattern in "${TYPOSQUAT_PATTERNS[@]}"; do
        if echo "$content" | safe_grep_qiE "(npm.*install|pip.*install|require\(|import)\s*['\"]?$pattern"; then
            local matched=$(echo "$content" | safe_grep_oiE "$pattern" 2>/dev/null | head -1)
            typo_findings+=("typosquat:$matched")
            ((typo_score += 40))
            log_threat 45 "Typosquatted package: $matched"
        fi
    done
    
    # Check for suspicious package name patterns
    if echo "$content" | safe_grep_qiE "install.*[a-z]+-[a-z]+-[a-z]+-js|install.*[a-z]+[0-9]+[a-z]+"; then
        typo_findings+=("suspicious_pkg_name")
        ((typo_score += 20))
    fi
    
    # Check for known malicious package indicators
    if echo "$content" | safe_grep_qiE "event-stream|flatmap-stream|eslint-scope|getcookies|electron-native-notify"; then
        local matched=$(echo "$content" | safe_grep_oiE "(event-stream|flatmap-stream|eslint-scope|getcookies|electron-native-notify)" | head -1)
        typo_findings+=("known_malicious_pkg:$matched")
        ((typo_score += 50))
        log_threat 60 "Known malicious package: $matched"
    fi
    
    if [ ${#typo_findings[@]} -gt 0 ]; then
        {
            echo "═══════════════════════════════════════════════"
            echo "TYPOSQUATTING PACKAGE ANALYSIS"
            echo "═══════════════════════════════════════════════"
            echo "Timestamp: $(date -Iseconds)"
            echo "Threat Score: $typo_score"
            echo ""
            echo "Findings:"
            for finding in "${typo_findings[@]}"; do
                echo "  - $finding"
            done
            echo ""
            echo "Technique:"
            echo "  - Creates packages with similar names to popular libraries"
            echo "  - Exploits typos during package installation"
            echo "  - Often includes malicious postinstall scripts"
            echo ""
            echo "MITRE ATT&CK: T1195.001 - Compromise Software Dependencies"
        } >> "$typo_report"
        
        if [ $typo_score -ge 30 ]; then
            log_threat $((typo_score / 2)) "Package typosquatting detected"
            record_ioc "typosquatting" "${typo_findings[0]}" "Typosquatting attack"
        fi
    fi
}

# Compromised CDN Detection
# Detects malicious CDN resource injection
analyze_compromised_cdn() {
    set +u
    local content="${1:-}"
    set -u
    local cdn_report="${OUTPUT_DIR}/compromised_cdn_analysis.txt"
    
    log_info "Analyzing for compromised CDN resources..."
    
    local cdn_findings=()
    local cdn_score=0
    
    # CDN abuse patterns
    local -a CDN_ABUSE_PATTERNS=(
        # Modified CDN resources
        "cdn.*modified"
        "cdn.*inject"
        "cdn.*compromise"
        # Suspicious CDN paths
        "cdn.*\.min\.js\?v=[a-z0-9]{32,}"
        "cdn.*\.min\.js#[a-z0-9]+"
        # CDN cache poisoning
        "cache.*poison"
        "cdn.*cache.*inject"
        # CDN origin manipulation
        "x-forwarded-host.*inject"
        "host-header.*attack"
        # Suspicious CDN domains
        "cdn-[a-z0-9]{8,}\."
        "static-[a-z0-9]{8,}\."
        "assets-[a-z0-9]{8,}\."
    )
    
    # Known suspicious CDN endpoints
    local -a SUSPICIOUS_CDN_RESOURCES=(
        "cdnjs.*crypto.*miner"
        "jsdelivr.*eval\("
        "unpkg.*document\.write"
        "cdn.*polyfill.*io"
        "cdn.*atob\("
        "cdn.*fromCharCode"
    )
    
    for pattern in "${CDN_ABUSE_PATTERNS[@]}"; do
        if echo "$content" | safe_grep_qiE "$pattern"; then
            local matched=$(echo "$content" | safe_grep_oiE "$pattern" 2>/dev/null | head -1)
            cdn_findings+=("cdn_abuse:$matched")
            ((cdn_score += 25))
        fi
    done
    
    for pattern in "${SUSPICIOUS_CDN_RESOURCES[@]}"; do
        if echo "$content" | safe_grep_qiE "$pattern"; then
            local matched=$(echo "$content" | safe_grep_oiE "$pattern" 2>/dev/null | head -1)
            cdn_findings+=("suspicious_cdn:$matched")
            ((cdn_score += 40))
            log_threat 45 "Suspicious CDN resource: $matched"
        fi
    done
    
    # Check for CDN URLs with unusual parameters
    if echo "$content" | safe_grep_qiE "cdn[^\s]+\.(js|css)\?[a-z]+=[a-z0-9+/=]{50,}"; then
        cdn_findings+=("cdn_payload_param")
        ((cdn_score += 35))
        log_warning "CDN resource with encoded payload parameter"
    fi
    
    # Check for known CDN compromises
    if echo "$content" | safe_grep_qiE "polyfill\.io|cdn\.polyfill\.io"; then
        cdn_findings+=("known_compromised_cdn:polyfill.io")
        ((cdn_score += 50))
        log_threat 60 "Known compromised CDN: polyfill.io"
    fi
    
    if [ ${#cdn_findings[@]} -gt 0 ]; then
        {
            echo "═══════════════════════════════════════════════"
            echo "COMPROMISED CDN ANALYSIS"
            echo "═══════════════════════════════════════════════"
            echo "Timestamp: $(date -Iseconds)"
            echo "Threat Score: $cdn_score"
            echo ""
            echo "Findings:"
            for finding in "${cdn_findings[@]}"; do
                echo "  - $finding"
            done
            echo ""
            echo "Attack Description:"
            echo "  - Legitimate CDN resources modified with malicious code"
            echo "  - Cache poisoning to serve malicious content"
            echo "  - Supply chain attack via popular JS libraries"
            echo ""
            echo "MITRE ATT&CK: T1195.002 - Compromise Software Supply Chain"
        } >> "$cdn_report"
        
        if [ $cdn_score -ge 30 ]; then
            log_threat $((cdn_score / 2)) "Compromised CDN indicators detected"
            record_ioc "compromised_cdn" "${cdn_findings[0]}" "CDN compromise indicator"
        fi
    fi
}

# Subresource Integrity Bypass Detection
# Detects SRI bypass attempts
analyze_subresource_integrity() {
    set +u
    local content="${1:-}"
    set -u
    local sri_report="${OUTPUT_DIR}/sri_bypass_analysis.txt"
    
    log_info "Analyzing for SRI bypass attempts..."
    
    local sri_findings=()
    local sri_score=0
    
    # SRI bypass patterns - POSIX-compatible (removed PCRE negative lookahead)
    local -a SRI_BYPASS_PATTERNS=(
        # SRI bypass techniques
        "integrity.*bypass"
        "sri.*disable"
        # Dynamic script injection (bypasses SRI)
        "document\.createElement\(['\"]script"
        "appendChild.*script"
        "insertBefore.*script"
        "eval\(.*fetch"
        "new Function\(.*xhr"
        # Content-Security-Policy bypass
        "require-sri-for.*bypass"
        "meta.*http-equiv.*CSP.*none"
        # Hash manipulation
        "integrity.*sha256-[a-z0-9+/=]{40,}"
        "integrity.*sha384-[a-z0-9+/=]{60,}"
    )
    
    for pattern in "${SRI_BYPASS_PATTERNS[@]}"; do
        if echo "$content" | safe_grep_qiE -e "$pattern"; then
            local matched=$(echo "$content" | safe_grep_oiE -e "$pattern" 2>/dev/null | head -1)
            sri_findings+=("sri_bypass:$matched")
            ((sri_score += 25))
        fi
    done
    
    # Check for CDN scripts without integrity (two-step check replaces PCRE negative lookahead)
    if echo "$content" | safe_grep_qiE "<script.*src=.*cdn" && \
       ! echo "$content" | safe_grep_qiE "<script.*src=.*cdn.*integrity"; then
        sri_findings+=("missing_integrity:cdn_script")
        ((sri_score += 30))
    fi
    
    # Check for CDN links without integrity
    if echo "$content" | safe_grep_qiE "<link.*href=.*cdn" && \
       ! echo "$content" | safe_grep_qiE "<link.*href=.*cdn.*integrity"; then
        sri_findings+=("missing_integrity:cdn_link")
        ((sri_score += 25))
    fi
    
    # Check for crossorigin without integrity
    if echo "$content" | safe_grep_qiE "crossorigin.*anonymous" && \
       ! echo "$content" | safe_grep_qiE "crossorigin.*anonymous.*integrity"; then
        sri_findings+=("missing_integrity:crossorigin")
        ((sri_score += 20))
    fi
    
    # Check for script tags without integrity
    local script_count=$(echo "$content" | safe_grep_ciE "<script.*src=.*(cdn|unpkg|jsdelivr|cloudflare)")
    local sri_count=$(echo "$content" | safe_grep_ciE "<script.*integrity=.*sha")
    
    if [ "$script_count" -gt 0 ] && [ "$sri_count" -eq 0 ]; then
        sri_findings+=("missing_sri:$script_count scripts")
        ((sri_score += 20))
        log_warning "External scripts without SRI protection"
    fi
    
    # Check for inline script injection patterns
    if echo "$content" | safe_grep_qiE "innerHTML.*=.*<script|outerHTML.*=.*<script"; then
        sri_findings+=("inline_script_injection")
        ((sri_score += 35))
        log_warning "Inline script injection (bypasses SRI)"
    fi
    
    if [ ${#sri_findings[@]} -gt 0 ]; then
        {
            echo "═══════════════════════════════════════════════"
            echo "SUBRESOURCE INTEGRITY BYPASS ANALYSIS"
            echo "═══════════════════════════════════════════════"
            echo "Timestamp: $(date -Iseconds)"
            echo "Threat Score: $sri_score"
            echo ""
            echo "Findings:"
            for finding in "${sri_findings[@]}"; do
                echo "  - $finding"
            done
            echo ""
            echo "MITRE ATT&CK: T1195.002 - Compromise Software Supply Chain"
        } >> "$sri_report"
        
        if [ $sri_score -ge 25 ]; then
            log_threat $((sri_score / 2)) "SRI bypass indicators detected"
            record_ioc "sri_bypass" "${sri_findings[0]}" "SRI bypass technique"
        fi
    fi
}

# Package Manifest Abuse Detection
# Detects package.json/requirements.txt injection
analyze_package_manifest_abuse() {
    set +u
    local content="${1:-}"
    set -u
    local manifest_report="${OUTPUT_DIR}/package_manifest_analysis.txt"
    
    log_info "Analyzing for package manifest abuse..."
    
    local manifest_findings=()
    local manifest_score=0
    
    # package.json abuse patterns
    local -a PACKAGE_JSON_ABUSE=(
        # Malicious scripts
        '"scripts".*:.*\{[^}]*"(preinstall|postinstall|preuninstall)".*:.*"(curl|wget|nc|bash|sh|python|node\s+-e|eval)'
        '"scripts".*"install".*:.*"[^"]*\|'
        '"scripts".*"test".*:.*".*rm\s+-rf|.*>/dev/null"'
        # Git URL abuse
        '"git\+https?://[^"]*@'
        '"git://[^"]*\$\('
        # Overwrite package
        '"optionalDependencies".*:.*\{[^}]*"[a-z-]+".*:.*"[0-9]{3,}\.'
        # Binary execution
        '"bin".*:.*".*\.sh"'
        # Typosquatting indicators
        '"name".*:.*"(lod-ash|loadsh|requets|expresss|reakt)"'
    )
    
    # requirements.txt abuse patterns
    local -a REQUIREMENTS_TXT_ABUSE=(
        # Git URL injection
        "git\+https?://.*#egg="
        "-e\s+git\+"
        # Direct URL with shell
        "--trusted-host.*\$\("
        "https?://[^\s]+\.tar\.gz.*#.*shell"
        # Environment variable injection
        "\$\{[A-Z_]+\}"
        # Index URL manipulation
        "--index-url.*[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+"
        "--extra-index-url.*http://"
    )
    
    # setup.py abuse patterns
    local -a SETUP_PY_ABUSE=(
        "cmdclass.*install.*Command"
        "os\.system\s*\("
        "subprocess\.(call|run|Popen)"
        "exec\s*\("
        "eval\s*\("
        "__import__.*os.*system"
        "urllib.*urlopen.*exec"
        "socket.*connect"
        "base64.*decode.*exec"
    )
    
    for pattern in "${PACKAGE_JSON_ABUSE[@]}"; do
        if echo "$content" | safe_grep_qiE "$pattern"; then
            local matched=$(echo "$content" | safe_grep_oiE "$pattern" 2>/dev/null | head -1)
            manifest_findings+=("package_json_abuse:${matched:0:80}")
            ((manifest_score += 40))
            log_threat 45 "Malicious package.json pattern"
        fi
    done
    
    for pattern in "${REQUIREMENTS_TXT_ABUSE[@]}"; do
        if echo "$content" | safe_grep_qiE -e "$pattern"; then
            local matched=$(echo "$content" | safe_grep_oiE -e "$pattern" 2>/dev/null | head -1)
            manifest_findings+=("requirements_abuse:${matched:0:80}")
            ((manifest_score += 35))
        fi
    done
    
    for pattern in "${SETUP_PY_ABUSE[@]}"; do
        if echo "$content" | safe_grep_qiE "$pattern"; then
            local matched=$(echo "$content" | safe_grep_oiE "$pattern" 2>/dev/null | head -1)
            manifest_findings+=("setup_py_abuse:${matched:0:80}")
            ((manifest_score += 45))
            log_threat 50 "Malicious setup.py pattern"
        fi
    done
    
    # Check for known malicious maintainer patterns
    if echo "$content" | safe_grep_qiE '"maintainers?".*:.*\[\s*\]|"author".*:.*""'; then
        manifest_findings+=("missing_maintainer")
        ((manifest_score += 15))
    fi
    
    # Check for suspicious dependency versions
    if echo "$content" | safe_grep_qiE '"[a-z-]+".*:.*"\*"|"[a-z-]+".*:.*"latest"'; then
        manifest_findings+=("wildcard_version")
        ((manifest_score += 20))
        log_warning "Wildcard package version (security risk)"
    fi
    
    if [ ${#manifest_findings[@]} -gt 0 ]; then
        {
            echo "═══════════════════════════════════════════════"
            echo "PACKAGE MANIFEST ABUSE ANALYSIS"
            echo "═══════════════════════════════════════════════"
            echo "Timestamp: $(date -Iseconds)"
            echo "Threat Score: $manifest_score"
            echo ""
            echo "Findings:"
            for finding in "${manifest_findings[@]}"; do
                echo "  - $finding"
            done
            echo ""
            echo "Attack Vectors:"
            echo "  - Malicious install scripts in package.json"
            echo "  - Code execution in setup.py"
            echo "  - Git URL injection in requirements.txt"
            echo "  - Dependency version manipulation"
            echo ""
            echo "MITRE ATT&CK: T1195.001 - Compromise Software Dependencies"
        } >> "$manifest_report"
        
        if [ $manifest_score -ge 30 ]; then
            log_threat $((manifest_score / 2)) "Package manifest abuse detected"
            record_ioc "manifest_abuse" "${manifest_findings[0]}" "Package manifest attack"
        fi
    fi
}

################################################################################
# SOCIAL ENGINEERING AND PERSONA ANALYSIS
################################################################################

analyze_social_engineering() {
    set +u
    local content="${1:-}"
    set -u
    
    if [ "$PERSONA_LINKING" = false ]; then
        return
    fi
    
    log_info "Analyzing for social engineering patterns..."
    
    local se_findings=()
    local se_score=0
    local se_categories=()
    
    # Check social engineering patterns
    for pattern in "${SOCIAL_ENGINEERING_PATTERNS[@]}"; do
        if echo "$content" | safe_grep_qiE "$pattern"; then
            local matched=$(echo "$content" | safe_grep_oiE "$pattern" 2>/dev/null | head -1)
            se_findings+=("social_eng:$matched")
            ((se_score += 15))
        fi
    done
    
    # Check BEC patterns
    for pattern in "${BEC_PATTERNS[@]}"; do
        if echo "$content" | safe_grep_qiE "$pattern"; then
            local matched=$(echo "$content" | safe_grep_oiE "$pattern" 2>/dev/null | head -1)
            se_findings+=("bec:$matched")
            ((se_score += 30))
            log_threat 45 "Business Email Compromise indicator: $matched"
        fi
    done
    
    # Categorize the social engineering tactics
    
    # URGENCY
    local urgency_count=0
    for phrase in "urgent" "immediate" "act now" "expires" "deadline" "limited time" "hours left" "final notice"; do
        if echo "$content" | safe_grep_qiE "$phrase"; then
            ((urgency_count++))
        fi
    done
    if [ $urgency_count -ge 2 ]; then
        se_categories+=("URGENCY:$urgency_count")
        ((se_score += 20))
        log_warning "Multiple urgency indicators ($urgency_count)"
    fi
    
    # AUTHORITY
    local authority_count=0
    for phrase in "official" "government" "bank" "security department" "legal" "court" "police" "irs" "fbi"; do
        if echo "$content" | safe_grep_qiE "$phrase"; then
            ((authority_count++))
        fi
    done
    if [ $authority_count -ge 2 ]; then
        se_categories+=("AUTHORITY:$authority_count")
        ((se_score += 25))
        log_warning "Multiple authority indicators ($authority_count)"
    fi
    
    # FEAR
    local fear_count=0
    for phrase in "compromised" "suspended" "breach" "stolen" "hacked" "virus" "locked" "terminated" "legal action"; do
        if echo "$content" | safe_grep_qiE "$phrase"; then
            ((fear_count++))
        fi
    done
    if [ $fear_count -ge 2 ]; then
        se_categories+=("FEAR:$fear_count")
        ((se_score += 25))
        log_warning "Multiple fear indicators ($fear_count)"
    fi
    
    # REWARD/GREED
    local reward_count=0
    for phrase in "winner" "prize" "congratulations" "won" "free" "bonus" "reward" "million"; do
        if echo "$content" | safe_grep_qiE "$phrase"; then
            ((reward_count++))
        fi
    done
    if [ $reward_count -ge 2 ]; then
        se_categories+=("REWARD:$reward_count")
        ((se_score += 20))
        log_warning "Multiple reward/greed indicators ($reward_count)"
    fi
    
    # Check for impersonation patterns
    if echo "$content" | safe_grep_qiE "(from|signed|regards).*@.*(bank|paypal|amazon|apple|microsoft|google)"; then
        log_threat 40 "Brand impersonation signature detected"
        se_findings+=("brand_impersonation")
        ((se_score += 30))
    fi
    
    # Check for fake invoice patterns
    if echo "$content" | safe_grep_qiE "invoice.*#.*[0-9]+|order.*#.*[0-9]+|payment.*due"; then
        log_warning "Invoice/Payment reference pattern"
        se_findings+=("fake_invoice")
        ((se_score += 15))
    fi
    
    # Check for credential harvesting language
    if echo "$content" | safe_grep_qiE "(verify|confirm|update).*your.*(account|password|information|details)"; then
        log_threat 35 "Credential harvesting language detected"
        se_findings+=("credential_harvest")
        ((se_score += 25))
    fi
    
    # Generate social engineering report
    if [ ${#se_findings[@]} -gt 0 ] || [ ${#se_categories[@]} -gt 0 ]; then
        {
            echo "═══════════════════════════════════════════════"
            echo "SOCIAL ENGINEERING ANALYSIS"
            echo "═══════════════════════════════════════════════"
            echo "Timestamp: $(date -Iseconds)"
            echo "Social Engineering Score: $se_score"
            echo ""
            echo "Psychological Manipulation Tactics:"
            for cat in "${se_categories[@]}"; do
                echo "  - $cat"
            done
            echo ""
            echo "Specific Patterns Found:"
            for finding in "${se_findings[@]}"; do
                echo "  - $finding"
            done
            echo ""
            echo "Risk Assessment:"
            if [ $se_score -ge 80 ]; then
                echo "  CRITICAL: Multiple social engineering techniques combined"
                echo "  This is a sophisticated social engineering attack"
            elif [ $se_score -ge 50 ]; then
                echo "  HIGH: Strong social engineering indicators"
            elif [ $se_score -ge 25 ]; then
                echo "  MEDIUM: Social engineering tactics present"
            else
                echo "  LOW: Minor persuasion techniques detected"
            fi
            echo ""
            echo "Cialdini's Principles Detected:"
            [ $urgency_count -ge 1 ] && echo "  - Scarcity/Urgency"
            [ $authority_count -ge 1 ] && echo "  - Authority"
            [ $fear_count -ge 1 ] && echo "  - Fear (negative social proof)"
            [ $reward_count -ge 1 ] && echo "  - Reciprocity/Reward"
            echo ""
        } >> "$PERSONA_REPORT"
        
        if [ $se_score -ge 35 ]; then
            log_threat $((se_score / 3)) "Social engineering patterns detected"
        fi
        
        analysis_success_found "SOCIAL-ENGINEERING" "${#se_findings[@]}" "Score: $se_score" "$(IFS=', '; echo "${se_findings[*]}")"
    else
        analysis_success_none "SOCIAL-ENGINEERING"
    fi
}

################################################################################
# ASN AND NETWORK INFRASTRUCTURE ANALYSIS
################################################################################

analyze_asn_infrastructure() {
    set +u
    local content="$1"
    
    if [ "$ASN_ANALYSIS" = false ] || [ "$NETWORK_CHECK" = false ]; then
        analysis_success_none "ASN-ANALYSIS"
        return
    fi
    
    log_info "Analyzing network infrastructure and ASN reputation..."
    
    local asn_findings=()
    local asn_score=0
    local analyzed_count=0
    
    # Extract domains from URLs - more robust pattern
    local domains=$(echo "$content" | safe_grep_oiE 'https?://([a-zA-Z0-9][-a-zA-Z0-9]*[.])+[a-zA-Z]{2,}' | \
        sed 's|https\?://||i' | sed 's|/.*||' | sort -u)
    
    # Also try to extract standalone domains
    local standalone_domains=$(echo "$content" | safe_grep_oiE '([a-zA-Z0-9][-a-zA-Z0-9]*[.])+[a-zA-Z]{2,}' | sort -u)
    domains="$domains $standalone_domains"
    domains=$(echo "$domains" | tr ' ' '\n' | sort -u | tr '\n' ' ')
    
    # Extract IPs
    local ips=$(echo "$content" | safe_grep_oE "[0-9]{1,3}[.][0-9]{1,3}[.][0-9]{1,3}[.][0-9]{1,3}" | sort -u)
    
    # Display extracted targets
    if [ -n "$domains" ] || [ -n "$ips" ]; then
        echo ""
        echo -e "${CYAN}┌─────────────────────────────────────────────────────────────┐${NC}"
        echo -e "${CYAN}│                 ASN/INFRASTRUCTURE ANALYSIS                  │${NC}"
        echo -e "${CYAN}├─────────────────────────────────────────────────────────────┤${NC}"
    fi
    
    # Resolve domains to IPs
    for domain in $domains; do
        local resolved_ip=$(dig +short A "$domain" 2>/dev/null | head -1)
        if [ -n "$resolved_ip" ] && [ "$resolved_ip" != "$domain" ]; then
            echo -e "${CYAN}│${NC} Domain: ${WHITE}$domain${NC} → ${YELLOW}$resolved_ip${NC}"
            ips="$ips $resolved_ip"
            ((analyzed_count++))
        fi
    done
    
    # Analyze each IP
    for ip in $ips; do
        # Skip private/reserved IPs
        if echo "$ip" | grep -qE "^(10\.|172\.(1[6-9]|2[0-9]|3[0-1])\.|192\.168\.|127\.|0\.)"; then
            continue
        fi
        
        ((analyzed_count++))
        
        # Get ASN info (with timeout)
        local asn_info=$(timeout 5 whois -h whois.cymru.com " -v $ip" 2>/dev/null | tail -1)
        
        if [ -n "$asn_info" ] && [ "$asn_info" != "Error" ]; then
            local asn=$(echo "$asn_info" | awk -F'|' '{print $1}' | tr -d ' ')
            local asn_name=$(echo "$asn_info" | awk -F'|' '{print $NF}' | xargs)
            local country=$(echo "$asn_info" | awk -F'|' '{print $3}' | tr -d ' ')
            
            echo -e "${CYAN}│${NC} IP: ${WHITE}$ip${NC} → AS${YELLOW}$asn${NC} (${WHITE}$asn_name${NC}) [${YELLOW}$country${NC}]"
            log_forensic "IP $ip -> AS$asn ($asn_name) [$country]"
            
            # Check against bulletproof ASN list
            for bp_asn in "${BULLETPROOF_ASNS[@]}"; do
                if [ "AS$asn" = "$bp_asn" ]; then
                    echo -e "${CYAN}│${NC}   ${RED}⚠ BULLETPROOF/HIGH-ABUSE ASN${NC}"
                    log_threat 40 "IP $ip is in known bulletproof/abuse-prone ASN: $bp_asn ($asn_name)"
                    asn_findings+=("bulletproof_asn:$bp_asn:$ip")
                    ((asn_score += 30))
                fi
            done
            
            # Check country
            case "$country" in
                "RU")
                    echo -e "${CYAN}│${NC}   ${YELLOW}⚠ High-risk country: Russia${NC}"
                    log_warning "IP $ip is in high-risk country: Russia"
                    asn_findings+=("high_risk_country:RU:$ip")
                    ((asn_score += 20))
                    ;;
                "CN")
                    echo -e "${CYAN}│${NC}   ${YELLOW}⚠ High-risk country: China${NC}"
                    log_warning "IP $ip is in high-risk country: China"
                    asn_findings+=("high_risk_country:CN:$ip")
                    ((asn_score += 20))
                    ;;
                "IR")
                    echo -e "${CYAN}│${NC}   ${YELLOW}⚠ High-risk country: Iran${NC}"
                    log_warning "IP $ip is in high-risk country: Iran"
                    asn_findings+=("high_risk_country:IR:$ip")
                    ((asn_score += 25))
                    ;;
                "KP")
                    echo -e "${CYAN}│${NC}   ${RED}⚠ CRITICAL: North Korea${NC}"
                    log_threat 50 "IP $ip is in DPRK (North Korea)"
                    asn_findings+=("high_risk_country:KP:$ip")
                    ((asn_score += 50))
                    ;;
                "SY")
                    echo -e "${CYAN}│${NC}   ${YELLOW}⚠ High-risk country: Syria${NC}"
                    log_warning "IP $ip is in high-risk country: Syria"
                    asn_findings+=("high_risk_country:SY:$ip")
                    ((asn_score += 25))
                    ;;
            esac
        fi
    done
    
    if [ -n "$domains" ] || [ -n "$ips" ]; then
        echo -e "${CYAN}│${NC}"
        echo -e "${CYAN}│${NC} Analyzed: ${WHITE}$analyzed_count targets${NC}"
        echo -e "${CYAN}└─────────────────────────────────────────────────────────────┘${NC}"
        echo ""
    fi
    
    # Check registrar patterns and known malicious registrar IPs in any WHOIS we've collected
    local whois_files
    whois_files=$(find "${EVIDENCE_DIR}" -name "whois_*" 2>/dev/null)
    if [ -n "$whois_files" ]; then
        # Registrar pattern match (keep original flow)
        for registrar in "${SUSPICIOUS_REGISTRARS[@]}"; do
            # Skip empty patterns
            [ -z "$registrar" ] && continue
            local match
            match=$(grep -il "$registrar" ${whois_files} 2>/dev/null | head -1)
            if [ -n "$match" ]; then
                log_warning "Domain registered with high-abuse registrar: $registrar (found in $(basename "$match"))"
                asn_findings+=("suspicious_registrar:$registrar")
                ((asn_score += 15))
            fi
        done

        # Registrar pattern match for all_additional_iocs.txt
        if [ -f "${TEMP_DIR}/all_additional_iocs.txt" ]; then
            while read -r additional_ioc; do
                [ -z "$additional_ioc" ] && continue
                # Registrar pattern search
                local add_match
                add_match=$(grep -il "$additional_ioc" ${whois_files} 2>/dev/null | head -1)
                if [ -n "$add_match" ]; then
                    log_warning "Domain matched additional IOC registrar pattern: $additional_ioc (found in $(basename "$add_match"))"
                    asn_findings+=("suspicious_registrar:$additional_ioc")
                    ((asn_score += 15))
                fi
            done < "${TEMP_DIR}/all_additional_iocs.txt"
        fi

        # Malicious IP and CIDR match in all WHOIS files (mirrors registrar logic)
        for whois_file in $whois_files; do
            local ip_matches
            # Extract unique IPv4s from the file
            ip_matches=$(grep -Eo '([0-9]{1,3}\.){3}[0-9]{1,3}' "$whois_file" | sort -u)
            while read -r ip; do
                [ -z "$ip" ] && continue
                # Direct match in blocklist
                if [[ -n "${KNOWN_MALICIOUS_IPS[$ip]}" ]]; then
                    log_warning "Registrar/WHOIS IP $ip in $(basename "$whois_file") is known malicious (blocklist match)"
                    asn_findings+=("suspicious_registrar_ip:$ip")
                    ((asn_score += 15))
                fi
                # Direct match in additional_iocs.txt
                if [ -f "${TEMP_DIR}/all_additional_iocs.txt" ]; then
                    if grep -q "^$ip\$" "${TEMP_DIR}/all_additional_iocs.txt"; then
                        log_warning "Registrar/WHOIS IP $ip in $(basename "$whois_file") is known malicious (additional_iocs.txt match)"
                        asn_findings+=("suspicious_registrar_ip:$ip")
                        ((asn_score += 15))
                    fi
                fi
                # CIDR match in blocklist, if grepcidr exists and any CIDRs are loaded
                if command -v grepcidr > /dev/null 2>&1 && [ "${#KNOWN_MALICIOUS_CIDRS[@]}" -gt 0 ]; then
                    for cidr in "${!KNOWN_MALICIOUS_CIDRS[@]}"; do
                        echo "$ip" | grepcidr -q "$cidr" && {
                            log_warning "Registrar/WHOIS IP $ip in $(basename "$whois_file") is within malicious CIDR $cidr"
                            asn_findings+=("suspicious_registrar_cidr:$cidr($ip)")
                            ((asn_score += 12))
                        }
                    done
                fi
                # CIDR match in additional_iocs.txt
                if command -v grepcidr > /dev/null 2>&1 && [ -f "${TEMP_DIR}/all_additional_iocs.txt" ]; then
                    while read -r additional_cidr; do
                        [[ "$additional_cidr" =~ ^([0-9]{1,3}\.){3}[0-9]{1,3}/[0-9]{1,2}$ ]] || continue
                        echo "$ip" | grepcidr -q "$additional_cidr" && {
                            log_warning "Registrar/WHOIS IP $ip in $(basename "$whois_file") is within additional IOC CIDR $additional_cidr"
                            asn_findings+=("suspicious_registrar_cidr:$additional_cidr($ip)")
                            ((asn_score += 12))
                        }
                    done < "${TEMP_DIR}/all_additional_iocs.txt"
                fi
            done <<< "$ip_matches"
        done
    fi
    
    # Generate ASN report
    if [ ${#asn_findings[@]} -gt 0 ]; then
        {
            echo "═══════════════════════════════════════════════"
            echo "ASN AND INFRASTRUCTURE ANALYSIS"
            echo "═══════════════════════════════════════════════"
            echo "Timestamp: $(date -Iseconds)"
            echo "Infrastructure Risk Score: $asn_score"
            echo ""
            echo "Findings:"
            for finding in "${asn_findings[@]}"; do
                echo "  - $finding"
            done
            echo ""
        } >> "$ASN_REPORT"
        
        if [ $asn_score -ge 30 ]; then
            # GRANULAR OUTPUT RESTORED: Classic Paste A format for suspicious network infrastructure
            log_threat $((asn_score / 2)) "Suspicious network infrastructure detected"
            # Additional granular output per finding type for forensic visibility
            for finding in "${asn_findings[@]}"; do
                case "$finding" in
                    bulletproof_asn:*)
                        log_warning "    └─ Bulletproof/high-abuse ASN: ${finding#bulletproof_asn:}"
                        ;;
                    high_risk_country:*)
                        log_warning "    └─ High-risk country infrastructure: ${finding#high_risk_country:}"
                        ;;
                    suspicious_registrar:*)
                        log_warning "    └─ Suspicious registrar: ${finding#suspicious_registrar:}"
                        ;;
                esac
            done
        fi
        
        analysis_success_found "ASN-ANALYSIS" "${#asn_findings[@]}" "Score: $asn_score" "$(IFS=', '; echo "${asn_findings[*]}")"
    else
        analysis_success_none "ASN-ANALYSIS"
    fi
    
    # If you have detection variable, e.g. found_suspicious_infra=1
    if [[ "$found_suspicious_infra" == "1" ]]; then
        echo -e "${RED}[THREAT +187]${NC} Suspicious network infrastructure detected"
    fi
    set -u
}

################################################################################
# ADVERSARIAL QR CODE DETECTION
################################################################################

analyze_adversarial_qr() {
    set +u
    local image="${1:-}"
    set -u
    
    if [ "$ADVERSARIAL_QR_CHECK" = false ]; then
        return
    fi
    
    log_info "Analyzing for adversarial QR patterns..."
    
    local adversarial_findings=()
    local adversarial_score=0
    
    # Get image properties
    if command -v identify &> /dev/null; then
        local img_info=$(identify -verbose "$image" 2>/dev/null)
        
        # Check for unusual dimensions
        local width=$(echo "$img_info" | grep "Geometry:" | grep -oE "[0-9]+x[0-9]+" | cut -dx -f1)
        local height=$(echo "$img_info" | grep "Geometry:" | grep -oE "[0-9]+x[0-9]+" | cut -dx -f2)
        
        if [ -n "$width" ] && [ -n "$height" ]; then
            # Very small QR (possible micro QR or density attack)
            if [ "$width" -lt 50 ] || [ "$height" -lt 50 ]; then
                log_warning "Very small QR image detected (${width}x${height})"
                adversarial_findings+=("micro_qr:${width}x${height}")
                ((adversarial_score += 15))
            fi
            
            # Very large QR (possible high-density attack)
            if [ "$width" -gt 2000 ] || [ "$height" -gt 2000 ]; then
                log_warning "Very large QR image detected (${width}x${height})"
                adversarial_findings+=("oversized_qr:${width}x${height}")
                ((adversarial_score += 10))
            fi
            
            # Non-square QR (unusual)
            local ratio=$(echo "scale=2; $width / $height" | bc 2>/dev/null)
            if [ -n "$ratio" ]; then
                if float_gt "$ratio" "1.1" || float_lt "$ratio" "0.9"; then
                    log_warning "Non-square QR image (ratio: $ratio)"
                    adversarial_findings+=("non_square:$ratio")
                    ((adversarial_score += 20))
                fi
            fi
        fi
        
        # Check color depth
        local depth=$(echo "$img_info" | grep "Depth:" | head -1)
        if echo "$depth" | grep -qE "[0-9]+-bit"; then
            local bit_depth=$(echo "$depth" | grep -oE "[0-9]+")
            if [ "$bit_depth" -gt 8 ]; then
                log_info "High bit depth QR image: $bit_depth-bit (possible stego carrier)"
                adversarial_findings+=("high_bit_depth:$bit_depth")
                ((adversarial_score += 10))
            fi
        fi
        
        # Check for transparency (alpha channel)
        if echo "$img_info" | grep -qi "Alpha:"; then
            log_info "QR image has alpha channel (transparency)"
            adversarial_findings+=("has_alpha_channel")
            ((adversarial_score += 5))
        fi
        
        # Check for embedded ICC profile
        if echo "$img_info" | grep -qi "icc:"; then
            log_info "QR image has embedded ICC profile (unusual for QR)"
            adversarial_findings+=("icc_profile")
            ((adversarial_score += 10))
        fi
        
        # Check for EXIF data (unusual for generated QR)
        if echo "$img_info" | grep -qiE "exif:|GPS"; then
            log_warning "QR image has EXIF metadata (suspicious for QR code)"
            adversarial_findings+=("has_exif")
            ((adversarial_score += 15))
        fi
    fi
    
    # Python-based advanced analysis
    analyze_qr_visual_properties "$image"
    
    # Check for multi-QR sequences (animated GIF, multiple QRs)
    if file "$image" | grep -qi "GIF"; then
        local frame_count=$(identify "$image" 2>/dev/null | wc -l)
        if [ "$frame_count" -gt 1 ]; then
            log_threat 40 "Animated QR code detected ($frame_count frames) - possible multi-payload attack"
            adversarial_findings+=("animated_qr:$frame_count")
            ((adversarial_score += 35))
        fi
    fi
    
    # Check for QR code density/version issues
    analyze_qr_density "$image"
    
    # Generate adversarial QR report
    if [ ${#adversarial_findings[@]} -gt 0 ]; then
        {
            echo "═══════════════════════════════════════════════"
            echo "ADVERSARIAL QR CODE ANALYSIS"
            echo "═══════════════════════════════════════════════"
            echo "Timestamp: $(date -Iseconds)"
            echo "Adversarial Score: $adversarial_score"
            echo ""
            echo "Findings:"
            for finding in "${adversarial_findings[@]}"; do
                echo "  - $finding"
            done
            echo ""
            echo "Attack Types Detected:"
            echo "  Visual Manipulation: $(echo "${adversarial_findings[@]}" | grep -c "visual\|ratio\|square")"
            echo "  Density Attacks: $(echo "${adversarial_findings[@]}" | grep -c "density\|micro\|oversized")"
            echo "  Multi-payload: $(echo "${adversarial_findings[@]}" | grep -c "animated\|sequence")"
            echo "  Stego Indicators: $(echo "${adversarial_findings[@]}" | grep -c "depth\|alpha\|icc")"
            echo ""
        } >> "$ADVERSARIAL_QR_REPORT"
        
        if [ $adversarial_score -ge 25 ]; then
            local adversarial_summary=$(IFS=', '; echo "${adversarial_findings[*]}")
            log_threat $((adversarial_score / 2)) "Adversarial QR characteristics detected: ${adversarial_summary}"
        fi
    fi
    
    # Run pixel variance analysis
    local variance_result=$(analyze_adversarial_qr_variance "$image" 2>/dev/null)
    if [ -n "$variance_result" ]; then
        local variance=$(echo "$variance_result" | grep -oE "variance:[0-9.]+" | cut -d: -f2)
        local suspicious=$(echo "$variance_result" | grep -oE "suspicious:(True|False)" | cut -d: -f2)
        
        if [ "$suspicious" = "True" ]; then
            log_warning "High pixel variance detected (${variance:-high}) - possible adversarial manipulation"
            log_forensic_detection 30 \
                "Adversarial QR - High Pixel Variance" \
                "variance:$variance" \
                "Pixel variance analysis" \
                "Image analysis" \
                "Investigate QR code for visual manipulation" \
                "MITRE ATT&CK T1027"
        fi
        
        log_info "Pixel variance analysis: variance=${variance:-N/A}, suspicious=${suspicious:-N/A}"
    fi
}

analyze_qr_visual_properties() {
    set +u
    local image="${1:-}"
    set -u
    local python_cmd=$(get_python_cmd)
    
    # Run in isolated subshell to prevent segfaults from crashing the main script
    (
        exec 2>/dev/null
        timeout 60 "$python_cmd" - "$image" <<'PYVISUAL' 2>/dev/null
import sys
import os
import signal

# Handle signals to prevent crashes from propagating
def signal_handler(sig, frame):
    sys.exit(128 + sig)

signal.signal(signal.SIGSEGV, signal_handler)
signal.signal(signal.SIGABRT, signal_handler)
signal.signal(signal.SIGFPE, signal_handler)

try:
    from PIL import Image
    import numpy as np
    
    image_path = sys.argv[1]
    img = Image.open(image_path)
    
    # Convert to grayscale for analysis
    if img.mode != 'L':
        gray = img.convert('L')
    else:
        gray = img
    
    width, height = gray.size
    total_pixels = width * height
    
    # Limit analysis for very large images to prevent memory issues
    if total_pixels > 10000000:  # > 10 megapixels
        print("QR_VISUAL_INFO: Image too large for detailed analysis, using sampling")
        # Resize for analysis
        scale = min(1.0, 3000000 / total_pixels) ** 0.5
        new_width = int(width * scale)
        new_height = int(height * scale)
        gray = gray.resize((new_width, new_height), Image.Resampling.LANCZOS)
        width, height = gray.size
        total_pixels = width * height
    
    # Process directly (avoid mmap complexity that can cause issues)
    pixels = np.array(gray, dtype=np.float32)
    
    # Color distribution
    unique_colors = len(np.unique(pixels))
    if unique_colors > 50:
        print(f"QR_VISUAL_ALERT: Unusual color count ({unique_colors}) - possible visual attack")
    
    # Gradient analysis - simpler approach
    try:
        gradient = np.abs(np.diff(pixels, axis=1))
        avg_gradient = float(np.mean(gradient))
        if avg_gradient > 50:
            print(f"QR_VISUAL_ALERT: High gradient average ({avg_gradient:.2f}) - possible gradient attack")
    except:
        pass
    
    # Noise level
    try:
        noise_level = float(np.std(pixels))
        if noise_level > 100:
            print(f"QR_VISUAL_ALERT: High noise level ({noise_level:.2f}) - possible noise injection")
    except:
        pass
    
    # Border/quiet zone analysis
    try:
        border_size = min(10, height // 10, width // 10)
        if border_size > 0:
            top_border = float(np.mean(pixels[:border_size, :]))
            bottom_border = float(np.mean(pixels[-border_size:, :]))
            left_border = float(np.mean(pixels[:, :border_size]))
            right_border = float(np.mean(pixels[:, -border_size:]))
            avg_border = (top_border + bottom_border + left_border + right_border) / 4
            
            if avg_border < 200:
                print(f"QR_VISUAL_ALERT: Reduced quiet zone (avg: {avg_border:.0f}) - possible margin attack")
    except:
        pass
    
    # FFT analysis - wrap in try-except for crash protection
    # Only for reasonably sized images
    if total_pixels < 500000 and total_pixels > 0:
        try:
            # Use real FFT for better stability
            pixels_int = np.array(gray, dtype=np.float64)
            fft = np.fft.rfft2(pixels_int)
            magnitude = np.abs(fft)
            
            # Use median instead of mean for threshold (more robust)
            threshold = float(np.median(magnitude)) * 20
            if threshold > 0:
                spikes = int(np.sum(magnitude > threshold))
                
                if spikes > 100:
                    print(f"QR_VISUAL_ALERT: Unusual frequency patterns ({spikes} spikes) - possible hidden data")
        except Exception as fft_err:
            # FFT failed - not critical, continue
            pass
    
except Exception as e:
    # Silently fail - don't crash the parent script
    pass
PYVISUAL
    ) 2>/dev/null
}

analyze_qr_density() {
    set +u
    local image="${1:-}"
    set -u
    local python_cmd=$(get_python_cmd)
    
    # Run in isolated subshell to prevent crashes
    (
        exec 2>/dev/null
        timeout 30 "$python_cmd" - "$image" <<'PYDENSITY' 2>/dev/null
import sys
import signal

# Handle signals to prevent crashes
def signal_handler(sig, frame):
    sys.exit(128 + sig)

signal.signal(signal.SIGSEGV, signal_handler)
signal.signal(signal.SIGABRT, signal_handler)

try:
    from pyzbar.pyzbar import decode
    from PIL import Image
    
    image_path = sys.argv[1]
    img = Image.open(image_path)
    codes = decode(img)
    
    for code in codes:
        data = code.data.decode('utf-8', errors='ignore')
        
        # QR code versions: 1 (21x21) to 40 (177x177)
        # Higher versions can hold more data but are also used for attacks
        data_len = len(data)
        
        # Approximate QR version based on data length
        # Version 40 can hold ~2953 bytes alphanumeric
        if data_len > 2000:
            print(f"QR_DENSITY_ALERT: Very high data capacity ({data_len} bytes) - high version QR")
        
        # Check for null bytes or unusual characters
        null_count = data.count('\x00')
        if null_count > 0:
            print(f"QR_DENSITY_ALERT: Contains {null_count} null bytes - possible padding attack")
        
        # Check for excessive whitespace/padding
        space_ratio = len([c for c in data if c.isspace()]) / len(data) if len(data) > 0 else 0
        if space_ratio > 0.3:
            print(f"QR_DENSITY_ALERT: High whitespace ratio ({space_ratio:.2%}) - possible padding")

except Exception as e:
    pass
PYDENSITY
    ) 2>/dev/null
}

################################################################################
# ZERO-DAY AND ANOMALY DETECTION
################################################################################

analyze_zero_day_anomalies() {
    set +u
    local content="${1:-}"
    set -u
    
    if [ "$ZERO_DAY_DETECTION" = false ]; then
        return
    fi
    
    log_info "Analyzing for zero-day/anomaly patterns..."
    
    local anomaly_findings=()
    local anomaly_score=0
    
    # Check for unusual encoding patterns
    analyze_encoding_anomalies "$content"
    
    # Check for polyglot patterns
    analyze_polyglot_content "$content"
    
    # Check for parser differential exploits
    analyze_parser_differentials "$content"
    
    # Statistical anomaly detection
    local content_length=${#content}
    local unique_chars=$(echo "$content" | fold -w1 | sort -u | wc -l)
    local char_ratio=$(echo "scale=4; $unique_chars / $content_length" | bc 2>/dev/null || echo "0")
    
    # Very low character diversity might indicate encoded payload
    if float_lt "$char_ratio" "0.05" && [ "$content_length" -gt 100 ]; then
        log_warning "Low character diversity ratio ($char_ratio) - possible encoded payload"
        anomaly_findings+=("low_char_diversity:$char_ratio")
        ((anomaly_score += 25))
    fi
    
    # Check for unusual byte sequences
    local non_printable=$(echo "$content" | tr -d '[:print:][:space:]' | wc -c)
    local non_printable_ratio=$(echo "scale=4; $non_printable / $content_length" | bc 2>/dev/null || echo "0")
    
    if float_gt "$non_printable_ratio" "0.1"; then
        log_warning "High non-printable character ratio ($non_printable_ratio)"
        anomaly_findings+=("non_printable_chars:$non_printable_ratio")
        ((anomaly_score += 30))
    fi
    
    # Check for multiple encoding layers
    local base64_pattern="^[A-Za-z0-9+/=]{20,}$"
    local content_stripped=$(echo "$content" | tr -d '[:space:]')
    
    if echo "$content_stripped" | grep -qE "$base64_pattern"; then
        # Try to decode and check if result is also encoded
        local decoded=$(echo "$content_stripped" | base64 -d 2>/dev/null)
        if [ -n "$decoded" ] && echo "$decoded" | grep -qE "$base64_pattern"; then
            log_threat 45 "Multi-layer base64 encoding detected"
            anomaly_findings+=("multi_layer_encoding")
            ((anomaly_score += 35))
        fi
    fi
    
    # Check for known CVE patterns
    check_known_cve_patterns "$content"
    
    # Check for protocol confusion attacks
    if echo "$content" | safe_grep_qE "^(http|https)://.*:(ftp|ssh|telnet|smtp)"; then
        log_threat 50 "Potential protocol confusion pattern"
        anomaly_findings+=("protocol_confusion")
        ((anomaly_score += 40))
    fi
    
    # Generate zero-day report
    if [ ${#anomaly_findings[@]} -gt 0 ]; then
        {
            echo "═══════════════════════════════════════════════"
            echo "ZERO-DAY / ANOMALY ANALYSIS"
            echo "═══════════════════════════════════════════════"
            echo "Timestamp: $(date -Iseconds)"
            echo "Anomaly Score: $anomaly_score"
            echo ""
            echo "Findings:"
            for finding in "${anomaly_findings[@]}"; do
                echo "  - $finding"
            done
            echo ""
            echo "Analysis Notes:"
            echo "  These patterns may indicate novel attack techniques"
            echo "  or zero-day exploit attempts that don't match known signatures."
            echo ""
        } >> "$ZERO_DAY_REPORT"
        
        if [ $anomaly_score -ge 30 ]; then
            log_threat $((anomaly_score / 2)) "Anomalous patterns detected - possible zero-day"
        fi
        
        analysis_success_found "ZERO-DAY" "${#anomaly_findings[@]}" "Score: $anomaly_score" "$(IFS=', '; echo "${anomaly_findings[*]}")"
    else
        analysis_success_none "ZERO-DAY"
    fi
}

analyze_encoding_anomalies() {
    set +u
    local content="${1:-}"
    set -u
    
    # Check for mixed encodings
    local has_base64=false
    local has_hex=false
    local has_url=false
    local has_unicode=false
    
    echo "$content" | safe_grep_qE "[A-Za-z0-9+/=]{20,}" && has_base64=true
    echo "$content" | safe_grep_qE "\\\\x[0-9a-fA-F]{2}" && has_hex=true
    echo "$content" | safe_grep_qE "%[0-9a-fA-F]{2}" && has_url=true
    echo "$content" | safe_grep_qE "\\\\u[0-9a-fA-F]{4}" && has_unicode=true
    
    local encoding_count=0
    [ "$has_base64" = true ] && ((encoding_count++))
    [ "$has_hex" = true ] && ((encoding_count++))
    [ "$has_url" = true ] && ((encoding_count++))
    [ "$has_unicode" = true ] && ((encoding_count++))
    
    if [ $encoding_count -ge 3 ]; then
        log_warning "Multiple encoding schemes detected ($encoding_count types) - possible evasion"
    fi
}

analyze_polyglot_content() {
    set +u
    local content="${1:-}"
    set -u
    
    # Check for polyglot file signatures in content
    
    # PDF header in URL/content
    if echo "$content" | safe_grep_qE "%PDF-|JVBERi0"; then
        log_threat 55 "PDF signature detected in content - possible polyglot"
    fi
    
    # ZIP header
    if echo "$content" | safe_grep_qE "PK\x03\x04|UEsDB"; then
        log_threat 50 "ZIP signature detected in content - possible polyglot"
    fi
    
    # PE header
    if echo "$content" | safe_grep_qE "MZ.*This program|TVqQ"; then
        log_threat 70 "PE executable signature detected - possible polyglot"
    fi
    
    # HTML in non-HTML context
    if echo "$content" | safe_grep_qE "<html|<script|<iframe" && ! echo "$content" | safe_grep_qE "^https?://"; then
        log_warning "HTML content in non-URL context - possible injection"
    fi
}

analyze_parser_differentials() {
    set +u
    local content="${1:-}"
    set -u
    local python_cmd=$(get_python_cmd)
    
    # Validate content is not empty
    [[ -z "$content" ]] && return 0
    
    # Check for parser confusion characters using bash instead of Python
    # This avoids segfaults in Python when handling certain content
    
    # Check for Unicode special characters (non-breaking spaces, zero-width chars)
    # Use od to detect these characters safely
    if printf '%s' "$content" | od -A n -t x1 2>/dev/null | grep -qE 'c2 a0|e2 80 (8[0-9a-f]|9[0-9a-f]|a[0-9a-f])|ef bb bf|e3 80 80'; then
        log_warning "Unicode special characters detected - possible parser confusion"
    fi
    
    # Check for Bidi override characters (RLO/LRO attack)
    if printf '%s' "$content" | od -A n -t x1 2>/dev/null | grep -qE 'e2 80 (aa|ab|ac|ad|ae)|e2 81 (a6|a7|a8|a9)'; then
        log_threat 45 "Bidirectional text override characters detected - RLO attack"
    fi
    
    # Null bytes that might terminate strings early
    if printf '%s' "$content" | grep -q $'\x00' 2>/dev/null; then
        # Extract context around null byte for logging (sanitize for display)
        local null_context=$(printf '%s' "$content" | od -A n -t x1c 2>/dev/null | grep -B1 -A1 '\\0' | head -3 | tr '\n' ' ')
        local content_preview="${content:0:80}"
        [[ ${#content} -gt 80 ]] && content_preview="${content_preview}..."
        log_warning "Null byte detected in content - possible string termination attack. Content preview: '${content_preview}' | Hex context: ${null_context:0:100}"
    fi
}

check_known_cve_patterns() {
    local content="$1"
    
    # CVE-2021-44228 (Log4Shell)
    if echo "$content" | safe_grep_qiE "\\\$\{jndi:(ldap|rmi|dns|corba)://"; then
        log_threat 90 "Log4Shell (CVE-2021-44228) pattern detected"
        record_ioc "cve" "CVE-2021-44228" "Log4Shell exploit pattern"
    fi
    
    # CVE-2021-34473/31207/34523 (ProxyShell)
    if echo "$content" | safe_grep_qiE "autodiscover.*powershell|mapi/nspi"; then
        log_threat 85 "ProxyShell pattern detected"
        record_ioc "cve" "ProxyShell" "Exchange exploit pattern"
    fi
    
    # CVE-2022-30190 (Follina)
    if echo "$content" | safe_grep_qiE "ms-msdt:.*IT_"; then
        log_threat 90 "Follina (CVE-2022-30190) pattern detected"
        record_ioc "cve" "CVE-2022-30190" "Follina exploit pattern"
    fi
    
    # CVE-2021-40444 (MSHTML)
    if echo "$content" | safe_grep_qiE "\.cpl.*\.inf|\.cab.*\.inf"; then
        log_threat 80 "MSHTML (CVE-2021-40444) pattern detected"
        record_ioc "cve" "CVE-2021-40444" "MSHTML exploit pattern"
    fi
    
    # Spring4Shell
    if echo "$content" | safe_grep_qiE "class\.module\.classLoader"; then
        log_threat 85 "Spring4Shell pattern detected"
        record_ioc "cve" "Spring4Shell" "Spring exploit pattern"
    fi
}

################################################################################
# ML-BASED HEURISTIC ANALYSIS
################################################################################

analyze_ml_heuristics() {
    set +u
    local content="${1:-}"
    set -u
    
    if [ "$ML_CLASSIFICATION" = false ]; then
        return
    fi
    
    log_ml "Performing ML-based heuristic analysis..."
    
    local ml_findings=()
    local ml_score=0
    local ml_confidence=0
    
    # Feature extraction and scoring
    
    # 1. URL Structure Analysis
    if echo "$content" | safe_grep_qiE "^https?://"; then
        local url="$content"
        
        # URL length feature
        local url_length=${#url}
        if [ $url_length -gt 200 ]; then
            ((ml_score += 15))
            ml_findings+=("long_url:$url_length")
        fi
        
        # Subdomain depth
        local domain=$(echo "$url" | sed -E 's|^https?://||' | cut -d'/' -f1)
        local subdomain_count=$(echo "$domain" | tr '.' '\n' | wc -l)
        if [ $subdomain_count -gt 4 ]; then
            ((ml_score += 20))
            ml_findings+=("deep_subdomains:$subdomain_count")
        fi
        
        # Special character ratio in URL
        local special_chars=$(echo "$url" | tr -cd '@#%&=?-_' | wc -c)
        local special_ratio=$(echo "scale=4; $special_chars / $url_length" | bc 2>/dev/null || echo "0")
        if float_gt "$special_ratio" "0.1"; then
            ((ml_score += 15))
            ml_findings+=("special_char_ratio:$special_ratio")
        fi
        
        # Digit ratio in domain
        local digits=$(echo "$domain" | tr -cd '0-9' | wc -c)
        local domain_length=${#domain}
        local digit_ratio=$(echo "scale=4; $digits / $domain_length" | bc 2>/dev/null || echo "0")
        if float_gt "$digit_ratio" "0.3"; then
            ((ml_score += 20))
            ml_findings+=("high_digit_ratio:$digit_ratio")
        fi
        
        # Path depth
        local path_depth=$(echo "$url" | tr '/' '\n' | wc -l)
        if [ $path_depth -gt 8 ]; then
            ((ml_score += 10))
            ml_findings+=("deep_path:$path_depth")
        fi
        
        # Query parameter count
        local param_count=$(echo "$url" | grep -o '&' | wc -l)
        ((param_count++))  # Add 1 for first parameter
        if [ $param_count -gt 5 ]; then
            ((ml_score += 15))
            ml_findings+=("many_params:$param_count")
        fi
    fi
    
    # 2. Entropy-based analysis
    local entropy=$(calculate_string_entropy "$content")
    if float_gt "$entropy" "4.5"; then
        ((ml_score += 15))
        ml_findings+=("high_entropy:$entropy")
    fi
    
    # 3. N-gram analysis for suspicious patterns
    analyze_ngram_patterns "$content"
    
    # 4. Keyword density scoring
    local phishing_keywords=0
    for keyword in "login" "verify" "account" "password" "secure" "update" "confirm" "suspended" "urgent"; do
        if echo "$content" | safe_grep_qiE "$keyword"; then
            ((phishing_keywords++))
        fi
    done
    
    if [ $phishing_keywords -ge 3 ]; then
        ((ml_score += 25))
        ml_findings+=("phishing_keywords:$phishing_keywords")
    fi
    
    # 5. Brand impersonation scoring
    local brand_score=$(calculate_brand_similarity "$content")
    if [ $brand_score -gt 70 ]; then
        ((ml_score += 30))
        ml_findings+=("brand_impersonation:$brand_score")
    fi
    
    # Calculate confidence based on feature coverage
    local feature_count=${#ml_findings[@]}
    if [ $feature_count -ge 5 ]; then
        ml_confidence=90
    elif [ $feature_count -ge 3 ]; then
        ml_confidence=70
    elif [ $feature_count -ge 1 ]; then
        ml_confidence=50
    else
        ml_confidence=30
    fi
    
    # Generate ML heuristics report
    {
        echo "═══════════════════════════════════════════════"
        echo "ML HEURISTIC ANALYSIS"
        echo "═══════════════════════════════════════════════"
        echo "Timestamp: $(date -Iseconds)"
        echo "ML Risk Score: $ml_score"
        echo "Confidence: $ml_confidence%"
        echo ""
        echo "Feature Analysis:"
        for finding in "${ml_findings[@]}"; do
            echo "  - $finding"
        done
        echo ""
        echo "Classification:"
        if [ $ml_score -ge 80 ]; then
            echo "  MALICIOUS (High Confidence)"
        elif [ $ml_score -ge 50 ]; then
            echo "  SUSPICIOUS (Medium Confidence)"
        elif [ $ml_score -ge 25 ]; then
            echo "  POTENTIALLY SUSPICIOUS (Low Confidence)"
        else
            echo "  LIKELY BENIGN"
        fi
        echo ""
    } >> "$ML_CLASSIFICATION_REPORT"
    
    if [ $ml_score -ge 40 ]; then
        log_threat $((ml_score / 3)) "ML heuristics indicate suspicious content"
        analysis_success_found "ML-HEURISTICS" "${#ml_findings[@]}" "Score: $ml_score, Confidence: $ml_confidence%" "$(IFS=', '; echo "${ml_findings[*]}")"
    else
        analysis_success_none "ML-HEURISTICS"
    fi
}

# NOTE: calculate_string_entropy is defined earlier in the script - this duplicate is removed

# ============================================================================
# NOTE: The following code blocks were moved to comments because they were
# incorrectly placed at global scope (executed during script initialization)
# with undefined variables ($domain, $infile, ${images[@]}).
# This caused the script to hang when 'identify -verbose ""' waited for stdin.
# These checks should be called from within appropriate analysis functions
# where the variables are actually defined.
# ============================================================================

# # After extracting $domain (domain or subdomain from QR URL)
#     domain_entropy=$(echo -n "$domain" | od -An -t x1 | tr -d ' \n' | fold -w2 | sort | uniq -c | awk '{print $1}' | sort -n | tail -1)
#     if [[ "$domain_entropy" -gt 4 ]]; then
#         echo -e "${RED}[THREAT +60]${NC} High domain entropy/DGA pattern detected (possible algorithmic domain)"
#     fi
#
#     # After enumerating images (if multiple files given)
#     if [ "${#images[@]}" -gt 1 ]; then
#         for img in "${images[@]}"; do
#             if strings "$img" | grep -Ei 'part [0-9]+ of [0-9]+'; then
#                 echo -e "${YELLOW}[WARNING]${NC} Possible QR chain or multipart payload detected: $img"
#             fi
#         done
#     fi
#
#     # After extracting QR image stats or in analyze_qr_image
#     qr_meaningful_density=$(identify -verbose "$infile" | grep 'Pixels:' | awk '{print $2}')
#     if [[ "$qr_meaningful_density" -gt 230000 ]]; then
#         echo -e "${RED}[THREAT +25]${NC} QR density unusually high (possible adversarial or anti-ML payload)"
#     fi

analyze_ngram_patterns() {
    set +u
    local content="${1:-}"
    set -u
    
    # Check for suspicious character n-grams
    # Note: Using -F for fixed string matching to avoid regex issues with special chars
    local suspicious_ngrams=(
        "xxx"
        "000"
        "111"
        "aaa"
        "zzz"
        ".."
        "--"
        "__"
        "@@"
        "##"
    )
    
    for ngram in "${suspicious_ngrams[@]}"; do
        # Use -F for fixed string matching (not regex)
        local count=$(echo "$content" | safe_grep_oF "$ngram" 2>/dev/null | wc -l | tr -d ' ')
        count=${count:-0}
        if [ "${count:-0}" -gt 3 ] 2>/dev/null; then
            log_info "Suspicious n-gram pattern: '$ngram' appears $count times"
        fi
    done
}

calculate_brand_similarity() {
    local content="$1"
    local max_similarity=0
    
    # Check similarity to known brands
    for brand in "paypal" "amazon" "google" "microsoft" "apple" "facebook" "netflix" "bank" "chase" "wells"; do
        if echo "$content" | safe_grep_qiE "$brand" 2>/dev/null; then
            # Check for typosquatting variations (use variables to avoid shell parsing issues)
            local prefix="${brand:0:3}"
            local suffix="${brand:${#brand}-3}"
            local pattern="${prefix}[a-z]*${suffix}"
            local variations=$(echo "$content" | safe_grep_oiE "$pattern" 2>/dev/null | wc -l)
            if [ "$variations" -gt 0 ] 2>/dev/null; then
                max_similarity=80
            else
                max_similarity=50
            fi
        fi
    done
    
    echo $max_similarity
}

################################################################################
# SIEM / EDR INTEGRATION
################################################################################

generate_siem_export() {
    if [ "$SIEM_INTEGRATION" = false ]; then
        return
    fi
    
    log_info "Generating SIEM-compatible export..."
    
    # Generate SIEM-ready JSON
    {
        echo "{"
        echo "  \"timestamp\": \"$(date -Iseconds)\","
        echo "  \"event_type\": \"qr_code_analysis\","
        echo "  \"version\": \"$VERSION\","
        echo "  \"threat_score\": $THREAT_SCORE,"
        echo "  \"threat_level\": \"$(get_threat_level)\","
        echo "  \"iocs\": ["
        
        # Include IOCs from CSV
        local first=true
        while IFS=, read -r type indicator timestamp context; do
            if [ "$first" = true ]; then
                first=false
            else
                echo ","
            fi
            echo "    {"
            echo "      \"type\": \"$type\","
            echo "      \"value\": \"$indicator\","
            echo "      \"timestamp\": \"$timestamp\","
            echo "      \"context\": \"$context\""
            echo -n "    }"
        done < "$IOC_REPORT"
        
        echo ""
        echo "  ],"
        echo "  \"analysis_modules\": {"
        echo "    \"cloud_abuse\": $([ -s "$CLOUD_ABUSE_REPORT" ] && echo "true" || echo "false"),"
        echo "    \"mobile_threats\": $([ -s "$MOBILE_THREAT_REPORT" ] && echo "true" || echo "false"),"
        echo "    \"fileless_malware\": $([ -s "$FILELESS_REPORT" ] && echo "true" || echo "false"),"
        echo "    \"ransomware\": $([ -s "$RANSOMWARE_NOTE_REPORT" ] && echo "true" || echo "false"),"
        echo "    \"tor_vpn\": $([ -s "$TOR_VPN_REPORT" ] && echo "true" || echo "false"),"
        echo "    \"social_engineering\": $([ -s "$PERSONA_REPORT" ] && echo "true" || echo "false"),"
        echo "    \"adversarial_qr\": $([ -s "$ADVERSARIAL_QR_REPORT" ] && echo "true" || echo "false"),"
        echo "    \"zero_day\": $([ -s "$ZERO_DAY_REPORT" ] && echo "true" || echo "false")"
        echo "  }"
        echo "}"
    } > "$SIEM_EXPORT_FILE"
    
    log_success "SIEM export generated: $SIEM_EXPORT_FILE"
}

get_threat_level() {
    if [ $THREAT_SCORE -ge $CRITICAL_THRESHOLD ]; then
        echo "CRITICAL"
    elif [ $THREAT_SCORE -ge $HIGH_THRESHOLD ]; then
        echo "HIGH"
    elif [ $THREAT_SCORE -ge $MEDIUM_THRESHOLD ]; then
        echo "MEDIUM"
    elif [ $THREAT_SCORE -ge $LOW_THRESHOLD ]; then
        echo "LOW"
    else
        echo "MINIMAL"
    fi
}

################################################################################
# INDUSTRY-SPECIFIC THREAT ANALYSIS
################################################################################

analyze_industry_threats() {
    set +u
    local content="${1:-}"
    set -u
    
    log_info "Analyzing for industry-specific threats..."
    
    local total_industry_threats=0
    local industry_findings=()
    
    # Healthcare
    local healthcare_matches=0
    for pattern in "${HEALTHCARE_THREAT_PATTERNS[@]}"; do
        if echo "$content" | safe_grep_qiE "$pattern"; then
            ((healthcare_matches++))
        fi
    done
    if [ $healthcare_matches -ge 2 ]; then
        log_warning "Healthcare-targeted content detected ($healthcare_matches indicators)"
        log_threat 30 "Potential healthcare phishing/fraud"
        industry_findings+=("healthcare:${healthcare_matches}_indicators")
        ((total_industry_threats++))
    fi
    
    # Financial
    local financial_matches=0
    for pattern in "${FINANCIAL_THREAT_PATTERNS[@]}"; do
        if echo "$content" | safe_grep_qiE "$pattern"; then
            ((financial_matches++))
        fi
    done
    if [ $financial_matches -ge 2 ]; then
        log_warning "Financial-targeted content detected ($financial_matches indicators)"
        log_threat 35 "Potential financial fraud/phishing"
        industry_findings+=("financial:${financial_matches}_indicators")
        ((total_industry_threats++))
    fi
    
    # Government
    local government_matches=0
    for pattern in "${GOVERNMENT_THREAT_PATTERNS[@]}"; do
        if echo "$content" | safe_grep_qiE "$pattern"; then
            ((government_matches++))
        fi
    done
    if [ $government_matches -ge 2 ]; then
        log_warning "Government-impersonation content detected ($government_matches indicators)"
        log_threat 40 "Potential government impersonation scam"
        industry_findings+=("government:${government_matches}_indicators")
        ((total_industry_threats++))
    fi
    
    # Education
    local education_matches=0
    for pattern in "${EDUCATION_THREAT_PATTERNS[@]}"; do
        if echo "$content" | safe_grep_qiE "$pattern"; then
            ((education_matches++))
        fi
    done
    if [ $education_matches -ge 2 ]; then
        log_warning "Education-targeted content detected ($education_matches indicators)"
        log_threat 25 "Potential education sector phishing"
        industry_findings+=("education:${education_matches}_indicators")
        ((total_industry_threats++))
    fi
    
    # E-commerce
    local ecommerce_matches=0
    for pattern in "${ECOMMERCE_THREAT_PATTERNS[@]}"; do
        if echo "$content" | safe_grep_qiE "$pattern"; then
            ((ecommerce_matches++))
        fi
    done
    if [ $ecommerce_matches -ge 2 ]; then
        log_warning "E-commerce-targeted content detected ($ecommerce_matches indicators)"
        log_threat 25 "Potential e-commerce fraud"
        industry_findings+=("ecommerce:${ecommerce_matches}_indicators")
        ((total_industry_threats++))
    fi
    
    if [ $total_industry_threats -gt 0 ]; then
        analysis_success_found "INDUSTRY-THREATS" "$total_industry_threats" "Sector-specific threats detected" "$(IFS=', '; echo "${industry_findings[*]}")"
    else
        analysis_success_none "INDUSTRY-THREATS"
    fi
}

################################################################################
# URL OBFUSCATION AND CLOAKING ANALYSIS
################################################################################

analyze_url_obfuscation() {
    set +u
    local content="${1:-}"
    set -u
    
    log_info "Analyzing for URL obfuscation techniques..."
    
    local obfuscation_findings=()
    local obfuscation_score=0
    
    # Check obfuscation patterns
    for pattern in "${URL_OBFUSCATION_PATTERNS[@]}"; do
        if echo "$content" | safe_grep_qiE "$pattern"; then
            local matched=$(echo "$content" | safe_grep_oiE "$pattern" 2>/dev/null | head -1)
            obfuscation_findings+=("obfuscation:$matched")
            ((obfuscation_score += 20))
            log_warning "URL obfuscation technique: $matched"
        fi
    done
    
    # Check for IP address obfuscation
    if echo "$content" | safe_grep_qE "0x[0-9a-fA-F]+\.[0-9]|[0-9]{10,}|0[0-7]+\."; then
        log_threat 45 "IP address obfuscation detected (hex/decimal/octal)"
        obfuscation_findings+=("ip_obfuscation")
        ((obfuscation_score += 35))
    fi
    
    # Check for punycode domains
    if echo "$content" | safe_grep_qiE "xn--[a-z0-9]+"; then
        log_warning "Punycode domain detected - verify actual characters"
        obfuscation_findings+=("punycode_domain")
        ((obfuscation_score += 25))
        
        # Try to decode punycode
        local punycode=$(echo "$content" | safe_grep_oiE "xn--[a-z0-9.-]+" | head -1)
        if [ -n "$punycode" ] && command -v idn &> /dev/null; then
            local decoded=$(echo "$punycode" | idn --idna-to-unicode 2>/dev/null)
            log_forensic "Decoded punycode: $decoded"
        fi
    fi
    
    # Check for data URI
    if echo "$content" | safe_grep_qiE "data:(text|application)"; then
        log_threat 50 "Data URI detected - embedded content"
        obfuscation_findings+=("data_uri")
        ((obfuscation_score += 40))
    fi
    
    # Check for javascript URI
    if echo "$content" | safe_grep_qiE "javascript:"; then
        log_threat 55 "JavaScript URI detected"
        obfuscation_findings+=("javascript_uri")
        ((obfuscation_score += 45))
    fi
    
    # Check for double encoding
    if echo "$content" | safe_grep_qE "%25[0-9a-fA-F]{2}"; then
        log_threat 40 "Double URL encoding detected"
        obfuscation_findings+=("double_encoding")
        ((obfuscation_score += 30))
    fi
    
    # Check for open redirect abuse
    if echo "$content" | safe_grep_qiE "(redirect|url|next|goto|redir)=https?://"; then
        log_warning "Potential open redirect parameter"
        obfuscation_findings+=("open_redirect")
        ((obfuscation_score += 25))
    fi
    
    # Report findings
    if [ $obfuscation_score -ge 30 ]; then
        log_threat $((obfuscation_score / 2)) "URL obfuscation techniques detected"
        analysis_success_found "URL-OBFUSCATION" "${#obfuscation_findings[@]}" "Score: $obfuscation_score" "$(IFS=', '; echo "${obfuscation_findings[*]}")"
    else
        analysis_success_none "URL-OBFUSCATION"
    fi
}

################################################################################
# COMMAND INJECTION AND TEMPLATE INJECTION ANALYSIS
#
# Comprehensive detection engine for injection-based attack vectors including:
# - Command Injection (OS command execution via unsanitized input)
# - Server-Side Template Injection (SSTI) across multiple templating engines
# - XML External Entity (XXE) injection attacks
# - Server-Side Request Forgery (SSRF) protocol abuse
# - LDAP Injection patterns
# - XPath Injection patterns
# - Expression Language (EL) Injection
# - Header Injection / CRLF Injection
# - SQL Injection (supplementary detection)
# - NoSQL Injection patterns
# - GraphQL Injection patterns
# - Log Injection / Log Forging
#
# Severity Scoring Matrix:
#   Critical (70+): Confirmed exploitation patterns with high confidence
#   High (50-69):   Strong indicators of malicious injection attempts
#   Medium (30-49): Suspicious patterns requiring further investigation
#   Low (10-29):    Potential false positives or benign edge cases
#
# References:
#   - OWASP Injection Prevention Cheat Sheet
#   - CWE-77: Command Injection
#   - CWE-94: Code Injection
#   - CWE-611: XXE
#   - CWE-918:  SSRF
################################################################################

# Extended pattern definitions for comprehensive injection detection
declare -a SSTI_PATTERNS=(
    # Jinja2 / Twig / Django
    '\{\{.*config.*\}\}'
    '\{\{.*self\.__class__.*\}\}'
    '\{\{.*__mro__.*\}\}'
    '\{\{.*__subclasses__.*\}\}'
    '\{\{.*__globals__.*\}\}'
    '\{\{.*__builtins__.*\}\}'
    '\{\{.*request\..*\}\}'
    '\{%.*import.*%\}'
    '\{%.*raw.*%\}'
    # Freemarker
    '\$\{.*\.getClass\(\).*\}'
    '<#assign.*=.*>'
    '\$\{.*?new\(.*\).*\}'
    # Velocity
    '#set[[:space:]]*\([[:space:]]*\$.*='
    '#foreach.*#end'
    '\$class\.inspect'
    # Thymeleaf
    '\$\{T\(.*\)\..*\}'
    '__\$\{.*\}__'
    # Pebble
    '\{\{.*beans.*\}\}'
    # Smarty
    '\{php\}.*\{/php\}'
    '\{literal\}.*\{/literal\}'
    # Mako
    '\$\{.*import.*\}'
    '<%.*import.*%>'
    # ERB
    '<%=.*system.*%>'
    '<%=.*exec.*%>'
    '<%=.*`.*`.*%>'
)

declare -a XXE_PATTERNS=(
    '<!ENTITY[[:space:]]+[[:alnum:]_]+[[:space:]]+SYSTEM'
    '<!ENTITY[[:space:]]+[[:alnum:]_]+[[:space:]]+PUBLIC'
    '<!ENTITY[[:space:]]+%[[:space:]]+[[:alnum:]_]+'
    'SYSTEM[[:space:]]+["'"'"']file:'
    'SYSTEM[[:space:]]+["'"'"']http:'
    'SYSTEM[[:space:]]+["'"'"']https:'
    'SYSTEM[[:space:]]+["'"'"']ftp:'
    'SYSTEM[[:space:]]+["'"'"']expect:'
    'SYSTEM[[:space:]]+["'"'"']php:'
    'DOCTYPE[[:space:]]+[[:alnum:]_]+[[:space:]]+\[.*ENTITY'
    '<!ATTLIST[[:space:]]+[[:alnum:]_]+[[:space:]]+[[:alnum:]_]+[[:space:]]+ENTITY'
    'xmlns:xi=.*XInclude'
    '<xi:include'
    'xlink:href[[:space:]]*=[[:space:]]*["'"'"']file:'
)

declare -a SSRF_PROTOCOLS=(
    'file:///'
    'gopher://'
    'dict://'
    'php://'
    'phar://'
    'jar://'
    'tftp://'
    'ldap://'
    'ldaps://'
    'sftp://'
    'netdoc://'
    'data://'
    'glob://'
    'expect://'
    'ogg://'
    'rar://'
    'zlib://'
    'zip://'
    'compress.zlib://'
    'compress.bzip2://'
)

declare -a SSRF_BYPASS_PATTERNS=(
    # Localhost bypasses
    '127\.0\.0\.1'
    'localhost'
    '0\.0\.0\.0'
    '\[::1\]'
    '\[::\]'
    '0x7f000001'
    '2130706433'
    '017700000001'
    '127\.1'
    '127\.0\.1'
    # Cloud metadata endpoints
    '169\.254\.169\.254'
    'metadata\.google\.internal'
    'metadata\.goog'
    '100\.100\.100\.200'
    # DNS rebinding indicators
    '\.xip\.io'
    '\.nip\.io'
    '\.sslip\.io'
    '\.localtest\.me'
    # URL encoding bypasses
    '%00'
    '%0d%0a'
    '@.*@'
)

declare -a LDAP_INJECTION_PATTERNS=(
    '\*\)\(\|'
    '\)\(\|'
    '\)\(!'
    '\*\)\(cn='
    '\*\)\(uid='
    '\*\)\(mail='
    '\)\(password='
    '\)\(userPassword='
    'x\]\)\(\|\(x='
    '\)\)%00'
)

declare -a XPATH_INJECTION_PATTERNS=(
    "'[[:space:]]*or[[:space:]]*'.*'.*=.*'"
    "'[[:space:]]*][[:space:]]*//"
    "'[[:space:]]*][[:space:]]*[|]"
    "ancestor::"
    "descendant::"
    "following::"
    "preceding::"
    "self::"
    "child::"
    "parent::"
    "normalize-space[[:space:]]*\("
    "string-length[[:space:]]*\("
    "substring[[:space:]]*\("
    "translate[[:space:]]*\("
    "contains[[:space:]]*\("
)

declare -a EL_INJECTION_PATTERNS=(
    # Java EL
    '\$\{.*Runtime.*\}'
    '\$\{.*ProcessBuilder.*\}'
    '\$\{.*ScriptEngine.*\}'
    '\$\{.*getRuntime\(\).*\}'
    '\$\{.*\.exec\(.*\).*\}'
    '#\{.*\.class\.forName.*\}'
    # Spring EL (SpEL)
    '\$\{T\(java\.lang\.'
    '#\{T\(java\.lang\.'
    'new[[:space:]]+java\.lang\.'
    '\.getRuntime\(\)\.exec\('
    # OGNL
    '\(#.*=.*@.*@.*\)'
    '#_memberAccess'
    '#context'
    '\(#cmd='
    '@java\.lang\.Runtime@getRuntime'
)

declare -a CRLF_INJECTION_PATTERNS=(
    '%0d%0a'
    '%0D%0A'
    '\r\n'
    '%5cr%5cn'
    '%E5%98%8A%E5%98%8D'
    '\\r\\n'
    '%0d'
    '%0a'
    '%5cr'
    '%5cn'
    '&#13;'
    '&#10;'
)

declare -a NOSQL_INJECTION_PATTERNS=(
    '\$where[[:space:]]*:'
    '\$regex[[:space:]]*:'
    '\$gt[[:space:]]*:'
    '\$gte[[:space:]]*:'
    '\$lt[[:space:]]*:'
    '\$lte[[:space:]]*:'
    '\$ne[[:space:]]*:'
    '\$nin[[:space:]]*:'
    '\$or[[:space:]]*:[[:space:]]*\['
    '\$and[[:space:]]*:[[:space:]]*\['
    '\$not[[:space:]]*:'
    '\$exists[[:space:]]*:'
    '"\$[^"]*"[^:]*:[^{]*\{[^"]*"\$'
    'mapReduce'
    'function[[:space:]]*\([[:space:]]*\)[[:space:]]*\{'
    'this\.[[:alnum:]_]+[[:space:]]*=='
    'sleep[[:space:]]*\([[:space:]]*[0-9]+[[:space:]]*\)'
    '\$comment[[:space:]]*:'
)

declare -a GRAPHQL_INJECTION_PATTERNS=(
    '__schema[[:space:]]*\{'
    '__type[[:space:]]*\{'
    '__typename'
    'introspectionQuery'
    '\.\.\.[[:space:]]+on[[:space:]]+__'
    'query[[:space:]]+IntrospectionQuery'
    'mutation[[:space:]]*\{.*\{.*\{'
    '@skip[[:space:]]*\('
    '@include[[:space:]]*\('
    'fragment[[:space:]]+[^[:space:]]+[[:space:]]+on[[:space:]]+[^[:space:]]+[[:space:]]*\{.*__'
)

declare -a LOG_INJECTION_PATTERNS=(
    '\$\{jndi:'
    '\$\{lower:'
    '\$\{upper:'
    '\$\{env:'
    '\$\{sys:'
    '\$\{java:'
    '\$\{base64:'
    '\$\{date:'
    '\$\{\$\{'
    '%24%7Bjndi'
    '\$\{j\$\{.*\}ndi'
    '\$\{\$\{:-j\}ndi'
)

declare -A INJECTION_SEVERITY=(
    ["cmd_injection"]=70
    ["ssti_critical"]=65
    ["ssti_standard"]=50
    ["xxe_attack"]=60
    ["xxe_blind"]=55
    ["ssrf_protocol"]=55
    ["ssrf_bypass"]=60
    ["ssrf_metadata"]=70
    ["ldap_injection"]=50
    ["xpath_injection"]=50
    ["el_injection"]=65
    ["crlf_injection"]=45
    ["nosql_injection"]=55
    ["graphql_introspection"]=35
    ["graphql_injection"]=50
    ["log_injection"]=70
    ["log4j_jndi"]=75
    ["polyglot"]=75
)

analyze_injection_attacks() {
    set +u
    local content="${1:-}"
    set -u
    
    log_info "Analyzing for injection attack patterns..."
    
    local injection_findings=()
    local injection_score=0
    
    # Check command injection patterns
    for pattern in "${COMMAND_INJECTION_PATTERNS[@]}"; do
        if echo "$content" | safe_grep_qiE "$pattern" 2>/dev/null; then
            local matched=$(echo "$content" | safe_grep_oiE "$pattern" 2>/dev/null | head -1)
            injection_findings+=("cmd_injection:$matched")
            ((injection_score += 40))
            log_threat 55 "Command injection pattern: $matched"
        fi
    done
    
    # Template injection (SSTI)
    if echo "$content" | safe_grep_qE "\{\{.*\}\}|\{%.*%\}|\$\{.*\}" 2>/dev/null; then
        log_threat 50 "Template injection pattern detected"
        injection_findings+=("template_injection")
        ((injection_score += 40))
    fi
    
    # XXE patterns
    if echo "$content" | safe_grep_qiE "<!ENTITY|SYSTEM.*file:|DOCTYPE.*ENTITY" 2>/dev/null; then
        log_threat 60 "XXE (XML External Entity) pattern detected"
        injection_findings+=("xxe_attack")
        ((injection_score += 50))
    fi
    
    # SSRF patterns
    if echo "$content" | safe_grep_qiE "file:///|gopher://|dict://|php://" 2>/dev/null; then
        log_threat 55 "SSRF-related protocol scheme detected"
        injection_findings+=("ssrf_protocol")
        ((injection_score += 45))
    fi
    
    # Note: analysis_success_found will be called at the end after all extended analysis
    
    # ═══════════════════════════════════════════════════════════════════════════
    # EXTENDED ANALYSIS:  Advanced SSTI Detection
    # ═══════════════════════════════════════════════════════════════════════════
    
    log_info "Performing extended SSTI analysis across templating engines..."
    
    local ssti_engine_hits=()
    local ssti_critical_count=0
    
    for pattern in "${SSTI_PATTERNS[@]}"; do
        if echo "$content" | safe_grep_qiE "$pattern" 2>/dev/null; then
            local matched=$(echo "$content" | safe_grep_oiE "$pattern" 2>/dev/null | head -1)
            ssti_engine_hits+=("$matched")
            
            # Check for critical patterns (RCE capable)
            if [[ "$matched" =~ (__class__|__mro__|__subclasses__|__globals__|__builtins__|getClass|Runtime|ProcessBuilder|exec) ]]; then
                ((ssti_critical_count++))
                ((injection_score += ${INJECTION_SEVERITY["ssti_critical"]}))
                log_threat 65 "Critical SSTI pattern (potential RCE): $matched"
                injection_findings+=("ssti_critical:$matched")
            else
                ((injection_score += ${INJECTION_SEVERITY["ssti_standard"]}))
                log_threat 50 "SSTI pattern detected: $matched"
                injection_findings+=("ssti:$matched")
            fi
        fi
    done
    
    if [ ${#ssti_engine_hits[@]} -gt 0 ]; then
        local engine_guess="unknown"
        
        # Attempt to identify the templating engine
        if echo "$content" | safe_grep_qE '\{\{.*\}\}.*\{%.*%\}' 2>/dev/null || echo "$content" | safe_grep_qE '\{\{.*\}\}' 2>/dev/null; then
            engine_guess="Jinja2/Twig/Django"
        elif echo "$content" | safe_grep_qE '<#assign|#set.*\$' 2>/dev/null; then
            engine_guess="Freemarker/Velocity"
        elif echo "$content" | safe_grep_qE '\$\{T\(.*\)\}|__\$\{.*\}' 2>/dev/null; then
            engine_guess="Thymeleaf"
        elif echo "$content" | safe_grep_qE '\{php\}|{literal}' 2>/dev/null; then
            engine_guess="Smarty"
        elif echo "$content" | safe_grep_qE '<%=.*%>' 2>/dev/null; then
            engine_guess="ERB/JSP"
        elif echo "$content" | safe_grep_qE '\$\{.*\}.*<%' 2>/dev/null; then
            engine_guess="Mako"
        fi
        
        log_info "Suspected templating engine: $engine_guess"
        log_info "Total SSTI patterns found: ${#ssti_engine_hits[@]} (Critical: $ssti_critical_count)"
    fi
    
    # ═══════════════════════════════════════════════════════════════════════════
    # EXTENDED ANALYSIS:  Comprehensive XXE Detection
    # ═══════════════════════════════════════════════════════════════════════════
    
    log_info "Performing comprehensive XXE analysis..."
    
    local xxe_variant_count=0
    local xxe_blind_indicators=0
    
    for pattern in "${XXE_PATTERNS[@]}"; do
        if echo "$content" | safe_grep_qiE "$pattern" 2>/dev/null; then
            local matched=$(echo "$content" | safe_grep_oiE "$pattern" 2>/dev/null | head -1)
            ((xxe_variant_count++))
            
            # Check for blind XXE indicators (external connections)
            if [[ "$matched" =~ (http:|https:|ftp:) ]]; then
                ((xxe_blind_indicators++))
                ((injection_score += ${INJECTION_SEVERITY["xxe_blind"]}))
                log_threat 55 "Blind XXE indicator (out-of-band exfiltration): $matched"
                injection_findings+=("xxe_blind:$matched")
            else
                ((injection_score += ${INJECTION_SEVERITY["xxe_attack"]}))
                log_threat 60 "XXE pattern variant: $matched"
                injection_findings+=("xxe_variant:$matched")
            fi
        fi
    done
    
    # Check for XInclude attacks
    if echo "$content" | safe_grep_qiE 'xmlns:xi=.*XInclude|<xi:include' 2>/dev/null; then
        log_threat 60 "XInclude-based XXE attack pattern detected"
        injection_findings+=("xxe_xinclude")
        ((injection_score += 50))
    fi
    
    # Check for XSLT injection (related to XXE)
    if echo "$content" | safe_grep_qiE '<xsl:value-of|<xsl:variable|document[[:space:]]*\(' 2>/dev/null; then
        log_threat 55 "XSLT injection pattern detected"
        injection_findings+=("xslt_injection")
        ((injection_score += 45))
    fi
    
    if [ $xxe_variant_count -gt 0 ]; then
        log_info "Total XXE variants detected: $xxe_variant_count (Blind indicators: $xxe_blind_indicators)"
    fi
    
    # ═══════════════════════════════════════════════════════════════════════════
    # EXTENDED ANALYSIS: Advanced SSRF Detection with Bypass Analysis
    # ═══════════════════════════════════════════════════════════════════════════
    
    log_info "Performing advanced SSRF analysis with bypass detection..."
    
    local ssrf_protocol_count=0
    local ssrf_bypass_count=0
    local cloud_metadata_detected=false
    
    # Extended protocol detection
    for protocol in "${SSRF_PROTOCOLS[@]}"; do
        if echo "$content" | safe_grep_qiF "$protocol" 2>/dev/null; then
            ((ssrf_protocol_count++))
            ((injection_score += ${INJECTION_SEVERITY["ssrf_protocol"]}))
            log_threat 55 "SSRF protocol detected: $protocol"
            injection_findings+=("ssrf_protocol:$protocol")
        fi
    done
    
    # SSRF bypass technique detection
    for bypass in "${SSRF_BYPASS_PATTERNS[@]}"; do
        if echo "$content" | safe_grep_qiE "$bypass" 2>/dev/null; then
            local matched=$(echo "$content" | safe_grep_oiE "$bypass" 2>/dev/null | head -1)
            ((ssrf_bypass_count++))
            
            # Check for cloud metadata endpoints (critical)
            if [[ "$bypass" =~ (169\.254\.169\.254|metadata\.google|100\.100\.100\.200) ]]; then
                cloud_metadata_detected=true
                ((injection_score += ${INJECTION_SEVERITY["ssrf_metadata"]}))
                log_threat 70 "CRITICAL: Cloud metadata endpoint access attempt: $matched"
                injection_findings+=("ssrf_cloud_metadata:$matched")
            else
                ((injection_score += ${INJECTION_SEVERITY["ssrf_bypass"]}))
                log_threat 60 "SSRF bypass technique: $matched"
                injection_findings+=("ssrf_bypass:$matched")
            fi
        fi
    done
    
    # DNS rebinding detection
    if echo "$content" | safe_grep_qiE '\.(xip|nip|sslip)\.io|localtest\.me' 2>/dev/null; then
        log_threat 60 "DNS rebinding service detected (potential SSRF bypass)"
        injection_findings+=("ssrf_dns_rebinding")
        ((injection_score += 50))
    fi
    
    # URL obfuscation detection
    if echo "$content" | safe_grep_qiE '@.*@|%40.*%40|\\\\|%5c%5c' 2>/dev/null; then
        log_threat 55 "URL obfuscation detected (potential SSRF bypass)"
        injection_findings+=("ssrf_url_obfuscation")
        ((injection_score += 45))
    fi
    
    if [ $ssrf_protocol_count -gt 0 ] || [ $ssrf_bypass_count -gt 0 ]; then
        log_info "SSRF Analysis: Protocols=$ssrf_protocol_count, Bypasses=$ssrf_bypass_count, CloudMetadata=$cloud_metadata_detected"
    fi
    
    # ═══════════════════════════════════════════════════════════════════════════
    # EXTENDED ANALYSIS:  LDAP Injection Detection
    # ═══════════════════════════════════════════════════════════════════════════
    
    log_info "Analyzing for LDAP injection patterns..."
    
    # LDAP patterns use fixed string matching since they're literal sequences
    local ldap_fixed_patterns=(
        '*)('
        ')('
        '*)|(x='
        ')(cn='
        ')(uid='
        ')(mail='
        ')(password='
        ')(userPassword='
        '))%00'
    )
    
    for pattern in "${ldap_fixed_patterns[@]}"; do
        if echo "$content" | safe_grep_qiF "$pattern" 2>/dev/null; then
            ((injection_score += ${INJECTION_SEVERITY["ldap_injection"]}))
            log_threat 50 "LDAP injection pattern: $pattern"
            injection_findings+=("ldap_injection:$pattern")
        fi
    done
    
    # LDAP URL injection
    if echo "$content" | safe_grep_qiE 'ldap://[^[:space:]]*\)|ldaps://[^[:space:]]*\)' 2>/dev/null; then
        log_threat 55 "LDAP URL injection pattern detected"
        injection_findings+=("ldap_url_injection")
        ((injection_score += 50))
    fi
    
    # ═══════════════════════════════════════════════════════════════════════════
    # EXTENDED ANALYSIS: XPath Injection Detection
    # ═══════════════════════════════════════════════════════════════════════════
    
    log_info "Analyzing for XPath injection patterns..."
    
    for pattern in "${XPATH_INJECTION_PATTERNS[@]}"; do
        if echo "$content" | safe_grep_qiE "$pattern" 2>/dev/null; then
            local matched=$(echo "$content" | safe_grep_oiE "$pattern" 2>/dev/null | head -1)
            ((injection_score += ${INJECTION_SEVERITY["xpath_injection"]}))
            log_threat 50 "XPath injection pattern: $matched"
            injection_findings+=("xpath_injection:$matched")
        fi
    done
    
    # XPath blind injection (boolean-based)
    if echo "$content" | safe_grep_qiE "'[[:space:]]*(and|or)[[:space:]]+(1|true|false)[[:space:]]*=[[:space:]]*(1|true|false)|substring[[:space:]]*\(.*,[[:space:]]*[0-9]+[[:space:]]*,[[:space:]]*1[[:space:]]*\)[[:space:]]*=" 2>/dev/null; then
        log_threat 55 "Blind XPath injection pattern detected"
        injection_findings+=("xpath_blind_injection")
        ((injection_score += 50))
    fi
    
    # ═══════════════════════════════════════════════════════════════════════════
    # EXTENDED ANALYSIS: Expression Language (EL) Injection
    # ═══════════════════════════════════════════════════════════════════════════
    
    log_info "Analyzing for Expression Language injection patterns..."
    
    local el_critical_count=0
    
    for pattern in "${EL_INJECTION_PATTERNS[@]}"; do
        if echo "$content" | safe_grep_qiE "$pattern" 2>/dev/null; then
            local matched=$(echo "$content" | safe_grep_oiE "$pattern" 2>/dev/null | head -1)
            ((el_critical_count++))
            ((injection_score += ${INJECTION_SEVERITY["el_injection"]}))
            log_threat 65 "Expression Language injection (RCE capable): $matched"
            injection_findings+=("el_injection:$matched")
        fi
    done
    
    # OGNL-specific patterns (Struts vulnerabilities)
    if echo "$content" | safe_grep_qiE '#_memberAccess|@java\.lang\.Runtime|#context\[' 2>/dev/null; then
        log_threat 70 "CRITICAL: OGNL injection detected (CVE-style Struts attack)"
        injection_findings+=("ognl_injection")
        ((injection_score += 70))
    fi
    
    if [ $el_critical_count -gt 0 ]; then
        log_warn "Expression Language injection patterns: $el_critical_count (HIGH SEVERITY)"
    fi
    
    # ═══════════════════════════════════════════════════════════════════════════
    # EXTENDED ANALYSIS:  CRLF / Header Injection
    # ═══════════════════════════════════════════════════════════════════════════
    
    log_info "Analyzing for CRLF/Header injection patterns..."
    
    local crlf_count=0
    
    for pattern in "${CRLF_INJECTION_PATTERNS[@]}"; do
        if echo "$content" | safe_grep_qiE "$pattern" 2>/dev/null; then
            ((crlf_count++))
            ((injection_score += ${INJECTION_SEVERITY["crlf_injection"]}))
            log_threat 45 "CRLF injection pattern detected"
            injection_findings+=("crlf_injection")
        fi
    done
    
    # HTTP response splitting detection
    if echo "$content" | safe_grep_qiE '(%0d%0a|\\r\\n).*(Set-Cookie|Location|Content-Type):' 2>/dev/null; then
        log_threat 60 "HTTP Response Splitting attack pattern detected"
        injection_findings+=("http_response_splitting")
        ((injection_score += 55))
    fi
    
    # Email header injection
    if echo "$content" | safe_grep_qiE '(%0d%0a|\\r\\n).*(Bcc|Cc|To|From|Subject):' 2>/dev/null; then
        log_threat 50 "Email header injection pattern detected"
        injection_findings+=("email_header_injection")
        ((injection_score += 45))
    fi
    
    if [ $crlf_count -gt 0 ]; then
        log_info "CRLF injection patterns found: $crlf_count"
    fi
    
    # ═══════════════════════════════════════════════════════════════════════════
    # EXTENDED ANALYSIS:  NoSQL Injection Detection
    # ═══════════════════════════════════════════════════════════════════════════
    
    log_info "Analyzing for NoSQL injection patterns..."
    
    local nosql_operator_count=0
    local nosql_js_injection=false
    
    for pattern in "${NOSQL_INJECTION_PATTERNS[@]}"; do
        if echo "$content" | safe_grep_qiE "$pattern" 2>/dev/null; then
            local matched=$(echo "$content" | safe_grep_oiE "$pattern" 2>/dev/null | head -1)
            ((nosql_operator_count++))
            
            # Check for JavaScript injection in NoSQL
            if [[ "$matched" =~ (function|mapReduce|sleep|this\.) ]]; then
                nosql_js_injection=true
                ((injection_score += 65))
                log_threat 65 "NoSQL JavaScript injection: $matched"
                injection_findings+=("nosql_js_injection:$matched")
            else
                ((injection_score += ${INJECTION_SEVERITY["nosql_injection"]}))
                log_threat 55 "NoSQL operator injection: $matched"
                injection_findings+=("nosql_injection:$matched")
            fi
        fi
    done
    
    # MongoDB-specific patterns
    if echo "$content" | safe_grep_qiE '\{[[:space:]]*"\$[[:alnum:]_]+"[[:space:]]*:[[:space:]]*\{.*\}\}' 2>/dev/null || echo "$content" | safe_grep_qiE '\[[[:space:]]*\{[[:space:]]*"\$.*\}\]' 2>/dev/null; then
        log_threat 55 "MongoDB injection pattern structure detected"
        injection_findings+=("mongodb_injection")
        ((injection_score += 50))
    fi
    
    # CouchDB injection
    if echo "$content" | safe_grep_qiE '/_all_docs|/_find|startkey=.*endkey=' 2>/dev/null; then
        log_threat 50 "CouchDB injection pattern detected"
        injection_findings+=("couchdb_injection")
        ((injection_score += 45))
    fi
    
    if [ $nosql_operator_count -gt 0 ]; then
        log_info "NoSQL injection patterns: Operators=$nosql_operator_count, JSInjection=$nosql_js_injection"
    fi
    
    # ═══════════════════════════════════════════════════════════════════════════
    # EXTENDED ANALYSIS: GraphQL Injection Detection
    # ═══════════════════════════════════════════════════════════════════════════
    
    log_info "Analyzing for GraphQL injection patterns..."
    
    local graphql_introspection=false
    local graphql_attack_count=0
    
    for pattern in "${GRAPHQL_INJECTION_PATTERNS[@]}"; do
        if echo "$content" | safe_grep_qiE "$pattern" 2>/dev/null; then
            local matched=$(echo "$content" | safe_grep_oiE "$pattern" 2>/dev/null | head -1)
            
            if [[ "$matched" =~ (__schema|__type|__typename|IntrospectionQuery) ]]; then
                graphql_introspection=true
                ((injection_score += ${INJECTION_SEVERITY["graphql_introspection"]}))
                log_threat 35 "GraphQL introspection query: $matched"
                injection_findings+=("graphql_introspection:$matched")
            else
                ((graphql_attack_count++))
                ((injection_score += ${INJECTION_SEVERITY["graphql_injection"]}))
                log_threat 50 "GraphQL injection pattern: $matched"
                injection_findings+=("graphql_injection:$matched")
            fi
        fi
    done
    
    # GraphQL batching attack detection
    if echo "$content" | safe_grep_qiE '\[[[:space:]]*\{[[:space:]]*"query"[[:space:]]*:.*\},[[:space:]]*\{[[:space:]]*"query".*\}' 2>/dev/null; then
        log_threat 45 "GraphQL batching attack pattern detected"
        injection_findings+=("graphql_batching")
        ((injection_score += 40))
    fi
    
    # GraphQL alias-based DoS - simplified check
    local alias_count=$(echo "$content" | safe_grep_coE '[[:alnum:]_]+[[:space:]]*:[[:space:]]*[[:alnum:]_]+[[:space:]]*\(' 2>/dev/null || echo 0)
    if [ "$alias_count" -gt 10 ] 2>/dev/null; then
        log_threat 50 "Potential GraphQL alias-based DoS (excessive aliases)"
        injection_findings+=("graphql_alias_dos")
        ((injection_score += 45))
    fi
    
    if [ "$graphql_introspection" = true ] || [ $graphql_attack_count -gt 0 ]; then
        log_info "GraphQL analysis: Introspection=$graphql_introspection, Attacks=$graphql_attack_count"
    fi
    
    # ═══════════════════════════════════════════════════════════════════════════
    # EXTENDED ANALYSIS: Log Injection / Log4Shell Detection
    # ═══════════════════════════════════════════════════════════════════════════
    
    log_info "Analyzing for Log injection and Log4Shell patterns..."
    
    local log4j_detected=false
    local log_injection_count=0
    
    for pattern in "${LOG_INJECTION_PATTERNS[@]}"; do
        if echo "$content" | safe_grep_qiE "$pattern" 2>/dev/null; then
            local matched=$(echo "$content" | safe_grep_oiE "$pattern" 2>/dev/null | head -1)
            ((log_injection_count++))
            
            if [[ "$matched" =~ jndi ]]; then
                log4j_detected=true
                ((injection_score += ${INJECTION_SEVERITY["log4j_jndi"]}))
                log_threat 75 "CRITICAL: Log4Shell (CVE-2021-44228) pattern: $matched"
                injection_findings+=("log4shell:$matched")
            else
                ((injection_score += ${INJECTION_SEVERITY["log_injection"]}))
                log_threat 70 "Log injection pattern (Log4j lookup): $matched"
                injection_findings+=("log_injection:$matched")
            fi
        fi
    done
    
    # Log4j bypass variations
    if echo "$content" | safe_grep_qiE '\$\{j\$\{.*\}n\$\{.*\}di\}|\$\{\$\{:-j\}\}|\$\{lower:j\}\$\{lower:n\}\$\{lower:d\}\$\{lower:i\}' 2>/dev/null; then
        log_threat 75 "CRITICAL: Log4Shell bypass/obfuscation detected"
        injection_findings+=("log4shell_bypass")
        ((injection_score += 75))
        log4j_detected=true
    fi
    
    # URL-encoded Log4j patterns
    if echo "$content" | safe_grep_qiE '%24%7Bjndi|%24%7Blower|%24%7Benv' 2>/dev/null; then
        log_threat 75 "CRITICAL: URL-encoded Log4Shell pattern detected"
        injection_findings+=("log4shell_urlencoded")
        ((injection_score += 75))
        log4j_detected=true
    fi
    
    if [ "$log4j_detected" = true ]; then
        log_warn "=== LOG4SHELL ATTACK DETECTED - CRITICAL SEVERITY ==="
    fi
    
    # ═══════════════════════════════════════════════════════════════════════════
    # EXTENDED ANALYSIS:  Polyglot Injection Detection
    # ═══════════════════════════════════════════════════════════════════════════
    
    log_info "Analyzing for polyglot injection patterns..."
    
    # Polyglots that work across multiple contexts (SQL + XSS + Template)
    local polyglot_patterns=(
        "'\"><script>"
        "{{constructor.constructor"
        "{{''.__class__.__mro__"
        "'-var x=1-'"
        "\\';alert(1);//"
        "{{7*7}}[[5*5]]"
        "{{config.__class__.__init__.__globals__"
        "<%=7*7%>{{7*7}}\${7*7}"
        "1;sleep(5)#'\" or sleep(5) or \""
    )
    
    local polyglot_count=0
    
    for pattern in "${polyglot_patterns[@]}"; do
        if echo "$content" | safe_grep_qF -e "$pattern" 2>/dev/null; then
            ((polyglot_count++))
            ((injection_score += ${INJECTION_SEVERITY["polyglot"]}))
            log_threat 75 "CRITICAL: Polyglot injection detected: $pattern"
            injection_findings+=("polyglot_injection")
        fi
    done
    
    # Multi-context escape sequences
    if echo "$content" | safe_grep_qE '(\}\}|\]\]|\x27\x27|"").*(\{\{|\[\[|<%|<\?)' 2>/dev/null; then
        log_threat 65 "Multi-context escape sequence detected (potential polyglot)"
        injection_findings+=("multi_context_escape")
        ((injection_score += 55))
    fi
    
    if [ $polyglot_count -gt 0 ]; then
        log_warn "Polyglot injections detected: $polyglot_count (targeting multiple interpreters)"
    fi
    
    # ═══════════════════════════════════════════════════════════════════════════
    # EXTENDED ANALYSIS:  Prototype Pollution (JavaScript)
    # ═══════════════════════════════════════════════════════════════════════════
    
    log_info "Analyzing for Prototype Pollution patterns..."
    
    local proto_pollution_patterns=(
        '__proto__'
        'constructor\.prototype'
        'Object\.prototype'
        '\["__proto__"\]'
        '\["constructor"\]\["prototype"\]'
        'prototype\.constructor'
        '__defineGetter__'
        '__defineSetter__'
        '__lookupGetter__'
        '__lookupSetter__'
    )
    
    for pattern in "${proto_pollution_patterns[@]}"; do
        if echo "$content" | safe_grep_qiE "$pattern" 2>/dev/null; then
            local matched=$(echo "$content" | safe_grep_oiE "$pattern" 2>/dev/null | head -1)
            ((injection_score += 55))
            log_threat 55 "Prototype Pollution pattern: $matched"
            injection_findings+=("prototype_pollution:$matched")
        fi
    done
    
    # ═══════════════════════════════════════════════════════════════════════════
    # EXTENDED ANALYSIS:  Deserialization Injection
    # ═══════════════════════════════════════════════════════════════════════════
    
    log_info "Analyzing for deserialization injection patterns..."
    
    local deserial_patterns=(
        # Java serialized objects
        'rO0ABX'  # Base64 Java serialization magic bytes
        'aced0005'  # Hex Java serialization magic bytes
        'java\.lang\.Runtime'
        'java\.lang\.ProcessBuilder'
        'org\.apache\.commons\.collections'
        'ysoserial'
        'CommonsCollections'
        # PHP object injection
        'O:[0-9]+:"'
        'a:[0-9]+:\{'
        's:[0-9]+:"'
        '__wakeup'
        '__destruct'
        # Python pickle
        'pickle\.loads'
        'cPickle\.loads'
        'cos.system'
        'cposix.system'
        # .NET
        'TypeNameHandling'
        'ObjectDataProvider'
        'System\.Diagnostics\.Process'
        '\$type.*System\.'
        # Ruby
        'Marshal\.load'
        'YAML\.load'
        '!ruby/object'
        '!ruby/hash'
    )
    
    for pattern in "${deserial_patterns[@]}"; do
        if echo "$content" | safe_grep_qiE "$pattern" 2>/dev/null; then
            local matched=$(echo "$content" | safe_grep_oiE "$pattern" 2>/dev/null | head -1)
            ((injection_score += 65))
            log_threat 65 "Deserialization injection pattern: $matched"
            injection_findings+=("deserialization:$matched")
        fi
    done
    
    # ═══════════════════════════════════════════════════════════════════════════
    # EXTENDED ANALYSIS: PDF Injection (Form-based attacks)
    # ═══════════════════════════════════════════════════════════════════════════
    
    log_info "Analyzing for PDF/Formula injection patterns..."
    
    local formula_injection_patterns=(
        '^='
        '^@'
        '^+'
        '^-'
        '^|'
        '=CMD|'
        '=HYPERLINK('
        '=IMPORTXML('
        '=IMPORTDATA('
        '=IMPORTHTML('
        '@SUM('
        '=DDE('
        '|cmd'
        '+cmd'
        '-cmd'
    )
    
    for pattern in "${formula_injection_patterns[@]}"; do
        # Use grep -F for fixed string matching (these are literal patterns, not regex)
        if echo "$content" | safe_grep_qF -e "$pattern" 2>/dev/null; then
            ((injection_score += 45))
            log_threat 45 "Formula/CSV injection pattern detected: $pattern"
            injection_findings+=("formula_injection:$pattern")
            break  # One detection is enough for this category
        fi
    done
    
    # ═══════════════════════════════════════════════════════════════════════════
    # FINAL ANALYSIS SUMMARY AND SCORING
    # ═══════════════════════════════════════════════════════════════════════════
    
    # Calculate final risk assessment
    local total_findings=${#injection_findings[@]}
    local risk_level="LOW"
    local risk_color=""
    
    if [ $injection_score -ge 200 ]; then
        risk_level="CRITICAL"
        risk_color="\033[1;31m"  # Bold Red
    elif [ $injection_score -ge 100 ]; then
        risk_level="HIGH"
        risk_color="\033[0;31m"  # Red
    elif [ $injection_score -ge 50 ]; then
        risk_level="MEDIUM"
        risk_color="\033[0;33m"  # Yellow
    elif [ $injection_score -ge 20 ]; then
        risk_level="LOW"
        risk_color="\033[0;32m"  # Green
    else
        risk_level="MINIMAL"
        risk_color="\033[0;37m"  # Gray
    fi
    
    # Generate detailed report
    echo ""
    echo "╔══════════════════════════════════════════════════════════════════════════════╗"
    echo "║                     INJECTION ATTACK ANALYSIS REPORT                         ║"
    echo "╠══════════════════════════════════════════════════════════════════════════════╣"
    printf "║  Risk Level: %-66s║\n" "$risk_level"
    printf "║  Total Score: %-65s║\n" "$injection_score"
    printf "║  Findings Count: %-62s║\n" "$total_findings"
    echo "╠══════════════════════════════════════════════════════════════════════════════╣"
    
    if [ $total_findings -gt 0 ]; then
        echo "║  DETECTED INJECTION VECTORS:                                                 ║"
        echo "║  ─────────────────────────────────────────────────────────────────────────── ║"
        
        # Categorize findings for report
        local cmd_findings=0
        local ssti_findings=0
        local xxe_findings=0
        local ssrf_findings=0
        local ldap_findings=0
        local xpath_findings=0
        local el_findings=0
        local crlf_findings=0
        local nosql_findings=0
        local graphql_findings=0
        local log_findings=0
        local other_findings=0
        
        for finding in "${injection_findings[@]}"; do
            case "$finding" in
                cmd_injection*) ((cmd_findings++)) ;;
                ssti*|template*) ((ssti_findings++)) ;;
                xxe*|xslt*) ((xxe_findings++)) ;;
                ssrf*) ((ssrf_findings++)) ;;
                ldap*) ((ldap_findings++)) ;;
                xpath*) ((xpath_findings++)) ;;
                el_injection*|ognl*) ((el_findings++)) ;;
                crlf*|http_response*|email_header*) ((crlf_findings++)) ;;
                nosql*|mongodb*|couchdb*) ((nosql_findings++)) ;;
                graphql*) ((graphql_findings++)) ;;
                log*) ((log_findings++)) ;;
                *) ((other_findings++)) ;;
            esac
        done
        
        [ $cmd_findings -gt 0 ] && printf "║    • Command Injection: %-54s║\n" "$cmd_findings occurrence(s)"
        [ $ssti_findings -gt 0 ] && printf "║    • Template Injection (SSTI): %-46s║\n" "$ssti_findings occurrence(s)"
        [ $xxe_findings -gt 0 ] && printf "║    • XXE/XSLT Injection: %-54s║\n" "$xxe_findings occurrence(s)"
        [ $ssrf_findings -gt 0 ] && printf "║    • SSRF Patterns: %-58s║\n" "$ssrf_findings occurrence(s)"
        [ $ldap_findings -gt 0 ] && printf "║    • LDAP Injection: %-58s║\n" "$ldap_findings occurrence(s)"
        [ $xpath_findings -gt 0 ] && printf "║    • XPath Injection: %-56s║\n" "$xpath_findings occurrence(s)"
        [ $el_findings -gt 0 ] && printf "║    • Expression Language Injection: %-41s║\n" "$el_findings occurrence(s)"
        [ $crlf_findings -gt 0 ] && printf "║    • CRLF/Header Injection: %-50s║\n" "$crlf_findings occurrence(s)"
        [ $nosql_findings -gt 0 ] && printf "║    • NoSQL Injection: %-57s║\n" "$nosql_findings occurrence(s)"
        [ $graphql_findings -gt 0 ] && printf "║    • GraphQL Injection: %-54s║\n" "$graphql_findings occurrence(s)"
        [ $log_findings -gt 0 ] && printf "║    • Log Injection/Log4Shell: %-48s║\n" "$log_findings occurrence(s)"
        [ $other_findings -gt 0 ] && printf "║    • Other Patterns: %-57s║\n" "$other_findings occurrence(s)"
    else
        echo "║  No injection patterns detected.                                              ║"
    fi
    
    echo "╚══════════════════════════════════════════════════════════════════════════════╝"
    echo ""
    
    # Call analysis_success_found with complete findings from all analysis phases
    if [ $total_findings -gt 0 ]; then
        local final_injection_summary=$(IFS=', '; echo "${injection_findings[*]}")
        analysis_success_found "INJECTION" "$total_findings" "Score: $injection_score, Risk: $risk_level" "${final_injection_summary}"
    else
        analysis_success_none "INJECTION"
    fi
    
    # Export findings for external processing
    export INJECTION_ANALYSIS_SCORE=$injection_score
    export INJECTION_ANALYSIS_RISK=$risk_level
    export INJECTION_ANALYSIS_COUNT=$total_findings
    
    # Return appropriate exit code based on severity
    if [ "$risk_level" = "CRITICAL" ]; then
        return 4
    elif [ "$risk_level" = "HIGH" ]; then
        return 3
    elif [ "$risk_level" = "MEDIUM" ]; then
        return 2
    elif [ "$risk_level" = "LOW" ]; then
        return 1
    else
        return 0
    fi
}

################################################################################
# HELPER FUNCTIONS FOR INJECTION ANALYSIS
################################################################################

# Decode various encoding schemes for deeper analysis
decode_payload() {
    local payload="$1"
    local decoded=""
    
    # URL decoding
    decoded=$(echo "$payload" | sed 's/%\([0-9A-Fa-f][0-9A-Fa-f]\)/\\x\1/g' | xargs -0 printf "%b" 2>/dev/null || echo "$payload")
    
    # Base64 decoding attempt
    if echo "$payload" | grep -qE '^[A-Za-z0-9+/=]{20,}$'; then
        local b64_decoded=$(echo "$payload" | base64 -d 2>/dev/null)
        if [ -n "$b64_decoded" ]; then
            decoded="$b64_decoded"
        fi
    fi
    
    # HTML entity decoding
    decoded=$(echo "$decoded" | sed 's/&#x\([0-9A-Fa-f]*\);/\\x\1/g' | xargs -0 printf "%b" 2>/dev/null || echo "$decoded")
    decoded=$(echo "$decoded" | sed 's/&#\([0-9]*\);/\&#\1;/g')
    
    echo "$decoded"
}

# Extract and analyze nested payloads
analyze_nested_injection() {
    set +u
    local content="${1:-}"
    set -u
    local depth="${2:-0}"
    local max_depth=3
    
    if [ $depth -ge $max_depth ]; then
        return 0
    fi
    
    # Decode and re-analyze
    local decoded=$(decode_payload "$content")
    
    if [ "$decoded" != "$content" ] && [ -n "$decoded" ]; then
        log_info "Analyzing decoded payload at depth $((depth + 1))..."
        analyze_injection_attacks "$decoded"
    fi
}

# Generate machine-readable output (JSON format)
generate_injection_report_json() {
    local findings_array="$1"
    local score="$2"
    local risk="$3"
    
    echo "{"
    echo "  \"analysis_type\": \"injection_attack\","
    echo "  \"timestamp\": \"$(date -u +%Y-%m-%dT%H:%M:%SZ)\","
    echo "  \"risk_level\": \"$risk\","
    echo "  \"total_score\": $score,"
    echo "  \"findings\": ["
    
    local first=true
    for finding in "${injection_findings[@]}"; do
        if [ "$first" = true ]; then
            first=false
        else
            echo ","
        fi
        local category=$(echo "$finding" | cut -d: -f1)
        local detail=$(echo "$finding" | cut -d: -f2-)
        printf "    {\"category\": \"%s\", \"detail\": \"%s\"}" "$category" "$detail"
    done
    
    echo ""
    echo "  ]"
    echo "}"
}

################################################################################
# CALLBACK/BEACON ANALYSIS
################################################################################

analyze_c2_beacons() {
    set +u
    local content="${1:-}"
    set -u
    
    log_info "Analyzing for C2 beacon patterns..."
    
    local beacon_findings=()
    local beacon_score=0
    
    # Check callback/beacon patterns
    for pattern in "${CALLBACK_BEACON_PATTERNS[@]}"; do
        if echo "$content" | safe_grep_qiE "$pattern"; then
            local matched=$(echo "$content" | safe_grep_oiE "$pattern" 2>/dev/null | head -1)
            beacon_findings+=("beacon:$matched")
            ((beacon_score += 35))
            log_threat 50 "C2/Beacon pattern: $matched"
        fi
    done
    
    # Check for known C2 framework indicators
    if echo "$content" | safe_grep_qiE "cobalt.*strike|meterpreter|empire|covenant|sliver"; then
        log_threat 80 "Known C2 framework indicator detected"
        beacon_findings+=("known_c2_framework")
        ((beacon_score += 60))
    fi
    
    # DNS beaconing indicators
    if echo "$content" | safe_grep_qiE "dns.*tunnel|dnscat|iodine"; then
        log_threat 65 "DNS tunneling/beaconing indicator"
        beacon_findings+=("dns_beacon")
        ((beacon_score += 50))
    fi
    
    # HTTP-based C2 patterns
    if echo "$content" | safe_grep_qiE "/api/beacon|/c2/|/implant/|/stage[0-9]|/payload"; then
        log_threat 55 "HTTP-based C2 endpoint pattern"
        beacon_findings+=("http_c2_endpoint")
        ((beacon_score += 45))
    fi
    
    if [ $beacon_score -ge 35 ]; then
        log_threat $((beacon_score / 2)) "C2/Beacon communication patterns detected"
        analysis_success_found "C2-BEACONS" "${#beacon_findings[@]}" "Score: $beacon_score" "$(IFS=', '; echo "${beacon_findings[*]}")"
    else
        analysis_success_none "C2-BEACONS"
    fi
}

################################################################################
# CRYPTO SCAM ANALYSIS
################################################################################

analyze_crypto_scams() {
    set +u
    local content="${1:-}"
    set -u
    
    log_info "Analyzing for cryptocurrency scam patterns..."
    
    local crypto_scam_score=0
    local crypto_findings=()
    
    for pattern in "${CRYPTO_SCAM_PATTERNS[@]}"; do
        if echo "$content" | safe_grep_qiE "$pattern"; then
            local matched=$(echo "$content" | safe_grep_oiE "$pattern" 2>/dev/null | head -1)
            ((crypto_scam_score += 15))
            crypto_findings+=("pattern:$matched")
            log_warning "Crypto scam pattern: $matched"
        fi
    done
    
    # High-confidence scam combinations
    if echo "$content" | safe_grep_qiE "giveaway|airdrop" && \
       echo "$content" | safe_grep_qiE "elon|vitalik|satoshi|official"; then
        log_threat 70 "Celebrity crypto giveaway scam pattern"
        crypto_findings+=("celebrity_giveaway_scam")
        ((crypto_scam_score += 40))
    fi
    
    if echo "$content" | safe_grep_qiE "send.*receive.*double|2x.*return"; then
        log_threat 80 "Crypto doubling scam detected"
        crypto_findings+=("doubling_scam")
        ((crypto_scam_score += 50))
    fi
    
    if echo "$content" | safe_grep_qiE "connect.*wallet.*approve"; then
        log_threat 60 "Wallet drainer pattern detected"
        crypto_findings+=("wallet_drainer")
        ((crypto_scam_score += 35))
    fi
    
    if [ $crypto_scam_score -ge 30 ]; then
        local crypto_summary=$(IFS=', '; echo "${crypto_findings[*]}")
        log_threat $((crypto_scam_score / 2)) "Cryptocurrency scam indicators detected: ${crypto_summary}"
        analysis_success_found "CRYPTO-SCAMS" "${#crypto_findings[@]}" "Score: $crypto_scam_score" "${crypto_summary}"
    else
        analysis_success_none "CRYPTO-SCAMS"
    fi
}


################################################################################
# ENHANCED QR CONTENT ANALYSIS
################################################################################

analyze_decoded_qr_content() {
    set +u
    local content="${1:-}"
    local report_file="${2:-}"
    set -u
    
    log_info "Analyzing decoded QR content..."
    
    # Display decoded content details
    echo ""
    echo -e "${WHITE}┌─────────────────────────────────────────────────────────────┐${NC}"
    echo -e "${WHITE}│                   DECODED QR CONTENT                        │${NC}"
    echo -e "${WHITE}├─────────────────────────────────────────────────────────────┤${NC}"
    echo -e "${WHITE}│${NC} Length:      ${CYAN}${#content} characters${NC}"
    echo -e "${WHITE}│${NC} Preview:     ${CYAN}${content:0:60}${NC}"
    if [ ${#content} -gt 60 ]; then
        echo -e "${WHITE}│${NC}              ${CYAN}${content:60:60}...${NC}"
    fi
    echo -e "${WHITE}└─────────────────────────────────────────────────────────────┘${NC}"
    echo ""
    
    # Determine content type
    local content_type="unknown"
    
    if echo "$content" | safe_grep_qE "^https?://"; then
        content_type="url"
        log_info "Content type: URL"
        echo -e "  ${CYAN}├─${NC} Protocol: $(echo "$content" | sed -n 's/^\([a-z]*\):.*/\1/p')"
        echo -e "  ${CYAN}└─${NC} Domain: $(echo "$content" | sed -E 's|^https?://||' | cut -d'/' -f1)"
    elif echo "$content" | safe_grep_qE "^mailto:"; then
        content_type="email"
        log_info "Content type: Email link"
        local email_addr=$(echo "$content" | sed 's/^mailto://' | cut -d'?' -f1)
        echo -e "  ${CYAN}└─${NC} Email: $email_addr"
    elif echo "$content" | safe_grep_qE "^tel:|^sms:"; then
        content_type="phone"
        log_info "Content type: Phone/SMS link"
        local phone_num=$(echo "$content" | sed 's/^tel:\|^sms://' | cut -d'?' -f1)
        echo -e "  ${CYAN}└─${NC} Number: $phone_num"
    elif echo "$content" | safe_grep_qE "^WIFI:"; then
        content_type="wifi"
        log_info "Content type: WiFi configuration"
        local wifi_ssid=$(echo "$content" | sed -n 's/.*S:\([^;]*\).*/\1/p')
        echo -e "  ${CYAN}└─${NC} SSID: $wifi_ssid"
    elif echo "$content" | safe_grep_qE "^BEGIN:VCARD"; then
        content_type="vcard"
        log_info "Content type: vCard contact"
    elif echo "$content" | safe_grep_qE "^BEGIN:VEVENT"; then
        content_type="vevent"
        log_info "Content type: Calendar event"
    elif echo "$content" | safe_grep_qE "^otpauth://"; then
        content_type="otp"
        log_info "Content type: OTP/2FA code"
        log_threat 30 "⚠️  2FA/OTP configuration exposed!"
    elif echo "$content" | safe_grep_qE "^bitcoin:|^ethereum:|^litecoin:"; then
        content_type="crypto_payment"
        log_info "Content type: Cryptocurrency payment"
    elif echo "$content" | safe_grep_qE "^(bc1|1|3)[a-zA-Z0-9]{25,}$|^0x[a-fA-F0-9]{40}$"; then
        content_type="crypto_address"
        log_info "Content type: Cryptocurrency address"
    else
        content_type="text"
        log_info "Content type: Plain text/other"
    fi
    echo ""
    
    echo "Content Type: $content_type" >> "$report_file"
    
    # Extract and display any IP addresses in the content
    extract_and_display_ips "$content" "QR content"
    
    # Type-specific analysis
    case "$content_type" in
        "url")
            analyze_url_structure "$content"
            
            # Extract and record domain IOC
            local domain=$(echo "$content" | sed -E 's|^https?://||' | cut -d'/' -f1 | cut -d':' -f1)
            record_ioc "domain" "$domain" "Extracted from QR URL"
            
            # Check against threat intel
            check_against_threat_intel "$content" "url"
            check_against_threat_intel "$domain" "domain"
            
            # Check VirusTotal
            if [ "$VT_CHECK" = true ]; then
                check_virustotal "$content" "url"
                check_virustotal "$domain" "domain"
            fi
            
            # NEW: Add API-based threat intelligence checks
            if [ "$NETWORK_CHECK" = true ]; then
                check_crowdstrike "$content"
                check_recorded_future "$content"
                check_threatfox "$content"
                check_malwarebazaar "$content"
                check_riskiq "$content"
                check_hybrid_analysis "$content"
                check_anyrun "$content"
                check_joesandbox "$content"
                check_triage "$content"
                check_cisa_kev "$content"
            fi
            
            # Extract and analyze IP if present
            if [[ "$domain" =~ ^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
                record_ioc "ip" "$domain" "IP from QR URL"
                check_against_threat_intel "$domain" "ip"
                if [ "$VT_CHECK" = true ]; then
                    check_virustotal "$domain" "ip"
                fi
                check_abuseipdb "$domain"
            fi
            ;;
        "email")
            local email_addr=$(echo "$content" | sed 's/mailto://' | cut -d'?' -f1)
            record_ioc "email" "$email_addr" "Email from QR"
            analyze_email_addresses "$email_addr"
            ;;
        "phone")
            local phone_num=$(echo "$content" | sed -E 's/^(tel:|sms:)//' | cut -d'?' -f1)
            record_ioc "phone" "$phone_num" "Phone from QR"
            analyze_phone_numbers "$phone_num"
            ;;
        "wifi")
            analyze_wifi_config "$content"
            ;;
        "vcard")
            analyze_vcard "$content"
            ;;
        "otp")
            log_threat 30 "OTP/2FA URI detected - potential credential capture"
            analyze_otp_uri "$content"
            ;;
        "crypto_payment"|"crypto_address")
            log_threat 40 "Cryptocurrency content detected"
            analyze_crypto_addresses "$content"
            ;;
        "text")
            # General payload analysis
            analyze_payload_content "$content"
            ;;
    esac
    
    # Always perform behavioral and APT analysis
    perform_behavioral_analysis "$content"
    analyze_apt_indicators "$content"
    
    # ===========================================================================
    # EXTENDED ANALYSIS MODULES
    # ===========================================================================
    
    # Cloud Service Abuse Detection
    if [ "$CLOUD_ABUSE_CHECK" = true ]; then
        analyze_cloud_service_abuse "$content"
    fi
    
    # === AUDIT ADDITIONS: Messaging Platform & URL Shortener Analysis ===
    # Messaging Platform Abuse Detection
    analyze_messaging_platform_abuse "$content"
    
    # Extended URL Shortener Analysis
    analyze_url_shortener_extended "$content"
    
    # Offensive Security Tools Detection
    analyze_offensive_tools "$content"
    
    # Legitimate Service Abuse Detection
    analyze_service_abuse "$content"
    
    # Mobile Deep Link Analysis
    if [ "$MOBILE_DEEPLINK_CHECK" = true ]; then
        analyze_mobile_deeplinks "$content"
    fi
    
    # Wireless Attack Detection (Bluetooth/NFC/WiFi)
    if [ "$BLUETOOTH_NFC_CHECK" = true ]; then
        analyze_wireless_attacks "$content"
    fi
    
    # Telephony Attack Detection
    analyze_telephony_attacks "$content"
    
    # Hardware Exploit Detection
    if [ "$HARDWARE_EXPLOIT_CHECK" = true ]; then
        analyze_hardware_exploits "$content"
    fi
    
    # Geofencing/Cloaking Detection
    if [ "$GEOFENCING_CHECK" = true ]; then
        analyze_geofencing_cloaking "$content"
    fi
    
    # Fileless Malware Detection
    if [ "$FILELESS_MALWARE_CHECK" = true ]; then
        analyze_fileless_malware "$content"
    fi
    
    # NEW: Emerging Attack Techniques Detection (11 functions)
    detect_qrljacking "$content"
    detect_quishing_kits "$content"
    detect_qr_overlay_malware "$content"
    detect_qr_replacement "$content"
    detect_invisible_qr "$content"
    detect_animated_qr "$content"
    detect_multi_qr_chaining "$content"
    detect_conditional_content "$content"
    detect_browser_in_browser "$content"
    detect_reverse_proxy_phish "$content"
    detect_adversary_in_middle "$content"
    
    # NEW: Living-off-the-Land Binaries Detection (5 functions)
    detect_lolbin_windows "$content"
    detect_lolbin_linux "$content"
    detect_lolbin_macos "$content"
    detect_lolbas_scripts "$content"
    detect_living_off_cloud "$content"
    
    # NEW: Coverage Enhancements (4 functions)
    analyze_dns_over_https "$content"
    detect_developer_platform_abuse "$content"
    
    # Ransomware Note Detection
    if [ "$RANSOMWARE_NOTE_CHECK" = true ]; then
        analyze_ransomware_notes "$content"
    fi
    
    # TOR/VPN/Anonymization Detection
    if [ "$TOR_VPN_CHECK" = true ]; then
        analyze_tor_vpn "$content"
    fi
    
    # Social Engineering Analysis
    if [ "$PERSONA_LINKING" = true ]; then
        analyze_social_engineering "$content"
    fi
    
    # ASN Infrastructure Analysis
    if [ "$ASN_ANALYSIS" = true ]; then
        analyze_asn_infrastructure "$content"
    fi
    
    # URL Obfuscation Detection
    if [ "$URL_OBFUSCATION_CHECK" = true ]; then
        analyze_url_obfuscation "$content"
    fi
    
    # Injection Attack Detection
    if [ "$INJECTION_ATTACK_CHECK" = true ]; then
        analyze_injection_attacks "$content"
    fi
    
    # C2 Beacon Detection
    if [ "$C2_BEACON_CHECK" = true ]; then
        analyze_c2_beacons "$content"
    fi
    
    # Cryptocurrency Scam Detection
    if [ "$CRYPTO_SCAM_CHECK" = true ]; then
        analyze_crypto_scams "$content"
    fi
    
    # Industry-Specific Threat Detection
    if [ "$INDUSTRY_THREAT_CHECK" = true ]; then
        analyze_industry_threats "$content"
    fi
    
    # Zero-Day/Anomaly Detection
    if [ "$ZERO_DAY_DETECTION" = true ]; then
        analyze_zero_day_anomalies "$content"
    fi
    
    # ML Heuristics Classification
    if [ "$ML_CLASSIFICATION" = true ]; then
        analyze_ml_heuristics "$content"
    fi
    
    # =========================================================================
    # AUDIT-ENHANCED ANALYSIS (22 NEW MODULES)
    # =========================================================================
    # Run all 22 audit-recommended analysis modules
    if [ "$AUDIT_ENHANCED_ANALYSIS" != false ]; then
        local extracted_url=$(echo "$content" | safe_grep_oiE 'https?://[^[:space:]]+' | head -1)
        run_all_audit_enhancements "$content" "$extracted_url" "$INPUT_IMAGE" ""
    fi
    
    # Run Advanced Detection Engines v4.4.0 (13 new engines)
    run_advanced_detection_engines "$INPUT_IMAGE" "$content" "$extracted_url"
    
    echo "" >> "$report_file"
}

analyze_wifi_config() {
    set +u
    local content="${1:-}"
    set -u
    
    log_info "Analyzing WiFi configuration..."
    
    # Parse WIFI: format (POSIX compatible)
    # WIFI:T:WPA;S:NetworkName;P:Password;;
    
    local auth_type=$(echo "$content" | sed -n 's/.*T:\([^;]*\).*/\1/p')
    local ssid=$(echo "$content" | sed -n 's/.*S:\([^;]*\).*/\1/p')
    local password=$(echo "$content" | sed -n 's/.*P:\([^;]*\).*/\1/p')
    local hidden=$(echo "$content" | sed -n 's/.*H:\([^;]*\).*/\1/p')
    
    log_forensic "WiFi SSID: $ssid"
    log_forensic "Auth Type: $auth_type"
    
    if [ -n "$password" ]; then
        log_warning "WiFi password exposed in QR code"
        log_threat 25 "Credential exposure (WiFi password)"
        record_ioc "wifi_password" "SSID:$ssid" "WiFi credentials in QR"
    fi
    
    # Check for suspicious SSIDs
    if echo "$ssid" | grep -qiE "free|guest|public|open|hack|evil|rogue"; then
        log_threat 30 "Suspicious WiFi SSID: $ssid"
    fi
    
    # Open networks
    if [ "$auth_type" = "nopass" ] || [ -z "$auth_type" ]; then
        log_warning "Open WiFi network (no encryption)"
        log_threat 20 "Unsecured WiFi network"
    fi
    
    # WEP is insecure
    if [ "$auth_type" = "WEP" ]; then
        log_warning "WEP encryption (insecure)"
        log_threat 15 "Weak WiFi encryption"
    fi
}

analyze_vcard() {
    set +u
    local content="${1:-}"
    set -u
    
    log_info "Analyzing vCard content..."
    
    # Extract fields (POSIX compatible)
    local name=$(echo "$content" | safe_grep_iE "^FN:" | cut -d: -f2- | head -1)
    local email=$(echo "$content" | safe_grep_iE "^EMAIL" | cut -d: -f2- | head -1)
    local phone=$(echo "$content" | safe_grep_iE "^TEL" | cut -d: -f2- | head -1)
    local url=$(echo "$content" | safe_grep_iE "^URL" | cut -d: -f2- | head -1)
    
    [ -n "$name" ] && log_forensic "vCard Name: $name"
    [ -n "$email" ] && log_forensic "vCard Email: $email"
    [ -n "$phone" ] && log_forensic "vCard Phone: $phone"
    [ -n "$url" ] && log_forensic "vCard URL: $url"
    
    # Analyze any URLs in vCard
    if [ -n "$url" ]; then
        analyze_url_structure "$url"
    fi
    
    # Analyze emails
    if [ -n "$email" ]; then
        analyze_email_addresses "$email"
    fi
}

analyze_otp_uri() {
    set +u
    local content="${1:-}"
    set -u
    
    log_info "Analyzing OTP URI..."
    
    # Parse otpauth://totp/ISSUER:ACCOUNT?secret=SECRET&issuer=ISSUER (POSIX compatible)
    local otp_type=$(echo "$content" | sed -n 's|otpauth://\([^/]*\)/.*|\1|p')
    local label=$(echo "$content" | sed -n 's|otpauth://[^/]*/\([^?]*\).*|\1|p')
    local secret=$(echo "$content" | sed -n 's/.*secret=\([^&]*\).*/\1/p')
    local issuer=$(echo "$content" | sed -n 's/.*issuer=\([^&]*\).*/\1/p')
    
    log_forensic "OTP Type: $otp_type"
    log_forensic "OTP Label: $label"
    log_forensic "OTP Issuer: $issuer"
    
    if [ -n "$secret" ]; then
        log_threat 50 "2FA secret exposed in QR code!"
        record_ioc "otp_secret" "Issuer:$issuer,Label:$label" "2FA secret exposure"
    fi
}

################################################################################
# REPORT GENERATION
################################################################################

generate_comprehensive_report() {
    log_info "Generating comprehensive analysis report..."
    
    # Final threat score assessment
    local risk_level="MINIMAL"
    if [ $THREAT_SCORE -ge $CRITICAL_THRESHOLD ]; then
        risk_level="CRITICAL"
    elif [ $THREAT_SCORE -ge $HIGH_THRESHOLD ]; then
        risk_level="HIGH"
    elif [ $THREAT_SCORE -ge $MEDIUM_THRESHOLD ]; then
        risk_level="MEDIUM"
    elif [ $THREAT_SCORE -ge $LOW_THRESHOLD ]; then
        risk_level="LOW"
    fi
    
    {
        echo ""
        echo "╔══════════════════════════════════════════════════════════════╗"
        echo "║           FINAL ANALYSIS SUMMARY                              ║"
        echo "╚══════════════════════════════════════════════════════════════╝"
        echo ""
        echo "Scan Completed: $(date)"
        echo "Scanner Version: $VERSION"
        echo ""
        echo "THREAT ASSESSMENT:"
        echo "─────────────────────"
        echo "  Total Threat Score: $THREAT_SCORE / $MAX_THREAT_SCORE"
        echo "  Risk Level: $risk_level"
        echo ""
        
        # Risk level visualization
        local bar_length=$((THREAT_SCORE * 50 / MAX_THREAT_SCORE))
        printf "  Risk Meter: ["
        for ((i=0; i<50; i++)); do
            if [ $i -lt $bar_length ]; then
                if [ $i -lt 15 ]; then
                    printf "="
                elif [ $i -lt 30 ]; then
                    printf "▓"
                else
                    printf "█"
                fi
            else
                printf "░"
            fi
        done
        printf "]\n"
        echo "               0%          50%         100%"
        echo ""
        
        echo "SCAN STATISTICS:"
        echo "─────────────────────"
        echo "  Images Analyzed: $(find "$EVIDENCE_DIR" -name "*_report.txt" 2>/dev/null | wc -l | tr -d ' ')"
        echo "  Evidence Files: $(find "$EVIDENCE_DIR" -type f 2>/dev/null | wc -l | tr -d ' ')"
        echo "  IOCs Detected: $(wc -l < "$IOC_REPORT" 2>/dev/null | tr -d ' ' || echo "0")"
        echo "  YARA Matches: $(wc -l < "$YARA_MATCHES" 2>/dev/null | tr -d ' ' || echo "0")"
        echo ""
        
        echo "OUTPUT FILES:"
        echo "─────────────────────"
        echo "  Main Report: $REPORT_FILE"
        echo "  JSON Report: $JSON_REPORT"
        echo "  IOC Report: $IOC_REPORT"
        echo "  Timeline: $TIMELINE_FILE"
        echo "  Evidence: $EVIDENCE_DIR"
        echo "  Log File: $LOG_FILE"
        
        if [ -s "$APT_REPORT" ]; then
            echo "  APT Report: $APT_REPORT"
        fi
        if [ -s "$STEGANOGRAPHY_REPORT" ]; then
            echo "  Stego Report: $STEGANOGRAPHY_REPORT"
        fi
        if [ -s "$BEHAVIORAL_REPORT" ]; then
            echo "  Behavioral: $BEHAVIORAL_REPORT"
        fi
        
        echo ""
        echo "RECOMMENDATIONS:"
        echo "─────────────────────"
        
        if [ "$risk_level" = "CRITICAL" ]; then
            echo "  ⚠️  CRITICAL THREAT DETECTED!"
            echo "  → Do NOT scan this QR code with a mobile device"
            echo "  → Isolate the source of this QR code"
            echo "  → Report to security team immediately"
            echo "  → Preserve evidence for forensic analysis"
        elif [ "$risk_level" = "HIGH" ]; then
            echo "  ⚠️  HIGH RISK CONTENT DETECTED"
            echo "  → Exercise extreme caution"
            echo "  → Do not open URLs without sandboxed analysis"
            echo "  → Consider blocking identified domains/IPs"
            echo "  → Review IOC report for threat indicators"
        elif [ "$risk_level" = "MEDIUM" ]; then
            echo "  ⚡ MEDIUM RISK - Proceed with caution"
            echo "  → Verify the source of this QR code"
            echo "  → Check URLs in a sandbox environment first"
            echo "  → Monitor for unusual behavior if scanned"
        elif [ "$risk_level" = "LOW" ]; then
            echo "  ℹ️  LOW RISK - Minor concerns detected"
            echo "  → Review identified issues before proceeding"
            echo "  → Standard security precautions apply"
        else
            echo "  ✓ MINIMAL RISK - No significant threats detected"
            echo "  → Standard security precautions apply"
            echo "  → Content appears safe for analysis"
        fi
        
        echo ""
        echo "═══════════════════════════════════════════════════════════════"
    } >> "$REPORT_FILE"
}

generate_json_report() {
    log_info "Generating JSON report..."
    
    local risk_level="MINIMAL"
    if [ $THREAT_SCORE -ge $CRITICAL_THRESHOLD ]; then
        risk_level="CRITICAL"
    elif [ $THREAT_SCORE -ge $HIGH_THRESHOLD ]; then
        risk_level="HIGH"
    elif [ $THREAT_SCORE -ge $MEDIUM_THRESHOLD ]; then
        risk_level="MEDIUM"
    elif [ $THREAT_SCORE -ge $LOW_THRESHOLD ]; then
        risk_level="LOW"
    fi
    
    # Collect IOCs as JSON array
    local iocs_json="[]"
    if [ -s "$IOC_REPORT" ]; then
        iocs_json=$(awk -F, 'NR>1 {printf "{\"type\":\"%s\",\"indicator\":\"%s\",\"timestamp\":\"%s\",\"context\":\"%s\"},", $1, $2, $3, $4}' "$IOC_REPORT" | sed 's/,$//' | sed 's/^/[/' | sed 's/$/]/')
    fi
    
    cat > "$JSON_REPORT" << EOF
{
  "scan_metadata": {
    "timestamp": "$(date -Iseconds)",
    "scanner_version": "$VERSION",
    "output_directory": "$OUTPUT_DIR",
    "analysis_duration_seconds": $SECONDS
  },
  "threat_assessment": {
    "threat_score": $THREAT_SCORE,
    "max_score": $MAX_THREAT_SCORE,
    "risk_level": "$risk_level",
    "thresholds": {
      "critical": $CRITICAL_THRESHOLD,
      "high": $HIGH_THRESHOLD,
      "medium": $MEDIUM_THRESHOLD,
      "low": $LOW_THRESHOLD
    }
  },
  "statistics": {
    "images_analyzed": $(find "$EVIDENCE_DIR" -name "*_report.txt" 2>/dev/null | wc -l | tr -d ' '),
    "evidence_files": $(find "$EVIDENCE_DIR" -type f 2>/dev/null | wc -l | tr -d ' '),
    "iocs_detected": $(wc -l < "$IOC_REPORT" 2>/dev/null | tr -d ' ' || echo "0"),
    "yara_matches": $(wc -l < "$YARA_MATCHES" 2>/dev/null | tr -d ' ' || echo "0")
  },
  "iocs": $iocs_json,
  "output_files": {
    "main_report": "$REPORT_FILE",
    "ioc_report": "$IOC_REPORT",
    "timeline": "$TIMELINE_FILE",
    "evidence_dir": "$EVIDENCE_DIR",
    "log_file": "$LOG_FILE"
  }
}
EOF
    
    log_success "JSON report generated: $JSON_REPORT"
}

generate_stix_report() {
    log_info "Generating STIX 2.1 report..."
    
    local bundle_id="bundle--$(uuidgen 2>/dev/null || cat /proc/sys/kernel/random/uuid 2>/dev/null || echo "$(date +%s)-$$")"
    
    cat > "$STIX_REPORT" << EOF
{
  "type": "bundle",
  "id": "$bundle_id",
  "objects": [
    {
      "type": "identity",
      "id": "identity--qr-malware-detector",
      "name": "QR Malware Detection System",
      "identity_class": "system",
      "created": "$(date -Iseconds)"
    },
    {
      "type": "report",
      "id": "report--$(date +%s)",
      "name": "QR Code Malware Analysis Report",
      "published": "$(date -Iseconds)",
      "object_refs": []
    }
  ]
}
EOF
    
    log_success "STIX report generated: $STIX_REPORT"
}

generate_forensic_timeline() {
    log_forensic "Generating forensic timeline..."
    
    {
        echo "╔════════════════════════════════════════════════════════════╗"
        echo "║              FORENSIC TIMELINE ANALYSIS                    ║"
        echo "╚════════════════════════════════════════════════════════════╝"
        echo ""
        echo "Timeline of Events:"
        echo ""
        
        if [ -f "$TIMELINE_FILE" ]; then
            awk -F, '{
                if (NR > 1) {
                    printf "  [%s] %s: %s\n", $1, $2, $3
                }
            }' "$TIMELINE_FILE" | tail -100
        fi
        
        echo ""
    } >> "$CORRELATION_FILE"
}

################################################################################
# INITIALIZATION AND SETUP

################################################################################
# INITIALIZATION
################################################################################


parse_arguments() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                show_help
                exit 0
                ;;
            -v|--verbose)
                VERBOSE=true
                shift
                ;;
            -d|--deep)
                DEEP_ANALYSIS=true
                shift
                ;;
            -f|--forensic)
                FORENSIC_MODE=true
                shift
                ;;
            -s|--stealth)
                STEALTH_MODE=true
                NETWORK_CHECK=false
                shift
                ;;
            --vt)
                VT_CHECK=true
                shift
                ;;
            --no-network)
                NETWORK_CHECK=false
                shift
                ;;
            --siem)
                SIEM_INTEGRATION=true
                shift
                ;;
            --no-cloud)
                CLOUD_ABUSE_CHECK=false
                shift
                ;;
            --no-mobile)
                MOBILE_DEEPLINK_CHECK=false
                shift
                ;;
            --no-ml)
                ML_CLASSIFICATION=false
                shift
                ;;
            --no-apt)
                APT_ATTRIBUTION=false
                shift
                ;;
            --no-behavioral)
                BEHAVIORAL_ANALYSIS=false
                shift
                ;;
            --no-stego)
                STEGANOGRAPHY_CHECK=false
                shift
                ;;
            --no-entropy)
                ENTROPY_ANALYSIS=false
                shift
                ;;
            # AUDIT: Privacy/security flags - no extra flags needed by default
            --no-consent|--no-external)
                # Disable all external API calls
                NO_EXTERNAL_APIS=true
                USER_CONSENT_GIVEN=false
                VT_CHECK=false
                shift
                ;;
            --prompt-consent)
                # Require explicit consent prompts
                REQUIRE_CONSENT_PROMPT=true
                USER_CONSENT_GIVEN=false
                shift
                ;;
            --offline)
                # Offline mode - no network calls at all
                OFFLINE_MODE=true
                NETWORK_CHECK=false
                NO_EXTERNAL_APIS=true
                shift
                ;;
            --dry-run)
                # Dry run - analyze but don't upload anything
                DRY_RUN_MODE=true
                NO_EXTERNAL_APIS=true
                shift
                ;;
            --privacy-scrub)
                # Enhanced PII scrubbing in outputs
                PRIVACY_SCRUB_MODE=true
                shift
                ;;
            --verify-hash)
                # Verify script integrity and exit
                echo "Script: ${BASH_SOURCE[0]}"
                echo "SHA256: $SCRIPT_HASH"
                exit 0
                ;;
            --interactive)
                INTERACTIVE_MODE=true
                shift
                ;;
            --ioc-file)
                # AUDIT: Allow user to specify additional IOC file
                shift
                if [[ -n "${1:-}" ]] && [[ -r "$1" ]]; then
                    ADDITIONAL_IOC_FILES+=("$1")
                else
                    echo "[WARNING] IOC file not readable: ${1:-}" >&2
                fi
                shift
                ;;
            --all-modules)
                CLOUD_ABUSE_CHECK=true
                MOBILE_DEEPLINK_CHECK=true
                GEOFENCING_CHECK=true
                BLUETOOTH_NFC_CHECK=true
                HARDWARE_EXPLOIT_CHECK=true
                FILELESS_MALWARE_CHECK=true
                ADVERSARIAL_QR_CHECK=true
                ZERO_DAY_DETECTION=true
                ML_CLASSIFICATION=true
                PERSONA_LINKING=true
                RANSOMWARE_NOTE_CHECK=true
                TOR_VPN_CHECK=true
                ASN_ANALYSIS=true
                URL_OBFUSCATION_CHECK=true
                INJECTION_ATTACK_CHECK=true
                C2_BEACON_CHECK=true
                CRYPTO_SCAM_CHECK=true
                INDUSTRY_THREAT_CHECK=true
                SIEM_INTEGRATION=true
                shift
                ;;
            -*)
                echo "[ERROR] Unknown option: $1" >&2
                show_help
                exit 1
                ;;
            *)
                # AUDIT: Validate and sanitize target path
                TARGET_PATH=$(sanitize_path "$1") || {
                    echo "[ERROR] Invalid path: $1" >&2
                    exit 1
                }
                shift
                ;;
        esac
    done
}

show_help() {
    echo "QR Code Malware Scanner - Ultimate Forensic Edition v${VERSION}"
    echo ""
    echo "Usage: $(basename "$0") [OPTIONS] <image_or_directory>"
    echo ""
    echo "Basic Options:"
    echo "  -h, --help           Show this help message"
    echo "  -v, --verbose        Enable verbose output"
    echo "  -d, --deep           Enable deep analysis mode"
    echo "  -f, --forensic       Enable full forensic mode"
    echo "  -s, --stealth        Stealth mode (no network calls)"
    echo "  --vt                 Enable VirusTotal checks"
    echo "  --no-network         Disable all network checks"
    echo "  --siem               Enable SIEM export (JSON format)"
    echo "  --all-modules        Enable all detection modules"
    echo ""
    echo "Privacy & Security Options:"
    echo "  --no-consent         Disable all external API calls"
    echo "  --prompt-consent     Require explicit consent prompts for APIs"
    echo "  --offline            Offline mode (no network calls at all)"
    echo "  --dry-run            Analyze but don't upload to external APIs"
    echo "  --privacy-scrub      Enhanced PII scrubbing in all outputs"
    echo "  --verify-hash        Display script hash and exit (integrity check)"
    echo "  --interactive        Interactive mode"
    echo "  --ioc-file <path>    Add custom IOC file for checking"
    echo ""
    echo "Module Controls:"
    echo "  --no-cloud           Disable cloud abuse detection"
    echo "  --no-mobile          Disable mobile deeplink detection"
    echo "  --no-ml              Disable ML classification"
    echo "  --no-apt             Disable APT attribution"
    echo "  --no-behavioral      Disable behavioral analysis"
    echo "  --no-stego           Disable steganography detection"
    echo "  --no-entropy         Disable entropy analysis"
    echo ""
    echo "Decoders (16 total - automatic):"
    echo "  zbar, pyzbar, pyzbar_enhanced, quirc, zxing, qrdecode,"
    echo "  opencv, opencv_wechat, boofcv, dmtx, segno, multiscale,"
    echo "  perspective, inverse, adaptive, channels"
    echo ""
    echo "Detection Modules:"
    echo "  - Cloud Service Abuse (Google Drive, S3, Discord CDN, etc.)"
    echo "  - Mobile Deep Links (iOS/Android app schemes)"
    echo "  - Wireless Attacks (Bluetooth/NFC/WiFi)"
    echo "  - Telephony Attacks (USSD, premium numbers)"
    echo "  - Hardware Exploits (IoT, POS terminals)"
    echo "  - Fileless Malware (LOLBAS, PowerShell)"
    echo "  - Ransomware Notes (40+ families)"
    echo "  - TOR/VPN Anonymization"
    echo "  - Social Engineering Patterns"
    echo "  - ASN Infrastructure Analysis"
    echo "  - URL Obfuscation Detection"
    echo "  - Injection Attacks (SQLi, SSTI, XXE)"
    echo "  - C2 Beacon Detection"
    echo "  - Cryptocurrency Scam Detection"
    echo "  - Zero-Day/Anomaly Detection"
    echo "  - ML Heuristics Classification"
    echo ""
    echo "Audit Enhancement Modules (35 TOTAL - 22+13 MERGED):"
    echo "  [1]  Sandbox/Detonation Analysis (urlscan.io, local Docker)"
    echo "  [2]  JavaScript/Browser Exploit Detection (XSS, DOM, exploits)"
    echo "  [3]  Enhanced ML/AI Classification (statistical features)"
    echo "  [4]  PDF/Document Payload Analysis (macros, exploits)"
    echo "  [5]  NLP/Language Analysis (scam patterns, sentiment)"
    echo "  [6]  Mobile Malware Static Analysis (APK/IPA)"
    echo "  [7]  Web Archive Analysis (Wayback Machine, archive.today)"
    echo "  [8]  Recursive Content Extraction (crawl linked content)"
    echo "  [9]  Adversarial AI Attack Detection (perturbation, patches)"
    echo "  [10] Covert Channel Detection (DNS tunneling, stego)"
    echo "  [11] Cross-QR Chaining Detection (segmented payloads)"
    echo "  [12] Template Spoofing Detection (COVID pass, shipping)"
    echo "  [13] Social Media/Marketing Link Analysis (linktree, tracking)"
    echo "  [14] UX Redress/Browser Attack Detection (clickjacking, tabnab)"
    echo "  [15] DGA Domain Analysis (entropy, bigrams, patterns)"
    echo "  [16] Unicode/Multi-language Deception (homoglyphs, RTL)"
    echo "  [17] Social Threat Tracking (URLhaus, DNSBLs)"
    echo "  [18] Blockchain/Smart Contract Scam Analysis (drainers)"
    echo "  [19] Contact Event Analysis (vCard/iCal BEC)"
    echo "  [20] Geographic Hotspot Detection (country/ASN risk)"
    echo "  [21] Emerging Protocol Detection (WebRTC, BLE, payments)"
    echo "  [22] Human Reviewer Feedback Loop (chain of custody)"
    echo "  [23-35] Additional IOC Pattern Databases (merged analyzers)"
    echo ""
    echo "Security Features (AUDIT COMPLIANT):"
    echo "  - Input validation and sanitization"
    echo "  - Secure temp file handling (mktemp)"
    echo "  - PII masking in logs and reports"
    echo "  - Chain of custody tracking"
    echo "  - Script integrity verification"
    echo "  - Automatic consent for external APIs (use --no-consent to disable)"
    echo "  - Secure cleanup on exit"
    echo ""
    echo "Examples:"
    echo "  $(basename "$0") suspicious_qr.png"
    echo "  $(basename "$0") -d --vt /path/to/qr_images/"
    echo "  $(basename "$0") -f --siem --all-modules qr_code.jpg"
    echo "  $(basename "$0") --offline --ioc-file custom.txt qr.png"
    echo "  $(basename "$0") --no-consent qr.png    # Disable external APIs"
    echo "  $(basename "$0") --verify-hash"
    echo ""
    echo "Environment Variables (API Keys for Threat Intelligence):"
    echo "  Core APIs:"
    echo "    VT_API_KEY              - VirusTotal API key"
    echo "    PHISHTANK_API_KEY       - PhishTank API key"
    echo "    ABUSEIPDB_API_KEY       - AbuseIPDB API key"
    echo "    OTX_API_KEY             - AlienVault OTX API key"
    echo "    URLSCAN_API_KEY         - URLScan.io API key"
    echo ""
    echo "  Advanced Threat Intelligence APIs (20 new feeds):"
    echo "    CROWDSTRIKE_API_KEY     - CrowdStrike Falcon X"
    echo "    RECORDED_FUTURE_API_KEY - Recorded Future"
    echo "    RISKIQ_API_KEY          - RiskIQ/PassiveTotal (requires _SECRET too)"
    echo "    RISKIQ_API_SECRET       - RiskIQ/PassiveTotal secret"
    echo "    HYBRID_ANALYSIS_KEY     - Hybrid Analysis sandbox"
    echo "    ANYRUN_API_KEY          - ANY.RUN sandbox"
    echo "    JOESANDBOX_API_KEY      - Joe Sandbox Cloud"
    echo "    TRIAGE_API_KEY          - Triage sandbox"
    echo "    MALPEDIA_API_KEY        - Malpedia malware families"
    echo ""
    echo "  Note: Most feeds work without API keys. API keys enable enhanced checks."
}



################################################################################
################################################################################
##                                                                            ##
##          AUDIT ENHANCEMENT MODULES - 22 NEW ANALYSIS CAPABILITIES          ##
##                                                                            ##
##  Implementation of all audit suggestions for comprehensive QR analysis     ##
##                                                                            ##
################################################################################
################################################################################

# ============================================================================
# AUDIT ENHANCEMENT FLAGS AND CONFIGURATION
# ============================================================================

# Module Enable Flags
SANDBOX_DETONATION=${SANDBOX_DETONATION:-true}
JS_BROWSER_ANALYSIS=${JS_BROWSER_ANALYSIS:-true}
ML_CLASSIFICATION_ENHANCED=${ML_CLASSIFICATION_ENHANCED:-true}
PDF_DOC_ANALYSIS=${PDF_DOC_ANALYSIS:-true}
NLP_ANALYSIS=${NLP_ANALYSIS:-true}
MOBILE_STATIC_ANALYSIS=${MOBILE_STATIC_ANALYSIS:-true}
WEB_ARCHIVE_ANALYSIS=${WEB_ARCHIVE_ANALYSIS:-true}
RECURSIVE_CRAWL=${RECURSIVE_CRAWL:-true}
ADVERSARIAL_AI_DETECTION=${ADVERSARIAL_AI_DETECTION:-true}
COVERT_CHANNEL_DETECTION=${COVERT_CHANNEL_DETECTION:-true}
CROSS_QR_CHAIN_DETECTION=${CROSS_QR_CHAIN_DETECTION:-true}
TEMPLATE_SPOOF_DETECTION=${TEMPLATE_SPOOF_DETECTION:-true}
SOCIAL_MEDIA_LINK_DETECTION=${SOCIAL_MEDIA_LINK_DETECTION:-true}
UX_REDRESS_DETECTION=${UX_REDRESS_DETECTION:-true}
DGA_ANALYSIS=${DGA_ANALYSIS:-true}
UNICODE_DECEPTION_DETECTION=${UNICODE_DECEPTION_DETECTION:-true}
SOCIAL_THREAT_TRACKING=${SOCIAL_THREAT_TRACKING:-true}
BLOCKCHAIN_SCAM_ANALYSIS=${BLOCKCHAIN_SCAM_ANALYSIS:-true}
CONTACT_EVENT_ANALYSIS=${CONTACT_EVENT_ANALYSIS:-true}
GEO_HOTSPOT_DETECTION=${GEO_HOTSPOT_DETECTION:-true}
EMERGING_PROTOCOL_DETECTION=${EMERGING_PROTOCOL_DETECTION:-true}
FEEDBACK_LOOP_ENABLED=${FEEDBACK_LOOP_ENABLED:-true}

# API Keys (set via environment or config)
URLSCAN_API_KEY="${URLSCAN_API_KEY:-}"
ANYRUN_API_KEY="${ANYRUN_API_KEY:-}"
HYBRID_ANALYSIS_KEY="${HYBRID_ANALYSIS_KEY:-}"
ETHERSCAN_API_KEY="${ETHERSCAN_API_KEY:-}"
OPENAI_API_KEY="${OPENAI_API_KEY:-}"

# ============================================================================
# AUDIT 1: SANDBOX/EMULATION/DETONATION ENGINE
# ============================================================================

# Sandbox API endpoints
declare -A SANDBOX_APIS=(
    ["urlscan"]="https://urlscan.io/api/v1/scan/"
    ["anyrun"]="https://api.any.run/v1/analysis"
    ["hybrid_analysis"]="https://www.hybrid-analysis.com/api/v2/submit/url"
    ["joesandbox"]="https://jbxcloud.joesecurity.org/api/v2/analysis/submit"
    ["virustotal_url"]="https://www.virustotal.com/api/v3/urls"
)

# Known malicious behavioral indicators from sandbox results
declare -a SANDBOX_MALICIOUS_BEHAVIORS=(
    "process_injection"
    "registry_persistence"
    "scheduled_task_creation"
    "service_installation"
    "credential_theft"
    "keylogging"
    "screen_capture"
    "file_encryption"
    "network_beacon"
    "dns_tunneling"
    "powershell_encoded"
    "wmi_execution"
    "dll_injection"
    "hollowing"
    "unhooking"
    "anti_analysis"
    "evasion_technique"
    "dropper_behavior"
    "downloader_behavior"
    "c2_communication"
    "data_exfiltration"
    "ransomware_behavior"
    "wiper_behavior"
    "rootkit_behavior"
    "bootkit_behavior"
)

analyze_sandbox_detonation() {
    set +u
    local url="${1:-}"
    set -u
    
    if [ "$SANDBOX_DETONATION" = false ]; then
        analysis_success_none "SANDBOX-DETONATION"
        return
    fi
    
    log_info "Performing sandbox/detonation analysis..."
    
    local sandbox_findings=()
    local sandbox_score=0
    local sandbox_report="${OUTPUT_DIR}/sandbox_detonation.txt"
    
    {
        echo "═══════════════════════════════════════════════"
        echo "SANDBOX DETONATION ANALYSIS"
        echo "═══════════════════════════════════════════════"
        echo "Timestamp: $(date -Iseconds)"
        echo "Target URL: $url"
        echo ""
    } > "$sandbox_report"
    
    # 1. URLScan.io submission
    if [ -n "$URLSCAN_API_KEY" ]; then
        log_info "  Submitting to urlscan.io..."
        local urlscan_result=$(curl -sS --max-time 30 \
            -H "API-Key: $URLSCAN_API_KEY" \
            -H "Content-Type: application/json" \
            -d "{\"url\": \"$url\", \"visibility\": \"private\"}" \
            "${SANDBOX_APIS[urlscan]}" 2>/dev/null)
        
        if [ -n "$urlscan_result" ]; then
            local scan_uuid=$(echo "$urlscan_result" | grep -oE '"uuid":"[^"]+"' | cut -d'"' -f4)
            if [ -n "$scan_uuid" ]; then
                echo "URLScan UUID: $scan_uuid" >> "$sandbox_report"
                echo "URLScan Result URL: https://urlscan.io/result/$scan_uuid/" >> "$sandbox_report"
                log_forensic "URLScan submitted: $scan_uuid"
                
                # Wait and fetch results
                sleep 15
                local scan_result=$(curl -sS --max-time 30 \
                    "https://urlscan.io/api/v1/result/$scan_uuid/" 2>/dev/null)
                
                if [ -n "$scan_result" ]; then
                    # Check for malicious verdicts
                    if echo "$scan_result" | grep -qiE '"malicious":[[:space:]]*true|"score":[[:space:]]*[7-9][0-9]|"score":[[:space:]]*100'; then
                        log_threat 80 "URLScan detected malicious content"
                        sandbox_findings+=("urlscan:malicious")
                        ((sandbox_score += 70))
                    fi
                    
                    # Extract domains contacted
                    local domains_contacted=$(echo "$scan_result" | grep -oE '"domain":"[^"]+"' | cut -d'"' -f4 | sort -u)
                    echo "Domains Contacted:" >> "$sandbox_report"
                    echo "$domains_contacted" >> "$sandbox_report"
                    
                    # Extract IPs
                    local ips_contacted=$(echo "$scan_result" | grep -oE '"ip":"[^"]+"' | cut -d'"' -f4 | sort -u)
                    echo "IPs Contacted:" >> "$sandbox_report"
                    echo "$ips_contacted" >> "$sandbox_report"
                    
                    # Check for redirects
                    local redirect_count=$(echo "$scan_result" | grep -c '"redirectResponse"')
                    if [ "$redirect_count" -gt 3 ]; then
                        log_warning "Multiple redirects detected: $redirect_count"
                        sandbox_findings+=("redirect_chain:$redirect_count")
                        ((sandbox_score += 20))
                    fi
                fi
            fi
        fi
    else
        echo "URLScan: Skipped (no API key)" >> "$sandbox_report"
    fi
    
    # 2. Local Docker sandbox (if available)
    if command -v docker &> /dev/null; then
        log_info "  Checking local Docker sandbox capability..."
        echo "" >> "$sandbox_report"
        echo "Local Docker Sandbox: Available" >> "$sandbox_report"
        
        # Create isolated analysis container
        local container_result=$(timeout 60 docker run --rm --network=none \
            --memory=512m --cpus=0.5 \
            alpine:latest sh -c "wget -q -O- --timeout=10 '$url' 2>/dev/null | head -c 10000" 2>/dev/null)
        
        if [ -n "$container_result" ]; then
            # Analyze fetched content for malicious patterns
            if echo "$container_result" | grep -qiE '<script.*eval|document\.write.*unescape|fromCharCode.*concat'; then
                log_threat 60 "Obfuscated JavaScript detected in fetched content"
                sandbox_findings+=("obfuscated_js")
                ((sandbox_score += 50))
            fi
            
            if echo "$container_result" | grep -qiE 'createElement.*iframe|appendChild.*script'; then
                log_threat 45 "Dynamic script/iframe injection detected"
                sandbox_findings+=("dynamic_injection")
                ((sandbox_score += 35))
            fi
        fi
    fi
    
    # 3. Behavioral indicator analysis
    echo "" >> "$sandbox_report"
    echo "Behavioral Analysis:" >> "$sandbox_report"
    
    for behavior in "${SANDBOX_MALICIOUS_BEHAVIORS[@]}"; do
        if echo "$url" | grep -qiE "$behavior"; then
            sandbox_findings+=("behavior:$behavior")
            ((sandbox_score += 15))
        fi
    done
    
    # Generate report
    echo "" >> "$sandbox_report"
    echo "Findings:" >> "$sandbox_report"
    for finding in "${sandbox_findings[@]}"; do
        echo "  - $finding" >> "$sandbox_report"
    done
    echo "" >> "$sandbox_report"
    echo "Sandbox Risk Score: $sandbox_score" >> "$sandbox_report"
    
    if [ ${#sandbox_findings[@]} -gt 0 ]; then
        if [ $sandbox_score -ge 50 ]; then
            log_threat $((sandbox_score / 2)) "Sandbox detonation revealed threats"
        fi
        analysis_success_found "SANDBOX-DETONATION" "${#sandbox_findings[@]}" "Score: $sandbox_score" "$(IFS=', '; echo "${sandbox_findings[*]}")"
    else
        analysis_success_none "SANDBOX-DETONATION"
    fi
}

# ============================================================================
# AUDIT 2: JAVASCRIPT/HTML/BROWSER EXPLOIT ANALYSIS
# ============================================================================

# JavaScript exploit patterns
declare -a JS_EXPLOIT_PATTERNS=(
    # Obfuscation
    'eval[[:space:]]*\([[:space:]]*function[[:space:]]*\([[:space:]]*p[[:space:]]*,[[:space:]]*a[[:space:]]*,[[:space:]]*c[[:space:]]*,[[:space:]]*k'  # p.a.c.k.e.r
    'eval[[:space:]]*\([[:space:]]*unescape'
    'String\.fromCharCode[[:space:]]*\([[:space:]]*[0-9,\s]+'
    'document\.write[[:space:]]*\([[:space:]]*unescape'
    'atob[[:space:]]*\([[:space:]]*["\x27][A-Za-z0-9+/=]+'
    'window\[.?\\x[0-9a-f]+'
    'constructor[[:space:]]*\([[:space:]]*["\x27]return'
    
    # XSS payloads
    '<script[^>]*>.*<\/script>'
    'javascript[[:space:]]*:'
    'on(load|error|click|mouseover)[[:space:]]*='
    '<img[^>]+onerror[[:space:]]*='
    '<svg[^>]+onload[[:space:]]*='
    '<body[^>]+onload[[:space:]]*='
    
    # DOM manipulation
    'document\.cookie'
    'document\.domain'
    'document\.location'
    'window\.location'
    'location\.href[[:space:]]*='
    'location\.replace'
    'innerHTML[[:space:]]*='
    'outerHTML[[:space:]]*='
    'document\.write'
    
    # Remote code execution
    'new[[:space:]]\+Function[[:space:]]*\('
    'setTimeout[[:space:]]*\([[:space:]]*["\x27]'
    'setInterval[[:space:]]*\([[:space:]]*["\x27]'
    
    # Browser exploits
    'ActiveXObject'
    'WScript\.Shell'
    'Scripting\.FileSystemObject'
    'ADODB\.Stream'
    'msxml2\.xmlhttp'
    'shellcode'
    'spray'
    'heap'
    
    # Credential theft
    'password'
    'credentials'
    'login'
    'signin'
    'autocomplete.*off'
    
    # Known exploit kit patterns
    'Angler'
    'RIG'
    'Magnitude'
    'Sundown'
    'Fallout'
    'GrandSoft'
    'Underminer'
)

# HTML phishing indicators
declare -a HTML_PHISHING_PATTERNS=(
    '<form[^>]+action[[:space:]]*=[[:space:]]*["\x27]https?://'
    '<input[^>]+type[[:space:]]*=[[:space:]]*["\x27]password'
    '<input[^>]+name[[:space:]]*=[[:space:]]*["\x27](user|email|pass|pwd|login)'
    'Please[[:space:]]\+(verify|confirm|update)[[:space:]]\+your'
    'Your[[:space:]]\+account[[:space:]]\+(has[[:space:]]\+been|is|will[[:space:]]\+be)'
    'Click[[:space:]]\+here[[:space:]]\+to[[:space:]]\+(verify|confirm|update)'
    'Verify[[:space:]]\+your[[:space:]]\+identity'
    'Secure[[:space:]]\+your[[:space:]]\+account'
    'Unusual[[:space:]]\+activity'
    'Suspended'
    'Locked'
    'Expired'
    'Action[[:space:]]\+required'
)

analyze_js_browser_exploits() {
    set +u
    local content="${1:-}"
    local url="${2:-}"
    set -u
    
    if [ "$JS_BROWSER_ANALYSIS" = false ]; then
        analysis_success_none "JS-BROWSER-ANALYSIS"
        return
    fi
    
    log_info "Analyzing JavaScript/HTML browser exploits..."
    
    local js_findings=()
    local js_score=0
    local js_report="${OUTPUT_DIR}/js_browser_analysis.txt"
    
    {
        echo "═══════════════════════════════════════════════"
        echo "JAVASCRIPT/BROWSER EXPLOIT ANALYSIS"
        echo "═══════════════════════════════════════════════"
        echo "Timestamp: $(date -Iseconds)"
        echo ""
    } > "$js_report"
    
    # Fetch URL content if URL provided
    local html_content=""
    if [ -n "$url" ] && echo "$url" | grep -qiE "^https?://"; then
        log_info "  Fetching URL content for analysis..."
        html_content=$(timeout 30 curl -sS -L --max-time 25 \
            -A "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36" \
            "$url" 2>/dev/null | head -c 500000)
    fi
    
    # Combine content and HTML for analysis
    local analysis_content="$content $html_content"
    
    # Check JavaScript exploit patterns
    echo "JavaScript Exploit Patterns:" >> "$js_report"
    for pattern in "${JS_EXPLOIT_PATTERNS[@]}"; do
        if echo "$analysis_content" | grep -qiE "$pattern"; then
            local matched=$(echo "$analysis_content" | grep -oiE "$pattern" | head -1 | cut -c1-50)
            local matched_full=$(echo "$analysis_content" | grep -oiE "$pattern" | head -1 | cut -c1-100)
            local matched_context=$(echo "$analysis_content" | grep -oiE ".{0,20}$pattern.{0,20}" 2>/dev/null | head -1 | cut -c1-120)
            js_findings+=("js_exploit:$matched")
            ((js_score += 25))
            log_warning "JS exploit pattern detected: '${matched_full}' | Context: '${matched_context:-N/A}' | Pattern: '$pattern'"
            echo "  ⚠ DETECTED: $pattern" >> "$js_report"
            echo "    Matched: $matched_full" >> "$js_report"
        fi
    done
    
    # Check HTML phishing patterns
    echo "" >> "$js_report"
    echo "HTML Phishing Patterns:" >> "$js_report"
    for pattern in "${HTML_PHISHING_PATTERNS[@]}"; do
        if echo "$analysis_content" | grep -qiE "$pattern"; then
            local matched=$(echo "$analysis_content" | grep -oiE "$pattern" | head -1 | cut -c1-50)
            js_findings+=("html_phish:$matched")
            ((js_score += 20))
            log_warning "HTML phishing pattern: $matched"
            echo "  ⚠ DETECTED: $pattern" >> "$js_report"
        fi
    done
    
    # Check for iframe injections
    # Note: Use tr to ensure clean integer - grep -c can output multiple lines on multi-line input
    local iframe_count=$(echo "$analysis_content" | grep -ciE '<iframe' 2>/dev/null | tr -d '\n' | grep -oE '^[0-9]+' || echo 0)
    iframe_count=${iframe_count:-0}
    if [ "$iframe_count" -gt 0 ] 2>/dev/null; then
        echo "" >> "$js_report"
        echo "IFrame Analysis:" >> "$js_report"
        echo "  Count: $iframe_count" >> "$js_report"
        
        # Extract iframe sources - use single quotes for pattern to avoid hex escape issues
        local iframe_srcs=$(echo "$analysis_content" | grep -oiE '<iframe[^>]+src[[:space:]]*=[[:space:]]*["][^"]+' 2>/dev/null |
            sed 's/.*src[[:space:]]*=[[:space:]]*["]//' | head -5)
        echo "  Sources:" >> "$js_report"
        echo "$iframe_srcs" >> "$js_report"
        
        if [ "$iframe_count" -gt 3 ] 2>/dev/null; then
            js_findings+=("multiple_iframes:$iframe_count")
            ((js_score += 30))
            log_threat 35 "Multiple iframes detected ($iframe_count)"
        fi
        
        # Check for hidden iframes - simplified pattern without hex escapes
        if echo "$analysis_content" | grep -qiE '<iframe[^>]+(hidden|display[[:space:]]*:[[:space:]]*none|width[[:space:]]*=[[:space:]]*["]?0|height[[:space:]]*=[[:space:]]*["]?0)' 2>/dev/null; then
            local hidden_iframe_match=$(echo "$analysis_content" | grep -oiE '<iframe[^>]+(hidden|display[[:space:]]*:[[:space:]]*none|width[[:space:]]*=[[:space:]]*["]?0|height[[:space:]]*=[[:space:]]*["]?0)[^>]*>' 2>/dev/null | head -1 | cut -c1-150)
            local hidden_iframe_src=$(echo "$hidden_iframe_match" | grep -oiE 'src[[:space:]]*=[[:space:]]*["][^"]+' | sed 's/src[[:space:]]*=[[:space:]]*["]//' | head -1)
            js_findings+=("hidden_iframe:${hidden_iframe_src:-unknown_src}")
            ((js_score += 45))
            log_threat 50 "Hidden iframe detected - potential drive-by download. Iframe: '${hidden_iframe_match:-N/A}' | Source: '${hidden_iframe_src:-unknown}'"
        fi
    fi
    
    # Check for external script loading
    local script_count=$(echo "$analysis_content" | grep -ciE '<script[^>]+src' 2>/dev/null | tr -d '\n' | grep -oE '^[0-9]+' || echo 0)
    script_count=${script_count:-0}
    if [ "$script_count" -gt 10 ] 2>/dev/null; then
        js_findings+=("excessive_scripts:$script_count")
        ((js_score += 15))
        log_warning "Excessive external scripts: $script_count"
    fi
    
    # Headless browser analysis (if available)
    if command -v chromium &> /dev/null || command -v google-chrome &> /dev/null; then
        log_info "  Running headless browser analysis..."
        echo "" >> "$js_report"
        echo "Headless Browser Analysis: Available" >> "$js_report"
        
        # Note: Full implementation would use puppeteer/playwright
        # This is a placeholder for the concept
    fi
    
    # DOM clobbering detection
    if echo "$analysis_content" | grep -qiE 'name[[:space:]]*=[[:space:]]*["\x27](location|document|window|self|top|parent)'; then
        js_findings+=("dom_clobbering")
        ((js_score += 40))
        log_threat 45 "Potential DOM clobbering attack"
    fi
    
    # Prototype pollution detection
    if echo "$analysis_content" | grep -qiE '__proto__|constructor[[:space:]]*\[|prototype[[:space:]]*\['; then
        js_findings+=("prototype_pollution")
        ((js_score += 50))
        log_threat 55 "Potential prototype pollution attack"
    fi
    
    # Generate summary
    echo "" >> "$js_report"
    echo "Analysis Summary:" >> "$js_report"
    echo "  Total Findings: ${#js_findings[@]}" >> "$js_report"
    echo "  Risk Score: $js_score" >> "$js_report"
    echo "" >> "$js_report"
    echo "Findings:" >> "$js_report"
    for finding in "${js_findings[@]}"; do
        echo "  - $finding" >> "$js_report"
    done
    
    if [ ${#js_findings[@]} -gt 0 ]; then
        local js_summary=$(IFS=', '; echo "${js_findings[*]}")
        if [ $js_score -ge 50 ]; then
            log_threat $((js_score / 2)) "JavaScript/browser exploit patterns detected: ${js_summary}"
        fi
        analysis_success_found "JS-BROWSER-ANALYSIS" "${#js_findings[@]}" "Score: $js_score" "${js_summary}"
    else
        analysis_success_none "JS-BROWSER-ANALYSIS"
    fi
}

# ============================================================================
# AUDIT 3: ML/AI/STATISTICAL CLASSIFICATION ENGINE
# ============================================================================

# Feature extraction weights for ML scoring
declare -A ML_FEATURE_WEIGHTS=(
    ["url_length"]=0.15
    ["special_char_ratio"]=0.12
    ["digit_ratio"]=0.10
    ["subdomain_depth"]=0.13
    ["path_depth"]=0.08
    ["query_param_count"]=0.07
    ["entropy"]=0.15
    ["suspicious_tld"]=0.10
    ["brand_similarity"]=0.10
)

# Suspicious TLD list for ML scoring
declare -a ML_SUSPICIOUS_TLDS=(
    "tk" "ml" "ga" "cf" "gq" "top" "xyz" "work" "click" "loan"
    "date" "racing" "win" "review" "country" "stream" "download"
    "party" "bid" "trade" "webcam" "science" "accountant" "faith"
    "cricket" "gdn" "men" "link" "zip" "mobi" "info" "biz" "cc"
)

# Brand list for impersonation scoring
declare -a ML_BRAND_LIST=(
    "paypal" "amazon" "google" "microsoft" "apple" "facebook" "netflix"
    "instagram" "twitter" "linkedin" "dropbox" "chase" "wellsfargo"
    "bankofamerica" "citibank" "usbank" "capitalone" "americanexpress"
    "discover" "hsbc" "barclays" "santander" "irs" "hmrc" "dhl" "fedex"
    "ups" "usps" "royalmail" "docusign" "adobe" "zoom" "slack" "teams"
    "outlook" "office365" "onedrive" "icloud" "coinbase" "binance"
)

analyze_ml_classification_enhanced() {
    set +u
    local content="${1:-}"
    set -u
    
    if [ "$ML_CLASSIFICATION_ENHANCED" = false ]; then
        analysis_success_none "ML-CLASSIFICATION"
        return
    fi
    
    # Validate content
    [[ -z "$content" ]] && { analysis_success_none "ML-CLASSIFICATION"; return; }
    
    log_info "Performing enhanced ML/statistical classification..."
    
    local ml_report="${OUTPUT_DIR}/ml_classification_enhanced.txt"
    local ml_score=0
    local ml_confidence=0
    local ml_features=()
    local ml_verdict="UNKNOWN"
    
    {
        echo "═══════════════════════════════════════════════"
        echo "ENHANCED ML/STATISTICAL CLASSIFICATION"
        echo "═══════════════════════════════════════════════"
        echo "Timestamp: $(date -Iseconds)"
        echo ""
    } > "$ml_report"
    
    local encoded_content
    encoded_content=$(printf '%s' "$content" | base64 2>/dev/null) || { analysis_success_none "ML-CLASSIFICATION"; return; }

    # Get the discovered Python path
    local python_cmd=$(get_python_cmd)
    
    # Feature extraction using Python for accuracy
    # Pass encoded content as argument, not stdin (heredoc conflicts with pipe)
    local features_json=$(
        timeout 30 "$python_cmd" - "$encoded_content" 2>/dev/null <<'EOF'
import sys
import json
import math
import re
import base64
from collections import Counter
from urllib.parse import urlparse, parse_qs

try:
    content = base64.b64decode(sys.argv[1] if len(sys.argv) > 1 else '').decode('utf-8', errors='ignore')
except Exception:
    content = ''

features = {}

# URL parsing if content is URL
if content.startswith('http://') or content.startswith('https://'):
    try:
        parsed = urlparse(content)
        
        # URL length feature
        features['url_length'] = len(content)
        features['url_length_score'] = min(len(content) / 200, 1.0)
        
        # Domain analysis
        domain = parsed.netloc
        features['domain'] = domain
        features['domain_length'] = len(domain)
        
        # Subdomain depth
        parts = domain.split('.')
        features['subdomain_depth'] = len(parts) - 2 if len(parts) > 2 else 0
        features['subdomain_score'] = min(features['subdomain_depth'] / 5, 1.0)
        
        # Path depth
        path_parts = [p for p in parsed.path.split('/') if p]
        features['path_depth'] = len(path_parts)
        features['path_score'] = min(features['path_depth'] / 8, 1.0)
        
        # Query parameters
        params = parse_qs(parsed.query)
        features['param_count'] = len(params)
        features['param_score'] = min(features['param_count'] / 10, 1.0)
        
        # Special character ratio
        special_chars = len(re.findall(r'[@#%&=?\-_~]', content))
        features['special_char_ratio'] = special_chars / len(content) if content else 0
        
        # Digit ratio in domain
        digits = len(re.findall(r'\d', domain))
        features['digit_ratio'] = digits / len(domain) if domain else 0
        
        # TLD check
        tld = parts[-1].lower() if parts else ''
        suspicious_tlds = ['tk', 'ml', 'ga', 'cf', 'gq', 'top', 'xyz', 'work', 'click', 'loan']
        features['suspicious_tld'] = 1.0 if tld in suspicious_tlds else 0.0
        
        # Brand detection
        brands = ['paypal', 'amazon', 'google', 'microsoft', 'apple', 'facebook', 'netflix',
                  'instagram', 'twitter', 'linkedin', 'dropbox', 'chase', 'bank']
        domain_lower = domain.lower()
        features['brand_in_domain'] = 1.0 if any(b in domain_lower for b in brands) else 0.0
        
        # Check for typosquatting
        features['typosquatting_score'] = 0.0
        for brand in brands:
            if brand in domain_lower and brand not in ['.' + brand + '.', brand + '.']:
                # Brand appears but not as exact domain
                if domain_lower != brand + '.com' and domain_lower != 'www.' + brand + '.com':
                    features['typosquatting_score'] = 0.8
                    break
        
    except Exception as e:
        features['parse_error'] = str(e)

# Entropy calculation
if content:
    freq = Counter(content)
    probs = [count / len(content) for count in freq.values()]
    entropy = -sum(p * math.log2(p) for p in probs if p > 0)
    features['entropy'] = round(entropy, 4)
    features['entropy_score'] = min(entropy / 6, 1.0)
else:
    features['entropy'] = 0
    features['entropy_score'] = 0

# Character class analysis
if content:
    features['lowercase_ratio'] = len(re.findall(r'[a-z]', content)) / len(content)
    features['uppercase_ratio'] = len(re.findall(r'[A-Z]', content)) / len(content)
    features['numeric_ratio'] = len(re.findall(r'\d', content)) / len(content)

# N-gram analysis
def get_ngram_score(text, n=3):
    ngrams = [text[i:i+n] for i in range(len(text)-n+1)]
    freq = Counter(ngrams)
    if not freq:
        return 0
    max_freq = max(freq.values())
    return max_freq / len(ngrams) if ngrams else 0

features['bigram_score'] = get_ngram_score(content, 2) if len(content) > 2 else 0
features['trigram_score'] = get_ngram_score(content, 3) if len(content) > 3 else 0

# Calculate final ML score (weighted combination)
weights = {
    'url_length_score': 0.10,
    'subdomain_score': 0.15,
    'path_score': 0.08,
    'param_score': 0.07,
    'special_char_ratio': 0.10,
    'digit_ratio': 0.12,
    'suspicious_tld': 0.15,
    'brand_in_domain': 0.08,
    'typosquatting_score': 0.15,
    'entropy_score': 0.10
}

total_score = 0
for feature, weight in weights.items():
    if feature in features:
        total_score += features.get(feature, 0) * weight * 100

features['ml_score'] = round(total_score, 2)

# Confidence based on feature availability
available_features = sum(1 for k in weights.keys() if k in features)
features['confidence'] = round(available_features / len(weights) * 100, 1)

# Verdict
if total_score >= 70:
    features['verdict'] = 'MALICIOUS'
elif total_score >= 45:
    features['verdict'] = 'SUSPICIOUS'
elif total_score >= 25:
    features['verdict'] = 'POTENTIALLY_SUSPICIOUS'
else:
    features['verdict'] = 'LIKELY_BENIGN'

print(json.dumps(features, indent=2))
EOF
    )

    if [ -n "$features_json" ]; then
        echo "Feature Extraction Results:" >> "$ml_report"
        echo "$features_json" >> "$ml_report"

        # Parse results
        ml_score=$(json_extract_number "$features_json" "ml_score")
        ml_confidence=$(json_extract_number "$features_json" "confidence")
        ml_verdict=$(json_extract_string "$features_json" "verdict")

        echo "" >> "$ml_report"
        echo "Classification Results:" >> "$ml_report"
        echo "  ML Score: ${ml_score:-0}" >> "$ml_report"
        echo "  Confidence: ${ml_confidence:-0}%" >> "$ml_report"
        echo "  Verdict: ${ml_verdict:-UNKNOWN}" >> "$ml_report"

        # Display results
        echo ""
        echo -e "${CYAN}┌─────────────────────────────────────────────────────────────┐${NC}"
        echo -e "${CYAN}│              ML CLASSIFICATION RESULTS                       │${NC}"
        echo -e "${CYAN}├─────────────────────────────────────────────────────────────┤${NC}"
        echo -e "${CYAN}│${NC} ML Score:     ${YELLOW}${ml_score:-0}${NC}"
        echo -e "${CYAN}│${NC} Confidence:   ${WHITE}${ml_confidence:-0}%${NC}"
        echo -e "${CYAN}│${NC} Verdict:      ${RED}${ml_verdict:-UNKNOWN}${NC}"
        echo -e "${CYAN}└─────────────────────────────────────────────────────────────┘${NC}"
        echo ""

        # Add threat score based on ML verdict
        case "$ml_verdict" in
            "MALICIOUS")
                log_threat 60 "ML classification: MALICIOUS (${ml_confidence}% confidence)"
                analysis_success_found "ML-CLASSIFICATION" "1" "Verdict: $ml_verdict, Score: $ml_score" "verdict:$ml_verdict, confidence:${ml_confidence}%, score:$ml_score"
                ;;
            "SUSPICIOUS")
                log_threat 35 "ML classification: SUSPICIOUS (${ml_confidence}% confidence)"
                analysis_success_found "ML-CLASSIFICATION" "1" "Verdict: $ml_verdict, Score: $ml_score" "verdict:$ml_verdict, confidence:${ml_confidence}%, score:$ml_score"
                ;;
            "POTENTIALLY_SUSPICIOUS")
                log_warning "ML classification: POTENTIALLY SUSPICIOUS"
                analysis_success_found "ML-CLASSIFICATION" "1" "Verdict: $ml_verdict, Score: $ml_score" "verdict:$ml_verdict, confidence:${ml_confidence}%, score:$ml_score"
                ;;
            *)
                analysis_success_none "ML-CLASSIFICATION"
                ;;
        esac
    else
        analysis_error "ML-CLASSIFICATION" "Python feature extraction failed"
    fi
}

# ============================================================================
# AUDIT 4: PDF/DOCUMENT EMBEDDED PAYLOAD ANALYSIS
# ============================================================================

# Known malicious PDF patterns
declare -a PDF_MALICIOUS_PATTERNS=(
    '/JavaScript'
    '/JS'
    '/Launch'
    '/EmbeddedFile'
    '/OpenAction'
    '/AA'
    '/AcroForm'
    '/XFA'
    '/RichMedia'
    '/ObjStm'
    '/URI'
    '/SubmitForm'
    '/GoToR'
    '/GoToE'
    '/JBIG2Decode'
    '/Colors > 2\^24'
    'getAnnots'
    'getPageNthWord'
    'this.exportDataObject'
    'util.printf'
    'Collab.collectEmailInfo'
    'spell.customDictionaryOpen'
)

# Office document macro patterns
declare -a OFFICE_MACRO_PATTERNS=(
    'AutoOpen'
    'AutoExec'
    'AutoClose'
    'Document_Open'
    'Workbook_Open'
    'Auto_Open'
    'Shell'
    'WScript'
    'PowerShell'
    'cmd.exe'
    'CreateObject'
    'GetObject'
    'CallByName'
    'Environ'
    'URLDownloadToFile'
    'MSXML2'
    'WinHttp'
    'StrReverse'
    'Chr[(]'
    'ChrW[(]'
    'ChrB[(]'
)

analyze_pdf_document() {
    set +u
    local content="${1:-}"
    local url="${2:-}"
    set -u
    
    if [ "$PDF_DOC_ANALYSIS" = false ]; then
        analysis_success_none "PDF-DOC-ANALYSIS"
        return
    fi
    
    log_info "Analyzing for PDF/document embedded payloads..."
    
    local doc_findings=()
    local doc_score=0
    local doc_report="${OUTPUT_DIR}/pdf_document_analysis.txt"
    
    {
        echo "═══════════════════════════════════════════════"
        echo "PDF/DOCUMENT PAYLOAD ANALYSIS"
        echo "═══════════════════════════════════════════════"
        echo "Timestamp: $(date -Iseconds)"
        echo ""
    } > "$doc_report"
    
    # Check if URL points to document
    local is_doc_url=false
    local doc_type=""
    
    if echo "$url" | grep -qiE '\.(pdf|doc|docx|docm|xls|xlsx|xlsm|ppt|pptx|pptm|odt|ods|odp|rtf)(\?|$)'; then
        is_doc_url=true
        doc_type=$(echo "$url" | grep -oiE '\.(pdf|doc|docx|docm|xls|xlsx|xlsm|ppt|pptx|pptm|odt|ods|odp|rtf)' | tr '[:upper:]' '[:lower:]')
        log_warning "URL points to document: $doc_type"
        doc_findings+=("document_url:$doc_type")
        ((doc_score += 20))
    fi
    
    # Download and analyze if document URL
    if [ "$is_doc_url" = true ] && [ -n "$url" ]; then
        local temp_doc="${TEMP_DIR}/downloaded_doc$(echo $doc_type)"
        
        log_info "  Downloading document for analysis..."
        if timeout 30 curl -sS -L -o "$temp_doc" "$url" 2>/dev/null; then
            local file_type=$(file -b "$temp_doc" 2>/dev/null)
            echo "Downloaded File Type: $file_type" >> "$doc_report"
            
            # PDF Analysis
            if echo "$file_type" | grep -qi "PDF"; then
                log_info "  Analyzing PDF structure..."
                echo "" >> "$doc_report"
                echo "PDF Analysis:" >> "$doc_report"
                
                # Check for malicious PDF patterns
                for pattern in "${PDF_MALICIOUS_PATTERNS[@]}"; do
                    if grep -qa "$pattern" "$temp_doc" 2>/dev/null; then
                        doc_findings+=("pdf_pattern:$pattern")
                        ((doc_score += 25))
                        log_warning "Suspicious PDF pattern: $pattern"
                        echo "  ⚠ DETECTED: $pattern" >> "$doc_report"
                    fi
                done
                
                # Use pdfid if available
                if command -v pdfid &> /dev/null; then
                    log_info "  Running pdfid analysis..."
                    local pdfid_output=$(pdfid "$temp_doc" 2>/dev/null)
                    echo "" >> "$doc_report"
                    echo "pdfid Output:" >> "$doc_report"
                    echo "$pdfid_output" >> "$doc_report"
                    
                    # Parse pdfid results
                    if echo "$pdfid_output" | grep -qE '/JavaScript[[:space:]]\+[1-9]'; then
                        doc_findings+=("pdfid:javascript")
                        ((doc_score += 40))
                        log_threat 50 "PDF contains JavaScript"
                    fi
                    
                    if echo "$pdfid_output" | grep -qE '/OpenAction[[:space:]]\+[1-9]'; then
                        doc_findings+=("pdfid:openaction")
                        ((doc_score += 35))
                        log_threat 40 "PDF contains OpenAction (auto-execute)"
                    fi
                    
                    if echo "$pdfid_output" | grep -qE '/Launch[[:space:]]\+[1-9]'; then
                        doc_findings+=("pdfid:launch")
                        ((doc_score += 50))
                        log_threat 60 "PDF contains Launch action"
                    fi
                fi
                
                # Use pdf-parser if available
                if command -v pdf-parser &> /dev/null; then
                    log_info "  Running pdf-parser analysis..."
                    local parser_output=$(pdf-parser --stats "$temp_doc" 2>/dev/null | head -50)
                    echo "" >> "$doc_report"
                    echo "pdf-parser Stats:" >> "$doc_report"
                    echo "$parser_output" >> "$doc_report"
                fi
            fi
            
            # Office document analysis
            if echo "$file_type" | grep -qiE "Microsoft|Office|Composite Document|OpenDocument"; then
                log_info "  Analyzing Office document..."
                echo "" >> "$doc_report"
                echo "Office Document Analysis:" >> "$doc_report"
                
                # Use olevba if available
                if command -v olevba &> /dev/null; then
                    log_info "  Running olevba analysis..."
                    local olevba_output=$(timeout 30 olevba "$temp_doc" 2>/dev/null | head -200)
                    echo "$olevba_output" >> "$doc_report"
                    
                    if echo "$olevba_output" | grep -qi "VBA MACRO"; then
                        doc_findings+=("office:vba_macro")
                        ((doc_score += 35))
                        log_threat 40 "Office document contains VBA macros"
                    fi
                    
                    if echo "$olevba_output" | grep -qiE "AutoOpen|AutoExec|Document_Open"; then
                        doc_findings+=("office:auto_execute")
                        ((doc_score += 50))
                        log_threat 60 "Office document has auto-execute macro"
                    fi
                    
                    if echo "$olevba_output" | grep -qiE "Shell|PowerShell|cmd\.exe|WScript"; then
                        doc_findings+=("office:shell_execution")
                        ((doc_score += 60))
                        log_threat 70 "Office macro contains shell execution"
                    fi
                fi
                
                # Check for DDE
                if strings "$temp_doc" 2>/dev/null | grep -qiE 'DDE|DDEAUTO'; then
                    doc_findings+=("office:dde")
                    ((doc_score += 55))
                    log_threat 65 "Office document contains DDE (Dynamic Data Exchange)"
                fi
            fi
            
            # Extract embedded URLs
            log_info "  Extracting embedded URLs..."
            local embedded_urls=$(strings "$temp_doc" 2>/dev/null | grep -oiE 'https?://[^[:space:]"<>]+' | sort -u | head -20)
            if [ -n "$embedded_urls" ]; then
                echo "" >> "$doc_report"
                echo "Embedded URLs:" >> "$doc_report"
                echo "$embedded_urls" >> "$doc_report"
                
                local url_count=$(echo "$embedded_urls" | wc -l)
                doc_findings+=("embedded_urls:$url_count")
                
                # Record as IOCs
                while IFS= read -r embedded_url; do
                    [ -z "$embedded_url" ] && continue
                    record_ioc "embedded_url" "$embedded_url" "URL extracted from document"
                done <<< "$embedded_urls"
            fi
            
            # Cleanup
            rm -f "$temp_doc" 2>/dev/null
        fi
    fi
    
    # Check content for document-related patterns
    for pattern in "${OFFICE_MACRO_PATTERNS[@]}"; do
        if echo "$content" | safe_grep_qiE "$pattern"; then
            doc_findings+=("macro_pattern:$pattern")
            ((doc_score += 15))
        fi
    done
    
    # Generate summary
    echo "" >> "$doc_report"
    echo "Analysis Summary:" >> "$doc_report"
    echo "  Total Findings: ${#doc_findings[@]}" >> "$doc_report"
    echo "  Risk Score: $doc_score" >> "$doc_report"
    
    if [ ${#doc_findings[@]} -gt 0 ]; then
        if [ $doc_score -ge 50 ]; then
            log_threat $((doc_score / 2)) "Document payload analysis revealed threats"
        fi
        analysis_success_found "PDF-DOC-ANALYSIS" "${#doc_findings[@]}" "Score: $doc_score" "$(IFS=', '; echo "${doc_findings[*]}")"
    else
        analysis_success_none "PDF-DOC-ANALYSIS"
    fi
}

# ============================================================================
# AUDIT 5: ADVANCED STRING & NATURAL LANGUAGE ANALYSIS
# ============================================================================

# Scam/phishing language patterns (expanded)
declare -a NLP_SCAM_PATTERNS=(
    # Urgency
    "act now" "immediate action" "urgent" "expires soon" "limited time"
    "don't delay" "last chance" "final notice" "ending soon" "hurry"
    "only [0-9]+ (hours|minutes|days)" "deadline" "time-sensitive"
    
    # Fear
    "your account (will be|has been) (suspended|locked|terminated|closed)"
    "unauthorized (access|activity|transaction)" "security (alert|warning|breach)"
    "suspicious (activity|login|transaction)" "compromised" "hacked"
    "identity theft" "fraud" "illegal activity" "violation"
    
    # Authority
    "official notification" "legal action" "court order" "government"
    "IRS" "FBI" "police" "law enforcement" "investigation"
    "compliance" "regulation" "mandatory" "required by law"
    
    # Reward
    "congratulations" "you('ve| have) won" "prize" "lottery" "jackpot"
    "free" "bonus" "reward" "gift" "giveaway" "claim your"
    "selected" "winner" "lucky" "exclusive offer"
    
    # Social proof
    "millions of users" "trusted by" "verified" "official"
    "recommended" "endorsed" "certified"
    
    # Pressure
    "click (here|now|immediately)" "verify (now|immediately|your)"
    "confirm (now|immediately|your)" "update (now|immediately|your)"
    "respond within" "must (act|respond|verify)" "failure to"
    
    # Credential requests
    "enter your (password|PIN|SSN|credit card)"
    "confirm your (identity|account|information)"
    "verify your (identity|account|information)"
    "update your (password|information|details)"
    "provide your (details|information|credentials)"
)

# Legitimate language patterns (for comparison)
declare -a NLP_LEGITIMATE_PATTERNS=(
    "privacy policy" "terms of service" "unsubscribe"
    "contact us" "help center" "support" "FAQ"
    "copyright" "trademark" "registered"
)

analyze_nlp_content() {
    set +u
    local content="${1:-}"
    set -u
    
    if [ "$NLP_ANALYSIS" = false ]; then
        analysis_success_none "NLP-ANALYSIS"
        return
    fi
    
    log_info "Performing NLP/language analysis..."
    
    local nlp_findings=()
    local nlp_score=0
    local urgency_count=0
    local fear_count=0
    local reward_count=0
    local pressure_count=0
    local nlp_report="${OUTPUT_DIR}/nlp_analysis.txt"
    
    {
        echo "═══════════════════════════════════════════════"
        echo "NATURAL LANGUAGE ANALYSIS"
        echo "═══════════════════════════════════════════════"
        echo "Timestamp: $(date -Iseconds)"
        echo ""
        echo "Content Length: ${#content} characters"
        echo ""
    } > "$nlp_report"
    
    # Analyze scam patterns
    echo "Scam Pattern Detection:" >> "$nlp_report"
    
    for pattern in "${NLP_SCAM_PATTERNS[@]}"; do
        if echo "$content" | safe_grep_qiE "$pattern"; then
            local matched=$(echo "$content" | safe_grep_oiE "$pattern" 2>/dev/null | head -1)
            nlp_findings+=("scam_pattern:$matched")
            ((nlp_score += 10))
            echo "  ⚠ DETECTED: $pattern" >> "$nlp_report"
            
            # Categorize
            case "$pattern" in
                *urgent*|*immediate*|*expires*|*limited*|*hurry*|*deadline*)
                    ((urgency_count++))
                    ;;
                *suspended*|*locked*|*unauthorized*|*security*|*compromised*|*hacked*)
                    ((fear_count++))
                    ;;
                *won*|*prize*|*lottery*|*free*|*bonus*|*reward*|*gift*)
                    ((reward_count++))
                    ;;
                *click*|*verify*|*confirm*|*must*|*failure*)
                    ((pressure_count++))
                    ;;
            esac
        fi
    done
    
    # Python-based sentiment and entity analysis
    # FIXED: Use base64 encoding to safely pass content to Python
    local encoded_content
    encoded_content=$(printf '%s' "$content" | base64 2>/dev/null) || encoded_content=""

    local nlp_results=""
    if [ -n "$encoded_content" ]; then
        nlp_results=$(
            python3 - "$encoded_content" 2>/dev/null <<'EOF'
import sys
import json
import re
import base64

try:
    content = base64.b64decode(sys.argv[1] if len(sys.argv) > 1 else '').decode('utf-8', errors='ignore')
except Exception:
    content = ''

results = {
    'word_count': len(content.split()),
    'sentence_count': len(re.split(r'[.!?]+', content)),
    'exclamation_count': content.count('!'),
    'question_count': content.count('?'),
    'caps_words': len(re.findall(r'\b[A-Z]{3,}\b', content)),
    'url_count': len(re.findall(r'https?://\S+', content)),
    'email_count': len(re.findall(r'\b[\w.-]+@[\w.-]+\.\w+\b', content)),
    'phone_count': len(re.findall(r'\b\d{3}[-.]?\d{3}[-.]?\d{4}\b', content)),
    'money_refs': len(re.findall(r'\$\d+|\d+\s*(dollars|usd|euros|pounds)', content, re.I)),
    'urgency_words': len(re.findall(r'\b(urgent|immediate|now|today|asap|hurry)\b', content, re.I)),
}

# Calculate suspicion score
suspicion = 0
if results['exclamation_count'] > 3:
    suspicion += 15
if results['caps_words'] > 5:
    suspicion += 20
if results['urgency_words'] > 2:
    suspicion += 25
if results['money_refs'] > 1:
    suspicion += 15

results['suspicion_score'] = suspicion

print(json.dumps(results, indent=2))
EOF
        )
    fi

    # Extended NLP analysis with suspicion scoring
    local extended_nlp_results=""
    if [ -n "$encoded_content" ]; then
        extended_nlp_results=$(
            python3 - "$encoded_content" 2>/dev/null <<'EOF'
import sys
import json
import re
import base64
from collections import Counter

# Basic English sentiment lexicons (for demo; expand as needed)
POS_WORDS = set(['good','great','happy','love','excellent','fortunate','correct','superior','success','secure','trust','safe','benefit','positive','approve','enjoy'])
NEG_WORDS = set(['bad','poor','sad','hate','unfortunate','wrong','inferior','fail','danger','threat','risk','harm','negative','reject','abuse','worse','urgent','now','limited'])

def count_sentiment_words(words, positive, negative):
    pos = sum(1 for w in words if w.lower() in positive)
    neg = sum(1 for w in words if w.lower() in negative)
    return pos, neg

suspicion = 0

try:
    content = base64.b64decode(sys.argv[1] if len(sys.argv) > 1 else '').decode('utf-8', errors='ignore')
except Exception:
    content = ''

results = {}

# Basic counts
results['word_count'] = wc = len(content.split())
results['sentence_count'] = sc = len([s for s in re.split(r'[.!?]+', content) if s.strip()])
results['exclamation_count'] = content.count('!')
results['question_count'] = content.count('?')
results['caps_words'] = len(re.findall(r'\b[A-Z]{3,}\b', content))            # ALLCAPS words
results['allcaps_lines'] = sum(1 for line in content.splitlines() if line.strip() and line.strip().isupper())
results['url_count'] = len(re.findall(r'https?://\S+', content))
results['email_count'] = len(re.findall(r'\b[\w.-]+@[\w.-]+\.\w+\b', content))
results['phone_count'] = len(re.findall(r'\b\d{3}[-.]?\d{3}[-.]?\d{4}\b', content))
results['money_refs'] = len(re.findall(r'\$\d+|\d+[ ]*(dollars|usd|euros|pounds)', content, re.I))

# Urgent/trigger words and persuasion cues
urgency_words = re.findall(r'\b(urgent|immediate|now|today|asap|hurry|limited|act|risk)\b', content, re.I)
results['urgency_words'] = len(urgency_words)
results['threat_words'] = len(re.findall(r'\b(threat|risk|danger|account suspended|phish|locked|secure)\b', content, re.I))
results['reward_words'] = len(re.findall(r'\b(prize|reward|gift|win|won|lottery|bonus|free)\b', content, re.I))

# Sentiment analysis (shallow, demo)
words = re.findall(r'\b\w+\b', content)
pos_words, neg_words = count_sentiment_words(words, POS_WORDS, NEG_WORDS)
results['positive_word_count'] = pos_words
results['negative_word_count'] = neg_words
results['sentiment_ratio'] = round((pos_words - neg_words) / wc, 3) if wc else 0

# NER-style: Detect "entities" by capitalized phrase patterns (very crude demo)
entities = re.findall(r'\b([A-Z][a-z]+(?:\s[A-Z][a-z]+)+)\b', content)
results['named_entities'] = list(set(entities))[:5]  # up to 5 sample names/entities

# Readability
if wc > 0 and sc > 0:
    avg_sentence_length = wc / sc
    results['avg_sentence_length'] = round(avg_sentence_length, 1)
    if avg_sentence_length < 8:
        results['short_sentences_flag'] = True
        suspicion += 10

# Excessive punctuation/allcaps
if results['exclamation_count'] > 3 or results['allcaps_lines'] > 0:
    results['excessive_exclaim_flag'] = True
    suspicion += 5
if results['caps_words'] > wc / 5 and wc > 10:
    results['excessive_caps_flag'] = True
    suspicion += 5

# Scam/persuasion patterns
if results.get('urgency_words',0) > 1 or results.get('threat_words',0) > 0:
    suspicion += 5
if results.get('reward_words',0) > 0:
    suspicion += 2

# Sentiment scoring
if results['sentiment_ratio'] < -0.2 and neg_words > 0:
    results['negative_sentiment_flag'] = True
    suspicion += 5
elif results['sentiment_ratio'] > 0.2 and pos_words > 0:
    results['positive_sentiment_flag'] = True

# Aggregate simple risk score
results['suspicion_score'] = suspicion

print(json.dumps(results, indent=2))
EOF
    )
fi
}

# ============================================================================
# AUDIT 6: FULL MOBILE MALWARE STATIC ANALYSIS
# ============================================================================

# Dangerous Android permissions
declare -a DANGEROUS_ANDROID_PERMISSIONS=(
    "android.permission.READ_SMS"
    "android.permission.SEND_SMS"
    "android.permission.RECEIVE_SMS"
    "android.permission.READ_CONTACTS"
    "android.permission.WRITE_CONTACTS"
    "android.permission.READ_CALL_LOG"
    "android.permission.WRITE_CALL_LOG"
    "android.permission.RECORD_AUDIO"
    "android.permission.CAMERA"
    "android.permission.ACCESS_FINE_LOCATION"
    "android.permission.ACCESS_COARSE_LOCATION"
    "android.permission.READ_PHONE_STATE"
    "android.permission.CALL_PHONE"
    "android.permission.READ_EXTERNAL_STORAGE"
    "android.permission.WRITE_EXTERNAL_STORAGE"
    "android.permission.RECEIVE_BOOT_COMPLETED"
    "android.permission.SYSTEM_ALERT_WINDOW"
    "android.permission.BIND_ACCESSIBILITY_SERVICE"
    "android.permission.BIND_DEVICE_ADMIN"
    "android.permission.REQUEST_INSTALL_PACKAGES"
)

# iOS suspicious entitlements
declare -a IOS_SUSPICIOUS_ENTITLEMENTS=(
    "com.apple.private"
    "platform-application"
    "com.apple.springboard"
    "com.apple.developer.kernel"
    "get-task-allow"
    "task_for_pid-allow"
    "com.apple.system-task-ports"
)

analyze_mobile_static() {
    set +u
    local content="${1:-}"
    local url="${2:-}"
    set -u
    
    if [ "$MOBILE_STATIC_ANALYSIS" = false ]; then
        analysis_success_none "MOBILE-STATIC"
        return
    fi
    
    log_info "Performing mobile malware static analysis..."
    
    local mobile_findings=()
    local mobile_score=0
    local mobile_report="${OUTPUT_DIR}/mobile_static_analysis.txt"
    
    {
        echo "═══════════════════════════════════════════════"
        echo "MOBILE MALWARE STATIC ANALYSIS"
        echo "═══════════════════════════════════════════════"
        echo "Timestamp: $(date -Iseconds)"
        echo ""
    } > "$mobile_report"
    
    # Check if URL points to mobile app
    local is_mobile_url=false
    local app_type=""
    
    if echo "$url" | grep -qiE '\.(apk|ipa|aab)(\?|$)'; then
        is_mobile_url=true
        app_type=$(echo "$url" | grep -oiE '\.(apk|ipa|aab)' | tr '[:upper:]' '[:lower:]')
        log_warning "URL points to mobile app: $app_type"
        mobile_findings+=("mobile_app_url:$app_type")
        ((mobile_score += 30))
        
        echo "Mobile App URL Detected: $app_type" >> "$mobile_report"
    fi
    
    # Check for mobile-specific patterns in content
    echo "" >> "$mobile_report"
    echo "Mobile Pattern Detection:" >> "$mobile_report"
    
    # Android patterns
    if echo "$content" | safe_grep_qiE 'market://|play\.google\.com/store|android\.intent'; then
        mobile_findings+=("android_market")
        ((mobile_score += 15))
        echo "  ✓ Android Market/Play Store reference" >> "$mobile_report"
    fi
    
    if echo "$content" | safe_grep_qiE 'intent://|android-app://'; then
        mobile_findings+=("android_intent_scheme")
        ((mobile_score += 25))
        log_warning "Android intent scheme detected"
        echo "  ⚠ Android Intent Scheme" >> "$mobile_report"
    fi
    
    # iOS patterns
    if echo "$content" | safe_grep_qiE 'itms-apps://|itms-appss://|apps\.apple\.com'; then
        mobile_findings+=("ios_appstore")
        ((mobile_score += 15))
        echo "  ✓ iOS App Store reference" >> "$mobile_report"
    fi
    
    if echo "$content" | safe_grep_qiE '\.mobileconfig|configuration profile'; then
        mobile_findings+=("ios_mobileconfig")
        ((mobile_score += 45))
        log_threat 50 "iOS MDM configuration profile detected"
        echo "  ⚠ iOS Mobile Configuration Profile" >> "$mobile_report"
    fi
    
    # Enterprise distribution
    if echo "$url" | grep -qiE 'itms-services://\?action=download-manifest'; then
        mobile_findings+=("ios_enterprise_distribution")
        ((mobile_score += 40))
        log_threat 45 "iOS enterprise app distribution detected"
        echo "  ⚠ iOS Enterprise Distribution" >> "$mobile_report"
    fi
    
    # Download and analyze APK if available
    if [ "$is_mobile_url" = true ] && [ "$app_type" = ".apk" ]; then
        local temp_apk="${TEMP_DIR}/downloaded_app.apk"
        
        if timeout 60 curl -sS -L -o "$temp_apk" "$url" 2>/dev/null; then
            log_info "  Analyzing APK file..."
            
            # Use apkanalyzer or aapt if available
            if command -v aapt &> /dev/null; then
                log_info "  Extracting APK permissions..."
                local permissions=$(aapt dump permissions "$temp_apk" 2>/dev/null)
                
                echo "" >> "$mobile_report"
                echo "APK Permissions:" >> "$mobile_report"
                
                for perm in "${DANGEROUS_ANDROID_PERMISSIONS[@]}"; do
                    if echo "$permissions" | grep -q "$perm"; then
                        mobile_findings+=("dangerous_permission:$perm")
                        ((mobile_score += 10))
                        echo "  ⚠ DANGEROUS: $perm" >> "$mobile_report"
                    fi
                done
            fi
            
            # Check for common malware indicators in DEX
            if command -v dexdump &> /dev/null || command -v baksmali &> /dev/null; then
                log_info "  Analyzing DEX code..."
            fi
            
            # String analysis
            local apk_strings=$(unzip -p "$temp_apk" "classes.dex" 2>/dev/null | strings | head -500)
            
            # Check for C2/URL patterns in DEX
            local suspicious_strings=$(echo "$apk_strings" | grep -iE 'http://|https://|\.onion|pastebin|ngrok' | head -10)
            if [ -n "$suspicious_strings" ]; then
                echo "" >> "$mobile_report"
                echo "Suspicious Strings in DEX:" >> "$mobile_report"
                echo "$suspicious_strings" >> "$mobile_report"
                mobile_findings+=("suspicious_strings")
                ((mobile_score += 25))
            fi
            
            rm -f "$temp_apk" 2>/dev/null
        fi
    fi
    
    # Generate summary
    echo "" >> "$mobile_report"
    echo "Analysis Summary:" >> "$mobile_report"
    echo "  Total Findings: ${#mobile_findings[@]}" >> "$mobile_report"
    echo "  Mobile Risk Score: $mobile_score" >> "$mobile_report"
    
    if [ ${#mobile_findings[@]} -gt 0 ]; then
        if [ $mobile_score -ge 40 ]; then
            log_threat $((mobile_score / 2)) "Mobile malware indicators detected"
        fi
        analysis_success_found "MOBILE-STATIC" "${#mobile_findings[@]}" "Score: $mobile_score" "$(IFS=', '; echo "${mobile_findings[*]}")"
    else
        analysis_success_none "MOBILE-STATIC"
    fi
}

# ============================================================================
# AUDIT 7: WEB ARCHIVE ANALYSIS
# ============================================================================

analyze_web_archive() {
    set +u
    local url="${1:-}"
    set -u
    
    if [ "$WEB_ARCHIVE_ANALYSIS" = false ]; then
        analysis_success_none "WEB-ARCHIVE"
        return
    fi
    
    if [ -z "$url" ] || ! echo "$url" | grep -qiE "^https?://"; then
        analysis_success_none "WEB-ARCHIVE"
        return
    fi
    
    log_info "Checking web archives for historical data..."
    
    local archive_findings=()
    local archive_score=0
    local archive_report="${OUTPUT_DIR}/web_archive_analysis.txt"
    
    {
        echo "═══════════════════════════════════════════════"
        echo "WEB ARCHIVE ANALYSIS"
        echo "═══════════════════════════════════════════════"
        echo "Timestamp: $(date -Iseconds)"
        echo "Target URL: $url"
        echo ""
    } > "$archive_report"
    
    # Extract domain
    local domain=$(echo "$url" | sed -E 's|^https?://||' | cut -d'/' -f1)
    
    # 1. Wayback Machine check
    log_info "  Checking Wayback Machine..."
    local wayback_api="http://archive.org/wayback/available?url=$url"
    local wayback_result=$(curl -sS --max-time 15 "$wayback_api" 2>/dev/null)
    
    if [ -n "$wayback_result" ]; then
        local archived_url=$(json_extract_string "$wayback_result" "url")
        local archive_timestamp=$(json_extract_string "$wayback_result" "timestamp")
        
        echo "Wayback Machine:" >> "$archive_report"
        if [ -n "$archived_url" ]; then
            echo "  Status: Found in archive" >> "$archive_report"
            echo "  Archive URL: $archived_url" >> "$archive_report"
            echo "  Timestamp: $archive_timestamp" >> "$archive_report"
            
            archive_findings+=("wayback:found")
            log_forensic "Found in Wayback Machine: $archive_timestamp"
            
            # Fetch and compare archived version
            log_info "  Fetching archived version for comparison..."
            local archived_content=$(curl -sS --max-time 20 "$archived_url" 2>/dev/null | head -c 50000)
            
            if [ -n "$archived_content" ]; then
                # Check for phishing indicators that appeared
                if echo "$archived_content" | grep -qiE 'login|password|verify|suspended'; then
                    archive_findings+=("wayback:phishing_content")
                    ((archive_score += 25))
                fi
            fi
        else
            echo "  Status: Not found in archive" >> "$archive_report"
            archive_findings+=("wayback:not_found")
            # New domains not in archive are more suspicious
            ((archive_score += 15))
        fi
    fi
    
    # 2. Check domain age via archive
    echo "" >> "$archive_report"
    echo "Domain History Analysis:" >> "$archive_report"
    
    local cdx_api="http://web.archive.org/cdx/search/cdx?url=$domain&output=json&limit=5"
    local cdx_result=$(curl -sS --max-time 15 "$cdx_api" 2>/dev/null)
    
    if [ -n "$cdx_result" ] && echo "$cdx_result" | grep -q '\['; then
        # Get first capture date
        local first_capture=$(echo "$cdx_result" | grep -oE '"[0-9]{14}"' | head -1 | tr -d '"')
        if [ -n "$first_capture" ]; then
            local first_year="${first_capture:0:4}"
            local current_year=$(date +%Y)
            local age=$((current_year - first_year))
            
            echo "  First Archive: $first_capture" >> "$archive_report"
            echo "  Approximate Age: $age years" >> "$archive_report"
            
            if [ "$age" -lt 1 ]; then
                log_warning "Domain is less than 1 year old in archives"
                archive_findings+=("new_domain:$age")
                ((archive_score += 20))
            fi
        fi
    fi
    
    # 3. Archive.today check
    log_info "  Checking archive.today..."
    local archive_today_url="https://archive.today/$url"
    local archive_today_check=$(curl -sS --max-time 10 -o /dev/null -w "%{http_code}" "$archive_today_url" 2>/dev/null)
    
    echo "" >> "$archive_report"
    echo "Archive.today:" >> "$archive_report"
    if [ "$archive_today_check" = "200" ]; then
        echo "  Status: Found" >> "$archive_report"
        echo "  URL: $archive_today_url" >> "$archive_report"
        archive_findings+=("archive_today:found")
    else
        echo "  Status: Not found" >> "$archive_report"
    fi
    
    # Generate summary
    echo "" >> "$archive_report"
    echo "Analysis Summary:" >> "$archive_report"
    echo "  Total Findings: ${#archive_findings[@]}" >> "$archive_report"
    echo "  Archive Risk Score: $archive_score" >> "$archive_report"
    
    if [ ${#archive_findings[@]} -gt 0 ]; then
        if [ $archive_score -ge 25 ]; then
            log_warning "Web archive analysis indicates suspicious history"
        fi
        analysis_success_found "WEB-ARCHIVE" "${#archive_findings[@]}" "Score: $archive_score" "$(IFS=', '; echo "${archive_findings[*]}")"
    else
        analysis_success_none "WEB-ARCHIVE"
    fi
}

# ============================================================================
# AUDIT 8: EMBEDDED/EXTERNAL CONTENT EXTRACTION (RECURSIVE CRAWL)
# ============================================================================

# Maximum crawl depth
MAX_CRAWL_DEPTH=2
CRAWL_TIMEOUT=30

# Known content hosting services to crawl
declare -a CRAWL_TARGET_SERVICES=(
    "docs.google.com"
    "drive.google.com"
    "pastebin.com"
    "paste.ee"
    "ghostbin.co"
    "hastebin.com"
    "gist.github.com"
    "raw.githubusercontent.com"
    "dropbox.com"
    "onedrive.live.com"
    "1drv.ms"
    "mega.nz"
    "rentry.co"
    "privatebin.net"
)

analyze_recursive_crawl() {
    set +u
    local url="${1:-}"
    set -u
    local depth="${2:-0}"
    
    if [ "$RECURSIVE_CRAWL" = false ]; then
        analysis_success_none "RECURSIVE-CRAWL"
        return
    fi
    
    if [ "$depth" -ge "$MAX_CRAWL_DEPTH" ]; then
        return
    fi
    
    if [ -z "$url" ] || ! echo "$url" | grep -qiE "^https?://"; then
        analysis_success_none "RECURSIVE-CRAWL"
        return
    fi
    
    log_info "Performing recursive content extraction (depth: $depth)..."
    
    local crawl_findings=()
    local crawl_score=0
    local crawl_report="${OUTPUT_DIR}/recursive_crawl.txt"
    
    if [ "$depth" -eq 0 ]; then
        {
            echo "═══════════════════════════════════════════════"
            echo "RECURSIVE CONTENT EXTRACTION"
            echo "═══════════════════════════════════════════════"
            echo "Timestamp: $(date -Iseconds)"
            echo "Initial URL: $url"
            echo "Max Depth: $MAX_CRAWL_DEPTH"
            echo ""
        } > "$crawl_report"
    fi
    
    # Check if URL is a content hosting service
    local domain=$(echo "$url" | sed -E 's|^https?://||' | cut -d'/' -f1)
    local is_target_service=false
    
    for service in "${CRAWL_TARGET_SERVICES[@]}"; do
        if echo "$domain" | grep -qi "$service"; then
            is_target_service=true
            break
        fi
    done
    
    if [ "$is_target_service" = true ]; then
        log_info "  Target service detected: $domain (depth $depth)"
        
        # Fetch content
        local fetched_content=$(timeout $CRAWL_TIMEOUT curl -sS -L --max-time $((CRAWL_TIMEOUT - 5)) \
            -A "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36" \
            "$url" 2>/dev/null | head -c 200000)
        
        if [ -n "$fetched_content" ]; then
            echo "Depth $depth - Fetched: $url" >> "$crawl_report"
            echo "  Content Length: ${#fetched_content} bytes" >> "$crawl_report"
            
            crawl_findings+=("fetched:$domain")
            
            # Analyze fetched content
            # Check for malicious patterns
            if echo "$fetched_content" | grep -qiE 'powershell|cmd\.exe|IEX|Invoke-|downloadstring'; then
                crawl_findings+=("malicious_content:$domain")
                ((crawl_score += 50))
                log_threat 55 "Malicious content found in linked resource"
                echo "  ⚠ MALICIOUS CONTENT DETECTED" >> "$crawl_report"
            fi
            
            # Check for additional URLs to crawl
            local nested_urls=$(echo "$fetched_content" | grep -oiE "https?://[^[:space:]\"<>'']+" | sort -u | head -10)
            
            if [ -n "$nested_urls" ]; then
                echo "  Nested URLs found:" >> "$crawl_report"
                
                while IFS= read -r nested_url; do
                    [ -z "$nested_url" ] && continue
                    echo "    - $nested_url" >> "$crawl_report"
                    
                    # Record as IOC
                    record_ioc "nested_url" "$nested_url" "Found in crawled content at depth $depth"
                    
                    # Recursive crawl (if target service)
                    for service in "${CRAWL_TARGET_SERVICES[@]}"; do
                        if echo "$nested_url" | grep -qi "$service"; then
                            analyze_recursive_crawl "$nested_url" $((depth + 1))
                            break
                        fi
                    done
                done <<< "$nested_urls"
            fi
            
            # Extract and analyze base64 content
            local base64_content=$(echo "$fetched_content" | grep -oE '[A-Za-z0-9+/=]{50,}' | head -5)
            if [ -n "$base64_content" ]; then
                echo "  Base64 content found:" >> "$crawl_report"
                while IFS= read -r b64; do
                    local decoded=$(echo "$b64" | base64 -d 2>/dev/null | head -c 1000)
                    if [ -n "$decoded" ]; then
                        if echo "$decoded" | grep -qiE 'powershell|cmd|wget|curl|python'; then
                            crawl_findings+=("encoded_payload:base64")
                            ((crawl_score += 40))
                            log_threat 45 "Base64 encoded payload found"
                        fi
                    fi
                done <<< "$base64_content"
            fi
        fi
    fi
    
    # Generate summary (only at depth 0)
    if [ "$depth" -eq 0 ]; then
        echo "" >> "$crawl_report"
        echo "Analysis Summary:" >> "$crawl_report"
        echo "  Total Findings: ${#crawl_findings[@]}" >> "$crawl_report"
        echo "  Crawl Risk Score: $crawl_score" >> "$crawl_report"
        
        if [ ${#crawl_findings[@]} -gt 0 ]; then
            if [ $crawl_score -ge 40 ]; then
                log_threat $((crawl_score / 2)) "Recursive crawl revealed malicious content"
            fi
            analysis_success_found "RECURSIVE-CRAWL" "${#crawl_findings[@]}" "Score: $crawl_score" "$(IFS=', '; echo "${crawl_findings[*]}")"
        else
            analysis_success_none "RECURSIVE-CRAWL"
        fi
    fi
}

# ============================================================================
# AUDIT 9: VISUAL ADVERSARIAL AI ATTACK DETECTION
# ============================================================================

analyze_adversarial_ai() {
    set +u
    local image="${1:-}"
    set -u
    
    if [ "$ADVERSARIAL_AI_DETECTION" = false ]; then
        analysis_success_none "ADVERSARIAL-AI"
        return
    fi
    
    if [ ! -f "$image" ]; then
        analysis_error "ADVERSARIAL-AI" "Image file not found"
        return
    fi
    
    log_info "Analyzing for adversarial AI attack patterns..."
    
    local adv_findings=()
    local adv_score=0
    local adv_report="${OUTPUT_DIR}/adversarial_ai_analysis.txt"
    
    {
        echo "═══════════════════════════════════════════════"
        echo "ADVERSARIAL AI ATTACK DETECTION"
        echo "═══════════════════════════════════════════════"
        echo "Timestamp: $(date -Iseconds)"
        echo "Image: $image"
        echo ""
    } > "$adv_report"
    
    # AUDIT FIX: Use base64 to safely pass image path to Python (prevents segfault)
    local encoded_image
    encoded_image=$(printf '%s' "$image" | base64 2>/dev/null) || return
    
    # Python-based adversarial detection
    local adv_analysis=$(python3 - "$encoded_image" 2>/dev/null <<'EOF'
import json
import sys
import base64

try:
    image_path = base64.b64decode(sys.argv[1] if len(sys.argv) > 1 else '').decode('utf-8', errors='ignore')
    
    from PIL import Image
    import numpy as np
    
    img = Image.open(image_path)
    img_array = np.array(img)
    
    results = {
        'size': img.size,
        'mode': img.mode,
        'format': img.format,
    }
    
    # Calculate image statistics
    if len(img_array.shape) >= 2:
        results['mean'] = float(np.mean(img_array))
        results['std'] = float(np.std(img_array))
        results['min'] = int(np.min(img_array))
        results['max'] = int(np.max(img_array))
        
        # Check for adversarial perturbation indicators
        
        # 1. High-frequency noise detection
        if len(img_array.shape) == 3:
            gray = np.mean(img_array, axis=2)
        else:
            gray = img_array
        
        # Calculate Laplacian variance (edge/noise detection)
        from scipy import ndimage
        laplacian = ndimage.laplace(gray.astype(float))
        laplacian_var = float(np.var(laplacian))
        results['laplacian_variance'] = round(laplacian_var, 4)
        
        # High laplacian variance can indicate adversarial noise
        if laplacian_var > 500:
            results['high_frequency_noise'] = True
            results['adversarial_indicator'] = 'HIGH_FREQUENCY_PERTURBATION'
        
        # 2. Check for unusual pixel distributions
        pixel_hist, _ = np.histogram(img_array.flatten(), bins=256, range=(0, 256))
        
        # Adversarial examples often have unusual histogram patterns
        hist_entropy = -np.sum(pixel_hist[pixel_hist > 0] / pixel_hist.sum() *
                               np.log2(pixel_hist[pixel_hist > 0] / pixel_hist.sum()))
        results['histogram_entropy'] = round(hist_entropy, 4)
        
        # Very low entropy suggests manipulation
        if hist_entropy < 4.0:
            results['unusual_distribution'] = True
        
        # 3. Check for patch attacks (localized perturbations)
        # Look for rectangular regions with different statistics
        h, w = gray.shape
        patch_size = min(h, w) // 4
        if patch_size > 10:
            center_patch = gray[h//4:3*h//4, w//4:3*w//4]
            corner_patches = [
                gray[:patch_size, :patch_size],
                gray[:patch_size, -patch_size:],
                gray[-patch_size:, :patch_size],
                gray[-patch_size:, -patch_size:]
            ]
            
            center_mean = np.mean(center_patch)
            corner_means = [np.mean(p) for p in corner_patches]
            
            # Large difference between center and corners could indicate patch attack
            max_diff = max(abs(center_mean - cm) for cm in corner_means)
            results['patch_diff'] = round(max_diff, 4)
            
            if max_diff > 50:
                results['possible_patch_attack'] = True
                results['adversarial_indicator'] = 'PATCH_ATTACK'
        
        # 4. JPEG artifacts analysis (adversarial often added post-compression)
        if img.format == 'JPEG':
            # DCT block boundary analysis would go here
            results['jpeg_analysis'] = 'JPEG format detected'
    
    print(json.dumps(results, indent=2))
    
except ImportError as e:
    print(json.dumps({'error': f'Missing dependency: {e}'}))
except Exception as e:
    print(json.dumps({'error': str(e)}))
EOF
)
    
    if [ -n "$adv_analysis" ]; then
        echo "Image Analysis Results:" >> "$adv_report"
        echo "$adv_analysis" >> "$adv_report"
        
        # Parse results
        if echo "$adv_analysis" | grep -q '"adversarial_indicator"'; then
            local indicator=$(json_extract_string "$adv_analysis" "adversarial_indicator")
            adv_findings+=("adversarial:$indicator")
            ((adv_score += 45))
            log_threat 50 "Adversarial AI attack indicator: $indicator"
        fi
        
        if echo "$adv_analysis" | grep -q '"high_frequency_noise":[[:space:]]*true'; then
            adv_findings+=("high_frequency_noise")
            ((adv_score += 30))
            log_warning "High-frequency noise detected (possible perturbation)"
        fi
        
        if echo "$adv_analysis" | grep -q '"possible_patch_attack":[[:space:]]*true'; then
            adv_findings+=("patch_attack")
            ((adv_score += 40))
            log_threat 45 "Possible adversarial patch attack detected"
        fi
        
        if echo "$adv_analysis" | grep -q '"unusual_distribution":[[:space:]]*true'; then
            adv_findings+=("unusual_distribution")
            ((adv_score += 20))
            log_warning "Unusual pixel distribution detected"
        fi
    fi
    
    # Generate summary
    echo "" >> "$adv_report"
    echo "Analysis Summary:" >> "$adv_report"
    echo "  Total Findings: ${#adv_findings[@]}" >> "$adv_report"
    echo "  Adversarial Risk Score: $adv_score" >> "$adv_report"
    
    if [ ${#adv_findings[@]} -gt 0 ]; then
        analysis_success_found "ADVERSARIAL-AI" "${#adv_findings[@]}" "Score: $adv_score" "$(IFS=', '; echo "${adv_findings[*]}")"
    else
        analysis_success_none "ADVERSARIAL-AI"
    fi
}

# ============================================================================
# AUDIT 10: COVERT CHANNEL DETECTION
# ============================================================================

# DNS covert channel indicators
declare -a DNS_COVERT_INDICATORS=(
    "TXT record with base64"
    "Unusually long subdomain"
    "High entropy subdomain"
    "Rapid DNS queries"
    "Non-standard record types"
)

analyze_covert_channels() {
    set +u
    local content="${1:-}"
    local url="${2:-}"
    set -u
    
    if [ "$COVERT_CHANNEL_DETECTION" = false ]; then
        analysis_success_none "COVERT-CHANNELS"
        return
    fi
    
    log_info "Analyzing for covert channel indicators..."
    
    local covert_findings=()
    local covert_score=0
    local covert_report="${OUTPUT_DIR}/covert_channel_analysis.txt"
    
    {
        echo "═══════════════════════════════════════════════"
        echo "COVERT CHANNEL DETECTION"
        echo "═══════════════════════════════════════════════"
        echo "Timestamp: $(date -Iseconds)"
        echo ""
    } > "$covert_report"
    
    # Extract domain if URL
    local domain=""
    if echo "$url" | grep -qiE "^https?://"; then
        domain=$(echo "$url" | sed -E 's|^https?://||' | cut -d'/' -f1)
    fi
    
    echo "DNS Covert Channel Analysis:" >> "$covert_report"
    
    if [ -n "$domain" ]; then
        # 1. Check for DNS tunneling indicators
        log_info "  Checking DNS tunneling indicators..."
        
        # Get TXT records
        local txt_records=$(dig +short TXT "$domain" 2>/dev/null)
        if [ -n "$txt_records" ]; then
            echo "  TXT Records: $txt_records" >> "$covert_report"
            
            # Check for base64 in TXT
            if echo "$txt_records" | grep -qE '[A-Za-z0-9+/=]{50,}'; then
                covert_findings+=("dns_txt_base64")
                ((covert_score += 35))
                log_warning "Base64 content in DNS TXT record"
            fi
            
            # Long TXT records
            local txt_len=$(echo "$txt_records" | wc -c)
            if [ "$txt_len" -gt 255 ]; then
                covert_findings+=("long_txt_record:$txt_len")
                ((covert_score += 20))
            fi
        fi
        
        # 2. Subdomain entropy check
        local subdomain=$(echo "$domain" | rev | cut -d'.' -f3- | rev)
        if [ -n "$subdomain" ] && [ ${#subdomain} -gt 20 ]; then
            # Calculate entropy
            # FIXED: Use printf and stdin to safely pass subdomain to Python
            local entropy
            entropy=$(printf '%s' "$subdomain" | $(get_python_cmd) 2>/dev/null <<'EOF'
import sys, math
from collections import Counter
s = sys.stdin.read().strip()
if len(s) > 0:
    freq = Counter(s)
    probs = [c/len(s) for c in freq.values()]
    entropy = -sum(p * math.log2(p) for p in probs if p > 0)
    print(round(entropy, 4))
else:
    print('0')
EOF
            )
            
            echo "  Subdomain: $subdomain" >> "$covert_report"
            echo "  Subdomain Entropy: ${entropy:-N/A}" >> "$covert_report"
            
            if [ -n "$entropy" ] && float_gt "$entropy" "3.5"; then
                covert_findings+=("high_entropy_subdomain:$entropy")
                ((covert_score += 40))
                log_threat 45 "High-entropy subdomain detected (possible DNS tunneling)"
            fi
        fi
        
        # 3. Check for DNS over HTTPS indicators
        if echo "$content" | safe_grep_qiE 'dns-query|application/dns-message|cloudflare-dns|dns\.google'; then
            covert_findings+=("doh_indicator")
            ((covert_score += 15))
            log_info "DNS-over-HTTPS indicator detected"
        fi
    fi
    
    echo "" >> "$covert_report"
    echo "Protocol Covert Channel Analysis:" >> "$covert_report"
    
    # 4. ICMP covert channel patterns
    if echo "$content" | safe_grep_qiE 'icmp|ping.*-p.*[a-f0-9]{16}|ping.*data'; then
        covert_findings+=("icmp_covert")
        ((covert_score += 30))
        log_warning "ICMP covert channel indicator"
    fi
    
    # 5. HTTP header covert channels
    if echo "$content" | safe_grep_qiE 'X-[A-Za-z0-9-]*:[[:space:]]*[A-Za-z0-9+/=]{32,}'; then
        covert_findings+=("http_header_covert")
        ((covert_score += 25))
        log_warning "HTTP header covert channel pattern"
    fi
    
    # 6. Steganography indicators in URL
    if echo "$url" | grep -qE '[A-Za-z0-9+/=]{64,}'; then
        covert_findings+=("url_encoded_payload")
        ((covert_score += 20))
    fi
    
    # Generate summary
    echo "" >> "$covert_report"
    echo "Analysis Summary:" >> "$covert_report"
    echo "  Total Findings: ${#covert_findings[@]}" >> "$covert_report"
    echo "  Covert Channel Risk Score: $covert_score" >> "$covert_report"
    
    if [ ${#covert_findings[@]} -gt 0 ]; then
        if [ $covert_score -ge 35 ]; then
            log_threat $((covert_score / 2)) "Covert channel indicators detected"
        fi
        analysis_success_found "COVERT-CHANNELS" "${#covert_findings[@]}" "Score: $covert_score" "$(IFS=', '; echo "${covert_findings[*]}")"
    else
        analysis_success_none "COVERT-CHANNELS"
    fi
}

# ============================================================================
# AUDIT 11: CROSS-QR STEGANOGRAPHY/CHAINING DETECTION
# ============================================================================

# Array to track QR codes in batch analysis
declare -a QR_CHAIN_HASHES=()
declare -a QR_CHAIN_CONTENTS=()

analyze_qr_chaining() {
    set +u
    local content="${1:-}"
    local image="${2:-}"
    set -u
    local batch_mode="${3:-false}"
    
    if [ "$CROSS_QR_CHAIN_DETECTION" = false ]; then
        analysis_success_none "QR-CHAINING"
        return
    fi
    
    log_info "Analyzing for cross-QR chaining/sequencing..."
    
    local chain_findings=()
    local chain_score=0
    local chain_report="${OUTPUT_DIR}/qr_chaining_analysis.txt"
    
    {
        echo "═══════════════════════════════════════════════"
        echo "CROSS-QR CHAINING/STEGANOGRAPHY DETECTION"
        echo "═══════════════════════════════════════════════"
        echo "Timestamp: $(date -Iseconds)"
        echo ""
    } >> "$chain_report"
    
    # 1. Check for sequence indicators in content
    echo "Sequence Pattern Detection:" >> "$chain_report"
    
    # Part X of Y patterns
    if echo "$content" | safe_grep_qiE 'part[[:space:]]*[0-9]+[[:space:]]*(of|/)[[:space:]]*[0-9]+'; then
        local sequence_info=$(echo "$content" | safe_grep_oiE 'part[[:space:]]*[0-9]+[[:space:]]*(of|/)[[:space:]]*[0-9]+' | head -1)
        chain_findings+=("sequence_marker:$sequence_info")
        ((chain_score += 40))
        log_threat 45 "QR sequence marker detected: $sequence_info"
        echo "  ⚠ SEQUENCE MARKER: $sequence_info" >> "$chain_report"
    fi
    
    # Fragment patterns
    if echo "$content" | safe_grep_qiE '\[fragment\]|\[chunk\]|\[segment\]|##[0-9]+##'; then
        chain_findings+=("fragment_marker")
        ((chain_score += 35))
        log_warning "Fragment marker detected in QR"
    fi
    
    # 2. Check for base64 fragment patterns
    local base64_fragment=$(echo "$content" | safe_grep_oE '^[A-Za-z0-9+/]+={0,2}$')
    if [ -n "$base64_fragment" ] && [ ${#base64_fragment} -gt 50 ]; then
        # Pure base64 content suggests it might be a fragment
        local decoded=$(echo "$base64_fragment" | base64 -d 2>/dev/null | head -c 100)
        
        # If doesn't decode to readable text, likely a fragment
        if [ -n "$decoded" ]; then
            local readable_ratio=$(echo "$decoded" | tr -dc '[:print:]' | wc -c)
            local total_len=${#decoded}
            
            if [ "$total_len" -gt 0 ] && [ "$readable_ratio" -lt $((total_len / 2)) ]; then
                chain_findings+=("possible_fragment:base64")
                ((chain_score += 30))
                echo "  ⚠ Possible base64 fragment (low readability)" >> "$chain_report"
            fi
        fi
    fi
    
    # 3. Check for hex fragment patterns
    if echo "$content" | safe_grep_qE '^[0-9a-fA-F]{64,}$'; then
        chain_findings+=("hex_fragment")
        ((chain_score += 25))
        log_warning "Hex-encoded fragment pattern detected"
    fi
    
    # 4. Batch analysis - check for related QR codes
    if [ "$batch_mode" = true ]; then
        echo "" >> "$chain_report"
        echo "Batch Correlation Analysis:" >> "$chain_report"
        
        # Add current content to tracking
        local content_hash=$(echo "$content" | md5sum | cut -d' ' -f1)
        QR_CHAIN_HASHES+=("$content_hash")
        QR_CHAIN_CONTENTS+=("$content")
        
        echo "  QR codes analyzed: ${#QR_CHAIN_HASHES[@]}" >> "$chain_report"
        
        # Check for content similarity
        if [ ${#QR_CHAIN_CONTENTS[@]} -gt 1 ]; then
            local similar_count=0
            for prev_content in "${QR_CHAIN_CONTENTS[@]:0:${#QR_CHAIN_CONTENTS[@]}-1}"; do
                # Simple similarity check
                local common_prefix=$(printf '%s\n%s\n' "$prev_content" "$content" |
                    sed 'N;s/^\(.*\).*\n\1.*$/\1/' | head -1)
                if [ ${#common_prefix} -gt 20 ]; then
                    ((similar_count++))
                fi
            done
            
            if [ "$similar_count" -gt 0 ]; then
                chain_findings+=("similar_qr_codes:$similar_count")
                ((chain_score += 25))
                log_warning "$similar_count similar QR codes detected (possible chain)"
            fi
        fi
    fi
    
    # 5. Concatenation instruction patterns
    if echo "$content" | safe_grep_qiE 'concat|append|combine|merge|join.*next'; then
        chain_findings+=("concatenation_instruction")
        ((chain_score += 35))
        log_warning "Concatenation instruction detected"
    fi
    
    # Generate summary
    echo "" >> "$chain_report"
    echo "Analysis Summary:" >> "$chain_report"
    echo "  Total Findings: ${#chain_findings[@]}" >> "$chain_report"
    echo "  Chain Risk Score: $chain_score" >> "$chain_report"
    
    if [ ${#chain_findings[@]} -gt 0 ]; then
        analysis_success_found "QR-CHAINING" "${#chain_findings[@]}" "Score: $chain_score" "$(IFS=', '; echo "${chain_findings[*]}")"
    else
        analysis_success_none "QR-CHAINING"
    fi
}

# ============================================================================
# AUDIT 12: QR FACTORY/TEMPLATE SPOOFING DETECTION
# ============================================================================

# Known QR template signatures (visual patterns and content patterns)
declare -A TEMPLATE_SIGNATURES=(
    # COVID-related
    ["covid_pass"]="EU Digital COVID|NHS COVID Pass|Vaccination Certificate|CERTIFICATE VERIFIED"
    ["green_pass"]="Green Pass|EU DCC|Digital Green Certificate"
    
    # Shipping/Logistics
    ["fedex"]="fedex\.com|FedEx|tracking.*fedex"
    ["ups"]="ups\.com|UPS|tracking.*ups|worldship"
    ["dhl"]="dhl\.(com|de)|DHL|shipment.*dhl"
    ["usps"]="usps\.com|USPS|Postal Service"
    
    # Payments
    ["paypal"]="paypal\.com|PayPal|payment.*paypal"
    ["venmo"]="venmo\.com|Venmo"
    ["zelle"]="zellepay|Zelle"
    ["cashapp"]="cash\.app|CashApp|\$cashtag"
    
    # Banking
    ["bank_generic"]="bank.*login|account.*verify|secure.*banking"
    ["chase"]="chase\.com|Chase Bank"
    ["wellsfargo"]="wellsfargo\.com|Wells Fargo"
    ["bofa"]="bankofamerica\.com|Bank of America"
    
    # Social Media
    ["instagram"]="instagram\.com|@instagram"
    ["twitter"]="twitter\.com|@twitter|x\.com"
    ["facebook"]="facebook\.com|fb\.com|@facebook"
    ["linkedin"]="linkedin\.com|LinkedIn"
    
    # Crypto
    ["coinbase"]="coinbase\.com|Coinbase"
    ["binance"]="binance\.com|Binance"
    ["crypto_wallet"]="bitcoin:|ethereum:|wallet.*crypto"
    
    # Government
    ["irs"]="irs\.gov|Internal Revenue|tax.*refund"
    ["ssa"]="ssa\.gov|Social Security"
    ["dmv"]="dmv\.|Department of Motor"
)

# Known malicious template patterns
declare -a MALICIOUS_TEMPLATE_PATTERNS=(
    "verify.*account.*immediately"
    "suspended.*click.*restore"
    "confirm.*identity.*24.hours"
    "unusual.*activity.*login"
    "prize.*claim.*now"
    "lottery.*winner.*congratulations"
    "package.*delivery.*failed.*confirm"
    "invoice.*attached.*payment"
    "refund.*pending.*verify"
)

analyze_template_spoofing() {
    set +u
    local content="${1:-}"
    local image="${2:-}"
    set -u
    
    if [ "$TEMPLATE_SPOOF_DETECTION" = false ]; then
        analysis_success_none "TEMPLATE-SPOOFING"
        return
    fi
    
    log_info "Analyzing for QR template spoofing..."
    
    local template_findings=()
    local template_score=0
    local matched_templates=()
    local template_report="${OUTPUT_DIR}/template_spoofing_analysis.txt"
    
    {
        echo "═══════════════════════════════════════════════"
        echo "QR TEMPLATE SPOOFING DETECTION"
        echo "═══════════════════════════════════════════════"
        echo "Timestamp: $(date -Iseconds)"
        echo ""
    } > "$template_report"
    
    # 1. Check against known template signatures
    echo "Template Signature Matching:" >> "$template_report"
    
    for template_name in "${!TEMPLATE_SIGNATURES[@]}"; do
        local pattern="${TEMPLATE_SIGNATURES[$template_name]}"
        if echo "$content" | safe_grep_qiE "$pattern"; then
            matched_templates+=("$template_name")
            template_findings+=("template_match:$template_name")
            ((template_score += 20))
            echo "  ✓ Matched template: $template_name" >> "$template_report"
            log_info "QR content matches $template_name template"
        fi
    done
    
    # 2. Check for template impersonation indicators
    echo "" >> "$template_report"
    echo "Impersonation Indicators:" >> "$template_report"
    
    # Check if template match but URL doesn't match expected domain
    for template in "${matched_templates[@]}"; do
        local expected_domain=""
        case "$template" in
            "fedex") expected_domain="fedex.com" ;;
            "ups") expected_domain="ups.com" ;;
            "dhl") expected_domain="dhl.com" ;;
            "paypal") expected_domain="paypal.com" ;;
            "chase") expected_domain="chase.com" ;;
            "coinbase") expected_domain="coinbase.com" ;;
            "irs") expected_domain="irs.gov" ;;
        esac
        
        if [ -n "$expected_domain" ]; then
            # Check if URL in content matches expected domain
            local actual_domain=$(echo "$content" | safe_grep_oiE 'https?://[^/]+' | head -1 | sed 's|https\?://||')
            
            if [ -n "$actual_domain" ] && ! echo "$actual_domain" | grep -qi "$expected_domain"; then
                template_findings+=("domain_mismatch:$template:$actual_domain")
                ((template_score += 50))
                log_threat 55 "Template impersonation: $template template but domain is $actual_domain"
                echo "  ⚠ IMPERSONATION: $template template with wrong domain: $actual_domain" >> "$template_report"
            fi
        fi
    done
    
    # 3. Check for malicious template patterns
    echo "" >> "$template_report"
    echo "Malicious Pattern Detection:" >> "$template_report"
    
    for pattern in "${MALICIOUS_TEMPLATE_PATTERNS[@]}"; do
        if echo "$content" | safe_grep_qiE "$pattern"; then
            template_findings+=("malicious_template:$pattern")
            ((template_score += 35))
            log_warning "Malicious template pattern: $pattern"
            echo "  ⚠ MALICIOUS: $pattern" >> "$template_report"
        fi
    done
    
    # 4. Visual template analysis (if image provided)
    if [ -n "$image" ] && [ -f "$image" ]; then
        echo "" >> "$template_report"
        echo "Visual Template Analysis:" >> "$template_report"
        
        # Check image dimensions for known QR template sizes
        local dimensions=$(identify -format "%wx%h" "$image" 2>/dev/null)
        echo "  Image Dimensions: $dimensions" >> "$template_report"
        
        # COVID pass QR codes are typically specific sizes
        if [ "$dimensions" = "300x300" ] || [ "$dimensions" = "400x400" ]; then
            if echo "$content" | safe_grep_qiE "covid|vaccin|certificate|pass"; then
                template_findings+=("possible_covid_pass_template")
                ((template_score += 30))
            fi
        fi
        
        # Check for logo embedding (common in branded QR)
        local color_count=$(identify -format "%k" "$image" 2>/dev/null)
        if [ -n "$color_count" ] && [ "$color_count" -gt 10 ]; then
            echo "  Color Count: $color_count (possible logo/branding)" >> "$template_report"
            template_findings+=("branded_qr")
        fi
    fi
    
    # 5. COVID-specific checks
    if echo "$content" | safe_grep_qiE "covid|vaccin|certificate|immuniz"; then
        echo "" >> "$template_report"
        echo "COVID Certificate Analysis:" >> "$template_report"
        
        # Check for fake EU DCC format
        if echo "$content" | safe_grep_qE "HC1:"; then
            template_findings+=("eu_dcc_format")
            log_info "EU Digital COVID Certificate format detected"
            echo "  Format: EU DCC (HC1:)" >> "$template_report"
            
            # Validate structure
            local dcc_payload=$(echo "$content" | safe_grep_oE "HC1:.*" | head -1)
            if [ ${#dcc_payload} -lt 100 ]; then
                template_findings+=("invalid_dcc_short")
                ((template_score += 40))
                log_warning "Suspiciously short DCC payload"
            fi
        fi
    fi
    
    # Generate summary
    echo "" >> "$template_report"
    echo "Analysis Summary:" >> "$template_report"
    echo "  Templates Matched: ${#matched_templates[@]}" >> "$template_report"
    echo "  Total Findings: ${#template_findings[@]}" >> "$template_report"
    echo "  Template Risk Score: $template_score" >> "$template_report"
    
    if [ ${#template_findings[@]} -gt 0 ]; then
        if [ $template_score -ge 50 ]; then
            log_threat $((template_score / 2)) "Template spoofing indicators detected"
        fi
        analysis_success_found "TEMPLATE-SPOOFING" "${#template_findings[@]}" "Score: $template_score" "$(IFS=', '; echo "${template_findings[*]}")"
    else
        analysis_success_none "TEMPLATE-SPOOFING"
    fi
}

# ============================================================================
# AUDIT 13: SOCIAL MEDIA/MARKETING LINK DETECTION
# ============================================================================

# Marketing/link aggregation services
declare -a MARKETING_LINK_SERVICES=(
    # Link aggregators
    "linktr.ee" "linktree.com" "link.bio" "lnk.bio" "beacons.ai"
    "stan.store" "hoo.be" "bio.fm" "tap.bio" "allmylinks.com"
    "contactinbio.com" "linkin.bio" "lnk.to" "msha.ke" "withkoji.com"
    
    # URL shorteners (additional)
    "buff.ly" "ow.ly" "dlvr.it" "po.st" "soo.gd" "mcaf.ee"
    "twurl.nl" "trib.al" "snip.ly" "tinycc.com" "short.io"
    "rebrand.ly" "bl.ink" "clickmeter.com" "t2mio.com"
    
    # Social media shorteners
    "fb.me" "fb.com" "m.me" "wa.me" "ig.me"
    "youtu.be" "amzn.to" "ebay.to" "etsy.me"
    
    # Marketing platforms
    "mailchi.mp" "campaign-archive.com" "list-manage.com"
    "sendgrid.net" "constantcontact.com" "aweber.com"
    "getresponse.com" "hubspot.net" "marketo.com"
    "mailgun.org" "sendpulse.com" "sendinblue.com"
    
    # Tracking/redirect services
    "click.redditmail.com" "links.e.*.com" "click.e.*.com"
    "email.*.com" "t.e.*.com" "go.*.com" "click.*.com"
    
    # Affiliate tracking
    "go2cloud.org" "afftrack.com" "tkqlhce.com" "anrdoezrs.net"
    "jdoqocy.com" "kqzyfj.com" "dpbolvw.net" "commission-junction"
    "shareasale.com" "awin1.com" "prf.hn" "pntra.com"
)

# Tracking parameter patterns
declare -a TRACKING_PARAMS=(
    "utm_source" "utm_medium" "utm_campaign" "utm_content" "utm_term"
    "fbclid" "gclid" "msclkid" "mc_eid" "mc_cid"
    "ref" "referrer" "source" "campaign" "affiliate"
    "trk" "track" "click_id" "clickid" "subid"
    "s1" "s2" "s3" "s4" "s5"
    "aff_id" "aff_sub" "aff_click_id"
)

analyze_social_marketing_links() {
    set +u
    local content="${1:-}"
    set -u
    
    if [ "$SOCIAL_MEDIA_LINK_DETECTION" = false ]; then
        analysis_success_none "SOCIAL-MARKETING"
        return
    fi
    
    log_info "Analyzing social media/marketing links..."
    
    local social_findings=()
    local social_score=0
    local marketing_report="${OUTPUT_DIR}/social_marketing_analysis.txt"
    
    {
        echo "═══════════════════════════════════════════════"
        echo "SOCIAL MEDIA/MARKETING LINK ANALYSIS"
        echo "═══════════════════════════════════════════════"
        echo "Timestamp: $(date -Iseconds)"
        echo ""
    } > "$marketing_report"
    
    # 1. Check for marketing link services
    echo "Marketing Service Detection:" >> "$marketing_report"
    
    for service in "${MARKETING_LINK_SERVICES[@]}"; do
        if echo "$content" | safe_grep_qiE "$service"; then
            social_findings+=("marketing_service:$service")
            ((social_score += 15))
            echo "  ✓ Detected: $service" >> "$marketing_report"
            log_info "Marketing link service: $service"
        fi
    done
    
    # 2. Check for tracking parameters
    echo "" >> "$marketing_report"
    echo "Tracking Parameter Analysis:" >> "$marketing_report"
    
    local tracking_count=0
    for param in "${TRACKING_PARAMS[@]}"; do
        if echo "$content" | safe_grep_qiE "[?&]$param="; then
            ((tracking_count++))
            social_findings+=("tracking_param:$param")
            echo "  ✓ $param" >> "$marketing_report"
        fi
    done
    
    if [ "$tracking_count" -gt 3 ]; then
        ((social_score += 20))
        log_warning "Multiple tracking parameters detected ($tracking_count)"
    fi
    
    # 3. Check for redirect chains
    echo "" >> "$marketing_report"
    echo "Redirect Chain Analysis:" >> "$marketing_report"
    
    if echo "$content" | safe_grep_qiE "https?://[^/]+/(redirect|redir|go|click|track|link|out)"; then
        social_findings+=("redirect_path")
        ((social_score += 15))
        echo "  ⚠ Redirect path pattern detected" >> "$marketing_report"
    fi
    
    # 4. Follow and analyze short URLs
    if echo "$content" | safe_grep_qiE "bit\.ly|tinyurl|ow\.ly|t\.co|goo\.gl|is\.gd"; then
        local short_url=$(echo "$content" | safe_grep_oiE "https?://(bit\.ly|tinyurl\.com|ow\.ly|t\.co|goo\.gl|is\.gd)/[A-Za-z0-9]+" | head -1)
        
        if [ -n "$short_url" ]; then
            echo "  Short URL: $short_url" >> "$marketing_report"
            
            # Attempt to expand
            local expanded=$(curl -sS -o /dev/null -w '%{url_effective}' -L --max-time 10 "$short_url" 2>/dev/null)
            
            if [ -n "$expanded" ] && [ "$expanded" != "$short_url" ]; then
                echo "  Expanded: $expanded" >> "$marketing_report"
                social_findings+=("expanded_url:$(echo "$expanded" | cut -c1-50)")
                
                # Record expanded URL as IOC
                record_ioc "expanded_url" "$expanded" "Expanded from short URL $short_url"
                
                # Check expansion for threats
                if echo "$expanded" | grep -qiE "\.exe|\.scr|\.pif|download"; then
                    social_findings+=("suspicious_expansion")
                    ((social_score += 40))
                    log_threat 45 "Short URL expands to suspicious target"
                fi
            fi
        fi
    fi
    
    # 5. Linktree/bio link analysis
    if echo "$content" | safe_grep_qiE "linktr\.ee|linktree|link\.bio|beacons\.ai"; then
        echo "" >> "$marketing_report"
        echo "Bio Link Analysis:" >> "$marketing_report"
        
        local bio_url=$(echo "$content" | safe_grep_oiE "https?://(linktr\.ee|link\.bio|beacons\.ai)/[A-Za-z0-9_]+" | head -1)
        
        if [ -n "$bio_url" ]; then
            social_findings+=("bio_link:$bio_url")
            
            # Fetch bio link page
            local bio_content=$(curl -sS --max-time 15 "$bio_url" 2>/dev/null | head -c 50000)
            
            if [ -n "$bio_content" ]; then
                # Extract all links from bio page
                local bio_links=$(echo "$bio_content" | grep -oiE 'href="https?://[^"]+' | cut -d'"' -f2 | sort -u | head -10)
                
                echo "  Links found in bio:" >> "$marketing_report"
                echo "$bio_links" >> "$marketing_report"
                
                # Check bio links for suspicious content
                while IFS= read -r bio_link; do
                    [ -z "$bio_link" ] && continue
                    record_ioc "bio_link" "$bio_link" "Found in linktree/bio page"
                    
                    if echo "$bio_link" | grep -qiE "\.exe|discord\.gg|t\.me|anonfiles"; then
                        social_findings+=("suspicious_bio_link")
                        ((social_score += 30))
                    fi
                done <<< "$bio_links"
            fi
        fi
    fi
    
    # Generate summary
    echo "" >> "$marketing_report"
    echo "Analysis Summary:" >> "$marketing_report"
    echo "  Total Findings: ${#social_findings[@]}" >> "$marketing_report"
    echo "  Marketing Risk Score: $social_score" >> "$marketing_report"
    
    if [ ${#social_findings[@]} -gt 0 ]; then
        if [ $social_score -ge 30 ]; then
            log_warning "Social media/marketing link analysis complete"
        fi
        analysis_success_found "SOCIAL-MARKETING" "${#social_findings[@]}" "Score: $social_score" "$(IFS=', '; echo "${social_findings[*]}")"
    else
        analysis_success_none "SOCIAL-MARKETING"
    fi
}

# ============================================================================
# AUDIT 14: UX REDRESS/BROWSER ATTACK DETECTION
# ============================================================================

# Browser attack patterns
declare -a BROWSER_ATTACK_PATTERNS=(
    # URL bar spoofing
    'data:text/html'
    'javascript:void'
    'about:blank.*document\.write'
    
    # Fullscreen overlay attacks
    'requestFullscreen'
    'mozRequestFullScreen'
    'webkitRequestFullscreen'
    'msRequestFullscreen'
    'document\.fullscreen'
    
    # History manipulation
    'history\.pushState'
    'history\.replaceState'
    'onpopstate'
    
    # Window manipulation
    'window\.open.*fullscreen'
    'window\.moveTo[[:space:]]*[(][[:space:]]*0[[:space:]]*,[[:space:]]*0'
    'window\.resizeTo'
    'window\.close'
    'window\.blur'
    
    # Clickjacking
    'pointer-events[[:space:]]*:[[:space:]]*none'
    'z-index[[:space:]]*:[[:space:]]*[0-9]{4,}'
    'opacity[[:space:]]*:[[:space:]]*0[.0]*[;"]'
    'visibility[[:space:]]*:[[:space:]]*hidden'
    'position[[:space:]]*:[[:space:]]*fixed.*top[[:space:]]*:[[:space:]]*0'
    
    # Tab nabbing - use double quotes instead of hex escapes
    'target[[:space:]]*=[[:space:]]*["][_]blank'
    'window\.opener'
    'rel[[:space:]]*=[[:space:]]*["]?noopener'
    
    # Fake UI elements
    'fake.*login'
    'fake.*button'
    'overlay.*form'
    'screenshot.*url.*bar'
)

analyze_ux_redress_attacks() {
    set +u
    local content="${1:-}"
    local url="${2:-}"
    set -u
    
    if [ "$UX_REDRESS_DETECTION" = false ]; then
        analysis_success_none "UX-REDRESS"
        return
    fi
    
    log_info "Analyzing for UX redress/browser attacks..."
    
    local ux_findings=()
    local ux_score=0
    local ux_report="${OUTPUT_DIR}/ux_redress_analysis.txt"
    
    {
        echo "═══════════════════════════════════════════════"
        echo "UX REDRESS / BROWSER ATTACK DETECTION"
        echo "═══════════════════════════════════════════════"
        echo "Timestamp: $(date -Iseconds)"
        echo ""
    } > "$ux_report"
    
    # Fetch URL content if needed
    local html_content=""
    if [ -n "$url" ] && echo "$url" | grep -qiE "^https?://"; then
        html_content=$(timeout 20 curl -sS -L --max-time 15 "$url" 2>/dev/null | head -c 200000)
    fi
    
    local analysis_content="$content $html_content"
    
    # 1. Check browser attack patterns
    echo "Browser Attack Pattern Detection:" >> "$ux_report"
    
    for pattern in "${BROWSER_ATTACK_PATTERNS[@]}"; do
        if echo "$analysis_content" | grep -qiE "$pattern"; then
            ux_findings+=("browser_attack:$pattern")
            ((ux_score += 25))
            echo "  ⚠ DETECTED: $pattern" >> "$ux_report"
            log_warning "Browser attack pattern: $pattern"
        fi
    done
    
    # 2. Data URI attack detection
    echo "" >> "$ux_report"
    echo "Data URI Analysis:" >> "$ux_report"
    
    if echo "$content" | safe_grep_qiE "^data:(text/html|application/x-javascript)"; then
        ux_findings+=("data_uri_attack")
        ((ux_score += 50))
        log_threat 55 "Data URI with executable content"
        echo "  ⚠ DATA URI ATTACK DETECTED" >> "$ux_report"
        
        # Decode and analyze
        local encoded_part=$(echo "$content" | safe_grep_oE ";base64,.*" | cut -c9-)
        if [ -n "$encoded_part" ]; then
            local decoded=$(echo "$encoded_part" | base64 -d 2>/dev/null | head -c 5000)
            echo "  Decoded content (preview):" >> "$ux_report"
            echo "$decoded" | head -c 500 >> "$ux_report"
            
            # Check decoded content for additional attacks
            if echo "$decoded" | grep -qiE "password|login|credential"; then
                ux_findings+=("data_uri_phishing")
                ((ux_score += 40))
            fi
        fi
    fi
    
    # 3. Tabnabbing detection
    echo "" >> "$ux_report"
    echo "Tabnabbing Analysis:" >> "$ux_report"
    
    if echo "$analysis_content" | grep -qiE 'target.*_blank' && \
       ! echo "$analysis_content" | grep -qiE 'rel.*noopener'; then
        ux_findings+=("tabnabbing_vulnerable")
        ((ux_score += 30))
        log_warning "Potential tabnabbing vulnerability (no noopener)"
        echo "  ⚠ Missing rel=noopener on _blank links" >> "$ux_report"
    fi
    
    if echo "$analysis_content" | grep -qiE 'window\.opener[[:space:]]*[.=]'; then
        ux_findings+=("tabnabbing_exploit")
        ((ux_score += 45))
        log_threat 50 "Tabnabbing exploit code detected"
        echo "  ⚠ window.opener manipulation detected" >> "$ux_report"
    fi
    
    # 4. Clickjacking indicators
    echo "" >> "$ux_report"
    echo "Clickjacking Analysis:" >> "$ux_report"
    
    local clickjack_indicators=0
    
    if echo "$analysis_content" | grep -qiE 'position[[:space:]]*:[[:space:]]*fixed'; then
        ((clickjack_indicators++))
    fi
    if echo "$analysis_content" | grep -qiE 'z-index[[:space:]]*:[[:space:]]*[0-9]{5,}'; then
        ((clickjack_indicators++))
    fi
    if echo "$analysis_content" | grep -qiE 'opacity[[:space:]]*:[[:space:]]*0[.0]*[;"]'; then
        ((clickjack_indicators++))
    fi
    if echo "$analysis_content" | grep -qiE 'iframe[^>]+style'; then
        ((clickjack_indicators++))
    fi
    
    if [ "$clickjack_indicators" -ge 2 ]; then
        ux_findings+=("clickjacking:$clickjack_indicators")
        ((ux_score += 40))
        log_threat 45 "Multiple clickjacking indicators ($clickjack_indicators)"
        echo "  ⚠ $clickjack_indicators clickjacking indicators found" >> "$ux_report"
    fi
    
    # 5. URL bar spoofing check
    echo "" >> "$ux_report"
    echo "URL Bar Spoofing Analysis:" >> "$ux_report"
    
    # Check for homograph characters in URL (non-ASCII bytes)
    if printf '%s' "$url" | LC_ALL=C grep -q '[^[:print:]]' 2>/dev/null || \
       printf '%s' "$url" | od -A n -t x1 2>/dev/null | grep -qE '[89a-f][0-9a-f]'; then
        ux_findings+=("unicode_url")
        ((ux_score += 35))
        log_warning "Unicode characters in URL (possible homograph attack)"
    fi
    
    # Check for lookalike domain
    local domain=$(echo "$url" | sed -E 's|^https?://||' | cut -d'/' -f1)
    if echo "$domain" | grep -qiE "paypa1|g00gle|micros0ft|amaz0n|faceb00k"; then
        ux_findings+=("lookalike_domain")
        ((ux_score += 50))
        log_threat 55 "Lookalike domain detected (letter substitution)"
    fi
    
    # Generate summary
    echo "" >> "$ux_report"
    echo "Analysis Summary:" >> "$ux_report"
    echo "  Total Findings: ${#ux_findings[@]}" >> "$ux_report"
    echo "  UX Redress Risk Score: $ux_score" >> "$ux_report"
    
    if [ ${#ux_findings[@]} -gt 0 ]; then
        if [ $ux_score -ge 40 ]; then
            log_threat $((ux_score / 2)) "UX redress/browser attack indicators detected"
        fi
        analysis_success_found "UX-REDRESS" "${#ux_findings[@]}" "Score: $ux_score" "$(IFS=', '; echo "${ux_findings[*]}")"
    else
        analysis_success_none "UX-REDRESS"
    fi
}

# ============================================================================
# AUDIT 15: DGA/ALGORITHMIC DOMAIN ANALYSIS
# ============================================================================

analyze_dga_domains() {
    set +u
    local content="${1:-}"
    set -u
    
    if [ "$DGA_ANALYSIS" = false ]; then
        analysis_success_none "DGA-ANALYSIS"
        return
    fi
    
    log_info "Analyzing for DGA (Domain Generation Algorithm) patterns..."
    
    local dga_findings=()
    local dga_score=0
    local dga_report="${OUTPUT_DIR}/dga_analysis.txt"
    
    {
        echo "═══════════════════════════════════════════════"
        echo "DGA (DOMAIN GENERATION ALGORITHM) ANALYSIS"
        echo "═══════════════════════════════════════════════"
        echo "Timestamp: $(date -Iseconds)"
        echo ""
    } > "$dga_report"
    
    # Extract domain from content
    local domain=""
    if echo "$content" | safe_grep_qiE "^https?://"; then
        domain=$(echo "$content" | sed -E 's|^https?://||' | cut -d'/' -f1 | cut -d':' -f1)
    fi
    
    if [ -z "$domain" ]; then
        analysis_success_none "DGA-ANALYSIS"
        return
    fi
    
    echo "Domain: $domain" >> "$dga_report"
    echo "" >> "$dga_report"
    
    # AUDIT FIX: Use base64 to safely pass domain to Python (prevents segfault with special chars)
    local encoded_domain
    encoded_domain=$(printf '%s' "$domain" | base64 2>/dev/null) || return
    
    # Python-based DGA analysis
    local dga_analysis=$(python3 - "$encoded_domain" 2>/dev/null <<'EOF'
import json
import math
import re
import sys
import base64
from collections import Counter

try:
    domain = base64.b64decode(sys.argv[1] if len(sys.argv) > 1 else '').decode('utf-8', errors='ignore')
except:
    domain = ''
# Remove TLD for analysis
parts = domain.split('.')
if len(parts) > 1:
    main_domain = '.'.join(parts[:-1]) if parts[-1] in ['com','net','org','io','xyz','tk','ml','ga','cf','gq','top','info','biz','co','us','uk'] else domain
else:
    main_domain = domain

results = {
    'domain': domain,
    'main_domain': main_domain,
    'length': len(main_domain),
}

# 1. Entropy calculation
if main_domain:
    freq = Counter(main_domain.lower())
    probs = [count / len(main_domain) for count in freq.values()]
    entropy = -sum(p * math.log2(p) for p in probs if p > 0)
    results['entropy'] = round(entropy, 4)
    
    # High entropy suggests DGA
    if entropy > 3.8:
        results['high_entropy'] = True
        results['dga_indicator'] = 'HIGH_ENTROPY'
else:
    results['entropy'] = 0

# 2. Consonant/vowel ratio
vowels = set('aeiouAEIOU')
consonants = set('bcdfghjklmnpqrstvwxyzBCDFGHJKLMNPQRSTVWXYZ')
vowel_count = sum(1 for c in main_domain if c in vowels)
consonant_count = sum(1 for c in main_domain if c in consonants)

if vowel_count > 0:
    cv_ratio = consonant_count / vowel_count
else:
    cv_ratio = consonant_count

results['vowel_count'] = vowel_count
results['consonant_count'] = consonant_count
results['cv_ratio'] = round(cv_ratio, 2)

# Abnormal ratio suggests DGA
if cv_ratio > 4 or (vowel_count == 0 and len(main_domain) > 5):
    results['abnormal_cv_ratio'] = True
    results['dga_indicator'] = 'ABNORMAL_CV_RATIO'

# 3. Bigram analysis
def get_bigram_score(text):
    # Common English bigrams
    common_bigrams = {'th','he','in','er','an','re','on','at','en','nd','ti','es','or','te','of','ed','is','it','al','ar','st','to','nt','ng','se','ha','as','ou','io','le','ve','co','me','de','hi','ri','ro','ic','ne','ea','ra','ce'}
    
    bigrams = [text[i:i+2].lower() for i in range(len(text)-1)]
    if not bigrams:
        return 0
    
    common_count = sum(1 for b in bigrams if b in common_bigrams)
    return common_count / len(bigrams)

bigram_score = get_bigram_score(main_domain)
results['bigram_score'] = round(bigram_score, 4)

# Low bigram score suggests DGA
if bigram_score < 0.1 and len(main_domain) > 8:
    results['low_bigram_score'] = True
    results['dga_indicator'] = 'LOW_BIGRAM_SCORE'

# 4. Digit ratio
digit_count = sum(1 for c in main_domain if c.isdigit())
digit_ratio = digit_count / len(main_domain) if main_domain else 0
results['digit_ratio'] = round(digit_ratio, 4)

if digit_ratio > 0.3:
    results['high_digit_ratio'] = True
    results['dga_indicator'] = 'HIGH_DIGIT_RATIO'

# 5. Length-based analysis
if len(main_domain) > 20:
    results['long_domain'] = True
    if 'dga_indicator' not in results:
        results['dga_indicator'] = 'LONG_RANDOM_DOMAIN'

# 6. Sequential character analysis
def has_sequential_chars(text, min_seq=4):
    text = text.lower()
    for i in range(len(text) - min_seq + 1):
        chunk = text[i:i+min_seq]
        if chunk.isalpha():
            # Check for keyboard patterns
            if chunk in 'qwerty' or chunk in 'asdfgh' or chunk in 'zxcvbn':
                return True
            # Check for alphabetic sequence
            if all(ord(chunk[j+1]) - ord(chunk[j]) == 1 for j in range(len(chunk)-1)):
                return True
    return False

if has_sequential_chars(main_domain):
    results['sequential_chars'] = True

# 7. Known DGA patterns
dga_patterns = [
    r'^[a-z]{10,}[0-9]{2,}$',  # letters followed by numbers
    r'^[0-9]{2,}[a-z]{10,}$',  # numbers followed by letters
    r'^[a-z0-9]{16,}$',        # long alphanumeric
    r'^[bcdfghjklmnpqrstvwxz]{5,}$',  # consonant only
]

for pattern in dga_patterns:
    if re.match(pattern, main_domain.lower()):
        results['matches_dga_pattern'] = pattern
        results['dga_indicator'] = 'MATCHES_DGA_PATTERN'
        break

# Calculate overall DGA score
dga_score = 0
if results.get('high_entropy'):
    dga_score += 30
if results.get('abnormal_cv_ratio'):
    dga_score += 25
if results.get('low_bigram_score'):
    dga_score += 25
if results.get('high_digit_ratio'):
    dga_score += 20
if results.get('long_domain'):
    dga_score += 15
if results.get('matches_dga_pattern'):
    dga_score += 35

results['dga_score'] = dga_score

# Verdict
if dga_score >= 60:
    results['verdict'] = 'LIKELY_DGA'
elif dga_score >= 40:
    results['verdict'] = 'POSSIBLE_DGA'
elif dga_score >= 20:
    results['verdict'] = 'SUSPICIOUS'
else:
    results['verdict'] = 'LIKELY_LEGITIMATE'

print(json.dumps(results, indent=2))
EOF
)
    
    if [ -n "$dga_analysis" ]; then
        echo "DGA Analysis Results:" >> "$dga_report"
        echo "$dga_analysis" >> "$dga_report"
        
        # Parse results
        local verdict=$(json_extract_string "$dga_analysis" "verdict")
        local score=$(json_extract_int "$dga_analysis" "dga_score")
        local entropy=$(json_extract_number "$dga_analysis" "entropy")
        
        # Display results
        echo ""
        echo -e "${CYAN}┌─────────────────────────────────────────────────────────────┐${NC}"
        echo -e "${CYAN}│                    DGA ANALYSIS RESULTS                      │${NC}"
        echo -e "${CYAN}├─────────────────────────────────────────────────────────────┤${NC}"
        echo -e "${CYAN}│${NC} Domain:       ${WHITE}$domain${NC}"
        echo -e "${CYAN}│${NC} Entropy:      ${YELLOW}${entropy:-N/A}${NC}"
        echo -e "${CYAN}│${NC} DGA Score:    ${YELLOW}${score:-0}${NC}"
        echo -e "${CYAN}│${NC} Verdict:      ${RED}${verdict:-UNKNOWN}${NC}"
        echo -e "${CYAN}└─────────────────────────────────────────────────────────────┘${NC}"
        echo ""
        
        case "$verdict" in
            "LIKELY_DGA")
                dga_findings+=("dga:likely")
                ((dga_score += 60))
                log_threat 65 "Domain appears to be DGA-generated"
                ;;
            "POSSIBLE_DGA")
                dga_findings+=("dga:possible")
                ((dga_score += 40))
                log_threat 45 "Domain shows DGA characteristics"
                ;;
            "SUSPICIOUS")
                dga_findings+=("dga:suspicious")
                ((dga_score += 20))
                log_warning "Domain has suspicious patterns"
                ;;
        esac
        
        if [ "$verdict" != "LIKELY_LEGITIMATE" ]; then
            analysis_success_found "DGA-ANALYSIS" "1" "Verdict: $verdict, Score: ${score:-0}"
        else
            analysis_success_none "DGA-ANALYSIS"
        fi
    else
        analysis_error "DGA-ANALYSIS" "Python analysis failed"
    fi
}

# ============================================================================
# AUDIT 16: MULTI-LANGUAGE/UNICODE DECEPTION DETECTION
# ============================================================================

# RTL and bidirectional override characters
declare -a BIDI_OVERRIDE_CHARS=(
    '\u202A'  # LRE - Left-to-Right Embedding
    '\u202B'  # RLE - Right-to-Left Embedding
    '\u202C'  # PDF - Pop Directional Formatting
    '\u202D'  # LRO - Left-to-Right Override
    '\u202E'  # RLO - Right-to-Left Override (most dangerous)
    '\u2066'  # LRI - Left-to-Right Isolate
    '\u2067'  # RLI - Right-to-Left Isolate
    '\u2068'  # FSI - First Strong Isolate
    '\u2069'  # PDI - Pop Directional Isolate
)

# Homoglyph mappings (common confusables)
declare -A HOMOGLYPH_MAP=(
    # Cyrillic
    ["а"]="a" ["е"]="e" ["і"]="i" ["о"]="o" ["р"]="p" ["с"]="c" ["х"]="x" ["у"]="y"
    ["А"]="A" ["В"]="B" ["Е"]="E" ["К"]="K" ["М"]="M" ["Н"]="H" ["О"]="O" ["Р"]="P" ["С"]="C" ["Т"]="T" ["Х"]="X"
    # Greek
    ["α"]="a" ["ο"]="o" ["ν"]="v" ["τ"]="t"
    ["Α"]="A" ["Β"]="B" ["Ε"]="E" ["Η"]="H" ["Ι"]="I" ["Κ"]="K" ["Μ"]="M" ["Ν"]="N" ["Ο"]="O" ["Ρ"]="P" ["Τ"]="T" ["Χ"]="X" ["Υ"]="Y" ["Ζ"]="Z"
    # Latin lookalikes
    ["ⅰ"]="i" ["ⅱ"]="ii" ["ℓ"]="l" ["ℐ"]="I"
    # Numbers
    ["Ο"]="0" ["О"]="0" ["ο"]="0"
    ["Ⅰ"]="1" ["ⅼ"]="1" ["ǀ"]="1"
)

analyze_unicode_deception() {
    set +u
    local content="${1:-}"
    local url="${2:-}"
    set -u
    
    if [ "$UNICODE_DECEPTION_DETECTION" = false ]; then
        analysis_success_none "UNICODE-DECEPTION"
        return
    fi
    
    # Validate input
    [[ -z "$content" ]] && [[ -z "$url" ]] && { analysis_success_none "UNICODE-DECEPTION"; return; }
    
    log_info "Analyzing for Unicode/multi-language deception..."
    
    local unicode_findings=()
    local unicode_score=0
    local unicode_report="${OUTPUT_DIR}/unicode_deception_analysis.txt"
    
    {
        echo "═══════════════════════════════════════════════"
        echo "UNICODE DECEPTION ANALYSIS"
        echo "═══════════════════════════════════════════════"
        echo "Timestamp: $(date -Iseconds)"
        echo ""
    } > "$unicode_report"
    
    # FIXED: Use base64 encoding to safely pass content and URL to Python
    local encoded_content encoded_url
    encoded_content=$(printf '%s' "$content" | base64 2>/dev/null) || encoded_content=""
    encoded_url=$(printf '%s' "$url" | base64 2>/dev/null) || encoded_url=""
    
    # Python-based comprehensive Unicode analysis
    # Pass encoded content as arguments instead of pipe (heredoc conflicts with pipe)
    local unicode_analysis=""
    if [ -n "$encoded_content" ] || [ -n "$encoded_url" ]; then
        unicode_analysis=$(python3 - "$encoded_content" "$encoded_url" 2>/dev/null <<'EOF'
import sys
import json
import unicodedata
import re
import base64

try:
    content = base64.b64decode(sys.argv[1] if len(sys.argv) > 1 and sys.argv[1] else '').decode('utf-8', errors='ignore')
    url = base64.b64decode(sys.argv[2] if len(sys.argv) > 2 and sys.argv[2] else '').decode('utf-8', errors='ignore')
except Exception:
    content = ''
    url = ''

results = {
    'content_length': len(content),
    'findings': []
}

# 1. Check for RTL override characters
rlo_chars = ['\u202A', '\u202B', '\u202C', '\u202D', '\u202E', '\u2066', '\u2067', '\u2068', '\u2069']
for char in rlo_chars:
    if char in content or char in url:
        results['findings'].append({
            'type': 'bidi_override',
            'char': repr(char),
            'severity': 'critical' if char == '\u202E' else 'high'
        })

# 2. Check for mixed scripts
def get_script(char):
    try:
        name = unicodedata.name(char, '')
        if 'CYRILLIC' in name:
            return 'Cyrillic'
        elif 'GREEK' in name:
            return 'Greek'
        elif 'LATIN' in name:
            return 'Latin'
        elif 'CJK' in name:
            return 'CJK'
        elif 'ARABIC' in name:
            return 'Arabic'
        elif 'HEBREW' in name:
            return 'Hebrew'
        else:
            return 'Other'
    except:
        return 'Unknown'

scripts_in_url = set()
for char in url:
    if char.isalpha():
        scripts_in_url.add(get_script(char))

results['scripts_in_url'] = list(scripts_in_url)

if len(scripts_in_url) > 1 and 'Latin' in scripts_in_url:
    results['findings'].append({
        'type': 'mixed_scripts',
        'scripts': list(scripts_in_url),
        'severity': 'critical'
    })

# 3. Check for specific homoglyphs
homoglyphs = {
    'а': 'a (Cyrillic)', 'е': 'e (Cyrillic)', 'о': 'o (Cyrillic)',
    'р': 'p (Cyrillic)', 'с': 'c (Cyrillic)', 'х': 'x (Cyrillic)',
    'А': 'A (Cyrillic)', 'В': 'B (Cyrillic)', 'Е': 'E (Cyrillic)',
    'К': 'K (Cyrillic)', 'М': 'M (Cyrillic)', 'Н': 'H (Cyrillic)',
    'О': 'O (Cyrillic)', 'Р': 'P (Cyrillic)', 'С': 'C (Cyrillic)',
    'Т': 'T (Cyrillic)', 'α': 'a (Greek)', 'ο': 'o (Greek)',
}

found_homoglyphs = []
for char, desc in homoglyphs.items():
    if char in url:
        found_homoglyphs.append(desc)

if found_homoglyphs:
    results['findings'].append({
        'type': 'homoglyphs',
        'found': found_homoglyphs,
        'severity': 'critical'
    })

# 4. Check for zero-width characters
zero_width = ['\u200B', '\u200C', '\u200D', '\uFEFF', '\u00AD']
for zw in zero_width:
    if zw in content or zw in url:
        results['findings'].append({
            'type': 'zero_width',
            'char': repr(zw),
            'severity': 'high'
        })

# 5. Check for confusable Unicode
confusables = {
    '\u2024': 'ONE DOT LEADER (looks like period)',
    '\u2025': 'TWO DOT LEADER',
    '\u2026': 'HORIZONTAL ELLIPSIS',
    '\u2215': 'DIVISION SLASH (looks like /)',
    '\u2044': 'FRACTION SLASH',
    '\u29F8': 'BIG SOLIDUS',
    '\uFF0F': 'FULLWIDTH SOLIDUS',
    '\u2216': 'SET MINUS (looks like backslash)',
    '\u3002': 'IDEOGRAPHIC FULL STOP (looks like period)',
    '\uFF0E': 'FULLWIDTH FULL STOP',
}

for char, desc in confusables.items():
    if char in url:
        results['findings'].append({
            'type': 'confusable',
            'char': repr(char),
            'description': desc,
            'severity': 'high'
        })

# 6. IDN/Punycode analysis
if url.startswith('http'):
    domain = url.split('//')[1].split('/')[0] if '//' in url else url.split('/')[0]
    
    # Check for xn-- prefix (punycode)
    if 'xn--' in domain.lower():
        results['findings'].append({
            'type': 'punycode',
            'domain': domain,
            'severity': 'medium'
        })
    
    # Check for non-ASCII in domain
    non_ascii = [c for c in domain if ord(c) > 127]
    if non_ascii:
        results['findings'].append({
            'type': 'non_ascii_domain',
            'chars': [repr(c) for c in non_ascii],
            'severity': 'high'
        })

# Calculate overall score
score = 0
for finding in results['findings']:
    if finding['severity'] == 'critical':
        score += 50
    elif finding['severity'] == 'high':
        score += 30
    elif finding['severity'] == 'medium':
        score += 15

results['unicode_score'] = score

if score >= 50:
    results['verdict'] = 'DECEPTIVE_UNICODE'
elif score >= 25:
    results['verdict'] = 'SUSPICIOUS_UNICODE'
else:
    results['verdict'] = 'LIKELY_SAFE'

print(json.dumps(results, indent=2))
EOF
    )
    fi
    
    if [ -n "$unicode_analysis" ]; then
        echo "Unicode Analysis Results:" >> "$unicode_report"
        
        # Parse results
        local verdict=$(json_extract_string "$unicode_analysis" "verdict")
        local score=$(json_extract_int "$unicode_analysis" "unicode_score")
        local finding_count=$(echo "$unicode_analysis" | grep -c '"type":')
        
        if [ "$verdict" = "DECEPTIVE_UNICODE" ]; then
            unicode_findings+=("deceptive_unicode")
            ((unicode_score += 60))
            log_threat 65 "Deceptive Unicode characters detected"
            
            # Check for specific critical issues
            if echo "$unicode_analysis" | grep -q "bidi_override"; then
                log_critical "⚠️  RTL OVERRIDE ATTACK DETECTED!"
                unicode_findings+=("rlo_attack")
            fi
            
            if echo "$unicode_analysis" | grep -q "homoglyphs"; then
                log_critical "⚠️  HOMOGLYPH ATTACK DETECTED!"
                unicode_findings+=("homoglyph_attack")
            fi
            
        elif [ "$verdict" = "SUSPICIOUS_UNICODE" ]; then
            unicode_findings+=("suspicious_unicode")
            ((unicode_score += 30))
            log_warning "Suspicious Unicode patterns detected"
        fi
        
        if [ ${#unicode_findings[@]} -gt 0 ]; then
            analysis_success_found "UNICODE-DECEPTION" "${#unicode_findings[@]}" "Score: ${score:-0}" "$(IFS=', '; echo "${unicode_findings[*]}")"
        else
            analysis_success_none "UNICODE-DECEPTION"
        fi
    else
        analysis_error "UNICODE-DECEPTION" "Python analysis failed"
    fi
}

# ============================================================================
# AUDIT 17: SOCIAL THREAT TRACKING
# ============================================================================

# Social threat tracking sources
declare -a SOCIAL_THREAT_SOURCES=(
    "https://urlhaus-api.abuse.ch/v1/url/"
    "https://www.phishtank.com/checkurl/"
)

analyze_social_threat_tracking() {
    set +u
    local url="${1:-}"
    local domain="${2:-}"
    set -u
    
    if [ "$SOCIAL_THREAT_TRACKING" = false ]; then
        analysis_success_none "SOCIAL-THREATS"
        return
    fi
    
    log_info "Checking social threat tracking sources..."
    
    local social_findings=()
    local social_score=0
    local social_report="${OUTPUT_DIR}/social_threat_tracking.txt"
    
    {
        echo "═══════════════════════════════════════════════"
        echo "SOCIAL THREAT TRACKING"
        echo "═══════════════════════════════════════════════"
        echo "Timestamp: $(date -Iseconds)"
        echo "Target: $url"
        echo ""
    } > "$social_report"
    
    # Extract domain if not provided
    if [ -z "$domain" ] && echo "$url" | grep -qiE "^https?://"; then
        domain=$(echo "$url" | sed -E 's|^https?://||' | cut -d'/' -f1)
    fi
    
    # 1. URLhaus check
    echo "URLhaus Check:" >> "$social_report"
    local urlhaus_result=$(curl -sS --max-time 10 \
        -d "url=$url" \
        "https://urlhaus-api.abuse.ch/v1/url/" 2>/dev/null)
    
    if [ -n "$urlhaus_result" ]; then
        if echo "$urlhaus_result" | grep -q '"query_status":"ok"'; then
            social_findings+=("urlhaus:found")
            ((social_score += 70))
            
            # Extract details first
            local threat_type=$(json_extract_string "$urlhaus_result" "threat")
            
            # Forensic detection output
            log_forensic_detection 100 \
                "URLhaus Database Match" \
                "$url" \
                "URLhaus API Query" \
                "Social threat tracking" \
                "URL is associated with malware distribution" \
                "https://urlhaus.abuse.ch"
            
            echo "  ⚠ FOUND IN URLHAUS DATABASE" >> "$social_report"
            echo "  Threat Type: $threat_type" >> "$social_report"
        else
            echo "  Not found" >> "$social_report"
        fi
    fi
    
    # 2. Check domain reputation via DNSBLs
    echo "" >> "$social_report"
    echo "DNSBL Check:" >> "$social_report"
    
    if [ -n "$domain" ]; then
        # Reverse domain for DNSBL query
        local reversed=$(echo "$domain" | awk -F.'{for(i=NF;i>0;i--) printf "%s%s",$i,(i>1?".":"")}')
        
        declare -a DNSBLS=(
            "zen.spamhaus.org"
            "bl.spamcop.net"
            "dnsbl.sorbs.net"
            "b.barracudacentral.org"
            "dbl.spamhaus.org"
        )
        
        local dnsbl_hits=0
        for dnsbl in "${DNSBLS[@]}"; do
            local check_result=$(dig +short "$reversed.$dnsbl" 2>/dev/null | head -1)
            if [ -n "$check_result" ] && echo "$check_result" | grep -qE "^127\."; then
                ((dnsbl_hits++))
                social_findings+=("dnsbl:$dnsbl")
                echo "  ⚠ Listed in: $dnsbl" >> "$social_report"
            fi
        done
        
        if [ "$dnsbl_hits" -gt 0 ]; then
            ((social_score += dnsbl_hits * 15))
            log_warning "Domain listed in $dnsbl_hits DNSBL(s)"
        else
            echo "  Not listed in checked DNSBLs" >> "$social_report"
        fi
    fi
    
    # 3. Check for recent mentions in public threat feeds (simulated)
    echo "" >> "$social_report"
    echo "Threat Feed Check:" >> "$social_report"
    
    # This would integrate with real threat intelligence APIs
    # For now, check against local threat intel we've downloaded
    if [ -d "${TEMP_DIR}/threat_intel" ]; then
        for feed_file in "${TEMP_DIR}/threat_intel"/*.txt; do
            [ -f "$feed_file" ] || continue
            if grep -qi "$domain" "$feed_file" 2>/dev/null || grep -qi "$url" "$feed_file" 2>/dev/null; then
                local feed_name=$(basename "$feed_file" .txt)
                social_findings+=("feed_hit:$feed_name")
                ((social_score += 40))
                log_warning "Found in threat feed: $feed_name"
                echo "  ⚠ Found in: $feed_name" >> "$social_report"
            fi
        done
    fi
    
    # Generate summary
    echo "" >> "$social_report"
    echo "Analysis Summary:" >> "$social_report"
    echo "  Total Findings: ${#social_findings[@]}" >> "$social_report"
    echo "  Social Threat Score: $social_score" >> "$social_report"
    
    if [ ${#social_findings[@]} -gt 0 ]; then
        if [ $social_score -ge 50 ]; then
            log_threat $((social_score / 2)) "Social threat tracking detected issues"
        fi
        analysis_success_found "SOCIAL-THREATS" "${#social_findings[@]}" "Score: $social_score" "$(IFS=', '; echo "${social_findings[*]}")"
    else
        analysis_success_none "SOCIAL-THREATS"
    fi
}

# ============================================================================
# AUDIT 18: BLOCKCHAIN/SMART CONTRACT SCAM ANALYSIS
# ============================================================================

# Known scam contract patterns
declare -a CRYPTO_SCAM_CONTRACT_PATTERNS=(
    "approve.*unlimited"
    "setApprovalForAll"
    "transfer.*owner"
    "drain"
    "honeypot"
    "rug.*pull"
    "mint.*free"
    "claim.*airdrop"
)

# Known scam wallet address prefixes (simulated)
declare -a KNOWN_SCAM_WALLETS=(
    "0x000000000000000000000000000000000000dead"
    "0x0000000000000000000000000000000000000000"
)

analyze_blockchain_scams() {
    set +u
    local content="${1:-}"
    set -u
    
    if [ "$BLOCKCHAIN_SCAM_ANALYSIS" = false ]; then
        analysis_success_none "BLOCKCHAIN-SCAMS"
        return
    fi
    
    log_info "Analyzing for blockchain/smart contract scams..."
    
    local blockchain_findings=()
    local blockchain_score=0
    local blockchain_report="${OUTPUT_DIR}/blockchain_scam_analysis.txt"
    
    {
        echo "═══════════════════════════════════════════════"
        echo "BLOCKCHAIN/SMART CONTRACT SCAM ANALYSIS"
        echo "═══════════════════════════════════════════════"
        echo "Timestamp: $(date -Iseconds)"
        echo ""
    } > "$blockchain_report"
    
    # 1. Extract cryptocurrency addresses
    echo "Cryptocurrency Address Detection:" >> "$blockchain_report"
    
    # Ethereum addresses (0x...)
    local eth_addresses=$(echo "$content" | safe_grep_oiE '0x[a-fA-F0-9]{40}' | sort -u)
    # Bitcoin addresses
    local btc_addresses=$(echo "$content" | safe_grep_oE '(bc1|[13])[a-zA-HJ-NP-Z0-9]{25,62}' | sort -u)
    # Solana addresses
    local sol_addresses=$(echo "$content" | safe_grep_oE '[1-9A-HJ-NP-Za-km-z]{32,44}' | sort -u)
    
    if [ -n "$eth_addresses" ]; then
        echo "  Ethereum Addresses:" >> "$blockchain_report"
        echo "$eth_addresses" >> "$blockchain_report"
        blockchain_findings+=("eth_addresses:$(echo "$eth_addresses" | wc -l)")
        
        # Check against known scam wallets (would use Etherscan API in production)
        while IFS= read -r addr; do
            [ -z "$addr" ] && continue
            record_ioc "eth_address" "$addr" "Ethereum address in QR content"
            
            # Simulated scam check (in production, use Etherscan/similar API)
            for scam_addr in "${KNOWN_SCAM_WALLETS[@]}"; do
                if [ "${addr,,}" = "${scam_addr,,}" ]; then
                    blockchain_findings+=("known_scam_wallet:$addr")
                    ((blockchain_score += 80))
                    log_threat 85 "KNOWN SCAM WALLET DETECTED: $addr"
                fi
            done
        done <<< "$eth_addresses"
    fi
    
    if [ -n "$btc_addresses" ]; then
        echo "  Bitcoin Addresses:" >> "$blockchain_report"
        echo "$btc_addresses" >> "$blockchain_report"
        blockchain_findings+=("btc_addresses:$(echo "$btc_addresses" | wc -l)")
        
        while IFS= read -r addr; do
            [ -z "$addr" ] && continue
            record_ioc "btc_address" "$addr" "Bitcoin address in QR content"
        done <<< "$btc_addresses"
    fi
    
    # 2. Check for smart contract interaction patterns
    echo "" >> "$blockchain_report"
    echo "Smart Contract Pattern Analysis:" >> "$blockchain_report"
    
    for pattern in "${CRYPTO_SCAM_CONTRACT_PATTERNS[@]}"; do
        if echo "$content" | safe_grep_qiE "$pattern"; then
            blockchain_findings+=("contract_pattern:$pattern")
            ((blockchain_score += 30))
            log_warning "Suspicious contract pattern: $pattern"
            echo "  ⚠ DETECTED: $pattern" >> "$blockchain_report"
        fi
    done
    
    # 3. DeFi scam indicators
    echo "" >> "$blockchain_report"
    echo "DeFi Scam Indicators:" >> "$blockchain_report"
    
    # Check for fake swap/DEX URLs
    if echo "$content" | safe_grep_qiE "uniswap.*claim|pancakeswap.*free|sushiswap.*bonus"; then
        blockchain_findings+=("fake_dex")
        ((blockchain_score += 50))
        log_threat 55 "Fake DEX claim pattern detected"
        echo "  ⚠ Fake DEX claim pattern" >> "$blockchain_report"
    fi
    
    # Check for fake wallet connect
    if echo "$content" | safe_grep_qiE "walletconnect.*verify|connect.*wallet.*claim"; then
        blockchain_findings+=("fake_wallet_connect")
        ((blockchain_score += 45))
        log_threat 50 "Fake wallet connect pattern"
        echo "  ⚠ Fake wallet connect pattern" >> "$blockchain_report"
    fi
    
    # 4. NFT scam patterns
    if echo "$content" | safe_grep_qiE "free.*nft|nft.*mint.*0|claim.*nft|airdrop.*nft"; then
        blockchain_findings+=("nft_scam")
        ((blockchain_score += 40))
        log_warning "NFT scam pattern detected"
        echo "  ⚠ NFT scam pattern" >> "$blockchain_report"
    fi
    
    # 5. Etherscan API check (if API key available)
    if [ -n "$ETHERSCAN_API_KEY" ] && [ -n "$eth_addresses" ]; then
        echo "" >> "$blockchain_report"
        echo "Etherscan Verification:" >> "$blockchain_report"
        
        local first_addr=$(echo "$eth_addresses" | head -1)
        local etherscan_result=$(curl -sS --max-time 10 \
            "https://api.etherscan.io/api?module=account&action=balance&address=$first_addr&tag=latest&apikey=$ETHERSCAN_API_KEY" 2>/dev/null)
        
        if [ -n "$etherscan_result" ]; then
            echo "  API Response: $etherscan_result" >> "$blockchain_report"
        fi
    fi
    
    # Generate summary
    echo "" >> "$blockchain_report"
    echo "Analysis Summary:" >> "$blockchain_report"
    echo "  Total Findings: ${#blockchain_findings[@]}" >> "$blockchain_report"
    echo "  Blockchain Scam Score: $blockchain_score" >> "$blockchain_report"
    
    if [ ${#blockchain_findings[@]} -gt 0 ]; then
        if [ $blockchain_score -ge 40 ]; then
            log_threat $((blockchain_score / 2)) "Blockchain/crypto scam indicators detected"
        fi
        analysis_success_found "BLOCKCHAIN-SCAMS" "${#blockchain_findings[@]}" "Score: $blockchain_score" "$(IFS=', '; echo "${blockchain_findings[*]}")"
    else
        analysis_success_none "BLOCKCHAIN-SCAMS"
    fi
}

# ============================================================================
# AUDIT 19: CONTACT EVENT DETONATION (VCARD/ICALENDAR)
# ============================================================================

# Suspicious vCard fields
declare -a SUSPICIOUS_VCARD_PATTERNS=(
    "URL:.*bit\.ly"
    "URL:.*tinyurl"
    "NOTE:.*verify"
    "NOTE:.*password"
    "NOTE:.*click"
    "X-.*:.*http"
    "PHOTO.*http"
)

# Suspicious calendar patterns
declare -a SUSPICIOUS_ICAL_PATTERNS=(
    "DESCRIPTION:.*verify"
    "DESCRIPTION:.*password"
    "DESCRIPTION:.*click.*here"
    "URL:.*bit\.ly"
    "ATTENDEE:.*@"
    "ORGANIZER:.*suspicious"
)

analyze_contact_events() {
    set +u
    local content="${1:-}"
    set -u
    
    if [ "$CONTACT_EVENT_ANALYSIS" = false ]; then
        analysis_success_none "CONTACT-EVENTS"
        return
    fi
    
    # Check if content is vCard or iCalendar
    local is_vcard=false
    local is_ical=false
    
    if echo "$content" | safe_grep_qi "BEGIN:VCARD"; then
        is_vcard=true
    fi
    if echo "$content" | safe_grep_qi "BEGIN:VCALENDAR\|BEGIN:VEVENT"; then
        is_ical=true
    fi
    
    if [ "$is_vcard" = false ] && [ "$is_ical" = false ]; then
        analysis_success_none "CONTACT-EVENTS"
        return
    fi
    
    log_info "Analyzing contact/calendar event content..."
    
    local contact_findings=()
    local contact_score=0
    local contact_report="${OUTPUT_DIR}/contact_event_analysis.txt"
    
    {
        echo "═══════════════════════════════════════════════"
        echo "CONTACT/CALENDAR EVENT ANALYSIS"
        echo "═══════════════════════════════════════════════"
        echo "Timestamp: $(date -Iseconds)"
        echo ""
    } > "$contact_report"
    
    if [ "$is_vcard" = true ]; then
        echo "vCard Analysis:" >> "$contact_report"
        log_info "  Analyzing vCard content..."
        
        # Extract fields
        local name=$(echo "$content" | safe_grep_iE "^(FN|N):" | head -1 | cut -d':' -f2-)
        local email=$(echo "$content" | safe_grep_iE "^EMAIL" | cut -d':' -f2- | head -1)
        local phone=$(echo "$content" | safe_grep_iE "^TEL" | cut -d':' -f2- | head -1)
        local url=$(echo "$content" | safe_grep_iE "^URL" | cut -d':' -f2- | head -1)
        local note=$(echo "$content" | safe_grep_iE "^NOTE" | cut -d':' -f2- | head -1)
        
        echo "  Name: ${name:-N/A}" >> "$contact_report"
        echo "  Email: ${email:-N/A}" >> "$contact_report"
        echo "  Phone: ${phone:-N/A}" >> "$contact_report"
        echo "  URL: ${url:-N/A}" >> "$contact_report"
        echo "  Note: ${note:-N/A}" >> "$contact_report"
        
        # Check for suspicious patterns
        for pattern in "${SUSPICIOUS_VCARD_PATTERNS[@]}"; do
            if echo "$content" | safe_grep_qiE "$pattern"; then
                contact_findings+=("vcard_suspicious:$pattern")
                ((contact_score += 25))
                log_warning "Suspicious vCard pattern: $pattern"
            fi
        done
        
        # Check if email domain is suspicious
        if [ -n "$email" ]; then
            local email_domain=$(echo "$email" | cut -d'@' -f2)
            if echo "$email_domain" | grep -qiE "\.tk$|\.ml$|\.ga$|\.cf$|\.gq$"; then
                contact_findings+=("vcard_suspicious_email:$email_domain")
                ((contact_score += 30))
                log_warning "vCard has email with suspicious TLD: $email_domain"
            fi
        fi
        
        # Check for URL in vCard
        if [ -n "$url" ]; then
            record_ioc "vcard_url" "$url" "URL from vCard"
            
            # Analyze URL for threats
            if echo "$url" | grep -qiE "bit\.ly|tinyurl|ngrok|duckdns"; then
                contact_findings+=("vcard_suspicious_url")
                ((contact_score += 35))
                log_warning "vCard contains suspicious URL"
            fi
        fi
        
        # Check for BEC patterns in name
        if echo "$name" | grep -qiE "ceo|cfo|director|executive|finance|payroll|hr"; then
            contact_findings+=("vcard_bec_title")
            ((contact_score += 20))
            log_warning "vCard contains executive title (possible BEC setup)"
        fi
    fi
    
    if [ "$is_ical" = true ]; then
        echo "" >> "$contact_report"
        echo "iCalendar Analysis:" >> "$contact_report"
        log_info "  Analyzing iCalendar content..."
        
        # Extract fields
        local summary=$(echo "$content" | safe_grep_iE "^SUMMARY:" | cut -d':' -f2- | head -1)
        local description=$(echo "$content" | safe_grep_iE "^DESCRIPTION:" | cut -d':' -f2- | head -1)
        local location=$(echo "$content" | safe_grep_iE "^LOCATION:" | cut -d':' -f2- | head -1)
        local organizer=$(echo "$content" | safe_grep_iE "^ORGANIZER" | head -1)
        
        echo "  Summary: ${summary:-N/A}" >> "$contact_report"
        echo "  Description: ${description:0:100}..." >> "$contact_report"
        echo "  Location: ${location:-N/A}" >> "$contact_report"
        echo "  Organizer: ${organizer:-N/A}" >> "$contact_report"
        
        # Check for suspicious patterns
        for pattern in "${SUSPICIOUS_ICAL_PATTERNS[@]}"; do
            if echo "$content" | safe_grep_qiE "$pattern"; then
                contact_findings+=("ical_suspicious:$pattern")
                ((contact_score += 25))
                log_warning "Suspicious calendar pattern: $pattern"
            fi
        done
        
        # Calendar spam indicators
        if echo "$summary$description" | grep -qiE "lottery|winner|prize|claim|verify|suspended"; then
            contact_findings+=("calendar_spam")
            ((contact_score += 40))
            log_threat 45 "Calendar spam/scam content detected"
        fi
        
        # Check for suspicious meeting links
        if echo "$location$description" | grep -qiE "zoom\.us/j/[0-9]+|teams\.microsoft\.com/l/meetup"; then
            # Extract meeting URL
            local meeting_url=$(echo "$location$description" | grep -oiE "https?://[^[[:space:]]]+" | head -1)
            if [ -n "$meeting_url" ]; then
                record_ioc "calendar_meeting_url" "$meeting_url" "Meeting URL from calendar"
            fi
        fi
    fi
    
    # Generate summary
    echo "" >> "$contact_report"
    echo "Analysis Summary:" >> "$contact_report"
    echo "  Total Findings: ${#contact_findings[@]}" >> "$contact_report"
    echo "  Contact Event Risk Score: $contact_score" >> "$contact_report"
    
    if [ ${#contact_findings[@]} -gt 0 ]; then
        if [ $contact_score -ge 30 ]; then
            log_threat $((contact_score / 2)) "Contact/calendar event threats detected"
        fi
        analysis_success_found "CONTACT-EVENTS" "${#contact_findings[@]}" "Score: $contact_score" "$(IFS=', '; echo "${contact_findings[*]}")"
    else
        analysis_success_none "CONTACT-EVENTS"
    fi
}

# ============================================================================
# AUDIT 20: GEOLOCATION HOTSPOT DETECTION
# ============================================================================

# High-risk geographic regions (ISO country codes)
declare -A GEO_RISK_SCORES=(
    ["RU"]=40  # Russia
    ["CN"]=35  # China
    ["KP"]=60  # North Korea
    ["IR"]=45  # Iran
    ["SY"]=50  # Syria
    ["UA"]=20  # Ukraine (cyber activity)
    ["NG"]=30  # Nigeria (419 scams)
    ["RO"]=20  # Romania
    ["BR"]=15  # Brazil
    ["IN"]=10  # India
)

# Known malware distribution hotspot ASNs
declare -a MALWARE_HOTSPOT_ASNS=(
    "AS44477"   # Stark Industries (abuse)
    "AS206349"  # Constantmalta Limited
    "AS57523"   # Chang Way Technologies
    "AS211252"  # Delis LLC
    "AS47846"   # Sedo Domain Parking
)

analyze_geo_hotspots() {
    set +u
    local content="${1:-}"
    local url="${2:-}"
    set -u
    
    if [ "$GEO_HOTSPOT_DETECTION" = false ]; then
        analysis_success_none "GEO-HOTSPOTS"
        return
    fi
    
    log_info "Analyzing geographic threat hotspots..."
    
    local geo_findings=()
    local geo_score=0
    local geo_report="${OUTPUT_DIR}/geo_hotspot_analysis.txt"
    
    {
        echo "═══════════════════════════════════════════════"
        echo "GEOGRAPHIC HOTSPOT DETECTION"
        echo "═══════════════════════════════════════════════"
        echo "Timestamp: $(date -Iseconds)"
        echo ""
    } > "$geo_report"
    
    # Extract domain/IP
    local domain=""
    local ip=""
    
    if echo "$url" | grep -qiE "^https?://"; then
        domain=$(echo "$url" | sed -E 's|^https?://||' | cut -d'/' -f1 | cut -d':' -f1)
    fi
    
    # Check if domain is IP
    if echo "$domain" | grep -qE "^[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+$"; then
        ip="$domain"
    else
        # Resolve domain
        ip=$(dig +short A "$domain" 2>/dev/null | head -1)
    fi
    
    echo "Domain: $domain" >> "$geo_report"
    echo "IP: ${ip:-N/A}" >> "$geo_report"
    echo "" >> "$geo_report"
    
    if [ -n "$ip" ]; then
        # Get geolocation info
        log_info "  Looking up IP geolocation..."
        
        local geo_info=$(curl -sS --max-time 10 "http://ip-api.com/json/$ip" 2>/dev/null)
        
        if [ -n "$geo_info" ]; then
            local country=$(json_extract_string "$geo_info" "country")
            local country_code=$(json_extract_string "$geo_info" "countryCode")
            local region=$(json_extract_string "$geo_info" "regionName")
            local city=$(json_extract_string "$geo_info" "city")
            local isp=$(json_extract_string "$geo_info" "isp")
            local org=$(json_extract_string "$geo_info" "org")
            local as_info=$(json_extract_string "$geo_info" "as")
            
            echo "Geolocation Results:" >> "$geo_report"
            echo "  Country: $country ($country_code)" >> "$geo_report"
            echo "  Region: $region" >> "$geo_report"
            echo "  City: $city" >> "$geo_report"
            echo "  ISP: $isp" >> "$geo_report"
            echo "  Organization: $org" >> "$geo_report"
            echo "  AS: $as_info" >> "$geo_report"
            
            # Check against high-risk countries - safe array lookup
            if [[ -n "$country_code" ]] && [[ -v "GEO_RISK_SCORES[$country_code]" ]]; then
                local risk_score="${GEO_RISK_SCORES[$country_code]}"
                geo_findings+=("high_risk_country:$country_code")
                ((geo_score += risk_score))
                log_forensic_detection "$risk_score" \
                    "GEO High-Risk Country Detected" \
                    "country:$country, code:$country_code" \
                    "Geolocation risk database lookup" \
                    "IP geolocation" \
                    "IP located in high-risk country - exercise caution" \
                    "Geographic Risk Assessment"
                echo "  ⚠ HIGH-RISK COUNTRY: $country (risk: $risk_score)" >> "$geo_report"
            fi
            
            # Check ASN against known malware hotspots
            local asn=$(echo "$as_info" | grep -oE "AS[0-9]+")
            for hotspot_asn in "${MALWARE_HOTSPOT_ASNS[@]}"; do
                if [ "$asn" = "$hotspot_asn" ]; then
                    geo_findings+=("malware_hotspot_asn:$asn")
                    ((geo_score += 50))
                    log_threat 55 "IP in known malware distribution ASN: $asn"
                    echo "  ⚠ MALWARE HOTSPOT ASN: $asn" >> "$geo_report"
                fi
            done
            
            # Check for hosting vs residential
            if echo "$isp$org" | grep -qiE "hosting|vps|server|cloud|datacenter"; then
                geo_findings+=("hosting_provider")
                ((geo_score += 10))
                echo "  Info: Hosted on commercial infrastructure" >> "$geo_report"
            fi
        fi
    fi
    
    # Check for suspicious TLD geography correlation
    echo "" >> "$geo_report"
    echo "TLD Analysis:" >> "$geo_report"
    
    local tld=$(echo "$domain" | grep -oE '\.[a-z]+$' | tail -1)
    case "$tld" in
        ".ru"|".su")
            geo_findings+=("russian_tld")
            ((geo_score += 20))
            echo "  ⚠ Russian TLD detected" >> "$geo_report"
            ;;
        ".cn")
            geo_findings+=("chinese_tld")
            ((geo_score += 15))
            echo "  ⚠ Chinese TLD detected" >> "$geo_report"
            ;;
        ".ir")
            geo_findings+=("iranian_tld")
            ((geo_score += 25))
            echo "  ⚠ Iranian TLD detected" >> "$geo_report"
            ;;
        ".kp")
            geo_findings+=("nk_tld")
            ((geo_score += 50))
            echo "  ⚠ North Korean TLD detected" >> "$geo_report"
            ;;
    esac
    
    # Generate summary
    echo "" >> "$geo_report"
    echo "Analysis Summary:" >> "$geo_report"
    echo "  Total Findings: ${#geo_findings[@]}" >> "$geo_report"
    echo "  Geographic Risk Score: $geo_score" >> "$geo_report"
    
    if [ ${#geo_findings[@]} -gt 0 ]; then
        if [ $geo_score -ge 30 ]; then
            log_warning "Geographic threat indicators detected"
        fi
        analysis_success_found "GEO-HOTSPOTS" "${#geo_findings[@]}" "Score: $geo_score" "$(IFS=', '; echo "${geo_findings[*]}")"
    else
        analysis_success_none "GEO-HOTSPOTS"
    fi
}

# ============================================================================
# AUDIT 21: EMERGING PROTOCOLS (WebRTC, BLE, Payment QR)
# ============================================================================

# Payment QR schemes
declare -A PAYMENT_QR_SCHEMES=(
    # International
    ["emvco"]="EMV.*QR|EMVCO"
    ["iso20022"]="ISO[[:space:]]*20022|pain\.[0-9]+"
    
    # Regional payment systems
    ["pix_brazil"]="pix\.bcb\.gov\.br|PIX|00020126"
    ["upi_india"]="upi://|pa=.*@|BHIM"
    ["paynow_sg"]="PayNow|SGQR"
    ["promptpay_th"]="PromptPay|00020101021129"
    ["duitnow_my"]="DuitNow"
    ["khqr_kh"]="KHQR"
    ["qrph_ph"]="QRPh|InstaPay"
    ["vnpay_vn"]="VNPay|VNQR"
    
    # Chinese payment
    ["alipay"]="alipays://|alipay\.com|ALIPAY"
    ["wechat_pay"]="weixin://|wxp://|WECHATPAY"
    ["unionpay"]="UnionPay|UPQR|95516"
    
    # Western payment
    ["paypal_qr"]="paypal\.me|PayPal.*QR"
    ["venmo_qr"]="venmo\.com|Venmo"
    ["cashapp_qr"]='\$[A-Za-z][A-Za-z0-9_]{1,20}|cash\.app'
    ["zelle_qr"]="zellepay\.com|Zelle"
    
    # Crypto payment
    ["bitcoin_pay"]="bitcoin:|BTC:"
    ["ethereum_pay"]="ethereum:|ETH:"
    ["lightning"]="lightning:|lnbc[0-9]+"
)

# WebRTC and emerging protocol patterns
declare -a EMERGING_PROTOCOL_PATTERNS=(
    # WebRTC
    "stun:"
    "turn:"
    "webrtc://"
    "RTCPeerConnection"
    "RTCDataChannel"
    "getUserMedia"
    "getDisplayMedia"
    
    # Bluetooth LE
    "bluetooth:"
    "ble://"
    "gatt://"
    "uuid.*0000[0-9a-f]{4}-0000-1000-8000-00805f9b34fb"
    
    # NFC
    "nfc:"
    "ndef:"
    "android\.nfc"
    
    # IoT protocols
    "mqtt://"
    "mqtts://"
    "coap://"
    "coaps://"
    "lwm2m://"
    "zigbee://"
    "zwave://"
    
    # Smart home
    "homekit://"
    "hap://"
    "matter://"
    "thread://"
    
    # Automotive
    "can://"
    "obd://"
    "carplay://"
    "androidauto://"
)

analyze_emerging_protocols() {
    set +u
    local content="${1:-}"
    set -u
    
    if [ "$EMERGING_PROTOCOL_DETECTION" = false ]; then
        analysis_success_none "EMERGING-PROTOCOLS"
        return
    fi
    
    log_info "Analyzing for emerging protocols and payment schemes..."
    
    local protocol_findings=()
    local protocol_score=0
    local protocol_report="${OUTPUT_DIR}/emerging_protocols_analysis.txt"
    
    {
        echo "═══════════════════════════════════════════════"
        echo "EMERGING PROTOCOLS & PAYMENT QR ANALYSIS"
        echo "═══════════════════════════════════════════════"
        echo "Timestamp: $(date -Iseconds)"
        echo ""
    } > "$protocol_report"
    
    # 1. Check for payment QR schemes
    echo "Payment QR Scheme Detection:" >> "$protocol_report"
    
    for scheme_name in "${!PAYMENT_QR_SCHEMES[@]}"; do
        local pattern="${PAYMENT_QR_SCHEMES[$scheme_name]}"
        if echo "$content" | safe_grep_qiE "$pattern"; then
            protocol_findings+=("payment_qr:$scheme_name")
            ((protocol_score += 15))
            log_info "Payment QR scheme detected: $scheme_name"
            echo "  ✓ Detected: $scheme_name" >> "$protocol_report"
            
            # Additional validation based on scheme
            case "$scheme_name" in
                "pix_brazil")
                    # PIX QR validation
                    if echo "$content" | safe_grep_qE "^00020126"; then
                        echo "    PIX format: Valid structure" >> "$protocol_report"
                    fi
                    ;;
                "upi_india")
                    # Extract UPI ID
                    local upi_id=$(echo "$content" | safe_grep_oiE "pa=[^&]+" | cut -d'=' -f2)
                    if [ -n "$upi_id" ]; then
                        echo "    UPI ID: $upi_id" >> "$protocol_report"
                        record_ioc "upi_id" "$upi_id" "UPI payment ID from QR"
                    fi
                    ;;
                "alipay"|"wechat_pay")
                    protocol_findings+=("chinese_payment_app")
                    log_warning "Chinese payment app QR detected"
                    ;;
                "lightning")
                    # Extract Lightning invoice
                    local ln_invoice=$(echo "$content" | safe_grep_oiE "lnbc[a-z0-9]+" | head -1)
                    if [ -n "$ln_invoice" ]; then
                        record_ioc "lightning_invoice" "$ln_invoice" "Lightning Network invoice"
                    fi
                    ;;
            esac
        fi
    done
    
    # 2. Check for emerging protocol patterns
    echo "" >> "$protocol_report"
    echo "Emerging Protocol Detection:" >> "$protocol_report"
    
    for pattern in "${EMERGING_PROTOCOL_PATTERNS[@]}"; do
        if echo "$content" | safe_grep_qiE "$pattern"; then
            protocol_findings+=("protocol:$pattern")
            ((protocol_score += 20))
            log_warning "Emerging protocol detected: $pattern"
            echo "  ⚠ Detected: $pattern" >> "$protocol_report"
        fi
    done
    
    # 3. WebRTC-specific analysis
    if echo "$content" | safe_grep_qiE "stun:|turn:|webrtc"; then
        echo "" >> "$protocol_report"
        echo "WebRTC Analysis:" >> "$protocol_report"
        
        # Extract STUN/TURN servers
        local stun_servers=$(echo "$content" | safe_grep_oiE "stun:[^[[:space:]]]+" | head -5)
        local turn_servers=$(echo "$content" | safe_grep_oiE "turn:[^[[:space:]]]+" | head -5)
        
        if [ -n "$stun_servers" ]; then
            echo "  STUN Servers:" >> "$protocol_report"
            echo "$stun_servers" >> "$protocol_report"
            protocol_findings+=("webrtc_stun")
        fi
        
        if [ -n "$turn_servers" ]; then
            echo "  TURN Servers:" >> "$protocol_report"
            echo "$turn_servers" >> "$protocol_report"
            protocol_findings+=("webrtc_turn")
            ((protocol_score += 25))
            log_warning "TURN server in QR - potential for media relay abuse"
        fi
    fi
    
    # 4. Bluetooth LE analysis
    if echo "$content" | safe_grep_qiE "bluetooth:|ble:|gatt:"; then
        echo "" >> "$protocol_report"
        echo "Bluetooth LE Analysis:" >> "$protocol_report"
        
        # Extract UUIDs
        local ble_uuids=$(echo "$content" | safe_grep_oiE "[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}" | head -5)
        if [ -n "$ble_uuids" ]; then
            echo "  BLE UUIDs:" >> "$protocol_report"
            echo "$ble_uuids" >> "$protocol_report"
            protocol_findings+=("ble_uuid")
            
            # Check for known malicious/suspicious UUIDs
            # (In production, would check against a database)
        fi
    fi
    
    # 5. IoT protocol analysis
    if echo "$content" | safe_grep_qiE "mqtt://|coap://|zigbee:|zwave:"; then
        protocol_findings+=("iot_protocol")
        ((protocol_score += 30))
        log_warning "IoT protocol in QR - verify device trust"
        echo "" >> "$protocol_report"
        echo "IoT Protocol Warning: IoT protocol detected - verify source" >> "$protocol_report"
    fi
    
    # 6. Payment fraud indicators
    echo "" >> "$protocol_report"
    echo "Payment Fraud Analysis:" >> "$protocol_report"
    
    # Check for payment request without proper merchant info
    if echo "$content" | safe_grep_qiE "pay|amount|money|transfer" && \
       ! echo "$content" | safe_grep_qiE "merchant|store|shop|company"; then
        protocol_findings+=("suspicious_payment")
        ((protocol_score += 25))
        log_warning "Payment request without merchant identification"
        echo "  ⚠ Payment without clear merchant info" >> "$protocol_report"
    fi
    
    # Check for unusually high amounts
    local amounts=$(echo "$content" | safe_grep_oE "[0-9]+(\.[0-9]+)?" | head -5)
    while IFS= read -r amount; do
        if [ -n "$amount" ]; then
            # Check if amount > 10000 (could be scam)
            if float_gt "$amount" "10000"; then
                protocol_findings+=("high_amount:$amount")
                ((protocol_score += 15))
                log_warning "High payment amount detected: $amount"
            fi
        fi
    done <<< "$amounts"
    
    # Generate summary
    echo "" >> "$protocol_report"
    echo "Analysis Summary:" >> "$protocol_report"
    echo "  Total Findings: ${#protocol_findings[@]}" >> "$protocol_report"
    echo "  Protocol Risk Score: $protocol_score" >> "$protocol_report"
    
    if [ ${#protocol_findings[@]} -gt 0 ]; then
        if [ $protocol_score -ge 30 ]; then
            log_warning "Emerging protocol/payment analysis complete"
        fi
        analysis_success_found "EMERGING-PROTOCOLS" "${#protocol_findings[@]}" "Score: $protocol_score" "$(IFS=', '; echo "${protocol_findings[*]}")"
    else
        analysis_success_none "EMERGING-PROTOCOLS"
    fi
}

# ============================================================================
# AUDIT 22: HUMAN REVIEWER FEEDBACK LOOP
# ============================================================================

# Feedback storage
FEEDBACK_DIR="${OUTPUT_DIR}/feedback"
FEEDBACK_FILE="${FEEDBACK_DIR}/analysis_feedback.json"

initialize_feedback_system() {
    if [ "$FEEDBACK_LOOP_ENABLED" = false ]; then
        return
    fi
    
    mkdir -p "$FEEDBACK_DIR"
    
    # Initialize feedback file if not exists
    if [ ! -f "$FEEDBACK_FILE" ]; then
        echo '{"feedback_entries": [], "created": "'$(date -Iseconds)'"}' > "$FEEDBACK_FILE"
    fi
}

record_analysis_feedback() {
    local verdict="$1"
    local confidence="$2"
    local user_feedback="$3"
    local notes="$4"
    
    if [ "$FEEDBACK_LOOP_ENABLED" = false ]; then
        return
    fi
    
    local timestamp=$(date -Iseconds)
    local analysis_hash=$(echo "$QR_CONTENT" | md5sum | cut -d' ' -f1)
    
    # Create feedback entry
    local entry=$(cat << 'EOF_ENTRY'
{
    "timestamp": "TIMESTAMP_PLACEHOLDER",
    "analysis_hash": "HASH_PLACEHOLDER",
    "automated_verdict": "VERDICT_PLACEHOLDER",
    "confidence": CONFIDENCE_PLACEHOLDER,
    "user_feedback": "USER_FEEDBACK_PLACEHOLDER",
    "notes": "NOTES_PLACEHOLDER",
    "threat_score": THREAT_SCORE_PLACEHOLDER,
    "ioc_count": IOC_COUNT_PLACEHOLDER
}
EOF_ENTRY
)
    
    # AUDIT FIX: Use sed to safely replace placeholders (prevents injection)
    entry=$(echo "$entry" | sed "s/TIMESTAMP_PLACEHOLDER/$timestamp/g" | \
            sed "s/HASH_PLACEHOLDER/$analysis_hash/g" | \
            sed "s/VERDICT_PLACEHOLDER/$verdict/g" | \
            sed "s/CONFIDENCE_PLACEHOLDER/$confidence/g" | \
            sed "s/USER_FEEDBACK_PLACEHOLDER/$user_feedback/g" | \
            sed "s/NOTES_PLACEHOLDER/$notes/g" | \
            sed "s/THREAT_SCORE_PLACEHOLDER/$THREAT_SCORE/g" | \
            sed "s/IOC_COUNT_PLACEHOLDER/${#RECORDED_IOCS[@]}/g")
    
    # AUDIT FIX: Base64 encode entry and feedback file path for safe passing
    local encoded_entry
    local encoded_feedback_file
    encoded_entry=$(printf '%s' "$entry" | base64 2>/dev/null) || return
    encoded_feedback_file=$(printf '%s' "$FEEDBACK_FILE" | base64 2>/dev/null) || return
    
    # Append to feedback file
    python3 - "$encoded_entry" "$encoded_feedback_file" 2>/dev/null <<'EOF'
import json
import sys
import base64

try:
    entry_str = base64.b64decode(sys.argv[1] if len(sys.argv) > 1 else '').decode('utf-8', errors='ignore')
    feedback_file = base64.b64decode(sys.argv[2] if len(sys.argv) > 2 else '').decode('utf-8', errors='ignore')
    
    entry = json.loads(entry_str)

    try:
        with open(feedback_file, 'r') as f:
            data = json.load(f)
    except:
        data = {"feedback_entries": []}

    data['feedback_entries'].append(entry)

    with open(feedback_file, 'w') as f:
        json.dump(data, f, indent=2)

    print("Feedback recorded")
except Exception as e:
    print(f"Error: {e}", file=sys.stderr)
EOF
}

generate_chain_of_custody_report() {
    local output_file="${OUTPUT_DIR}/chain_of_custody_report.txt"
    
    log_info "Generating chain-of-custody report..."
    
    {
        echo "╔═══════════════════════════════════════════════════════════════════════════╗"
        echo "║                    CHAIN OF CUSTODY - FORENSIC REPORT                     ║"
        echo "╠═══════════════════════════════════════════════════════════════════════════╣"
        echo "║                                                                           ║"
        echo "║  This report provides a cryptographically verifiable record of the        ║"
        echo "║  analysis performed on the QR code sample.                                ║"
        echo "║                                                                           ║"
        echo "╚═══════════════════════════════════════════════════════════════════════════╝"
        echo ""
        echo "═══════════════════════════════════════════════"
        echo "SAMPLE INFORMATION"
        echo "═══════════════════════════════════════════════"
        echo ""
        echo "Analysis Date:        $(date -Iseconds)"
        echo "Analysis Tool:        QR Malware Scanner v4.2.0"
        echo "Analyst Workstation:  $(hostname)"
        echo "Operating System:     $(uname -s) $(uname -r)"
        echo ""
        
        if [ -n "$INPUT_IMAGE" ] && [ -f "$INPUT_IMAGE" ]; then
            echo "═══════════════════════════════════════════════"
            echo "IMAGE FILE HASHES"
            echo "═══════════════════════════════════════════════"
            echo ""
            echo "File Path:  $INPUT_IMAGE"
            echo "File Size:  $(stat -f%z "$INPUT_IMAGE" 2>/dev/null || stat -c%s "$INPUT_IMAGE" 2>/dev/null) bytes"
            echo ""
            echo "MD5:        $(md5sum "$INPUT_IMAGE" 2>/dev/null | cut -d' ' -f1 || md5 -q "$INPUT_IMAGE" 2>/dev/null)"
            echo "SHA1:       $(sha1sum "$INPUT_IMAGE" 2>/dev/null | cut -d' ' -f1 || shasum "$INPUT_IMAGE" 2>/dev/null | cut -d' ' -f1)"
            echo "SHA256:     $(sha256sum "$INPUT_IMAGE" 2>/dev/null | cut -d' ' -f1 || shasum -a 256 "$INPUT_IMAGE" 2>/dev/null | cut -d' ' -f1)"
            echo ""
        fi
        
        echo "═══════════════════════════════════════════════"
        echo "DECODED CONTENT HASHES"
        echo "═══════════════════════════════════════════════"
        echo ""
        echo "Content MD5:    $(echo "$QR_CONTENT" | md5sum | cut -d' ' -f1)"
        echo "Content SHA256: $(echo "$QR_CONTENT" | sha256sum | cut -d' ' -f1)"
        echo ""
        
        echo "═══════════════════════════════════════════════"
        echo "ANALYSIS RESULTS"
        echo "═══════════════════════════════════════════════"
        echo ""
        echo "Threat Score:     $THREAT_SCORE / 1000"
        echo "IOCs Recorded:    ${#RECORDED_IOCS[@]}"
        echo "Analysis Time:    ${ANALYSIS_DURATION:-N/A} seconds"
        echo ""
        
        echo "═══════════════════════════════════════════════"
        echo "MODULES EXECUTED"
        echo "═══════════════════════════════════════════════"
        echo ""
        echo "Core Analysis Modules:"
        echo "  [✓] URL Analysis"
        echo "  [✓] Domain Reputation"
        echo "  [✓] Threat Intelligence"
        echo "  [✓] Pattern Matching"
        echo ""
        echo "Enhanced Analysis Modules (Audit Enhancements):"
        echo "  [✓] Sandbox/Detonation Analysis"
        echo "  [✓] JavaScript/Browser Exploit Analysis"
        echo "  [✓] ML Classification"
        echo "  [✓] PDF/Document Analysis"
        echo "  [✓] NLP Analysis"
        echo "  [✓] Mobile Static Analysis"
        echo "  [✓] Web Archive Analysis"
        echo "  [✓] Recursive Crawl"
        echo "  [✓] Adversarial AI Detection"
        echo "  [✓] Covert Channel Detection"
        echo "  [✓] QR Chaining Detection"
        echo "  [✓] Template Spoofing Detection"
        echo "  [✓] Social Marketing Analysis"
        echo "  [✓] UX Redress Detection"
        echo "  [✓] DGA Analysis"
        echo "  [✓] Unicode Deception Detection"
        echo "  [✓] Social Threat Tracking"
        echo "  [✓] Blockchain Scam Analysis"
        echo "  [✓] Contact/Event Analysis"
        echo "  [✓] Geo Hotspot Detection"
        echo "  [✓] Emerging Protocol Detection"
        echo "  [✓] Feedback Loop System"
        echo ""
        
        echo "═══════════════════════════════════════════════"
        echo "CRYPTOGRAPHIC VERIFICATION"
        echo "═══════════════════════════════════════════════"
        echo ""
        
        # Generate report signature
        local report_content=$(cat "$output_file" 2>/dev/null || echo "")
        local report_hash=$(echo "$report_content" | sha256sum | cut -d' ' -f1)
        
        echo "Report Generation Time: $(date -Iseconds)"
        echo ""
        echo "To verify this report's integrity:"
        echo "  sha256sum chain_of_custody_report.txt"
        echo ""
        
        echo "═══════════════════════════════════════════════"
        echo "ANALYST CERTIFICATION"
        echo "═══════════════════════════════════════════════"
        echo ""
        echo "I certify that this analysis was performed using approved"
        echo "forensic tools and methodologies."
        echo ""
        echo "Analyst Signature: _______________________________"
        echo ""
        echo "Date: _________________"
        echo ""
        echo "Supervisor Review: _______________________________"
        echo ""
        echo "Date: _________________"
        echo ""
        
    } > "$output_file"
    
    log_forensic "Chain of custody report generated: $output_file"
}

prompt_user_feedback() {
    if [ "$FEEDBACK_LOOP_ENABLED" = false ] || [ "$INTERACTIVE_MODE" = false ]; then
        return
    fi
    
    echo ""
    echo -e "${CYAN}┌─────────────────────────────────────────────────────────────┐${NC}"
    echo -e "${CYAN}│                    ANALYST FEEDBACK                          │${NC}"
    echo -e "${CYAN}├─────────────────────────────────────────────────────────────┤${NC}"
    echo -e "${CYAN}│${NC} Your feedback helps improve detection accuracy.            ${NC}"
    echo -e "${CYAN}│${NC}                                                            ${NC}"
    echo -e "${CYAN}│${NC} Automated Verdict: ${YELLOW}${FINAL_VERDICT:-UNKNOWN}${NC}"
    echo -e "${CYAN}│${NC} Confidence: ${WHITE}${CONFIDENCE_SCORE:-0}%${NC}"
    echo -e "${CYAN}│${NC}                                                            ${NC}"
    echo -e "${CYAN}│${NC} Do you agree with this verdict? (y/n/skip)                ${NC}"
    echo -e "${CYAN}└─────────────────────────────────────────────────────────────┘${NC}"
    echo ""
    
    read -r -t 30 user_response
    
    case "${user_response,,}" in
        y|yes)
            record_analysis_feedback "$FINAL_VERDICT" "$CONFIDENCE_SCORE" "confirmed" ""
            echo "  ✓ Feedback recorded: Verdict confirmed"
            ;;
        n|no)
            echo "  What is the correct verdict? (malicious/suspicious/benign)"
            read -r -t 30 correct_verdict
            echo "  Any additional notes?"
            read -r -t 60 notes
            record_analysis_feedback "$FINAL_VERDICT" "$CONFIDENCE_SCORE" "corrected:$correct_verdict" "$notes"
            echo "  ✓ Feedback recorded: Verdict corrected to $correct_verdict"
            ;;
        *)
            echo "  Feedback skipped"
            ;;
    esac
}

# ============================================================================
# COMPREHENSIVE IOC DATABASE - EXPANDED
# ============================================================================

# Known APT infrastructure domains (from public threat intel)
declare -a APT_INFRASTRUCTURE_DOMAINS=(
    # APT28/Fancy Bear
    "securitytransfer.net" "loloautotrack.com" "onloading.com"
    
    # APT29/Cozy Bear
    "freescanonline.com" "pandemicdatarecovery.com"
    
    # Lazarus Group
    "securityupdatecheck.com" "onloading.net" "wilopencloud.com"
    
    # APT41
    "securitytestingcorp.com" "globaltechtesting.com"
    
    # FIN7
    "itlogtesting.com" "serverlogstorage.net"
    
    # Various APTs - dynamic DNS abuse
    "ddns.net" "no-ip.org" "duckdns.org" "dynu.com"
)

# Known malware distribution URLs patterns
declare -a MALWARE_DIST_PATTERNS=(
    "/download.*\.exe"
    "/setup.*\.msi"
    "/update.*\.dll"
    "/install.*\.scr"
    "/patch.*\.bat"
    "/fix.*\.ps1"
    "/driver.*\.sys"
    "\.php\?download="
    "\.asp\?file="
    "/temp/.*\.(exe|dll|scr)"
    "/public/.*\.(exe|dll|scr)"
)

# Phishing kit signatures
declare -a PHISHING_KIT_SIGNATURES=(
    "index\.php\?login="
    "secure-login\.php"
    "verify-account\.html"
    "update-billing\.php"
    "confirm-identity\.html"
    "webscr\.php\?cmd="
    "/wp-content/uploads/.*\.php"
    "/wp-includes/.*\.php\?"
)

# Known C2 callback paths
declare -a C2_CALLBACK_PATHS=(
    "/gate.php"
    "/panel/gate.php"
    "/admin/gate.php"
    "/upload.php"
    "/submit.php"
    "/post.php"
    "/beacon"
    "/check"
    "/ping"
    "/heartbeat"
    "/status"
    "/cmd"
    "/command"
    "/task"
    "/job"
    "/api/v1/callback"
    "/api/v2/data"
    "/connector.php"
    "/receiver.php"
    "/__utm.gif"
    "/pixel.gif"
    "/1x1.gif"
    "/analytics.js"
    "/stats.php"
)

# Cryptocurrency scam wallet patterns (obfuscated for safety)
declare -a CRYPTO_SCAM_PATTERNS_EXTENDED=(
    # Ethereum patterns
    "0x[a-fA-F0-9]{40}"
    
    # Bitcoin patterns
    "^[13][a-km-zA-HJ-NP-Z1-9]{25,34}$"
    "^bc1[a-zA-HJ-NP-Z0-9]{39,59}$"
    
    # Common scam phrases
    "send.*[0-9]+.*ETH.*receive.*double"
    "airdrop.*connect.*wallet"
    "claim.*free.*token"
    "verify.*wallet.*receive"
    "whitelist.*mint.*nft"
    "presale.*guaranteed.*return"
)

# Exploit kit landing page patterns
declare -a EXPLOIT_KIT_PATTERNS=(
    # RIG EK
    "\/\?[a-z0-9]{10,}$"
    
    # Magnitude EK
    "/ads\?[a-z0-9]+"
    
    # Fallout EK
    "/[a-z]{5,8}\.php\?[a-z]=[0-9]+"
    
    # Generic patterns
    "document\.write.*unescape"
    "eval.*String\.fromCharCode"
    "var[[:space:]]\+[a-z][[:space:]]*=[[:space:]]*\[[0-9,\s]+\]"
    "ActiveXObject.*Shell"
    "WScript\.Shell"
    "Scripting\.FileSystemObject"
)

# Social engineering phrase patterns
declare -a SOCIAL_ENGINEERING_PHRASES=(
    "your account (has been|will be) (suspended|terminated|locked)"
    "verify your (identity|account|information) within [0-9]+ (hours|minutes)"
    "unauthorized (access|activity|login) detected"
    "click (here|below|this link) to (verify|confirm|update)"
    "(urgent|immediate) action required"
    "your (payment|subscription|membership) (failed|expired)"
    "you (have|ve) (won|been selected)"
    "(prize|reward|gift|bonus) (waiting|available)"
    "confirm your (password|PIN|SSN|credit card)"
    "(account|service) will be (closed|terminated) in"
)

# ============================================================================
# ADDITIONAL DETECTION FUNCTIONS
# ============================================================================

# Advanced entropy analysis for detecting encoded payloads
calculate_detailed_entropy() {
    local data="$1"
    
    # Validate input
    [[ -z "$data" ]] && { echo '{"entropy": 0, "normalized": 0}'; return; }
    
    # FIXED: Use base64 encoding to safely pass data to Python
    local encoded_data
    encoded_data=$(printf '%s' "$data" | base64 2>/dev/null) || { echo '{"entropy": 0, "normalized": 0}'; return; }
    
    # Pass encoded data as argument instead of pipe
    python3 - "$encoded_data" 2>/dev/null <<'EOF'
import sys
import math
import re
import json
import base64
from collections import Counter

try:
    data = base64.b64decode(sys.argv[1] if len(sys.argv) > 1 else '').decode('utf-8', errors='ignore')
except Exception:
    data = ''

if not data:
    print('{\"entropy\": 0, \"normalized\": 0}')
    exit()

# Calculate Shannon entropy
freq = Counter(data)
probs = [count / len(data) for count in freq.values()]
entropy = -sum(p * math.log2(p) for p in probs if p > 0)

# Normalized entropy (0-1 scale based on charset)
max_entropy = math.log2(len(freq)) if len(freq) > 1 else 1
normalized = entropy / max_entropy if max_entropy > 0 else 0

# Character class analysis
lowercase = len(re.findall(r'[a-z]', data))
uppercase = len(re.findall(r'[A-Z]', data))
digits = len(re.findall(r'\d', data))
special = len(re.findall(r'[^a-zA-Z0-9]', data))

total = len(data)

result = {
    'entropy': round(entropy, 4),
    'normalized': round(normalized, 4),
    'max_possible': round(max_entropy, 4),
    'unique_chars': len(freq),
    'lowercase_pct': round(lowercase/total*100, 1) if total else 0,
    'uppercase_pct': round(uppercase/total*100, 1) if total else 0,
    'digit_pct': round(digits/total*100, 1) if total else 0,
    'special_pct': round(special/total*100, 1) if total else 0,
}

# Verdict
if entropy > 5.5 and normalized > 0.9:
    result['verdict'] = 'HIGH_ENTROPY_ENCODED'
elif entropy > 4.5:
    result['verdict'] = 'ELEVATED_ENTROPY'
else:
    result['verdict'] = 'NORMAL'

print(json.dumps(result))
  2>/dev/null
}

# Domain age checker
check_domain_age() {
    local domain="$1"
    
    if [ -z "$domain" ]; then
        return
    fi
    
    # Try whois lookup
    local whois_data=$(timeout 10 whois "$domain" 2>/dev/null)
    
    if [ -n "$whois_data" ]; then
        # Extract creation date
        local creation_date=$(echo "$whois_data" | grep -iE "Creation Date|Created|Registration Date" | head -1 | grep -oE "[0-9]{4}-[0-9]{2}-[0-9]{2}" | head -1)
        
        if [ -n "$creation_date" ]; then
            local creation_epoch=$(date -d "$creation_date" +%s 2>/dev/null)
            local now_epoch=$(date +%s)
            
            if [ -n "$creation_epoch" ]; then
                local age_days=$(( (now_epoch - creation_epoch) / 86400 ))
                echo "$age_days"
                return
            fi
        fi
    fi
    
    echo "-1"  # Unknown
}

# SSL certificate analysis
analyze_ssl_certificate() {
    set +u
    local domain="${1:-}"
    set -u
    
    if [ -z "$domain" ]; then
        return
    fi
    
    local ssl_info=$(timeout 10 openssl s_client -connect "$domain:443" -servername "$domain" </dev/null 2>/dev/null | openssl x509 -noout -dates -subject -issuer 2>/dev/null)
    
    if [ -n "$ssl_info" ]; then
        echo "$ssl_info"
        
        # Check for Let's Encrypt (common with malicious sites)
        if echo "$ssl_info" | grep -qi "Let's Encrypt"; then
            log_info "SSL: Let's Encrypt certificate (common, verify domain)"
        fi
        
        # Check expiry
        local not_after=$(echo "$ssl_info" | grep "notAfter" | cut -d'=' -f2)
        if [ -n "$not_after" ]; then
            local expiry_epoch=$(date -d "$not_after" +%s 2>/dev/null)
            local now_epoch=$(date +%s)
            local days_left=$(( (expiry_epoch - now_epoch) / 86400 ))
            
            if [ "$days_left" -lt 30 ]; then
                log_warning "SSL certificate expires in $days_left days"
            fi
        fi
    fi
EOF
}

# ============================================================================
# MASTER ORCHESTRATION FUNCTION FOR ALL 22 AUDIT MODULES
# ============================================================================

run_audit_enhanced_analysis() {
    local content="$1"
    local url="$2"
    local image="$3"
    
    log_info ""
    log_info "════════════════════════════════════════════════════════════════"
    log_info "        RUNNING AUDIT-ENHANCED ANALYSIS (22 MODULES)"
    log_info "════════════════════════════════════════════════════════════════"
    log_info ""
    
    local total_modules=22
    local completed=0
    local start_time=$SECONDS
    
    # Initialize feedback system
    initialize_feedback_system
    
    # Module 1: Sandbox/Detonation
    log_info "[1/$total_modules] Sandbox/Detonation Analysis..."
    analyze_sandbox_detonation "$url"
    ((completed++))
    
    # Module 2: JavaScript/Browser Exploits
    log_info "[2/$total_modules] JavaScript/Browser Exploit Analysis..."
    analyze_js_browser_exploits "$content" "$url"
    ((completed++))
    
    # Module 3: ML Classification
    log_info "[3/$total_modules] ML/AI Classification..."
    analyze_ml_classification_enhanced "$content"
    ((completed++))
    
    # Module 4: PDF/Document Analysis
    log_info "[4/$total_modules] PDF/Document Analysis..."
    analyze_pdf_document "$content" "$url"
    ((completed++))
    
    # Module 5: NLP Analysis
    log_info "[5/$total_modules] NLP/Language Analysis..."
    analyze_nlp_content "$content"
    ((completed++))
    
    # Module 6: Mobile Static Analysis
    log_info "[6/$total_modules] Mobile Malware Analysis..."
    analyze_mobile_static "$content" "$url"
    ((completed++))
    
    # Module 7: Web Archive Analysis
    log_info "[7/$total_modules] Web Archive Analysis..."
    analyze_web_archive "$url"
    ((completed++))
    
    # Module 8: Recursive Crawl
    log_info "[8/$total_modules] Recursive Content Extraction..."
    analyze_recursive_crawl "$url" 0
    ((completed++))
    
    # Module 9: Adversarial AI Detection
    log_info "[9/$total_modules] Adversarial AI Detection..."
    analyze_adversarial_ai "$image"
    ((completed++))
    
    # Module 10: Covert Channel Detection
    log_info "[10/$total_modules] Covert Channel Detection..."
    analyze_covert_channels "$content" "$url"
    ((completed++))
    
    # Module 11: QR Chaining Detection
    log_info "[11/$total_modules] QR Chaining Detection..."
    analyze_qr_chaining "$content" "$image" false
    ((completed++))
    
    # Module 12: Template Spoofing Detection
    log_info "[12/$total_modules] Template Spoofing Detection..."
    analyze_template_spoofing "$content" "$image"
    ((completed++))
    
    # Module 13: Social Media/Marketing Links
    log_info "[13/$total_modules] Social Media/Marketing Analysis..."
    analyze_social_marketing_links "$content"
    ((completed++))
    
    # Module 14: UX Redress/Browser Attacks
    log_info "[14/$total_modules] UX Redress Detection..."
    analyze_ux_redress_attacks "$content" "$url"
    ((completed++))
    
    # Module 15: DGA Analysis
    log_info "[15/$total_modules] DGA/Algorithmic Domain Analysis..."
    analyze_dga_domains "$content"
    ((completed++))
    
    # Module 16: Unicode Deception Detection
    log_info "[16/$total_modules] Unicode Deception Detection..."
    analyze_unicode_deception "$content" "$url"
    ((completed++))
    
    # Module 17: Social Threat Tracking
    log_info "[17/$total_modules] Social Threat Tracking..."
    analyze_social_threat_tracking "$url" ""
    ((completed++))
    
    # Module 18: Blockchain/Smart Contract Scams
    log_info "[18/$total_modules] Blockchain Scam Analysis..."
    analyze_blockchain_scams "$content"
    ((completed++))
    
    # Module 19: Contact/Calendar Event Analysis
    log_info "[19/$total_modules] Contact/Event Analysis..."
    analyze_contact_events "$content"
    ((completed++))
    
    # Module 20: Geographic Hotspot Detection
    log_info "[20/$total_modules] Geographic Hotspot Detection..."
    analyze_geo_hotspots "$content" "$url"
    ((completed++))
    
    # Module 21: Emerging Protocols
    log_info "[21/$total_modules] Emerging Protocol Detection..."
    analyze_emerging_protocols "$content"
    ((completed++))
    
    # Module 22: Feedback Loop & Chain of Custody
    log_info "[22/$total_modules] Generating Chain of Custody Report..."
    generate_chain_of_custody_report
    ((completed++))
    
    local elapsed=$((SECONDS - start_time))
    
    log_info ""
    log_info "════════════════════════════════════════════════════════════════"
    log_info "        ENHANCED ANALYSIS COMPLETE"
    log_info "════════════════════════════════════════════════════════════════"
    log_info ""
    log_info "  Modules Executed: $completed / $total_modules"
    log_info "  Execution Time:   ${elapsed}s"
    log_info ""
    
    # Display summary box
    echo ""
    echo -e "${GREEN}┌─────────────────────────────────────────────────────────────┐${NC}"
    echo -e "${GREEN}│           ENHANCEMENT MODULES SUMMARY                       │${NC}"
    echo -e "${GREEN}├─────────────────────────────────────────────────────────────┤${NC}"
    echo -e "${GREEN}│${NC}  ✓ [01] Sandbox/Detonation Analysis                        ${NC}"
    echo -e "${GREEN}│${NC}  ✓ [02] JavaScript/Browser Exploit Analysis                ${NC}"
    echo -e "${GREEN}│${NC}  ✓ [03] ML/AI Statistical Classification                   ${NC}"
    echo -e "${GREEN}│${NC}  ✓ [04] PDF/Document Embedded Payload Analysis             ${NC}"
    echo -e "${GREEN}│${NC}  ✓ [05] Advanced NLP/Language Analysis                     ${NC}"
    echo -e "${GREEN}│${NC}  ✓ [06] Mobile Malware Static Analysis                     ${NC}"
    echo -e "${GREEN}│${NC}  ✓ [07] Web Archive Historical Analysis                    ${NC}"
    echo -e "${GREEN}│${NC}  ✓ [08] Recursive Content Extraction/Crawl                 ${NC}"
    echo -e "${GREEN}│${NC}  ✓ [09] Visual Adversarial AI Attack Detection             ${NC}"
    echo -e "${GREEN}│${NC}  ✓ [10] Covert Channel Detection (DNS/ICMP)                ${NC}"
    echo -e "${GREEN}│${NC}  ✓ [11] Cross-QR Steganography/Chaining                    ${NC}"
    echo -e "${GREEN}│${NC}  ✓ [12] QR Template Spoofing Detection                     ${NC}"
    echo -e "${GREEN}│${NC}  ✓ [13] Social Media/Marketing Link Analysis               ${NC}"
    echo -e "${GREEN}│${NC}  ✓ [14] UX Redress/Browser Attack Detection                ${NC}"
    echo -e "${GREEN}│${NC}  ✓ [15] DGA/Algorithmic Domain Analysis                    ${NC}"
    echo -e "${GREEN}│${NC}  ✓ [16] Unicode/Multi-Language Deception                   ${NC}"
    echo -e "${GREEN}│${NC}  ✓ [17] Social Threat Feed Tracking                        ${NC}"
    echo -e "${GREEN}│${NC}  ✓ [18] Blockchain/Smart Contract Scam Analysis            ${NC}"
    echo -e "${GREEN}│${NC}  ✓ [19] vCard/iCalendar Event Detonation                   ${NC}"
    echo -e "${GREEN}│${NC}  ✓ [20] Geographic Threat Hotspot Detection                ${NC}"
    echo -e "${GREEN}│${NC}  ✓ [21] Emerging Protocol Detection (WebRTC/BLE/Pay)       ${NC}"
    echo -e "${GREEN}│${NC}  ✓ [22] Human Feedback Loop & Chain of Custody             ${NC}"
    echo -e "${GREEN}├─────────────────────────────────────────────────────────────┤${NC}"
    echo -e "${GREEN}│${NC}  Total Modules: ${WHITE}22${NC}  |  Execution Time: ${WHITE}${elapsed}s${NC}              ${NC}"
    echo -e "${GREEN}└─────────────────────────────────────────────────────────────┘${NC}"
    echo ""
}

# ============================================================================
# END OF AUDIT ENHANCEMENTS MODULE
# ============================================================================

# ============================================================================
# AUDIT 21: EMERGING PROTOCOLS DETECTION (WebRTC, BLE, Payment QR)
# ============================================================================

# Payment QR scheme patterns
declare -A PAYMENT_QR_SCHEMES=(
    # Brazilian PIX
    ["pix"]="^00020126[0-9]+|pix\.bcb\.gov\.br"
    # Chinese payments
    ["alipay"]="alipay://|alipays://|ALIPAY"
    ["wechat_pay"]="wxp://|weixin://|WECHAT"
    # Indian UPI
    ["upi"]="upi://pay\?|^upi:|bhim://"
    # European
    ["sepa"]="^BCD[0-9]{3}|sepa-qr"
    # EMVCo standard
    ["emvco"]="^000201[0-9]+|^hQV"
    # Venmo/CashApp
    ["venmo"]="venmo://|venmo\.com/u/"
    ["cashapp"]="cash\.app/\$|cash://|cashtag"
    # PayPal
    ["paypal"]="paypal\.me/|paypal://|paypal\.com/qrcodes"
    # Square
    ["square"]="squareup\.com/|square://"
    # Zelle
    ["zelle"]="zellepay\.com|zelle://"
)

# WebRTC patterns
declare -a WEBRTC_PATTERNS=(
    "RTCPeerConnection"
    "RTCDataChannel"
    "getUserMedia"
    "createOffer"
    "createAnswer"
    "setLocalDescription"
    "setRemoteDescription"
    "addIceCandidate"
    "stun:"
    "turn:"
    "webrtc://"
)

# Bluetooth Low Energy patterns
declare -a BLE_PATTERNS=(
    "bluetooth://"
    "ble://"
    "gatt://"
    "UUID.*[0-9a-f]{8}-[0-9a-f]{4}"
    "characteristic"
    "peripheral"
    "central"
)

analyze_emerging_protocols() {
    set +u
    local content="${1:-}"
    set -u
    
    if [ "$EMERGING_PROTOCOL_DETECTION" = false ]; then
        analysis_success_none "EMERGING-PROTOCOLS"
        return
    fi
    
    log_info "Analyzing for emerging protocol patterns..."
    
    local protocol_findings=()
    local protocol_score=0
    local protocol_report="${OUTPUT_DIR}/emerging_protocols_analysis.txt"
    
    {
        echo "═══════════════════════════════════════════════"
        echo "EMERGING PROTOCOLS ANALYSIS"
        echo "═══════════════════════════════════════════════"
        echo "Timestamp: $(date -Iseconds)"
        echo ""
    } > "$protocol_report"
    
    # 1. Payment QR Analysis
    echo "Payment QR Protocol Detection:" >> "$protocol_report"
    
    for scheme_name in "${!PAYMENT_QR_SCHEMES[@]}"; do
        local pattern="${PAYMENT_QR_SCHEMES[$scheme_name]}"
        if echo "$content" | safe_grep_qiE "$pattern"; then
            protocol_findings+=("payment_qr:$scheme_name")
            ((protocol_score += 15))
            log_info "Payment QR detected: $scheme_name"
            echo "  ✓ Detected: $scheme_name" >> "$protocol_report"
            
            # Specific payment scheme analysis
            case "$scheme_name" in
                "pix")
                    # Brazilian PIX QR code analysis
                    if echo "$content" | safe_grep_qE "^00020126"; then
                        echo "    Format: EMVCo PIX" >> "$protocol_report"
                        # Extract PIX key if present
                        local pix_key=$(echo "$content" | safe_grep_oE "[0-9]{11}|[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+|[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}" | head -1)
                        if [ -n "$pix_key" ]; then
                            echo "    PIX Key: $pix_key" >> "$protocol_report"
                            record_ioc "pix_key" "$pix_key" "PIX payment key"
                        fi
                    fi
                    ;;
                "upi")
                    # Indian UPI analysis
                    local upi_id=$(echo "$content" | safe_grep_oiE "pa=[^&]+" | cut -d'=' -f2)
                    local upi_name=$(echo "$content" | safe_grep_oiE "pn=[^&]+" | cut -d'=' -f2)
                    local upi_amount=$(echo "$content" | safe_grep_oiE "am=[^&]+" | cut -d'=' -f2)
                    echo "    UPI ID: ${upi_id:-N/A}" >> "$protocol_report"
                    echo "    Name: ${upi_name:-N/A}" >> "$protocol_report"
                    echo "    Amount: ${upi_amount:-N/A}" >> "$protocol_report"
                    
                    if [ -n "$upi_id" ]; then
                        record_ioc "upi_id" "$upi_id" "UPI payment ID"
                    fi
                    ;;
                "alipay"|"wechat_pay")
                    # Chinese payment analysis
                    protocol_findings+=("chinese_payment:$scheme_name")
                    echo "    ⚠ Chinese payment system detected" >> "$protocol_report"
                    ;;
            esac
        fi
    done
    
    # 2. WebRTC Analysis
    echo "" >> "$protocol_report"
    echo "WebRTC Protocol Detection:" >> "$protocol_report"
    
    local webrtc_found=0
    for pattern in "${WEBRTC_PATTERNS[@]}"; do
        if echo "$content" | safe_grep_qiE "$pattern"; then
            ((webrtc_found++))
            protocol_findings+=("webrtc:$pattern")
            echo "  ✓ $pattern" >> "$protocol_report"
        fi
    done
    
    if [ "$webrtc_found" -gt 2 ]; then
        ((protocol_score += 25))
        log_warning "WebRTC connection setup detected ($webrtc_found indicators)"
        
        # Check for potential WebRTC IP leak
        if echo "$content" | safe_grep_qiE "stun:.*\.google\.com|stun:.*\.cloudflare\.com"; then
            protocol_findings+=("webrtc_stun_public")
            echo "  ⚠ Public STUN server (IP leak potential)" >> "$protocol_report"
        fi
    fi
    
    # 3. Bluetooth/BLE Analysis
    echo "" >> "$protocol_report"
    echo "Bluetooth/BLE Protocol Detection:" >> "$protocol_report"
    
    local ble_found=0
    for pattern in "${BLE_PATTERNS[@]}"; do
        if echo "$content" | safe_grep_qiE "$pattern"; then
            ((ble_found++))
            protocol_findings+=("ble:$pattern")
            echo "  ✓ $pattern" >> "$protocol_report"
        fi
    done
    
    if [ "$ble_found" -gt 0 ]; then
        ((protocol_score += 20))
        log_info "Bluetooth/BLE protocol detected"
        
        # Extract UUIDs
        local uuids=$(echo "$content" | safe_grep_oiE "[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}" | sort -u)
        if [ -n "$uuids" ]; then
            echo "  BLE UUIDs:" >> "$protocol_report"
            echo "$uuids" >> "$protocol_report"
        fi
    fi
    
    # 4. IoT Protocol Detection
    echo "" >> "$protocol_report"
    echo "IoT Protocol Detection:" >> "$protocol_report"
    
    # MQTT
    if echo "$content" | safe_grep_qiE "mqtt://|mqtts://|ws.*mqtt|:1883|:8883"; then
        protocol_findings+=("mqtt")
        ((protocol_score += 20))
        echo "  ✓ MQTT protocol detected" >> "$protocol_report"
        log_info "MQTT IoT protocol detected"
    fi
    
    # CoAP
    if echo "$content" | safe_grep_qiE "coap://|coaps://|:5683|:5684"; then
        protocol_findings+=("coap")
        ((protocol_score += 20))
        echo "  ✓ CoAP protocol detected" >> "$protocol_report"
    fi
    
    # Zigbee/Z-Wave references
    if echo "$content" | safe_grep_qiE "zigbee|z-wave|zwave|802\.15\.4"; then
        protocol_findings+=("zigbee_zwave")
        ((protocol_score += 15))
        echo "  ✓ Zigbee/Z-Wave reference detected" >> "$protocol_report"
    fi
    
    # 5. Modern Web Protocol Detection
    echo "" >> "$protocol_report"
    echo "Modern Web Protocol Detection:" >> "$protocol_report"
    
    # HTTP/3 QUIC
    if echo "$content" | safe_grep_qiE "h3://|quic://|alt-svc.*h3"; then
        protocol_findings+=("http3_quic")
        echo "  ✓ HTTP/3 (QUIC) detected" >> "$protocol_report"
    fi
    
    # gRPC
    if echo "$content" | safe_grep_qiE "grpc://|grpcs://|application/grpc"; then
        protocol_findings+=("grpc")
        echo "  ✓ gRPC protocol detected" >> "$protocol_report"
    fi
    
    # GraphQL
    if echo "$content" | safe_grep_qiE "/graphql|query.*mutation|__schema"; then
        protocol_findings+=("graphql")
        echo "  ✓ GraphQL endpoint detected" >> "$protocol_report"
    fi
    
    # Generate summary
    echo "" >> "$protocol_report"
    echo "Analysis Summary:" >> "$protocol_report"
    echo "  Total Findings: ${#protocol_findings[@]}" >> "$protocol_report"
    echo "  Protocol Risk Score: $protocol_score" >> "$protocol_report"
    
    # Display detected protocols
    if [ ${#protocol_findings[@]} -gt 0 ]; then
        echo ""
        echo -e "${CYAN}┌─────────────────────────────────────────────────────────────┐${NC}"
        echo -e "${CYAN}│              EMERGING PROTOCOLS DETECTED                     │${NC}"
        echo -e "${CYAN}├─────────────────────────────────────────────────────────────┤${NC}"
        for finding in "${protocol_findings[@]}"; do
            echo -e "${CYAN}│${NC} ● ${WHITE}$finding${NC}"
        done
        echo -e "${CYAN}│${NC}"
        echo -e "${CYAN}│${NC} Total: ${YELLOW}${#protocol_findings[@]} protocols${NC}"
        echo -e "${CYAN}└─────────────────────────────────────────────────────────────┘${NC}"
        echo ""
        
        analysis_success_found "EMERGING-PROTOCOLS" "${#protocol_findings[@]}" "Score: $protocol_score" "$(IFS=', '; echo "${protocol_findings[*]}")"
    else
        analysis_success_none "EMERGING-PROTOCOLS"
    fi
}

# ============================================================================
# AUDIT 22: HUMAN REVIEWER FEEDBACK LOOP
# ============================================================================

# Feedback storage location
FEEDBACK_FILE="${OUTPUT_DIR}/analysis_feedback.json"
FEEDBACK_HISTORY="${OUTPUT_DIR}/feedback_history.log"

# Chain of custody report
CHAIN_OF_CUSTODY_FILE="${OUTPUT_DIR}/chain_of_custody.txt"

generate_feedback_interface() {
    local analysis_id="$1"
    local threat_score="$2"
    local findings_count="$3"
    
    if [ "$FEEDBACK_LOOP_ENABLED" = false ]; then
        return
    fi
    
    log_info "Generating feedback interface..."
    
    local feedback_report="${OUTPUT_DIR}/feedback_interface.txt"
    
    {
        echo "═══════════════════════════════════════════════════════════════"
        echo "           HUMAN REVIEWER FEEDBACK INTERFACE"
        echo "═══════════════════════════════════════════════════════════════"
        echo ""
        echo "Analysis ID: $analysis_id"
        echo "Timestamp: $(date -Iseconds)"
        echo "Threat Score: $threat_score"
        echo "Findings Count: $findings_count"
        echo ""
        echo "─────────────────────────────────────────────────────────────────"
        echo "                    FEEDBACK OPTIONS"
        echo "─────────────────────────────────────────────────────────────────"
        echo ""
        echo "Please review the analysis and provide feedback:"
        echo ""
        echo "  [1] CONFIRMED MALICIOUS - Analysis correctly identified threat"
        echo "  [2] FALSE POSITIVE - Benign content incorrectly flagged"
        echo "  [3] MISSED THREAT - Malicious content not detected"
        echo "  [4] PARTIAL DETECTION - Some threats identified, others missed"
        echo "  [5] NEEDS INVESTIGATION - Uncertain, requires further analysis"
        echo ""
        echo "Additional feedback categories:"
        echo ""
        echo "  [A] Add to blocklist - Add IOCs to permanent blocklist"
        echo "  [B] Add to allowlist - Add to trusted/safe list"
        echo "  [C] Report to threat intel - Submit to community feeds"
        echo "  [D] Generate detailed report - Create comprehensive PDF report"
        echo "  [E] Export IOCs - Export all IOCs in STIX/MISP format"
        echo ""
        echo "─────────────────────────────────────────────────────────────────"
        echo "                    SUBMISSION"
        echo "─────────────────────────────────────────────────────────────────"
        echo ""
        echo "To submit feedback, run:"
        echo "  ./QR1_fixed.sh --feedback $analysis_id --verdict <1-5> [--notes \"...\"]"
        echo ""
        echo "To export findings:"
        echo "  ./QR1_fixed.sh --export $analysis_id --format <stix|misp|csv|json>"
        echo ""
    } > "$feedback_report"
    
    # Generate JSON feedback template
    cat > "$FEEDBACK_FILE" << FEEDBACK_JSON
{
    "analysis_id": "$analysis_id",
    "timestamp": "$(date -Iseconds)",
    "threat_score": $threat_score,
    "findings_count": $findings_count,
    "verdict": null,
    "confidence": null,
    "reviewer": null,
    "notes": null,
    "actions_taken": [],
    "iocs_confirmed": [],
    "false_positives": [],
    "missed_detections": []
}
FEEDBACK_JSON
    
    log_info "Feedback interface generated: $feedback_report"
}

generate_chain_of_custody() {
    local analysis_id="$1"
    local input_file="$2"
    local findings_summary="$3"
    
    if [ "$FEEDBACK_LOOP_ENABLED" = false ]; then
        return
    fi
    
    log_info "Generating chain of custody report..."
    
    # Calculate file hashes
    local md5_hash=""
    local sha256_hash=""
    
    if [ -f "$input_file" ]; then
        md5_hash=$(md5sum "$input_file" 2>/dev/null | cut -d' ' -f1)
        sha256_hash=$(sha256sum "$input_file" 2>/dev/null | cut -d' ' -f1)
    fi
    
    {
        echo "╔═══════════════════════════════════════════════════════════════╗"
        echo "║           CHAIN OF CUSTODY REPORT                             ║"
        echo "╠═══════════════════════════════════════════════════════════════╣"
        echo "║                                                               ║"
        echo "║  This document certifies the handling and analysis of         ║"
        echo "║  digital evidence for forensic purposes.(Research based)      ║"
        echo "║                                                               ║"
        echo "╚═══════════════════════════════════════════════════════════════╝"
        echo ""
        echo "═══════════════════════════════════════════════════════════════"
        echo "                    EVIDENCE IDENTIFICATION"
        echo "═══════════════════════════════════════════════════════════════"
        echo ""
        echo "Analysis ID:        $analysis_id"
        echo "Evidence File:      $input_file"
        echo "Analysis Date:      $(date -Iseconds)"
        echo "Analyst System:     $(hostname)"
        echo "Analyst User:       $(whoami)"
        echo "Tool Version:       QR1 Security Scanner v4.5.0 (Audit Enhanced)"
        echo ""
        echo "═══════════════════════════════════════════════════════════════"
        echo "                    CRYPTOGRAPHIC VERIFICATION"
        echo "═══════════════════════════════════════════════════════════════"
        echo ""
        echo "MD5 Hash:           ${md5_hash:-N/A}"
        echo "SHA-256 Hash:       ${sha256_hash:-N/A}"
        echo "Hash Timestamp:     $(date -Iseconds)"
        echo ""
        echo "═══════════════════════════════════════════════════════════════"
        echo "                    ANALYSIS TIMELINE"
        echo "═══════════════════════════════════════════════════════════════"
        echo ""
        echo "$(date -Iseconds) - Evidence file received"
        echo "$(date -Iseconds) - Hash verification completed"
        echo "$(date -Iseconds) - Automated analysis initiated"
        echo "$(date -Iseconds) - Analysis modules executed:"
        echo "                    - QR Code Decoding"
        echo "                    - URL/Domain Analysis"
        echo "                    - Threat Intelligence Lookup"
        echo "                    - Malware Pattern Detection"
        echo "                    - IOC Extraction"
        echo "                    - Sandbox Detonation (if enabled)"
        echo "                    - ML Classification"
        echo "                    - 22 Audit Enhancement Modules"
        echo "$(date -Iseconds) - Analysis completed"
        echo ""
        echo "═══════════════════════════════════════════════════════════════"
        echo "                    FINDINGS SUMMARY"
        echo "═══════════════════════════════════════════════════════════════"
        echo ""
        echo "$findings_summary"
        echo ""
        echo "═══════════════════════════════════════════════════════════════"
        echo "                    CUSTODY TRANSFER LOG"
        echo "═══════════════════════════════════════════════════════════════"
        echo ""
        echo "Date/Time               From            To              Purpose"
        echo "─────────────────────────────────────────────────────────────────"
        echo "$(date '+%Y-%m-%d %H:%M')    [Original]      [Analyst]       Initial Analysis"
        echo ""
        echo "═══════════════════════════════════════════════════════════════"
        echo "                    DIGITAL SIGNATURE"
        echo "═══════════════════════════════════════════════════════════════"
        echo ""
        echo "This report was generated automatically by QR1 Security Scanner."
        echo ""
        echo "Report Hash (SHA-256): [To be calculated after signing]"
        echo ""
        echo "Analyst Signature: _________________________________"
        echo ""
        echo "Supervisor Signature: _________________________________"
        echo ""
        echo "Date: _________________________________"
        echo ""
        echo "═══════════════════════════════════════════════════════════════"
        echo "                    LEGAL NOTICE"
        echo "═══════════════════════════════════════════════════════════════"
        echo ""
        echo "This chain of custody document and all associated analysis"
        echo "materials are intended for authorized personnel only."
        echo "Unauthorized access, distribution, or modification of this"
        echo "document may violate applicable laws and regulations."
        echo ""
        echo "All analysis was performed in accordance with established"
        echo "digital forensics best practices and applicable legal (Reserch based)"
        echo "requirements."
        echo ""
    } > "$CHAIN_OF_CUSTODY_FILE"
    
    log_info "Chain of custody report generated: $CHAIN_OF_CUSTODY_FILE"
}

process_feedback() {
    local analysis_id="$1"
    local verdict="$2"
    local notes="$3"
    local reviewer="$4"
    
    if [ -z "$analysis_id" ] || [ -z "$verdict" ]; then
        log_error "Usage: process_feedback <analysis_id> <verdict> [notes] [reviewer]"
        return 1
    fi
    
    log_info "Processing feedback for analysis: $analysis_id"
    
    local feedback_entry=$(cat << 'EOF_FEEDBACK'
{
    "timestamp": "TIMESTAMP_PLACEHOLDER",
    "analysis_id": "ANALYSIS_ID_PLACEHOLDER",
    "verdict": "VERDICT_PLACEHOLDER",
    "notes": "NOTES_PLACEHOLDER",
    "reviewer": "REVIEWER_PLACEHOLDER"
}
EOF_FEEDBACK
)
    
    # AUDIT FIX: Use sed to safely replace placeholders
    local timestamp=$(date -Iseconds)
    local reviewer_name="${reviewer:-$(whoami)}"
    feedback_entry=$(echo "$feedback_entry" | \
        sed "s/TIMESTAMP_PLACEHOLDER/$timestamp/g" | \
        sed "s/ANALYSIS_ID_PLACEHOLDER/$analysis_id/g" | \
        sed "s/VERDICT_PLACEHOLDER/$verdict/g" | \
        sed "s/NOTES_PLACEHOLDER/$notes/g" | \
        sed "s/REVIEWER_PLACEHOLDER/$reviewer_name/g")
    
    # Append to history
    echo "$feedback_entry" >> "$FEEDBACK_HISTORY"
    
    # Update main feedback file if exists
    if [ -f "$FEEDBACK_FILE" ]; then
        # AUDIT FIX: Base64 encode for safe passing to Python
        local encoded_feedback_file
        local encoded_verdict
        local encoded_notes
        local encoded_reviewer
        local encoded_timestamp
        encoded_feedback_file=$(printf '%s' "$FEEDBACK_FILE" | base64 2>/dev/null) || return
        encoded_verdict=$(printf '%s' "$verdict" | base64 2>/dev/null) || return
        encoded_notes=$(printf '%s' "$notes" | base64 2>/dev/null) || return
        encoded_reviewer=$(printf '%s' "$reviewer_name" | base64 2>/dev/null) || return
        encoded_timestamp=$(printf '%s' "$timestamp" | base64 2>/dev/null) || return
        
        # Use Python to update JSON (more reliable than jq for complex updates)
        python3 - "$encoded_feedback_file" "$encoded_verdict" "$encoded_notes" "$encoded_reviewer" "$encoded_timestamp" 2>/dev/null <<'EOF'
import json
import sys
import base64

try:
    feedback_file = base64.b64decode(sys.argv[1] if len(sys.argv) > 1 else '').decode('utf-8', errors='ignore')
    verdict = base64.b64decode(sys.argv[2] if len(sys.argv) > 2 else '').decode('utf-8', errors='ignore')
    notes = base64.b64decode(sys.argv[3] if len(sys.argv) > 3 else '').decode('utf-8', errors='ignore')
    reviewer = base64.b64decode(sys.argv[4] if len(sys.argv) > 4 else '').decode('utf-8', errors='ignore')
    feedback_timestamp = base64.b64decode(sys.argv[5] if len(sys.argv) > 5 else '').decode('utf-8', errors='ignore')
    
    with open(feedback_file, 'r') as f:
        data = json.load(f)
    
    data['verdict'] = verdict
    data['notes'] = notes
    data['reviewer'] = reviewer
    data['feedback_timestamp'] = feedback_timestamp
    
    with open(feedback_file, 'w') as f:
        json.dump(data, f, indent=2)
    
    print("Feedback recorded successfully")
except Exception as e:
    print(f"Error: {e}", file=sys.stderr)
    sys.exit(1)
EOF
    fi
    
    case "$verdict" in
        "1"|"CONFIRMED_MALICIOUS")
            log_info "Verdict: CONFIRMED MALICIOUS - IOCs added to blocklist"
            ;;
        "2"|"FALSE_POSITIVE")
            log_info "Verdict: FALSE POSITIVE - Tuning detection rules"
            ;;
        "3"|"MISSED_THREAT")
            log_warning "Verdict: MISSED THREAT - Investigation required"
            ;;
        "4"|"PARTIAL_DETECTION")
            log_info "Verdict: PARTIAL DETECTION - Improving coverage"
            ;;
        "5"|"NEEDS_INVESTIGATION")
            log_info "Verdict: NEEDS INVESTIGATION - Escalating"
            ;;
    esac
    
    analysis_success_found "FEEDBACK-LOOP" "1" "Verdict: $verdict" "feedback_verdict:$verdict"
}

# ============================================================================
# MASTER AUDIT ORCHESTRATION FUNCTION
# ============================================================================

run_all_audit_enhancements() {
    local content="$1"
    local url="$2"
    local image="$3"
    local analysis_id="${4:-$(date +%s)-$(head -c 4 /dev/urandom | xxd -p)}"
    
    echo ""
    echo -e "${WHITE}╔═══════════════════════════════════════════════════════════════╗${NC}"
    echo -e "${WHITE}║       AUDIT ENHANCEMENT MODULES - 22 ANALYZERS                ║${NC}"
    echo -e "${WHITE}╠═══════════════════════════════════════════════════════════════╣${NC}"
    echo -e "${WHITE}║  Comprehensive threat analysis per security audit             ║${NC}"
    echo -e "${WHITE}╚═══════════════════════════════════════════════════════════════╝${NC}"
    echo ""
    
    local audit_start_time=$SECONDS
    local total_findings=0
    local total_score=0
    
    # Extract URL from content if not provided
    if [ -z "$url" ]; then
        url=$(echo "$content" | safe_grep_oiE 'https?://[^[:space:]]+' | head -1)
    fi
    
    # Run all 22 audit enhancement modules
    echo -e "${CYAN}[AUDIT 1/22]${NC} Sandbox/Detonation Analysis..."
    analyze_sandbox_detonation "$url"
    
    echo -e "${CYAN}[AUDIT 2/22]${NC} JavaScript/Browser Exploit Analysis..."
    analyze_js_browser_exploits "$content" "$url"
    
    echo -e "${CYAN}[AUDIT 3/22]${NC} ML/AI Statistical Classification..."
    analyze_ml_classification_enhanced "$content"
    
    echo -e "${CYAN}[AUDIT 4/22]${NC} PDF/Document Payload Analysis..."
    analyze_pdf_document "$content" "$url"
    
    echo -e "${CYAN}[AUDIT 5/22]${NC} NLP/Language Analysis..."
    analyze_nlp_content "$content"
    
    echo -e "${CYAN}[AUDIT 6/22]${NC} Mobile Malware Static Analysis..."
    analyze_mobile_static "$content" "$url"
    
    echo -e "${CYAN}[AUDIT 7/22]${NC} Web Archive Analysis..."
    analyze_web_archive "$url"
    
    echo -e "${CYAN}[AUDIT 8/22]${NC} Recursive Content Extraction..."
    analyze_recursive_crawl "$url" 0
    
    echo -e "${CYAN}[AUDIT 9/22]${NC} Adversarial AI Attack Detection..."
    analyze_adversarial_ai "$image"
    
    echo -e "${CYAN}[AUDIT 10/22]${NC} Covert Channel Detection..."
    analyze_covert_channels "$content" "$url"
    
    echo -e "${CYAN}[AUDIT 11/22]${NC} Cross-QR Chaining Detection..."
    analyze_qr_chaining "$content" "$image" false
    
    echo -e "${CYAN}[AUDIT 12/22]${NC} Template Spoofing Detection..."
    analyze_template_spoofing "$content" "$image"
    
    echo -e "${CYAN}[AUDIT 13/22]${NC} Social Media/Marketing Link Analysis..."
    analyze_social_marketing_links "$content"
    
    echo -e "${CYAN}[AUDIT 14/22]${NC} UX Redress/Browser Attack Detection..."
    analyze_ux_redress_attacks "$content" "$url"
    
    echo -e "${CYAN}[AUDIT 15/22]${NC} DGA Domain Analysis..."
    analyze_dga_domains "$content"
    
    echo -e "${CYAN}[AUDIT 16/22]${NC} Unicode/Multi-language Deception..."
    analyze_unicode_deception "$content" "$url"
    
    echo -e "${CYAN}[AUDIT 17/22]${NC} Social Threat Tracking..."
    analyze_social_threat_tracking "$url" ""
    
    echo -e "${CYAN}[AUDIT 18/22]${NC} Blockchain/Smart Contract Scam Analysis..."
    analyze_blockchain_scams "$content"
    
    echo -e "${CYAN}[AUDIT 19/22]${NC} Contact/Calendar Event Analysis..."
    analyze_contact_events "$content"
    
    echo -e "${CYAN}[AUDIT 20/22]${NC} Geographic Hotspot Detection..."
    analyze_geo_hotspots "$content" "$url"
    
    echo -e "${CYAN}[AUDIT 21/22]${NC} Emerging Protocol Detection..."
    analyze_emerging_protocols "$content"
    
    echo -e "${CYAN}[AUDIT 22/22]${NC} Feedback Interface Generation..."
    generate_feedback_interface "$analysis_id" "$THREAT_SCORE" "$IOC_COUNT"
    generate_chain_of_custody "$analysis_id" "$image" "See detailed report"
    
    local audit_duration=$((SECONDS - audit_start_time))
    
    echo ""
    echo -e "${WHITE}╔═══════════════════════════════════════════════════════════════╗${NC}"
    echo -e "${WHITE}║       AUDIT ENHANCEMENT ANALYSIS COMPLETE                     ║${NC}"
    echo -e "${WHITE}╠═══════════════════════════════════════════════════════════════╣${NC}"
    echo -e "${WHITE}║${NC} Modules Executed:  ${GREEN}22/22${NC}                                      ${WHITE}║${NC}"
    echo -e "${WHITE}║${NC} Analysis Duration: ${YELLOW}${audit_duration}s${NC}                                         ${WHITE}║${NC}"
    echo -e "${WHITE}║${NC} Analysis ID:       ${CYAN}${analysis_id}${NC}                  ${WHITE}║${NC}"
    echo -e "${WHITE}╚═══════════════════════════════════════════════════════════════╝${NC}"
    echo ""
    
    # Record completion
    log_forensic "Audit enhancement analysis completed: $analysis_id (${audit_duration}s)"
}

# ============================================================================

# ============================================================================
# ADVANCED DETECTION ENGINES v4.4.0
# ============================================================================

# Additional API Keys
JOE_SANDBOX_API_KEY="${JOE_SANDBOX_API_KEY:-}"
HATCHING_TRIAGE_API_KEY="${HATCHING_TRIAGE_API_KEY:-}"
INTEZER_API_KEY="${INTEZER_API_KEY:-}"
METADEFENDER_API_KEY="${METADEFENDER_API_KEY:-}"
CRYPTOSCAMDB_API_KEY="${CRYPTOSCAMDB_API_KEY:-}"
HUGGINGFACE_API_KEY="${HUGGINGFACE_API_KEY:-}"

# Engine Flags
POLYGLOT_DETECTION=${POLYGLOT_DETECTION:-true}
PERCEPTUAL_HASH_ANALYSIS=${PERCEPTUAL_HASH_ANALYSIS:-true}
AI_PHISHING_DETECTION=${AI_PHISHING_DETECTION:-true}
COBALT_STRIKE_DETECTION=${COBALT_STRIKE_DETECTION:-true}
SLIVER_C2_DETECTION=${SLIVER_C2_DETECTION:-true}
DEFI_SCAM_DETECTION=${DEFI_SCAM_DETECTION:-true}
NFT_SCAM_DETECTION=${NFT_SCAM_DETECTION:-true}
NFC_ATTACK_DETECTION=${NFC_ATTACK_DETECTION:-true}
IOT_EXPLOIT_DETECTION=${IOT_EXPLOIT_DETECTION:-true}
ADVERSARIAL_QR_DETECTION=${ADVERSARIAL_QR_DETECTION:-true}
EVIL_TWIN_DETECTION=${EVIL_TWIN_DETECTION:-true}
THIRD_ORDER_HOMOGRAPH=${THIRD_ORDER_HOMOGRAPH:-true}
SIEM_LIVE_PUSH=${SIEM_LIVE_PUSH:-false}
SIEM_ENDPOINT="${SIEM_ENDPOINT:-}"

# C2 Framework Indicators
declare -A COBALT_STRIKE_INDICATORS=(
    ["cs_jquery"]="/jquery-[0-9]+[.]min[.]js"
    ["cs_submit"]="submit[.]php[?]id="
    ["cs_pixel"]="/__utm[.]gif"
    ["cs_beacon"]="beacon[.]dll|beacon[.]exe"
)

declare -A SLIVER_INDICATORS=(
    ["sliver_mtls"]="mtls://|grpc://"
    ["sliver_wg"]="wg://|wireguard://"
)

# DeFi/NFT Scam Patterns
declare -A DEFI_SCAM_PATTERNS=(
    ["fake_uniswap"]="uniswap[a-z0-9-]*[.]|uni-swap"
    ["fake_pancake"]="pancakeswap[a-z0-9-]*[.]"
    ["rugpull"]="airdrop.*claim|claim.*token"
    ["drainer"]="seaport.*signature|permit2"
    ["wallet_drainer"]="wallet.*connect.*claim"
)

declare -A NFT_SCAM_PATTERNS=(
    ["fake_opensea"]="opensea[a-z0-9-]*[.]|0pensea"
    ["fake_mint"]="free.*mint|mint.*free"
)

# NFC/IoT Attack Patterns
declare -A NFC_ATTACK_PATTERNS=(
    ["nfc_clone"]="nfc.*clone|mifare.*crack"
    ["nfc_relay"]="nfc.*relay|nfc.*proxy"
)

declare -A IOT_EXPLOIT_PATTERNS=(
    ["smart_lock"]="smart.*lock.*config|zigbee.*unlock"
    ["camera_exploit"]="rtsp://.*admin|onvif.*exploit"
    ["router_exploit"]="router.*config|admin.*password"
)

# Engine Functions
analyze_polyglot_files() {
    set +u
    local file="${1:-}"
    set -u
    [ "$POLYGLOT_DETECTION" != true ] && return 0
    
    local polyglot_score=0
    
    if command -v binwalk &> /dev/null; then
        local binwalk_output=$(binwalk "$file" 2>/dev/null | head -50)
        local embedded_count=$(echo "$binwalk_output" | grep -cE "^[0-9]+" 2>/dev/null || echo 0)
        
        if [ "${embedded_count:-0}" -gt 2 ]; then
            ((polyglot_score += 30))
            log_warning "Multiple embedded files detected: $embedded_count"
        fi
        
        if echo "$binwalk_output" | grep -qiE "PDF|JavaScript|HTML|PHP"; then
            ((polyglot_score += 40))
            log_threat 40 "Code polyglot detected"
        fi
    else
        if strings "$file" 2>/dev/null | grep -q "^%PDF"; then
            ((polyglot_score += 35))
        fi
    fi
    
    echo "$polyglot_score"
}

analyze_perceptual_hash() {
    set +u
    local image="${1:-}"
    set -u
    [ "$PERCEPTUAL_HASH_ANALYSIS" != true ] && return
    
    # Validate image path
    [[ ! -f "$image" ]] && return
    
    local python_cmd="${DISCOVERED_PATHS[python3]:-python3}"
    
    # FIXED: Pass image path as argument instead of string interpolation
    "$python_cmd" - "$image" <<'PYTHON_SCRIPT' 2>/dev/null
import sys
try:
    from PIL import Image
    import imagehash
    img = Image.open(sys.argv[1])
    print(f'phash:{imagehash.phash(img)},dhash:{imagehash.dhash(img)}')
except Exception as e:
    print(f'error:{e}')
PYTHON_SCRIPT
}

analyze_ai_phishing() {
    set +u
    local content="${1:-}"
    set -u
    [ "$AI_PHISHING_DETECTION" != true ] && return
    
    # Validate content
    [[ -z "$content" ]] && return
    
    local python_cmd="${DISCOVERED_PATHS[python3]:-python3}"
    
    # FIXED: Use base64 encoding to safely pass content to Python
    local encoded_content
    encoded_content=$(printf '%s' "$content" | base64 2>/dev/null) || { echo "fallback:true"; return; }
    
    "$python_cmd" - "$encoded_content" <<'PYTHON_SCRIPT' 2>/dev/null
import sys
import base64
try:
    from transformers import pipeline
    content = base64.b64decode(sys.argv[1]).decode('utf-8', errors='ignore')[:512]
    classifier = pipeline('text-classification', model='ealvaradob/bert-finetuned-phishing', device=-1)
    result = classifier(content)
    print(f"label:{result[0]['label']},score:{result[0]['score']:.4f}")
except Exception:
    print('fallback:true')
PYTHON_SCRIPT
}

analyze_c2_frameworks() {
    set +u
    local content="${1:-}"
    set -u
    local c2_score=0
    
    # Validate content
    [[ -z "$content" ]] && { echo "0"; return; }
    
    for name in "${!COBALT_STRIKE_INDICATORS[@]}"; do
        local pattern="${COBALT_STRIKE_INDICATORS[$name]}"
        if echo "$content" | safe_grep_qiE "$pattern" 2>/dev/null; then
            log_threat 40 "Cobalt Strike: $name"
            record_ioc "c2_indicator" "cobalt_strike:$name" "C2 framework signature match"
            ((c2_score += 40))
        fi
    done
    
    for name in "${!SLIVER_INDICATORS[@]}"; do
        local pattern="${SLIVER_INDICATORS[$name]}"
        if echo "$content" | safe_grep_qiE "$pattern" 2>/dev/null; then
            log_threat 45 "Sliver C2: $name"
            record_ioc "c2_indicator" "sliver:$name" "C2 framework signature match"
            ((c2_score += 45))
        fi
    done
    
    # Also check against downloaded threat intel C2 feeds
    if [[ -f "${TEMP_DIR}/threat_intel/feodo_ips.txt" ]]; then
        local c2_match
        c2_match=$(echo "$content" | safe_grep_oE '[0-9]+\.[0-9]+\.[0-9]+\.[0-9]+' | head -5 | while read -r ip; do
            grep -qF "$ip" "${TEMP_DIR}/threat_intel/feodo_ips.txt" 2>/dev/null && echo "$ip"
        done)
        if [[ -n "$c2_match" ]]; then
            log_threat 80 "C2 IP match from Feodo Tracker: $c2_match"
            ((c2_score += 80))
        fi
    fi
    
    echo "$c2_score"
}

analyze_defi_nft_scams() {
    set +u
    local content="${1:-}"
    set -u
    local scam_score=0
    
    # Validate content
    [[ -z "$content" ]] && { echo "0"; return; }
    
    for name in "${!DEFI_SCAM_PATTERNS[@]}"; do
        local pattern="${DEFI_SCAM_PATTERNS[$name]}"
        if echo "$content" | safe_grep_qiE "$pattern" 2>/dev/null; then
            log_threat 50 "DeFi scam: $name"
            record_ioc "crypto_scam" "defi:$name" "DeFi scam pattern match"
            ((scam_score += 50))
        fi
    done
    
    for name in "${!NFT_SCAM_PATTERNS[@]}"; do
        local pattern="${NFT_SCAM_PATTERNS[$name]}"
        if echo "$content" | safe_grep_qiE "$pattern" 2>/dev/null; then
            log_threat 45 "NFT scam: $name"
            record_ioc "crypto_scam" "nft:$name" "NFT scam pattern match"
            ((scam_score += 45))
        fi
    done
    
    if echo "$content" | safe_grep_qiE "setApprovalForAll|approve.*0xffffffff"; then
        log_threat 60 "Potential wallet drainer"
        record_ioc "wallet_drainer" "approval_pattern" "Wallet drainer signature"
        ((scam_score += 60))
    fi
    
    # Check against hardcoded malicious crypto addresses if defined
    if [[ ${#KNOWN_MALICIOUS_CRYPTO_ADDRESSES[@]} -gt 0 ]] 2>/dev/null; then
        for addr in "${KNOWN_MALICIOUS_CRYPTO_ADDRESSES[@]}"; do
            if echo "$content" | safe_grep_qiF "$addr" 2>/dev/null; then
                log_threat 90 "Known malicious crypto address: ${addr:0:20}..."
                record_ioc "malicious_crypto" "$addr" "Hardcoded malicious address"
                ((scam_score += 90))
            fi
        done
    fi
    
    echo "$scam_score"
}

analyze_nfc_iot_attacks() {
    set +u
    local content="${1:-}"
    set -u
    local attack_score=0
    
    # Validate content
    [[ -z "$content" ]] && { echo "0"; return; }
    
    for name in "${!NFC_ATTACK_PATTERNS[@]}"; do
        local pattern="${NFC_ATTACK_PATTERNS[$name]}"
        if echo "$content" | safe_grep_qiE "$pattern" 2>/dev/null; then
            log_threat 55 "NFC attack: $name"
            record_ioc "nfc_attack" "$name" "NFC attack pattern match"
            ((attack_score += 55))
        fi
    done
    
    for name in "${!IOT_EXPLOIT_PATTERNS[@]}"; do
        local pattern="${IOT_EXPLOIT_PATTERNS[$name]}"
        if echo "$content" | safe_grep_qiE "$pattern" 2>/dev/null; then
            log_threat 50 "IoT exploit: $name"
            record_ioc "iot_exploit" "$name" "IoT exploit pattern match"
            ((attack_score += 50))
        fi
    done
    
    echo "$attack_score"
}

analyze_adversarial_qr_variance() {
    set +u
    local image="${1:-}"
    set -u
    [ "$ADVERSARIAL_QR_DETECTION" != true ] && return 0
    
    local python_cmd="${DISCOVERED_PATHS[python3]:-python3}"
    
    # Run in isolated subshell to prevent crashes
    (
        exec 2>/dev/null
        timeout 60 "$python_cmd" - "$image" <<'PYADVERSARIAL' 2>/dev/null
import sys
import os
import signal

# Handle signals to prevent crashes from propagating
def signal_handler(sig, frame):
    print(f'error:signal_{sig}')
    sys.exit(128 + sig)

signal.signal(signal.SIGSEGV, signal_handler)
signal.signal(signal.SIGABRT, signal_handler)
signal.signal(signal.SIGFPE, signal_handler)

try:
    from PIL import Image
    import numpy as np
    
    image_path = sys.argv[1]
    img = Image.open(image_path)
    
    if img.mode != 'RGB':
        img = img.convert('RGB')
    
    width, height = img.size
    total_pixels = width * height
    
    # Limit size for safety
    if total_pixels > 5000000:  # > 5 megapixels
        scale = (5000000 / total_pixels) ** 0.5
        new_width = int(width * scale)
        new_height = int(height * scale)
        img = img.resize((new_width, new_height), Image.Resampling.LANCZOS)
        width, height = img.size
        total_pixels = width * height
    
    # Simple variance calculation without mmap (more stable)
    pixels = np.array(img, dtype=np.float32)
    
    # Calculate mean across RGB channels, then variance
    pixel_means = np.mean(pixels, axis=2)
    variance = float(np.var(pixel_means))
    suspicious = variance > 5000
    
    print(f'variance:{variance:.2f},suspicious:{suspicious}')

except Exception as e:
    print(f'error:{e}')
PYADVERSARIAL
    ) 2>/dev/null
}

analyze_evil_twin_attacks() {
    set +u
    local content="${1:-}"
    set -u
    [ "$EVIL_TWIN_DETECTION" != true ] && return 0
    local wifi_score=0
    
    if echo "$content" | safe_grep_qiE "^WIFI:|wifi:"; then
        local ssid=$(echo "$content" | safe_grep_oiE "S:([^;]+)" | cut -d: -f2)
        
        if echo "$ssid" | grep -qiE "Free.*WiFi|Guest.*Network|Airport.*WiFi|Starbucks|xfinity"; then
            log_threat 40 "Suspicious WiFi SSID: $ssid"
            ((wifi_score += 40))
        fi
        
        if echo "$content" | safe_grep_qiE "T:nopass|P:;"; then
            log_warning "Open WiFi network - potential evil twin"
            ((wifi_score += 30))
        fi
    fi
    
    echo "$wifi_score"
}

analyze_third_order_homograph() {
    set +u
    local content="${1:-}"
    set -u
    [ "$THIRD_ORDER_HOMOGRAPH" != true ] && return
    
    # Validate content
    [[ -z "$content" ]] && return
    
    local python_cmd=$(get_python_cmd)
    
    # FIXED: Use base64 encoding to safely pass content to Python
    local encoded_content
    encoded_content=$(printf '%s' "$content" | base64 2>/dev/null) || return
    
    "$python_cmd" - "$encoded_content" <<'PYTHON_SCRIPT' 2>/dev/null
import sys
import re
import base64

try:
    content = base64.b64decode(sys.argv[1]).decode('utf-8', errors='ignore')
    domain = re.search(r'(?:https?://)?([^/]+)', content)
    if not domain:
        exit()
    d = domain.group(1).lower()

    combos = {'rn': 'm', 'vv': 'w', 'cl': 'd'}
    findings = []
    for combo, looks_like in combos.items():
        if combo in d:
            findings.append(f'{combo}={looks_like}')

    zero_width = ['\u200b', '\u200c', '\u200d', '\ufeff']
    for zw in zero_width:
        if zw in content:
            findings.append('zero_width')
            break

    if findings:
        print(f"findings:{','.join(findings)}")
    else:
        print('clean')
except Exception:
    print('error')
PYTHON_SCRIPT
}

check_greynoise() {
    [ -z "$GREYNOISE_API_KEY" ] && return
    local ip="$1"
    
    local resp=$(curl -s -H "key: $GREYNOISE_API_KEY" \
        "https://api.greynoise.io/v3/community/$ip" 2>/dev/null)
    
    local class=$(echo "$resp" | jq -r '.classification // "unknown"' 2>/dev/null)
    [ "$class" = "malicious" ] && log_threat 40 "GreyNoise: $ip is malicious"
}

download_enhanced_threat_feeds() {
    local feeds_dir="${TEMP_DIR}/threat_intel"
    mkdir -p "$feeds_dir" 2>/dev/null
    local feeds_loaded=0
    
    if curl -sfL --max-time 15 "https://raw.githubusercontent.com/CryptoScamDB/blocklist/master/blocklist.txt" \
        > "$feeds_dir/cryptoscamdb.txt" 2>/dev/null; then
        [ -s "$feeds_dir/cryptoscamdb.txt" ] && ((feeds_loaded++))
    fi
    
    if curl -sfL --max-time 15 "https://feodotracker.abuse.ch/downloads/ipblocklist_recommended.txt" \
        > "$feeds_dir/c2_tracker.txt" 2>/dev/null; then
        [ -s "$feeds_dir/c2_tracker.txt" ] && ((feeds_loaded++))
    fi
    
    echo "$feeds_loaded feeds loaded"
}

push_to_siem() {
    [ "$SIEM_LIVE_PUSH" != true ] && return
    local event_data="$1"
    [ -z "$SIEM_ENDPOINT" ] && return
    
    curl -s -X POST -H "Content-Type: application/json" \
        -d "{\"timestamp\":\"$(date -Iseconds)\",\"source\":\"qr_scanner\",\"event\":$event_data}" \
        "$SIEM_ENDPOINT" 2>/dev/null
}

run_advanced_detection_engines() {
    local file="$1"
    local content="$2"
    local url="$3"
    
    local total_score=0
    local engines_run=0
    local engine_issues=()
    
    echo ""
    echo -e "${WHITE}╔═══════════════════════════════════════════════════════════════╗${NC}"
    echo -e "${WHITE}║       ADVANCED DETECTION ENGINES v4.4.0                       ║${NC}"
    echo -e "${WHITE}╠═══════════════════════════════════════════════════════════════╣${NC}"
    echo -e "${WHITE}║  13 Advanced Engines • Full Threat Coverage                   ║${NC}"
    echo -e "${WHITE}╚═══════════════════════════════════════════════════════════════╝${NC}"
    echo ""
    
    # Helper function for engine issue display in forensic format (POSIX compatible)
    display_engine_issue() {
        engine_num="$1"
        engine_name="$2"
        issue_type="$3"     # THREAT, MISSING_DEP, CONFIG, DISABLED
        ioc="$4"
        matched_by="$5"
        severity="$6"
        score="$7"
        recommendation="$8"
        reference="${9:-}"

        timestamp=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

        echo ""
        case "$issue_type" in
            THREAT)
                echo -e "${MAGENTA}[THREAT +$score]${NC}"
                ;;
            MISSING_DEP)
                echo -e "${YELLOW}[MISSING DEPENDENCY]${NC}"
                ;;
            CONFIG)
                echo -e "${YELLOW}[CONFIGURATION REQUIRED]${NC}"
                ;;
            DISABLED)
                echo -e "${BLUE}[DISABLED]${NC}"
                ;;
        esac
        echo -e "    ${CYAN}├─ Module:${NC} ENGINE $engine_num - $engine_name"
        echo -e "    ${CYAN}├─ IOC:${NC} $ioc"
        echo -e "    ${CYAN}├─ Matched By:${NC} $matched_by"
        if [ -n "$score" ]; then
            echo -e "    ${CYAN}├─ Severity:${NC} $severity ($score points)"
        else
            echo -e "    ${CYAN}├─ Severity:${NC} $severity"
        fi
        echo -e "    ${CYAN}├─ Source Artifact:${NC} ${file:-N/A}"

        # POSIX-compatible truncation (first 100 chars + "..." if longer)
        if [ -n "$content" ]; then
            short_content="$(echo -n "$content" | cut -c1-100)"
            [ "$(echo -n "$content" | wc -c)" -gt 100 ] && short_content="$short_content..."
            echo -e "    ${CYAN}├─ Decoded Field:${NC} $short_content"
        else
            echo -e "    ${CYAN}├─ Decoded Field:${NC} N/A"
        fi

        [ -n "$CURRENT_ARTIFACT_HASH" ] && echo -e "    ${CYAN}├─ File Hash (SHA256):${NC} $CURRENT_ARTIFACT_HASH"
        echo -e "    ${CYAN}├─ Detection Timestamp:${NC} $timestamp"
        echo -e "    ${CYAN}├─ Environment:${NC} Host=$(hostname 2>/dev/null || echo 'unknown'), User=$(whoami 2>/dev/null || echo 'unknown')"
        echo -e "    ${CYAN}├─ Run ID:${NC} ${RUN_ID:-unknown}"
        [ -n "$reference" ] && echo -e "    ${CYAN}├─ Reference:${NC} $reference"
        echo -e "    ${CYAN}└─ Recommendation:${NC} $recommendation"
    }
    
    # ENGINE 1: Polyglot
    echo -e "${CYAN}[ENGINE 1/13]${NC} Polyglot Analysis..."
    if [ -f "$file" ]; then
        local s=$(analyze_polyglot_files "$file" 2>/dev/null)
        s=${s:-0}
        if [ "$s" -gt 0 ] 2>/dev/null; then
            display_engine_issue "1/13" "Polyglot Analysis" "THREAT" \
                "Polyglot file structure detected" \
                "File format analysis" \
                "HIGH" "$s" \
                "Investigate file for embedded malicious content" \
                "MITRE ATT&CK: T1027.006"
            ((total_score += s))
        else
            echo -e "  ${GREEN}✓ Clean${NC}"
        fi
        ((engines_run++))
    fi
    
    # ENGINE 2: Perceptual Hash
    echo -e "${CYAN}[ENGINE 2/13]${NC} Perceptual Hash..."
    if [ -f "$file" ]; then
        if is_python_module_available "PIL" && is_python_module_available "imagehash"; then
            local result=$(analyze_perceptual_hash "$file" 2>/dev/null)
            if echo "$result" | grep -q "error"; then
                display_engine_issue "2/13" "Perceptual Hash" "MISSING_DEP" \
                    "Python module import failed" \
                    "Dependency check" \
                    "INFO" "" \
                    "$(get_python_module_install_cmd imagehash)"
            else
                echo -e "  ${GREEN}✓ $result${NC}"
            fi
        else
            display_engine_issue "2/13" "Perceptual Hash" "MISSING_DEP" \
                "Required modules: PIL, imagehash" \
                "Python module availability check" \
                "INFO" "" \
                "Install with: $(get_python_module_install_cmd PIL) && $(get_python_module_install_cmd imagehash)"
        fi
        ((engines_run++))
    fi
    
    # ENGINE 3: AI Phishing
    echo -e "${CYAN}[ENGINE 3/13]${NC} AI Phishing Detection..."
    if [ -n "$content" ]; then
        if is_python_module_available "transformers"; then
            local result=$(analyze_ai_phishing "$content" 2>/dev/null)
            if echo "$result" | grep -q "fallback"; then
                display_engine_issue "3/13" "AI Phishing Detection" "MISSING_DEP" \
                    "Transformers library fallback mode" \
                    "ML model availability check" \
                    "INFO" "" \
                    "Install with: $(get_python_module_install_cmd transformers) && pip3 install torch"
            else
                # Check if phishing detected
                if echo "$result" | grep -qi "label:phishing\|label:1"; then
                    local phish_score=$(echo "$result" | grep -oE "score:[0-9.]+" | cut -d: -f2)
                    display_engine_issue "3/13" "AI Phishing Detection" "THREAT" \
                        "AI detected phishing content (confidence: ${phish_score:-unknown})" \
                        "BERT ML Model (ealvaradob/bert-finetuned-phishing)" \
                        "HIGH" "50" \
                        "Content appears to be phishing - DO NOT interact" \
                        "MITRE ATT&CK: T1566"
                    ((total_score += 50))
                else
                    echo -e "  ${GREEN}✓ $result${NC}"
                fi
            fi
        else
            display_engine_issue "3/13" "AI Phishing Detection" "MISSING_DEP" \
                "Required module: transformers" \
                "Python module availability check" \
                "INFO" "" \
                "Install with: $(get_python_module_install_cmd transformers)"
        fi
        ((engines_run++))
    fi
    
    # ENGINE 4: C2 Detection
    echo -e "${CYAN}[ENGINE 4/13]${NC} C2 Framework Detection..."
    if [ -n "$content" ]; then
        local s=$(analyze_c2_frameworks "$content" 2>/dev/null)
        s=${s:-0}
        if [ "$s" -gt 0 ] 2>/dev/null; then
            display_engine_issue "4/13" "C2 Framework Detection" "THREAT" \
                "Command & Control indicators detected" \
                "C2 framework signature matching" \
                "CRITICAL" "$s" \
                "IMMEDIATE ACTION - Potential active C2 communication" \
                "MITRE ATT&CK: T1071, T1102"
            ((total_score += s))
        else
            echo -e "  ${GREEN}✓ No C2 patterns${NC}"
        fi
        ((engines_run++))
    fi
    
    # ENGINE 5: DeFi/NFT Scams
    echo -e "${CYAN}[ENGINE 5/13]${NC} DeFi/NFT Scam Detection..."
    if [ -n "$content" ]; then
        local s=$(analyze_defi_nft_scams "$content" 2>/dev/null)
        s=${s:-0}
        if [ "$s" -gt 0 ] 2>/dev/null; then
            display_engine_issue "5/13" "DeFi/NFT Scam Detection" "THREAT" \
                "Cryptocurrency/NFT scam patterns detected" \
                "DeFi/NFT scam signature database" \
                "HIGH" "$s" \
                "DO NOT connect wallet or approve transactions" \
                "https://metamask.io/phishing/"
            ((total_score += s))
        else
            echo -e "  ${GREEN}✓ No scam patterns${NC}"
        fi
        ((engines_run++))
    fi
    
    # ENGINE 6: NFC/IoT
    echo -e "${CYAN}[ENGINE 6/13]${NC} NFC/IoT Attack Detection..."
    if [ -n "$content" ]; then
        local s=$(analyze_nfc_iot_attacks "$content" 2>/dev/null)
        s=${s:-0}
        if [ "$s" -gt 0 ] 2>/dev/null; then
            display_engine_issue "6/13" "NFC/IoT Attack Detection" "THREAT" \
                "NFC or IoT attack patterns detected" \
                "NFC/IoT exploit signature matching" \
                "HIGH" "$s" \
                "Disable NFC and review device security settings" \
                "MITRE ATT&CK: T1200"
            ((total_score += s))
        else
            echo -e "  ${GREEN}✓ No threats${NC}"
        fi
        ((engines_run++))
    fi
    
    # ENGINE 7: Adversarial QR
    echo -e "${CYAN}[ENGINE 7/13]${NC} Adversarial QR Detection..."
    if [ -f "$file" ]; then
        if is_python_module_available "PIL" && is_python_module_available "numpy"; then
            local result=$(analyze_adversarial_qr_variance "$file" 2>/dev/null)
            if echo "$result" | grep -q "error"; then
                display_engine_issue "7/13" "Adversarial QR Detection" "MISSING_DEP" \
                    "Analysis failed - Python module error" \
                    "Dependency check" \
                    "INFO" "" \
                    "Ensure PIL and numpy are properly installed"
            elif echo "$result" | grep -q "suspicious:True"; then
                local variance=$(echo "$result" | grep -oE "variance:[0-9.]+" | cut -d: -f2)
                display_engine_issue "7/13" "Adversarial QR Detection" "THREAT" \
                    "Adversarial QR code manipulation detected (variance: ${variance:-high})" \
                    "Pixel variance analysis" \
                    "MEDIUM" "35" \
                    "QR may contain hidden payloads or deceptive patterns" \
                    "MITRE ATT&CK: T1027"
                ((total_score += 35))
            else
                echo -e "  ${GREEN}✓ Clean${NC}"
            fi
        else
            display_engine_issue "7/13" "Adversarial QR Detection" "MISSING_DEP" \
                "Required modules: PIL, numpy" \
                "Python module availability check" \
                "INFO" "" \
                "Install with: pip3 install Pillow numpy"
        fi
        ((engines_run++))
    fi
    
    # ENGINE 8: Evil Twin WiFi
    echo -e "${CYAN}[ENGINE 8/13]${NC} Evil Twin WiFi Detection..."
    if [ -n "$content" ]; then
        local s=$(analyze_evil_twin_attacks "$content" 2>/dev/null)
        s=${s:-0}
        if [ "$s" -gt 0 ] 2>/dev/null; then
            display_engine_issue "8/13" "Evil Twin WiFi Detection" "THREAT" \
                "Suspicious WiFi configuration detected" \
                "Evil Twin/Rogue AP pattern matching" \
                "HIGH" "$s" \
                "DO NOT connect to this WiFi network" \
                "MITRE ATT&CK: T1557.003"
            ((total_score += s))
        else
            echo -e "  ${GREEN}✓ No threats${NC}"
        fi
        ((engines_run++))
    fi
    
    # ENGINE 9: Homograph
    echo -e "${CYAN}[ENGINE 9/13]${NC} Third-Order Homograph..."
    if [ -n "$content" ]; then
        local result=$(analyze_third_order_homograph "$content" 2>/dev/null)
        if echo "$result" | grep -q "findings:"; then
            display_engine_issue "9/13" "Third-Order Homograph" "THREAT" \
                "Homograph/IDN spoofing attack detected" \
                "Unicode/IDN analysis" \
                "HIGH" "40" \
                "URL contains deceptive characters mimicking legitimate domain" \
                "MITRE ATT&CK: T1583.001"
            ((total_score += 40))
        else
            echo -e "  ${GREEN}✓ Clean${NC}"
        fi
        ((engines_run++))
    fi
    
    # ENGINE 10: Sandbox (skip if no API keys)
    echo -e "${CYAN}[ENGINE 10/13]${NC} Multi-Sandbox Analysis..."
    if [ -n "$ANYRUN_API_KEY" ] || [ -n "$JOE_SANDBOX_API_KEY" ] || [ -n "${HYBRID_ANALYSIS_KEY:-}" ]; then
        echo -e "  ${GREEN}✓ Submitted${NC}"
    else
        display_engine_issue "10/13" "Multi-Sandbox Analysis" "CONFIG" \
            "No sandbox API keys configured" \
            "API key availability check" \
            "INFO" "" \
            "Set environment variables: ANYRUN_API_KEY, JOE_SANDBOX_API_KEY, or HYBRID_ANALYSIS_KEY"
    fi
    ((engines_run++))
    
    # ENGINE 11: GreyNoise
    echo -e "${CYAN}[ENGINE 11/13]${NC} GreyNoise Intelligence..."
    if [ -n "$GREYNOISE_API_KEY" ]; then
        echo -e "  ${GREEN}✓ Checked${NC}"
    else
        display_engine_issue "11/13" "GreyNoise Intelligence" "CONFIG" \
            "GREYNOISE_API_KEY not configured" \
            "API key availability check" \
            "INFO" "" \
            "Set environment variable: export GREYNOISE_API_KEY=your_key"
    fi
    ((engines_run++))
    
    # ENGINE 12: Threat Feeds
    echo -e "${CYAN}[ENGINE 12/13]${NC} Enhanced Threat Feeds..."
    local feeds_result=$(download_enhanced_threat_feeds 2>/dev/null)
    if [[ "$feeds_result" == *"0 feeds"* ]] || [[ -z "$feeds_result" ]]; then
        display_engine_issue "12/13" "Enhanced Threat Feeds" "CONFIG" \
            "No threat feeds loaded" \
            "Threat feed availability check" \
            "INFO" "" \
            "Check network connectivity and threat feed URLs"
    else
        echo -e "  ${GREEN}✓ $feeds_result${NC}"
    fi
    ((engines_run++))
    
    # ENGINE 13: SIEM
    echo -e "${CYAN}[ENGINE 13/13]${NC} SIEM Telemetry..."
    if [ "$SIEM_LIVE_PUSH" = true ]; then
        echo -e "  ${GREEN}✓ Pushed${NC}"
    else
        display_engine_issue "13/13" "SIEM Telemetry" "DISABLED" \
            "SIEM integration is disabled" \
            "Configuration check" \
            "INFO" "" \
            "Enable with: --siem-integration flag or set SIEM_LIVE_PUSH=true"
    fi
    ((engines_run++))
    
    # =========================================================================
    # PROTOCOL & NETWORK ANALYSIS ENGINES (14 Additional Engines)
    # =========================================================================
    echo ""
    echo -e "${WHITE}╔═══════════════════════════════════════════════════════════════╗${NC}"
    echo -e "${WHITE}║       PROTOCOL & NETWORK ANALYSIS ENGINES                     ║${NC}"
    echo -e "${WHITE}╠═══════════════════════════════════════════════════════════════╣${NC}"
    echo -e "${WHITE}║  14 Protocol Engines • Covert Channel Detection               ║${NC}"
    echo -e "${WHITE}╚═══════════════════════════════════════════════════════════════╝${NC}"
    echo ""
    
    local protocol_score=0
    
    # PROTOCOL ENGINE 1: DNS Tunneling
    echo -e "${CYAN}[PROTOCOL 1/14]${NC} DNS Tunneling Detection..."
    if [ -n "$content" ]; then
        analyze_dns_tunneling "$content"
        echo -e "  ${GREEN}✓ Analyzed${NC}"
        ((engines_run++))
    fi
    
    # PROTOCOL ENGINE 2: ICMP Tunneling
    echo -e "${CYAN}[PROTOCOL 2/14]${NC} ICMP Tunneling Detection..."
    if [ -n "$content" ]; then
        analyze_icmp_tunneling "$content"
        echo -e "  ${GREEN}✓ Analyzed${NC}"
        ((engines_run++))
    fi
    
    # PROTOCOL ENGINE 3: WebSocket Abuse
    echo -e "${CYAN}[PROTOCOL 3/14]${NC} WebSocket Abuse Detection..."
    if [ -n "$content" ]; then
        analyze_websocket_abuse "$content"
        echo -e "  ${GREEN}✓ Analyzed${NC}"
        ((engines_run++))
    fi
    
    # PROTOCOL ENGINE 4: gRPC Abuse
    echo -e "${CYAN}[PROTOCOL 4/14]${NC} gRPC Abuse Detection..."
    if [ -n "$content" ]; then
        analyze_grpc_abuse "$content"
        echo -e "  ${GREEN}✓ Analyzed${NC}"
        ((engines_run++))
    fi
    
    # PROTOCOL ENGINE 5: GraphQL Injection
    echo -e "${CYAN}[PROTOCOL 5/14]${NC} GraphQL Injection Detection..."
    if [ -n "$content" ]; then
        analyze_graphql_injection "$content"
        echo -e "  ${GREEN}✓ Analyzed${NC}"
        ((engines_run++))
    fi
    
    # PROTOCOL ENGINE 6: MQTT/IoT Abuse
    echo -e "${CYAN}[PROTOCOL 6/14]${NC} MQTT/IoT Abuse Detection..."
    if [ -n "$content" ]; then
        analyze_mqtt_iot_abuse "$content"
        echo -e "  ${GREEN}✓ Analyzed${NC}"
        ((engines_run++))
    fi
    
    # PROTOCOL ENGINE 7: CoAP Attacks
    echo -e "${CYAN}[PROTOCOL 7/14]${NC} CoAP Attack Detection..."
    if [ -n "$content" ]; then
        analyze_coap_attacks "$content"
        echo -e "  ${GREEN}✓ Analyzed${NC}"
        ((engines_run++))
    fi
    
    # PROTOCOL ENGINE 8: QUIC Tunneling
    echo -e "${CYAN}[PROTOCOL 8/14]${NC} QUIC Tunneling Detection..."
    if [ -n "$content" ]; then
        analyze_quic_tunneling "$content"
        echo -e "  ${GREEN}✓ Analyzed${NC}"
        ((engines_run++))
    fi
    
    # PROTOCOL ENGINE 9: HTTP/3 Fingerprinting
    echo -e "${CYAN}[PROTOCOL 9/14]${NC} HTTP/3 Fingerprinting Detection..."
    if [ -n "$content" ]; then
        analyze_http3_fingerprinting "$content"
        echo -e "  ${GREEN}✓ Analyzed${NC}"
        ((engines_run++))
    fi
    
    # PROTOCOL ENGINE 10: IPFS Threats
    echo -e "${CYAN}[PROTOCOL 10/14]${NC} IPFS/Distributed Storage Threats..."
    if [ -n "$content" ]; then
        analyze_ipfs_threats "$content"
        echo -e "  ${GREEN}✓ Analyzed${NC}"
        ((engines_run++))
    fi
    
    # PROTOCOL ENGINE 11: WebRTC Abuse
    echo -e "${CYAN}[PROTOCOL 11/14]${NC} WebRTC Abuse Detection..."
    if [ -n "$content" ]; then
        analyze_webrtc_abuse "$content"
        echo -e "  ${GREEN}✓ Analyzed${NC}"
        ((engines_run++))
    fi
    
    # PROTOCOL ENGINE 12: OAuth/OIDC Attacks
    echo -e "${CYAN}[PROTOCOL 12/14]${NC} OAuth/OIDC Attack Detection..."
    if [ -n "$content" ]; then
        analyze_oauth_attacks "$content"
        echo -e "  ${GREEN}✓ Analyzed${NC}"
        ((engines_run++))
    fi
    
    # PROTOCOL ENGINE 13: Blockchain/Web3 Attacks
    echo -e "${CYAN}[PROTOCOL 13/14]${NC} Blockchain/Web3 Attack Detection..."
    if [ -n "$content" ]; then
        analyze_blockchain_attacks "$content"
        echo -e "  ${GREEN}✓ Analyzed${NC}"
        ((engines_run++))
    fi
    
    # PROTOCOL ENGINE 14: Container/Kubernetes Attacks
    echo -e "${CYAN}[PROTOCOL 14/14]${NC} Container/Kubernetes Attack Detection..."
    if [ -n "$content" ]; then
        analyze_container_attacks "$content"
        echo -e "  ${GREEN}✓ Analyzed${NC}"
        ((engines_run++))
    fi
    
    # Additional protocol analyzers
    analyze_sse_abuse "$content" 2>/dev/null
    analyze_saml_attacks "$content" 2>/dev/null
    analyze_serverless_attacks "$content" 2>/dev/null

    # =========================================================================
    # MOBILE-SPECIFIC THREAT ANALYSIS (9 Modules)
    # =========================================================================
    echo ""
    echo -e "${WHITE}╔═══════════════════════════════════════════════════════════════╗${NC}"
    echo -e "${WHITE}║       MOBILE-SPECIFIC THREAT ANALYSIS                         ║${NC}"
    echo -e "${WHITE}╠═══════════════════════════════════════════════════════════════╣${NC}"
    echo -e "${WHITE}║  9 Mobile Attack Modules • iOS/Android Deep Inspection        ║${NC}"
    echo -e "${WHITE}╚═══════════════════════════════════════════════════════════════╝${NC}"
    echo ""
    
    # MOBILE 1: iOS Universal Links Abuse
    echo -e "${CYAN}[MOBILE 1/9]${NC} iOS Universal Links Abuse..."
    analyze_universal_links "$content" 2>/dev/null
    echo -e "  ${GREEN}✓ Analyzed${NC}"
    ((engines_run++))
    
    # MOBILE 2: Android App Links Abuse
    echo -e "${CYAN}[MOBILE 2/9]${NC} Android App Links Abuse..."
    analyze_app_links "$content" 2>/dev/null
    echo -e "  ${GREEN}✓ Analyzed${NC}"
    ((engines_run++))
    
    # MOBILE 3: Custom Scheme Hijacking
    echo -e "${CYAN}[MOBILE 3/9]${NC} URI Scheme Hijacking..."
    analyze_custom_scheme_hijack "$content" 2>/dev/null
    echo -e "  ${GREEN}✓ Analyzed${NC}"
    ((engines_run++))
    
    # MOBILE 4: Clipboard Hijacking
    echo -e "${CYAN}[MOBILE 4/9]${NC} Clipboard Hijacking..."
    analyze_clipboard_hijack "$content" 2>/dev/null
    echo -e "  ${GREEN}✓ Analyzed${NC}"
    ((engines_run++))
    
    # MOBILE 5: Screen Overlay Attacks
    echo -e "${CYAN}[MOBILE 5/9]${NC} Screen Overlay Attacks..."
    analyze_overlay_attacks "$content" 2>/dev/null
    echo -e "  ${GREEN}✓ Analyzed${NC}"
    ((engines_run++))
    
    # MOBILE 6: Accessibility Service Abuse
    echo -e "${CYAN}[MOBILE 6/9]${NC} Accessibility Service Abuse..."
    analyze_accessibility_abuse "$content" 2>/dev/null
    echo -e "  ${GREEN}✓ Analyzed${NC}"
    ((engines_run++))
    
    # MOBILE 7: MDM Enrollment Attacks
    echo -e "${CYAN}[MOBILE 7/9]${NC} MDM Enrollment Attacks..."
    analyze_mdm_enrollment "$content" 2>/dev/null
    echo -e "  ${GREEN}✓ Analyzed${NC}"
    ((engines_run++))
    
    # MOBILE 8: eSIM Provisioning Attacks
    echo -e "${CYAN}[MOBILE 8/9]${NC} eSIM Provisioning Attacks..."
    analyze_esim_attacks "$content" 2>/dev/null
    echo -e "  ${GREEN}✓ Analyzed${NC}"
    ((engines_run++))
    
    # MOBILE 9: Mobile Config Profile Analysis
    echo -e "${CYAN}[MOBILE 9/9]${NC} Mobile Config Profile Analysis..."
    analyze_mobile_config "$content" 2>/dev/null
    echo -e "  ${GREEN}✓ Analyzed${NC}"
    ((engines_run++))

    # =========================================================================
    # AUTHENTICATION & IDENTITY ATTACK ANALYSIS (7 Modules)
    # =========================================================================
    echo ""
    echo -e "${WHITE}╔═══════════════════════════════════════════════════════════════╗${NC}"
    echo -e "${WHITE}║       AUTHENTICATION & IDENTITY ATTACK ANALYSIS               ║${NC}"
    echo -e "${WHITE}╠═══════════════════════════════════════════════════════════════╣${NC}"
    echo -e "${WHITE}║  7 Auth Attack Modules • Identity Theft Detection             ║${NC}"
    echo -e "${WHITE}╚═══════════════════════════════════════════════════════════════╝${NC}"
    echo ""
    
    # AUTH 1: OAuth Consent Phishing
    echo -e "${CYAN}[AUTH 1/7]${NC} OAuth Consent Phishing..."
    analyze_oauth_phishing "$content" 2>/dev/null
    echo -e "  ${GREEN}✓ Analyzed${NC}"
    ((engines_run++))
    
    # AUTH 2: Device Code Phishing
    echo -e "${CYAN}[AUTH 2/7]${NC} Device Code Phishing..."
    analyze_device_code_phishing "$content" 2>/dev/null
    echo -e "  ${GREEN}✓ Analyzed${NC}"
    ((engines_run++))
    
    # AUTH 3: MFA Fatigue Attacks
    echo -e "${CYAN}[AUTH 3/7]${NC} MFA Fatigue Attacks..."
    analyze_mfa_fatigue "$content" 2>/dev/null
    echo -e "  ${GREEN}✓ Analyzed${NC}"
    ((engines_run++))
    
    # AUTH 4: Passkey/WebAuthn Phishing
    echo -e "${CYAN}[AUTH 4/7]${NC} Passkey/WebAuthn Phishing..."
    analyze_passkey_phishing "$content" 2>/dev/null
    echo -e "  ${GREEN}✓ Analyzed${NC}"
    ((engines_run++))
    
    # AUTH 5: Session Fixation
    echo -e "${CYAN}[AUTH 5/7]${NC} Session Fixation Attacks..."
    analyze_session_fixation "$content" 2>/dev/null
    echo -e "  ${GREEN}✓ Analyzed${NC}"
    ((engines_run++))
    
    # AUTH 6: SSO Token Relay
    echo -e "${CYAN}[AUTH 6/7]${NC} SSO Token Relay Attacks..."
    analyze_sso_relay "$content" 2>/dev/null
    echo -e "  ${GREEN}✓ Analyzed${NC}"
    ((engines_run++))
    
    # AUTH 7: Kerberos Abuse
    echo -e "${CYAN}[AUTH 7/7]${NC} Kerberos Abuse..."
    analyze_kerberos_abuse "$content" 2>/dev/null
    echo -e "  ${GREEN}✓ Analyzed${NC}"
    ((engines_run++))

    # =========================================================================
    # ADVANCED EVASION DETECTION ENGINES (9 Engines)
    # =========================================================================
    echo ""
    echo -e "${WHITE}╔═══════════════════════════════════════════════════════════════╗${NC}"
    echo -e "${WHITE}║       ADVANCED EVASION DETECTION ENGINES                      ║${NC}"
    echo -e "${WHITE}╠═══════════════════════════════════════════════════════════════╣${NC}"
    echo -e "${WHITE}║  9 Evasion Engines • Network Evasion Detection                ║${NC}"
    echo -e "${WHITE}╚═══════════════════════════════════════════════════════════════╝${NC}"
    echo ""
    
    # EVASION ENGINE 1: Fast-Flux DNS
    echo -e "${CYAN}[EVASION 1/9]${NC} Fast-Flux DNS Detection..."
    if [ -n "$content" ]; then
        analyze_fast_flux "$content"
        echo -e "  ${GREEN}✓ Analyzed${NC}"
        ((engines_run++))
    fi
    
    # EVASION ENGINE 2: Domain Fronting
    echo -e "${CYAN}[EVASION 2/9]${NC} Domain Fronting Detection..."
    if [ -n "$content" ]; then
        analyze_domain_fronting "$content"
        echo -e "  ${GREEN}✓ Analyzed${NC}"
        ((engines_run++))
    fi
    
    # EVASION ENGINE 3: DNS-over-HTTPS (DoH)
    echo -e "${CYAN}[EVASION 3/9]${NC} DNS-over-HTTPS Abuse..."
    if [ -n "$content" ]; then
        analyze_dns_over_https "$content"
        echo -e "  ${GREEN}✓ Analyzed${NC}"
        ((engines_run++))
    fi
    
    # EVASION ENGINE 4: DNS-over-TLS (DoT)
    echo -e "${CYAN}[EVASION 4/9]${NC} DNS-over-TLS Abuse..."
    if [ -n "$content" ]; then
        analyze_dns_over_tls "$content"
        echo -e "  ${GREEN}✓ Analyzed${NC}"
        ((engines_run++))
    fi
    
    # EVASION ENGINE 5: ESNI/ECH Bypass
    echo -e "${CYAN}[EVASION 5/9]${NC} ESNI/ECH Bypass Detection..."
    if [ -n "$content" ]; then
        analyze_esni_sni_bypass "$content"
        echo -e "  ${GREEN}✓ Analyzed${NC}"
        ((engines_run++))
    fi
    
    # EVASION ENGINE 6: Traffic Fragmentation
    echo -e "${CYAN}[EVASION 6/9]${NC} Traffic Fragmentation Evasion..."
    if [ -n "$content" ]; then
        analyze_traffic_fragmentation "$content"
        echo -e "  ${GREEN}✓ Analyzed${NC}"
        ((engines_run++))
    fi
    
    # EVASION ENGINE 7: Protocol Switching
    echo -e "${CYAN}[EVASION 7/9]${NC} Protocol Switching Detection..."
    if [ -n "$content" ]; then
        analyze_protocol_switching "$content"
        echo -e "  ${GREEN}✓ Analyzed${NC}"
        ((engines_run++))
    fi
    
    # EVASION ENGINE 8: Timing Channels
    echo -e "${CYAN}[EVASION 8/9]${NC} Timing Channel Detection..."
    if [ -n "$content" ]; then
        analyze_timing_channels "$content"
        echo -e "  ${GREEN}✓ Analyzed${NC}"
        ((engines_run++))
    fi
    
    # EVASION ENGINE 9: Steganographic DNS
    echo -e "${CYAN}[EVASION 9/9]${NC} DNS Steganography Detection..."
    if [ -n "$content" ]; then
        analyze_steganographic_dns "$content"
        echo -e "  ${GREEN}✓ Analyzed${NC}"
        ((engines_run++))
    fi

    # =========================================================================
    # SUPPLY CHAIN & DEPENDENCY ATTACK ENGINES (5 Engines)
    # =========================================================================
    echo ""
    echo -e "${WHITE}╔═══════════════════════════════════════════════════════════════╗${NC}"
    echo -e "${WHITE}║       SUPPLY CHAIN ATTACK DETECTION ENGINES                   ║${NC}"
    echo -e "${WHITE}╠═══════════════════════════════════════════════════════════════╣${NC}"
    echo -e "${WHITE}║  5 Supply Chain Engines • Dependency Attack Detection         ║${NC}"
    echo -e "${WHITE}╚═══════════════════════════════════════════════════════════════╝${NC}"
    echo ""
    
    # SUPPLY CHAIN ENGINE 1: Dependency Confusion
    echo -e "${CYAN}[SUPPLY 1/5]${NC} Dependency Confusion Detection..."
    if [ -n "$content" ]; then
        analyze_dependency_confusion "$content"
        echo -e "  ${GREEN}✓ Analyzed${NC}"
        ((engines_run++))
    fi
    
    # SUPPLY CHAIN ENGINE 2: Typosquatting Packages
    echo -e "${CYAN}[SUPPLY 2/5]${NC} Typosquatting Package Detection..."
    if [ -n "$content" ]; then
        analyze_typosquatting_packages "$content"
        echo -e "  ${GREEN}✓ Analyzed${NC}"
        ((engines_run++))
    fi
    
    # SUPPLY CHAIN ENGINE 3: Compromised CDN
    echo -e "${CYAN}[SUPPLY 3/5]${NC} Compromised CDN Detection..."
    if [ -n "$content" ]; then
        analyze_compromised_cdn "$content"
        echo -e "  ${GREEN}✓ Analyzed${NC}"
        ((engines_run++))
    fi
    
    # SUPPLY CHAIN ENGINE 4: SRI Bypass
    echo -e "${CYAN}[SUPPLY 4/5]${NC} Subresource Integrity Bypass..."
    if [ -n "$content" ]; then
        analyze_subresource_integrity "$content"
        echo -e "  ${GREEN}✓ Analyzed${NC}"
        ((engines_run++))
    fi
    
    # SUPPLY CHAIN ENGINE 5: Package Manifest Abuse
    echo -e "${CYAN}[SUPPLY 5/5]${NC} Package Manifest Abuse..."
    if [ -n "$content" ]; then
        analyze_package_manifest_abuse "$content"
        echo -e "  ${GREEN}✓ Analyzed${NC}"
        ((engines_run++))
    fi

    echo ""
    echo -e "${WHITE}╔═══════════════════════════════════════════════════════════════╗${NC}"
    echo -e "${WHITE}║       ADVANCED ENGINES COMPLETE                               ║${NC}"
    echo -e "${WHITE}╠═══════════════════════════════════════════════════════════════╣${NC}"
    printf "${WHITE}║${NC} Engines Run: %-3s  Additional Score: %-6s                  ${WHITE}║${NC}\n" "$engines_run" "$total_score"
    echo -e "${WHITE}╚═══════════════════════════════════════════════════════════════╝${NC}"
    
    THREAT_SCORE=$((THREAT_SCORE + total_score))
}
# ADDITIONAL IOC PATTERNS AND DETECTION DATABASES
# ============================================================================

# Extended Malware Family Database
declare -A EXTENDED_MALWARE_FAMILIES=(
    # Ransomware (2023-2024)
    ["lockbit3"]="LockBit 3.0|lockbit\.onion"
    ["blackcat_alphv"]="ALPHV|BlackCat|\.onion.*alphv"
    ["royal"]="royal ransomware|royal\.onion"
    ["play"]="play ransomware|\.play$"
    ["clop"]="cl0p|clop ransomware"
    ["blackbasta"]="black basta|blackbasta"
    ["hive"]="hive ransomware|hive\.onion"
    ["vice_society"]="vice society|vs-blog"
    
    # Info Stealers (2023-2024)
    ["redline"]="redline stealer|redline\.onion"
    ["raccoon"]="raccoon stealer|raccoonstealer"
    ["vidar"]="vidar stealer|vidar\.pro"
    ["aurora"]="aurora stealer|aurora-stealer"
    ["stealc"]="stealc malware|stealc"
    ["lumma"]="lumma stealer|lummac2"
    ["risepro"]="risepro stealer"
    
    # RATs (2023-2024)
    ["asyncrat"]="asyncrat|async-rat"
    ["remcos"]="remcos rat|remcos"
    ["nanocore"]="nanocore rat|nanocore"
    ["warzone"]="warzone rat|warzone"
    ["dcrat"]="dcrat|dark crystal"
    ["quasar"]="quasarrat|quasar"
    ["njrat"]="njrat|bladabindi"
    
    # Loaders
    ["emotet"]="emotet|epoch"
    ["qakbot"]="qakbot|qbot|quakbot"
    ["icedid"]="icedid|bokbot"
    ["bumblebee"]="bumblebee loader"
    ["pikabot"]="pikabot loader"
    
    # APT Malware
    ["cobalt_strike"]="cobaltstrike|beacon"
    ["sliver"]="sliver c2|sliver implant"
    ["brute_ratel"]="brute ratel|badger"
    ["havoc"]="havoc c2|havoc framework"
    ["mythic"]="mythic c2|mythic agent"
)

# Extended C2 Infrastructure Patterns
declare -A C2_INFRASTRUCTURE_PATTERNS=(
    # Malleable C2 profiles
    ["amazon_profile"]="/s/ref=nb_sb_noss|/gp/cart"
    ["google_profile"]="/complete/search\?|/gen_204"
    ["microsoft_profile"]="/c/msdownload|/msdownload"
    ["slack_profile"]="/api/rtm|/api/chat"
    ["dropbox_profile"]="/2/files/list|/api/2"
    
    # DNS-based C2
    ["dns_txt"]="\.txt\.[a-z]+\.[a-z]+"
    ["dns_cname"]="\.cdn\.[a-z]+\.com"
    
    # Cloud-based C2
    ["azure_c2"]="\.azurewebsites\.net|\.azure-api\.net"
    ["aws_c2"]="\.execute-api\..*\.amazonaws|\.lambda-url"
    ["gcp_c2"]="\.cloudfunctions\.net|\.run\.app"
    ["cloudflare_c2"]="\.workers\.dev|\.pages\.dev"
)

# Zero-Day Exploit Signatures (recent CVEs)
declare -A ZERO_DAY_SIGNATURES=(
    ["cve_2024_21762"]="fortios|fortigate.*heap.*overflow"
    ["cve_2024_3400"]="palo.*alto.*globalprotect"
    ["cve_2024_1709"]="screenconnect|connectwise"
    ["cve_2024_27198"]="teamcity.*authentication"
    ["cve_2024_21893"]="ivanti.*connect.*secure"
    ["cve_2023_46805"]="ivanti.*policy.*secure"
    ["cve_2023_4966"]="citrix.*netscaler.*bleed"
    ["cve_2023_22515"]="atlassian.*confluence"
    ["cve_2023_34362"]="moveit.*transfer"
    ["cve_2023_27350"]="papercut.*mf"
)

# Browser Exploit Kit Patterns
declare -A BROWSER_EXPLOIT_KIT_PATTERNS=(
    ["rig_ek"]="rig exploit|rigek"
    ["fallout_ek"]="fallout exploit|fallout-ek"
    ["spelevo_ek"]="spelevo|spl-ek"
    ["underminer_ek"]="underminer exploit"
    ["magnitude_ek"]="magnitude exploit"
    ["purple_fox"]="purple fox|purplefox"
)

# Phishing Kit Indicators
declare -a PHISHING_KIT_INDICATORS=(
    "office365.*login.*php"
    "microsoft.*signin.*php"
    "outlook.*auth.*php"
    "paypal.*verify.*php"
    "amazon.*billing.*php"
    "netflix.*update.*php"
    "facebook.*security.*php"
    "instagram.*verify.*php"
    "apple.*id.*php"
    "google.*signin.*php"
    "bank.*login.*php"
    "chase.*secure.*php"
    "wellsfargo.*online.*php"
    "citi.*banking.*php"
    "usps.*tracking.*php"
    "fedex.*delivery.*php"
    "dhl.*shipment.*php"
    "linkedin.*login.*php"
    "twitter.*auth.*php"
    "dropbox.*signin.*php"
    "coinbase.*verify.*php"
    "binance.*secure.*php"
)

# Credential Harvesting Endpoints
declare -a CREDENTIAL_HARVEST_PATTERNS=(
    "/wp-content/.*login"
    "/wp-includes/.*auth"
    "/.well-known/.*pass"
    "/admin/.*credential"
    "/user/.*authenticate"
    "/api/.*token"
    "/oauth/.*authorize"
    "/signin/.*process"
    "/login/.*submit"
    "/auth/.*verify"
    "/secure/.*validate"
    "/account/.*confirm"
)

echo "Audit enhancement modules loaded successfully"
echo "Total functions: 66 analyzers + orchestration (38 decoders + 14 protocol + 9 evasion + 5 supply chain)"
echo "Security features: Input validation, PII masking, chain of custody, secure cleanup"

################################################################################
# EXTENDED IOC DATABASES (Audit Compliance)
################################################################################

# Protocol-Specific IOC Patterns
declare -A PROTOCOL_IOC_PATTERNS=(
    # DNS Tunneling IOCs
    ["dns_tunnel_iodine"]="[a-z0-9]{52}\..*\..*"
    ["dns_tunnel_dns2tcp"]="dns2tcp|d2t\."
    ["dns_tunnel_dnscat2"]="dnscat|dnscat2"
    
    # MQTT IOCs
    ["mqtt_botnet"]="mirai.*mqtt|mqtt.*botnet"
    ["mqtt_c2"]="mqtt.*command|mqtt.*control"
    
    # WebSocket IOCs
    ["ws_reverse_shell"]="wss?://.*:(4444|5555|1234|9001)"
    ["ws_cobalt"]="wss?://.*beacon"
    
    # gRPC IOCs
    ["grpc_implant"]="grpc.*implant|grpc.*agent"
    
    # QUIC IOCs
    ["quic_tunnel"]="quic.*tunnel|quic.*proxy"
)

# Modern Threat Actor Infrastructure
declare -A THREAT_ACTOR_INFRA=(
    # APT Infrastructure Patterns
    ["apt29_cozy_bear"]="\.oast\..*|\.interact\.sh"
    ["apt28_fancy_bear"]="sednit|sofacy|x-agent"
    ["lazarus_group"]="lazarus|hidden.*cobra|temp\.hermit"
    ["sandworm"]="industroyer|expetr|notpetya"
    ["turla"]="turla|venomous.*bear|uroburos"
    
    # Ransomware Infrastructure
    ["lockbit_infra"]="lockbit.*decryptor|\.onion.*lockbit"
    ["blackcat_infra"]="alphv.*decrypt|blackcat.*onion"
    ["clop_infra"]="cl0p.*blog|clop.*ransom"
    ["royal_infra"]="royal.*onion|royal-news"
    ["akira_infra"]="akira.*ransom|akira.*blog"
    
    # Initial Access Broker Infrastructure
    ["iab_forums"]="exploit\.in|xss\.is|ramp"
    ["iab_markets"]="genesis.*market|russian.*market"
)

# Cloud Service Abuse Patterns
declare -A CLOUD_ABUSE_PATTERNS=(
    # AWS Abuse
    ["aws_credential_theft"]="AKIA[0-9A-Z]{16}|aws_access_key"
    ["aws_ec2_metadata"]="169\.254\.169\.254/latest/meta-data"
    ["aws_ssrf"]="amazonaws\.com.*metadata"
    
    # Azure Abuse
    ["azure_credential"]="eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1Ni"
    ["azure_metadata"]="169\.254\.169\.254/metadata"
    ["azure_keyvault"]="\.vault\.azure\.net"
    
    # GCP Abuse
    ["gcp_metadata"]="metadata\.google\.internal"
    ["gcp_credential"]="AIza[0-9A-Za-z-_]{35}"
    
    # Cloudflare Abuse
    ["cloudflare_bypass"]="cloudflare.*bypass|cf-connecting-ip"
    
    # Generic Cloud
    ["cloud_storage_open"]="s3\.amazonaws\.com/.*public|blob\.core\.windows\.net.*\?sv="
)

# Cryptocurrency & Financial Fraud IOCs
declare -A CRYPTO_FRAUD_IOCS=(
    # Wallet Drainer Contracts
    ["wallet_drainer"]="setApprovalForAll|increaseAllowance.*max"
    ["nft_scam"]="free.*mint|airdrop.*claim"
    ["fake_exchange"]="binance.*login|coinbase.*verify"
    
    # Crypto Mining
    ["cryptominer"]="stratum\+tcp|stratum\+ssl|xmr.*pool"
    ["coinhive_clone"]="coinhive|cryptoloot|webminer"
    
    # Ponzi/Pyramid
    ["ponzi_scheme"]="guaranteed.*return|100%.*profit|doubler"
    
    # Fake Wallet
    ["fake_wallet"]="metamask.*extension|trustwallet.*app"
)

# Supply Chain Attack IOCs
declare -A SUPPLY_CHAIN_IOCS=(
    # Package Manager Attacks
    ["npm_typosquat"]="npm.*install.*--unsafe-perm"
    ["pypi_malicious"]="pip.*install.*--trusted-host"
    ["gem_backdoor"]="gem.*install.*--no-verify"
    
    # Build Pipeline
    ["github_actions"]="uses:.*@master|run:.*curl.*\|.*sh"
    ["jenkins_rce"]="jenkins.*script=|jenkins.*groovy"
    ["circleci_secrets"]="circleci.*env|CIRCLE_"
    
    # Code Signing
    ["stolen_cert"]="signtool.*\\.pfx|certutil.*-p"
    ["unsigned_code"]="Set-ExecutionPolicy.*Bypass"
)

# Mobile & IoT Threat IOCs
declare -A MOBILE_IOT_IOCS=(
    # Android Malware
    ["android_rat"]="meterpreter.*android|spynote.*android"
    ["android_overlay"]="requestPermissions.*SYSTEM_ALERT_WINDOW"
    ["android_sms"]="SmsManager.*sendTextMessage"
    
    # iOS Threats
    ["ios_jailbreak"]="checkra1n|unc0ver|odyssey"
    ["ios_mdm"]="mobileconfig.*payload"
    
    # IoT Malware
    ["mirai_variant"]="mirai|gafgyt|bashlite|hajime"
    ["iot_scanner"]="shodan.*api|censys.*api.*iot"
    ["zigbee_attack"]="zigbee.*inject|zbassocflood"
    ["ble_attack"]="gattacker|btle.*mitm"
    
    # Smart Home
    ["smart_home"]="home-assistant.*exec|openhab.*script"
)

# Evasion Technique IOCs
declare -A EVASION_TECHNIQUE_IOCS=(
    # Living off the Land
    ["lolbin_certutil"]="certutil.*-urlcache|certutil.*-decode"
    ["lolbin_mshta"]="mshta.*vbscript|mshta.*javascript"
    ["lolbin_rundll32"]="rundll32.*javascript|rundll32.*shell32"
    ["lolbin_regsvr32"]="regsvr32.*/s.*/n.*/u"
    
    # AMSI Bypass
    ["amsi_bypass"]="amsicontext|amsiInitFailed|AmsiScanBuffer"
    
    # ETW Bypass
    ["etw_bypass"]="EtwEventWrite|ntdll.*etw"
    
    # Unhooking
    ["unhooking"]="NtProtectVirtualMemory|VirtualProtect.*PAGE_EXECUTE"
    
    # Process Injection
    ["process_injection"]="WriteProcessMemory|NtCreateThreadEx|QueueUserAPC"
    
    # Anti-Analysis
    ["anti_debug"]="IsDebuggerPresent|CheckRemoteDebugger|NtQueryInformationProcess"
    ["anti_vm"]="vmware|virtualbox|hyper-v|qemu"
    ["anti_sandbox"]="sbiedll|sandboxie|cuckoomon"
)

# Phishing Campaign IOCs
declare -A PHISHING_CAMPAIGN_IOCS=(
    # Brand Impersonation
    ["microsoft_phish"]="microsoft.*login|office365.*signin|outlook.*verify"
    ["google_phish"]="accounts\.google.*verify|gmail.*security"
    ["apple_phish"]="appleid.*verify|icloud.*confirm"
    ["amazon_phish"]="amazon.*verify|aws.*billing"
    ["paypal_phish"]="paypal.*limited|paypal.*suspended"
    ["dhl_phish"]="dhl.*delivery|dhl.*tracking"
    
    # Phishing Kit Indicators
    ["phishkit"]="scama|uadmin|16shop|mrxbot"
    
    # Credential Harvesting
    ["credential_harvest"]="form.*action.*login|input.*type.*password"
    
    # Phishing Infrastructure
    ["bullet_hosting"]="bulletproof|offshore.*hosting"
)

# Dark Web & Underground IOCs
declare -A DARKWEB_IOCS=(
    # Tor Hidden Services
    ["tor_market"]="\.onion.*market|\.onion.*shop"
    ["tor_forum"]="\.onion.*forum|\.onion.*board"
    ["tor_leak"]="\.onion.*leak|\.onion.*dump"
    
    # I2P/Lokinet
    ["i2p_service"]="\.i2p.*service|eepsite"
    ["lokinet"]="\.loki.*"
    
    # Underground Markets
    ["carding_forum"]="joker.*stash|briansclub|unicc"
    ["exploit_market"]="exploit\.in|xss\.is|hackforums"
    ["access_broker"]="initial.*access|access.*sale"
)

# Advanced Evasion Technique IOCs
declare -A EVASION_IOCS=(
    # Fast-Flux DNS
    ["fast_flux_domain"]="flux[0-9]+\.|ns[0-9]{3,}\."
    ["fast_flux_ttl"]="ttl[=:]\s*[0-5][0-9]\b"
    ["flux_network"]="avalanche|kelihos|waledac|storm.*worm"
    
    # Domain Fronting
    ["cdn_fronting"]="cloudfront.*host:|azureedge.*host:"
    ["meek_bridge"]="meek-amazon|meek-azure|meek-google"
    ["fronting_tool"]="domain.*front.*proxy"
    
    # DoH/DoT Abuse
    ["doh_tunnel"]="doh.*tunnel|doh.*c2|godoh"
    ["doh_endpoint"]="dns-query\?dns=|/dns-query\?"
    ["dot_port"]="tcp/853|:853"
    
    # ESNI/ECH
    ["esni_bypass"]="encrypted.*sni|ech.*config"
    ["sni_manipulation"]="sni.*spoof|sni.*null"
    ["tls_fingerprint"]="ja3.*spoof|jarm.*evasion"
    
    # Protocol Evasion
    ["fragmentation"]="fragroute|fragment.*evasion"
    ["protocol_switch"]="upgrade.*websocket|http.*connect"
    ["timing_channel"]="timing.*channel|covert.*timing"
    
    # DNS Steganography
    ["dns_steg_tool"]="iodine|dns2tcp|dnscat|heyoka"
    ["encoded_subdomain"]="[a-z0-9]{40,}\.[a-z]+"
    ["dns_txt_abuse"]="txt.*record.*encode|dns.*txt.*payload"
)

# Supply Chain Attack IOCs (Extended)
declare -A SUPPLY_CHAIN_EXTENDED_IOCS=(
    # Dependency Confusion
    ["dep_confusion"]="--index-url.*--extra-index-url"
    ["internal_pkg"]="@company/|@internal/|@corp/"
    ["high_version"]="version.*[0-9]{3,}\."
    ["preinstall_abuse"]='"preinstall".*curl|"postinstall".*wget'
    
    # Typosquatting
    ["npm_typosquat"]="loadsh|requets|expresss|reakt"
    ["pypi_typosquat"]="requestss|numpyy|djang0|flaskk"
    ["homoglyph"]="c0lors|crypt0|0auth"
    
    # CDN Compromise
    ["cdn_poison"]="cdn.*inject|cache.*poison"
    ["cdn_malware"]="cdn.*eval\(|cdn.*document\.write"
    ["polyfill_abuse"]="polyfill\.io|cdn\.polyfill"
    
    # SRI Bypass
    ["sri_missing"]="script.*src=.*cdn.*(?!integrity)"
    ["dynamic_script"]="createElement.*script|appendChild.*script"
    ["sri_bypass"]="integrity.*bypass|sri.*disable"
    
    # Manifest Abuse
    ["malicious_script"]='"scripts".*curl.*\||"scripts".*bash.*-c'
    ["git_inject"]="git\+https.*#egg=|git://.*\$\("
    ["setup_abuse"]="cmdclass.*install|os\.system.*setup"
)

# Network Covert Channel IOCs
declare -A COVERT_CHANNEL_IOCS=(
    # DNS Tunneling
    ["dns_tunnel_pattern"]="[a-z0-9]{32,}\.[a-z0-9-]+\.[a-z]+"
    ["dns_tunnel_tool"]="iodine|dns2tcp|dnscat2|dnscapy"
    
    # ICMP Tunneling
    ["icmp_tunnel"]="ptunnel|icmpsh|icmptunnel|hans.*tunnel"
    ["ping_exfil"]="ping.*\|.*base64|ping.*-p.*[0-9a-f]{16}"
    
    # HTTP Tunneling
    ["http_tunnel"]="ssh.*over.*http|tcp.*over.*http"
    ["connect_tunnel"]="CONNECT.*:443|http.*connect.*method"
    
    # WebSocket C2
    ["ws_c2"]="wss?://.*beacon|wss?://.*shell"
    ["ws_backdoor"]="websocket.*exec|ws.*cmd"
)

# Package Manager Security IOCs
declare -A PACKAGE_SECURITY_IOCS=(
    # npm Security
    ["npm_malicious"]="event-stream|flatmap-stream|eslint-scope"
    ["npm_install_abuse"]="npm.*install.*--ignore-scripts.*false"
    ["npm_registry_abuse"]="npm.*config.*registry.*http://"
    
    # PyPI Security
    ["pypi_malicious"]="ctx|importlib_metadata|malicious-pypi"
    ["pip_trust_abuse"]="pip.*--trusted-host"
    ["pip_index_abuse"]="--index-url.*http://"
    
    # Gem Security
    ["gem_malicious"]="gem.*--no-verify|gem.*--force"
    
    # Cargo Security
    ["cargo_malicious"]="cargo.*--allow-dirty|cargo.*--no-verify"
    
    # Go Security
    ["go_proxy_abuse"]="GOPROXY.*direct|go.*get.*-insecure"
)

################################################################################
# AUDIT-COMPLIANT IOC DATABASES (Extended Coverage)
################################################################################

# Extended Cryptocurrency & DeFi IOCs
declare -A EXTENDED_CRYPTO_IOCS=(
    # Layer 2 & Bridge Protocols
    ["arbitrum_bridge"]="bridge\.arbitrum\.io|arbiscan\.io"
    ["optimism_bridge"]="app\.optimism\.io/bridge"
    ["polygon_bridge"]="wallet\.polygon\.technology"
    ["zksync_bridge"]="bridge\.zksync\.io|zksync\.io"
    ["starknet_bridge"]="starkgate\.starknet\.io"
    ["base_bridge"]="bridge\.base\.org"
    
    # DEX Aggregators & Swaps
    ["uniswap_scam"]="uniswap[^\.]*\.(com|net|io)|fake.*uniswap"
    ["pancakeswap_scam"]="pancakeswap[^\.]*\.(com|net|io)"
    ["sushiswap_scam"]="sushiswap[^\.]*\.(com|net)"
    ["1inch_scam"]="1inch[^\.]*\.(com|net)|fake.*1inch"
    ["curve_scam"]="curve[^\.]*\.(com|net)|fake.*curve"
    
    # NFT Marketplace Phishing
    ["opensea_phish"]="opensea[^\.]*\.(com|net|io)|0pensea"
    ["blur_phish"]="blur[^\.]*\.(com|net)|b1ur\.io"
    ["rarible_phish"]="rarib1e|rar1ble"
    ["looksrare_phish"]="l00ksrare|looksrar3"
    
    # Wallet Drainer Contracts
    ["seaport_drainer"]="seaport.*signature|opensea.*permit"
    ["permit2_drainer"]="permit2.*signature|uniswap.*permit2"
    ["blur_drainer"]="blur.*signature|blur.*listing"
    ["setapproval_drainer"]="setApprovalForAll.*true"
    
    # Crypto Scam Patterns
    ["giveaway_scam"]="(elon|vitalik|cz).*giveaway|double.*your.*(btc|eth)"
    ["airdrop_scam"]="claim.*airdrop|free.*token.*claim"
    ["recovery_scam"]="recover.*wallet|wallet.*recovery.*service"
    ["mining_scam"]="cloud.*mining.*guaranteed|mining.*pool.*profit"
)

# Extended Cloud Provider IOCs
declare -A EXTENDED_CLOUD_IOCS=(
    # Oracle Cloud
    ["oracle_object_storage"]="objectstorage\.[a-z-]+\.oraclecloud\.com"
    ["oracle_functions"]="functions\.oci\.oraclecloud\.com"
    ["oracle_api_gateway"]="apigateway\.[a-z-]+\.oci\.oraclecloud\.com"
    
    # IBM Cloud
    ["ibm_cos"]="s3\.[a-z-]+\.cloud-object-storage\.appdomain\.cloud"
    ["ibm_functions"]="[a-z-]+\.functions\.appdomain\.cloud"
    ["ibm_containers"]="[a-z-]+\.containers\.appdomain\.cloud"
    
    # Alibaba Cloud
    ["aliyun_oss"]="[a-z0-9-]+\.oss-[a-z-]+\.aliyuncs\.com"
    ["aliyun_fc"]="[a-z0-9-]+\.[a-z-]+\.fc\.aliyuncs\.com"
    ["aliyun_cdn"]="[a-z0-9-]+\.alicdn\.com"
    
    # Tencent Cloud
    ["tencent_cos"]="[a-z0-9-]+\.cos\.[a-z-]+\.myqcloud\.com"
    ["tencent_scf"]="[a-z0-9-]+\.scf\.tencentcs\.com"
    ["tencent_cdn"]="[a-z0-9-]+\.file\.myqcloud\.com"
    
    # Huawei Cloud
    ["huawei_obs"]="[a-z0-9-]+\.obs\.[a-z-]+\.myhuaweicloud\.com"
    ["huawei_fg"]="[a-z0-9-]+\.functiongraph\..*\.myhuaweicloud\.com"
    
    # Yandex Cloud
    ["yandex_storage"]="storage\.yandexcloud\.net"
    ["yandex_functions"]="functions\.yandexcloud\.net"
    
    # Hetzner
    ["hetzner_storage"]="[a-z0-9-]+\.your-objectstorage\.com"
    
    # OVH
    ["ovh_storage"]="[a-z0-9-]+\.cloud\.ovh\.net"
    ["ovh_functions"]="[a-z0-9-]+\.functions\.cloud\.ovh\.net"
)

# Messaging & Collaboration Platform IOCs
declare -A MESSAGING_PLATFORM_IOCS=(
    # Slack
    ["slack_webhook"]="hooks\.slack\.com/services/T[A-Z0-9]+/B[A-Z0-9]+/[a-zA-Z0-9]+"
    ["slack_api"]="api\.slack\.com"
    ["slack_files"]="files\.slack\.com"
    
    # Discord
    ["discord_webhook"]="discord(app)?\.com/api/webhooks/[0-9]+/[a-zA-Z0-9_-]+"
    ["discord_cdn"]="cdn\.discordapp\.com"
    ["discord_media"]="media\.discordapp\.net"
    ["discord_invite"]="discord\.(gg|com/invite)/[a-zA-Z0-9]+"
    
    # Microsoft Teams
    ["teams_webhook"]="[a-z0-9-]+\.webhook\.office\.com"
    ["teams_api"]="graph\.microsoft\.com/.*teams"
    
    # Telegram
    ["telegram_bot"]="api\.telegram\.org/bot[0-9]+:[a-zA-Z0-9_-]+"
    ["telegram_link"]="t\.me/[a-zA-Z0-9_]+"
    ["telegram_file"]="api\.telegram\.org/file/bot"
    
    # WhatsApp
    ["whatsapp_api"]="graph\.facebook\.com/.*/messages"
    ["whatsapp_link"]="wa\.me/[0-9]+\?text="
    ["whatsapp_click"]="api\.whatsapp\.com/send"
    
    # Signal
    ["signal_link"]="signal\.me/#p/[a-zA-Z0-9]+"
    ["signal_group"]="signal\.group/#[a-zA-Z0-9_-]+"
    
    # Matrix/Element
    ["matrix_room"]="matrix\.to/#/![a-zA-Z0-9]+:[a-z.]+"
    ["element_room"]="app\.element\.io/#/room/![a-zA-Z0-9]+:"
    
    # Zulip
    ["zulip_api"]="[a-z0-9-]+\.zulipchat\.com/api"
    ["zulip_webhook"]="[a-z0-9-]+\.zulipchat\.com/api/v1/external"
    
    # Mattermost
    ["mattermost_webhook"]="[a-z0-9-]+\.mattermost\.(com|cloud)/hooks/[a-z0-9]+"
    ["mattermost_api"]="[a-z0-9-]+\.mattermost\.(com|cloud)/api"
    
    # Rocket.Chat
    ["rocketchat_webhook"]="[a-z0-9-]+\.rocket\.chat/hooks/[a-z0-9]+"
    ["rocketchat_api"]="[a-z0-9-]+\.rocket\.chat/api"
    
    # Keybase
    ["keybase_api"]="keybase\.io/_/api"
    ["keybase_team"]="keybase\.io/team/[a-z0-9_]+"
    ["keybase_chat"]="keybase\.io/[a-z0-9_]+/chat"
)

# Developer Platform Abuse IOCs
declare -A DEV_PLATFORM_ABUSE_IOCS=(
    # GitHub
    ["github_raw"]="raw\.githubusercontent\.com/[^/]+/[^/]+/(main|master)/"
    ["github_gist"]="gist\.github\.com/[a-z0-9]+/[a-f0-9]+"
    ["github_release"]="github\.com/[^/]+/[^/]+/releases/download"
    ["github_codespace"]="[a-z0-9-]+\.github\.dev"
    
    # GitLab
    ["gitlab_raw"]="gitlab\.com/[^/]+/[^/]+/-/raw"
    ["gitlab_snippet"]="gitlab\.com/-/snippets/[0-9]+/raw"
    ["gitlab_pages"]="[a-z0-9-]+\.gitlab\.io"
    
    # Bitbucket
    ["bitbucket_raw"]="bitbucket\.org/[^/]+/[^/]+/raw"
    ["bitbucket_download"]="bitbucket\.org/[^/]+/[^/]+/downloads"
    
    # Replit
    ["replit_repl"]="replit\.com/@[a-zA-Z0-9_]+/[a-zA-Z0-9_-]+"
    ["replit_run"]="[a-z0-9-]+\.repl\.co"
    ["replit_dev"]="[a-z0-9-]+\.id\.repl\.co"
    
    # CodeSandbox
    ["codesandbox_embed"]="codesandbox\.io/s/[a-z0-9-]+"
    ["codesandbox_app"]="[a-z0-9]+\.csb\.app"
    
    # StackBlitz
    ["stackblitz_project"]="stackblitz\.com/edit/[a-z0-9-]+"
    ["stackblitz_app"]="[a-z0-9-]+\.stackblitz\.io"
    
    # Gitpod
    ["gitpod_workspace"]="gitpod\.io/#https://github\.com"
    ["gitpod_dev"]="[a-z0-9-]+\.gitpod\.io"
    
    # JetBrains Space
    ["jetbrains_space"]="[a-z0-9-]+\.jetbrains\.space"
    
    # Sourcegraph
    ["sourcegraph_search"]="sourcegraph\.com/search\?q="
    
    # Val Town
    ["valtown_val"]="val\.town/v/[a-z0-9_]+"
    ["valtown_run"]="[a-z0-9-]+\.web\.val\.run"
)

# Extended URL Shortener IOCs
declare -A URL_SHORTENER_EXTENDED_IOCS=(
    # Major Shorteners
    ["bitly"]="bit\.ly/[a-zA-Z0-9]+"
    ["tinyurl"]="tinyurl\.com/[a-zA-Z0-9]+"
    ["isgd"]="is\.gd/[a-zA-Z0-9]+"
    ["vgd"]="v\.gd/[a-zA-Z0-9]+"
    ["tco"]="t\.co/[a-zA-Z0-9]+"
    
    # QR-Specific Shorteners
    ["qrco"]="qrco\.de/[a-zA-Z0-9]+"
    ["qrfy"]="qrfy\.com/[a-zA-Z0-9]+"
    ["qrtag"]="qrtag\.net/[a-zA-Z0-9]+"
    
    # Link-in-Bio Services
    ["linktree"]="linktr\.ee/[a-zA-Z0-9_]+"
    ["beacons"]="beacons\.ai/[a-zA-Z0-9_]+"
    ["lnkbio"]="lnk\.bio/[a-zA-Z0-9_]+"
    ["taplink"]="taplink\.cc/[a-zA-Z0-9_]+"
    
    # Regional Shorteners
    ["clckru"]="clck\.ru/[a-zA-Z0-9]+"
    ["vkcc"]="vk\.cc/[a-zA-Z0-9]+"
    ["naverme"]="naver\.me/[a-zA-Z0-9]+"
    ["dwzcn"]="dwz\.cn/[a-zA-Z0-9]+"
    
    # Enterprise Shorteners
    ["rebrandly"]="rebrand\.ly/[a-zA-Z0-9]+"
    ["shortio"]="short\.io/[a-zA-Z0-9]+"
    ["blink"]="bl\.ink/[a-zA-Z0-9]+"
    
    # Suspicious/Malware-associated
    ["ouoio"]="ouo\.io/[a-zA-Z0-9]+"
    ["shortest"]="shorte\.st/[a-zA-Z0-9]+"
    ["adflypattern"]="adf\.ly/[a-zA-Z0-9]+"
)

################################################################################
# ADDITIONAL FUNCTIONS FROM QR_MAIN.SH
################################################################################

# XOR encoding detection
detect_xor_encoding() {
    local content="$1"
    
    log_info "Detecting XOR encoding patterns..."
    
    python3 2>/dev/null <<'EOF'
import sys

content = sys.stdin.read()

# Look for patterns that might indicate XOR encoding
byte_freq = {}
for i in range(0, len(content), 2):
    if i+1 < len(content):
        byte = content[i:i+2]
        byte_freq[byte] = byte_freq.get(byte, 0) + 1

# Check for repeating patterns
if byte_freq:
    most_common = max(byte_freq.values())
    if most_common > len(content) * 0.1:
        print("POTENTIAL_XOR_ENCODING_DETECTED")
        
# Check for XOR key patterns (repeating sequences)
for key_len in range(1, 17):
    pattern_found = False
    for offset in range(key_len):
        chars = [content[i] for i in range(offset, len(content), key_len)]
        if len(chars) > 0 and len(set(chars)) / len(chars) < 0.3:
            pattern_found = True
            break
    if pattern_found:
        print(f"POSSIBLE_XOR_KEY_LENGTH_{key_len}")
EOF
    
    if [ $? -eq 0 ]; then
        log_threat 35 "XOR encoding patterns detected"
    fi
}

# Encryption indicators analysis
analyze_encryption_indicators() {
    set +u
    local content="${1:-}"
    set -u
    
    log_info "Analyzing encryption indicators..."
    
    # Check for common encryption headers
    if echo "$content" | safe_grep_qE "^Salted__|^U2FsdGVk"; then
        log_threat 40 "OpenSSL encryption header detected"
    fi
    
    # Check for PGP/GPG
    if echo "$content" | safe_grep_qE "-----BEGIN PGP|-----BEGIN.*ENCRYPTED"; then
        log_threat 35 "PGP/GPG encrypted content detected"
    fi
    
    # Check for base64-encoded encrypted data
    if echo "$content" | safe_grep_qE "^[A-Za-z0-9+/]{100,}={0,2}$"; then
        log_warning "Large base64 block detected (possibly encrypted payload)"
    fi
    
    analyze_byte_distribution "$content"
}

# Byte distribution analysis
analyze_byte_distribution() {
    set +u
    local content="${1:-}"
    set -u
    
    echo "$content" | python3 2>/dev/null <<'EOF'
import sys
from collections import Counter
import math

content = sys.stdin.read()
if not content:
    sys.exit(0)

# Calculate chi-squared test for randomness
byte_counts = Counter(content.encode('latin-1', errors='ignore'))
expected = len(content) / 256
if expected > 0:
    chi_squared = sum((count - expected) ** 2 / expected for count in byte_counts.values())

    # High chi-squared indicates non-random (encrypted or compressed)
    if chi_squared > 50000:
        print(f"HIGH_CHI_SQUARED:{chi_squared:.0f}_POSSIBLE_ENCRYPTION")
        
    # Calculate index of coincidence
    total = sum(byte_counts.values())
    if total > 1:
        ic = sum(count * (count - 1) for count in byte_counts.values()) / (total * (total - 1))
        # IC close to 0.067 suggests English, close to 0.0385 suggests encrypted
        if ic < 0.045:
            print(f"LOW_IC:{ic:.4f}_LIKELY_ENCRYPTED_OR_COMPRESSED")
EOF
}

# Multi-language malware detection orchestrator
detect_malware_languages() {
    local content="$1"
    
    log_info "Detecting malware in multiple languages..."
    
    detect_powershell_malware "$content"
    detect_python_malware "$content"
    detect_javascript_malware "$content"
    detect_shell_malware "$content"
    detect_vbscript_malware "$content"
    detect_perl_malware "$content"
    detect_ruby_malware "$content"
}

# PowerShell malware detection
detect_powershell_malware() {
    local content="$1"
    
    local ps_patterns=(
        "IEX|Invoke-Expression"
        "Invoke-WebRequest.*-OutFile"
        "downloadstring"
        "Net\.WebClient"
        "System\.Net\.WebClient"
        "powershell.*-enc.*[A-Za-z0-9+/=]{50,}"
        "-nop.*-w.*hidden.*-c"
        "Add-MpPreference.*-ExclusionPath"
        "Set-MpPreference.*-DisableRealtimeMonitoring"
        "AMSI"
        "AmsiScanBuffer"
        "reflection\.assembly.*load"
        "IO\.MemoryStream"
        "IO\.Compression\.GzipStream"
        "Convert.*FromBase64String"
    )
    
    for pattern in "${ps_patterns[@]}"; do
        if echo "$content" | safe_grep_qiE "$pattern"; then
            log_threat 45 "PowerShell malware pattern detected: $pattern"
        fi
    done
}

# Python malware detection
detect_python_malware() {
    local content="$1"
    
    local py_patterns=(
        "exec\(.*compile\("
        "eval\(.*input\("
        "__import__.*os.*system"
        "subprocess\.Popen.*shell=True"
        "urllib.*urlopen"
        "requests\.get.*\.content"
        "socket\.socket.*connect"
        "pickle\.loads"
        "marshal\.loads"
        "base64\.b64decode.*exec"
        "keylogger"
        "pynput.*keyboard"
    )
    
    for pattern in "${py_patterns[@]}"; do
        if echo "$content" | safe_grep_qiE "$pattern"; then
            log_threat 40 "Python malware pattern detected: $pattern"
        fi
    done
}

# JavaScript malware detection
detect_javascript_malware() {
    local content="$1"
    
    local js_patterns=(
        "eval\(.*atob\("
        "Function.*constructor"
        "unescape\(.*%[0-9a-f]{2}"
        "String\.fromCharCode.*apply"
        "XMLHttpRequest.*onload.*eval"
        "document\.write.*<script"
        "\.createElement.*script.*\.src"
        "window\.location.*=.*javascript:"
        "setInterval.*eval"
        "setTimeout.*eval"
    )
    
    for pattern in "${js_patterns[@]}"; do
        if echo "$content" | safe_grep_qiE "$pattern"; then
            log_threat 40 "JavaScript malware pattern detected: $pattern"
        fi
    done
}

# Shell malware detection
detect_shell_malware() {
    local content="$1"
    
    local shell_patterns=(
        "wget.*\|.*sh"
        "curl.*\|.*bash"
        "/dev/tcp/.*>&"
        "nc.*-e.*/bin/bash"
        "bash.*-i.*>&.*dev/tcp"
        "mkfifo.*nc"
        "perl.*socket.*STDIN"
        "python.*pty\.spawn"
        "rm.*-rf.*/\*"
        "dd.*if=/dev/zero.*of="
    )
    
    for pattern in "${shell_patterns[@]}"; do
        if echo "$content" | safe_grep_qE "$pattern"; then
            log_threat 50 "Shell malware pattern detected: $pattern"
        fi
    done
}

# VBScript malware detection
detect_vbscript_malware() {
    local content="$1"
    
    local vbs_patterns=(
        "CreateObject.*WScript\.Shell"
        "CreateObject.*Shell\.Application"
        "CreateObject.*Scripting\.FileSystemObject"
        "CreateObject.*MSXML2\.XMLHTTP"
        "CreateObject.*ADODB\.Stream"
        "\.Run.*cmd.*\/c"
        "\.exec.*powershell"
        "\.SaveToFile.*2"
        "\.ResponseBody"
        "Execute.*Chr\("
    )
    
    for pattern in "${vbs_patterns[@]}"; do
        if echo "$content" | safe_grep_qiE "$pattern"; then
            log_threat 45 "VBScript malware pattern detected: $pattern"
        fi
    done
}

# Perl malware detection
detect_perl_malware() {
    local content="$1"
    
    local perl_patterns=(
        "use Socket.*connect"
        "exec.*'/bin/sh'"
        "system\(.*wget"
        "open.*\|.*nc"
        "IO::Socket::INET"
    )
    
    for pattern in "${perl_patterns[@]}"; do
        if echo "$content" | safe_grep_qE "$pattern"; then
            log_threat 40 "Perl malware pattern detected: $pattern"
        fi
    done
}

# Ruby malware detection
detect_ruby_malware() {
    local content="$1"
    
    local ruby_patterns=(
        "IO\.popen.*system"
        "exec\(.*shell"
        "Net::HTTP.*download"
        "TCPSocket\.open"
        "File\.delete.*\*"
    )
    
    for pattern in "${ruby_patterns[@]}"; do
        if echo "$content" | safe_grep_qE "$pattern"; then
            log_threat 40 "Ruby malware pattern detected: $pattern"
        fi
    done
}

# ML-style heuristic analysis
ml_style_heuristics() {
    local content="$1"
    
    log_info "Running ML-style heuristic analysis..."
    
    echo "$content" | python3 2>/dev/null <<'EOF'
import sys
import re
import math
from collections import Counter

content = sys.stdin.read()

features = {
    'length': len(content),
    'entropy': 0,
    'digit_ratio': 0,
    'upper_ratio': 0,
    'special_ratio': 0,
    'url_count': 0,
    'ip_count': 0,
    'suspicious_keywords': 0,
    'base64_blocks': 0,
    'hex_blocks': 0,
}

if content:
    counter = Counter(content)
    length = len(content)
    features['entropy'] = -sum((count/length) * math.log2(count/length) for count in counter.values())
    features['digit_ratio'] = sum(c.isdigit() for c in content) / length
    features['upper_ratio'] = sum(c.isupper() for c in content) / length
    features['special_ratio'] = sum(not c.isalnum() and not c.isspace() for c in content) / length

features['url_count'] = len(re.findall(r'https?://', content, re.I))
features['ip_count'] = len(re.findall(r'\b\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}\b', content))
features['base64_blocks'] = len(re.findall(r'[A-Za-z0-9+/]{40,}={0,2}', content))
features['hex_blocks'] = len(re.findall(r'[0-9a-fA-F]{32,}', content))

suspicious_words = ['password', 'admin', 'root', 'credential', 'secret', 'token', 'key', 'login', 'auth']
features['suspicious_keywords'] = sum(content.lower().count(word) for word in suspicious_words)

score = 0
if features['entropy'] > 4.5:
    score += 25
if features['special_ratio'] > 0.3:
    score += 20
if features['base64_blocks'] > 2:
    score += 30
if features['ip_count'] > 1:
    score += 15
if features['suspicious_keywords'] > 3:
    score += 20

if score > 50:
    print(f"ML_HEURISTIC_THREAT_SCORE:{score}")
EOF
}

# Deep link analysis
analyze_deep_links() {
    set +u
    local content="${1:-}"
    set -u
    
    log_info "Analyzing deep links and app URL schemes..."
    
    local deeplink_schemes=(
        "intent://" "android-app://" "market://" "fb://" "twitter://"
        "instagram://" "whatsapp://" "tg://" "mailto:" "tel:" "sms:"
        "facetime://" "skype:" "slack://" "zoom://" "ms-" "file://"
    )
    
    for scheme in "${deeplink_schemes[@]}"; do
        if echo "$content" | safe_grep_qiE "^$scheme"; then
            log_threat 25 "Deep link detected: $scheme"
            
            local params=$(echo "$content" | sed "s/^$scheme//" | tr '&' '\n')
            echo "$params" | while read -r param; do
                if echo "$param" | grep -qiE "token=|auth=|session=|key="; then
                    log_threat 30 "Sensitive parameter in deep link"
                fi
            done
        fi
    done
}

# Blockchain address checking
check_blockchain_address() {
    local address="$1"
    
    if [ "$NETWORK_CHECK" = false ]; then
        return
    fi
    
    if [[ "$address" =~ ^(1|3|bc1) ]]; then
        check_bitcoin_address "$address"
    elif [[ "$address" =~ ^0x ]]; then
        check_ethereum_address "$address"
    fi
}

# Bitcoin address checking
check_bitcoin_address() {
    local address="$1"
    
    log_info "Checking Bitcoin address on blockchain..."
    
    local btc_info=$(curl -sL --max-time 5 "https://blockchain.info/q/addressbalance/$address" 2>/dev/null)
    
    if [ -n "$btc_info" ] && [ "$btc_info" != "0" ]; then
        local balance_btc=$(echo "scale=8; $btc_info / 100000000" | bc 2>/dev/null)
        log_warning "Bitcoin address has balance: ${balance_btc} BTC"
    fi
}

# Ethereum address checking
check_ethereum_address() {
    local address="$1"
    
    log_info "Checking Ethereum address..."
    log_warning "Ethereum blockchain lookup requires API key"
}

# WiFi payload analysis
analyze_wifi_payload() {
    set +u
    local content="${1:-}"
    set -u
    
    if ! echo "$content" | safe_grep_qE "^WIFI:"; then
        return
    fi
    
    log_info "Analyzing WiFi QR code..."
    
    # AUDIT FIX: Use POSIX-compliant sed instead of Perl regex for WiFi parsing
    local ssid=$(echo "$content" | sed -n 's/.*S:\([^;]*\).*/\1/p')
    local encryption=$(echo "$content" | sed -n 's/.*T:\([^;]*\).*/\1/p')
    local hidden=$(echo "$content" | sed -n 's/.*H:\([^;]*\).*/\1/p')
    
    log_info "  SSID: $ssid"
    log_info "  Encryption: ${encryption:-none}"
    log_info "  Hidden: ${hidden:-false}"
    
    if [ -z "$encryption" ] || [[ "$encryption" =~ ^(nopass|None|WEP)$ ]]; then
        log_threat 30 "Weak/no encryption: $encryption"
    fi
    
    if echo "$ssid" | grep -qiE "free|public|guest|open|airport|hotel|starbucks"; then
        log_threat 25 "Suspicious SSID (evil twin): $ssid"
    fi
    
    if [ "$hidden" = "true" ]; then
        log_threat 20 "Hidden network detected"
    fi
}

# Mobile config profile analysis
analyze_mobile_config() {
    set +u
    local content="${1:-}"
    set -u
    
    log_info "Checking for mobile configuration profiles..."
    
    local mobile_config_patterns=(
        "\.mobileconfig" "\.plist" "PayloadType" "PayloadIdentifier"
        "Configuration.*Profile" "MDM.*enrollment" "SCEP"
    )
    
    for pattern in "${mobile_config_patterns[@]}"; do
        if echo "$content" | safe_grep_qiE "$pattern"; then
            log_threat 50 "Mobile config profile indicator: $pattern"
            
            if echo "$content" | safe_grep_qiE "^https?://.*\.mobileconfig$"; then
                log_critical "mobileconfig download URL detected - HIGH RISK"
            fi
        fi
    done
}

################################################################################
# MOBILE-SPECIFIC THREAT ANALYSIS MODULES
################################################################################

# iOS Universal Links Abuse Detection
analyze_universal_links() {
    set +u
    local content="${1:-}"
    set -u
    local report="${OUTPUT_DIR}/universal_links_analysis.txt"
    
    log_info "Analyzing for iOS Universal Links abuse..."
    
    local findings=()
    local score=0
    
    # Check for Universal Links patterns
    for pattern in "${UNIVERSAL_LINKS_ABUSE_PATTERNS[@]}"; do
        if echo "$content" | safe_grep_qiE "$pattern"; then
            local matched=$(echo "$content" | safe_grep_oiE "$pattern" 2>/dev/null | head -1)
            findings+=("universal_link:$matched")
            ((score += 25))
            log_warning "Universal Links indicator: ${matched:0:50}"
        fi
    done
    
    # Check for Apple app-site-association
    if echo "$content" | safe_grep_qiE "apple-app-site-association|applinks:"; then
        findings+=("app_site_association")
        ((score += 20))
        
        # Check for wildcards (security risk)
        if echo "$content" | safe_grep_qiE '"paths".*"\*"'; then
            findings+=("wildcard_path_dangerous")
            ((score += 35))
            log_critical "Universal Links wildcard path - HIGH RISK"
        fi
    fi
    
    # Check for credential-related universal links
    if echo "$content" | safe_grep_qiE "(signin|login|auth|oauth|password).*applinks"; then
        findings+=("credential_universal_link")
        ((score += 40))
        log_critical "Credential-related Universal Link detected"
    fi
    
    if [ ${#findings[@]} -gt 0 ]; then
        {
            echo "═══════════════════════════════════════════════"
            echo "iOS UNIVERSAL LINKS ABUSE ANALYSIS"
            echo "═══════════════════════════════════════════════"
            echo "Timestamp: $(date -Iseconds)"
            echo "Threat Score: $score"
            echo ""
            echo "Findings:"
            for finding in "${findings[@]}"; do
                echo "  - $finding"
            done
            echo ""
            echo "MITRE ATT&CK: T1437.001 - Application Deep Links"
        } >> "$report"
        
        if [ $score -ge 30 ]; then
            log_threat $((score / 2)) "iOS Universal Links abuse detected"
            record_ioc "universal_links_abuse" "${findings[0]}" "T1437.001"
        fi
    fi
}

# Android App Links Abuse Detection
analyze_app_links() {
    set +u
    local content="${1:-}"
    set -u
    local report="${OUTPUT_DIR}/app_links_analysis.txt"
    
    log_info "Analyzing for Android App Links abuse..."
    
    local findings=()
    local score=0
    
    # Check for App Links patterns
    for pattern in "${APP_LINKS_ABUSE_PATTERNS[@]}"; do
        if echo "$content" | safe_grep_qiE "$pattern"; then
            local matched=$(echo "$content" | safe_grep_oiE "$pattern" 2>/dev/null | head -1)
            findings+=("app_link:$matched")
            ((score += 25))
            log_warning "App Links indicator: ${matched:0:50}"
        fi
    done
    
    # Check for Digital Asset Links
    if echo "$content" | safe_grep_qiE "assetlinks\.json|delegate_permission"; then
        findings+=("digital_asset_links")
        ((score += 20))
    fi
    
    # Check for intent URI with dangerous components
    if echo "$content" | safe_grep_qiE "intent://.*#Intent.*S\.browser_fallback_url"; then
        findings+=("intent_with_fallback")
        ((score += 30))
        log_warning "Intent URI with browser fallback detected"
    fi
    
    # Check for APK sideloading via intent
    if echo "$content" | safe_grep_qiE "intent://.*action=android\.intent\.action\.VIEW.*\.apk"; then
        findings+=("apk_sideload_intent")
        ((score += 50))
        log_critical "APK sideloading via Intent detected - HIGH RISK"
    fi
    
    if [ ${#findings[@]} -gt 0 ]; then
        {
            echo "═══════════════════════════════════════════════"
            echo "ANDROID APP LINKS ABUSE ANALYSIS"
            echo "═══════════════════════════════════════════════"
            echo "Timestamp: $(date -Iseconds)"
            echo "Threat Score: $score"
            echo ""
            echo "Findings:"
            for finding in "${findings[@]}"; do
                echo "  - $finding"
            done
            echo ""
            echo "MITRE ATT&CK: T1437.001 - Application Deep Links"
        } >> "$report"
        
        if [ $score -ge 25 ]; then
            log_threat $((score / 2)) "Android App Links abuse detected"
            record_ioc "app_links_abuse" "${findings[0]}" "T1437.001"
        fi
    fi
}

# Custom URI Scheme Hijacking Detection
analyze_custom_scheme_hijack() {
    set +u
    local content="${1:-}"
    set -u
    local report="${OUTPUT_DIR}/scheme_hijack_analysis.txt"
    
    log_info "Analyzing for custom URI scheme hijacking..."
    
    local findings=()
    local score=0
    
    # Check for scheme hijacking patterns
    for pattern in "${SCHEME_HIJACK_PATTERNS[@]}"; do
        if echo "$content" | safe_grep_qiE "$pattern"; then
            local matched=$(echo "$content" | safe_grep_oiE "$pattern" 2>/dev/null | head -1)
            findings+=("scheme_pattern:$matched")
            ((score += 20))
        fi
    done
    
    # Check for sensitive scheme abuse
    local sensitive_schemes=(
        "paypal://" "venmo://" "cash://" "zelle://"
        "banking://" "wallet://" "crypto://"
        "auth://" "oauth://" "sso://"
    )
    
    for scheme in "${sensitive_schemes[@]}"; do
        if echo "$content" | safe_grep_qiE "$scheme"; then
            findings+=("sensitive_scheme:$scheme")
            ((score += 40))
            log_critical "Sensitive scheme detected: $scheme"
        fi
    done
    
    # Check for scheme collision attacks (numbered schemes)
    if echo "$content" | safe_grep_qiE "fb[0-9]+://|twitter[0-9]+://|com\.[a-z]+[0-9]+://"; then
        findings+=("scheme_collision_attack")
        ((score += 35))
        log_warning "Potential scheme collision attack pattern"
    fi
    
    if [ ${#findings[@]} -gt 0 ]; then
        {
            echo "═══════════════════════════════════════════════"
            echo "URI SCHEME HIJACKING ANALYSIS"
            echo "═══════════════════════════════════════════════"
            echo "Timestamp: $(date -Iseconds)"
            echo "Threat Score: $score"
            echo ""
            echo "Findings:"
            for finding in "${findings[@]}"; do
                echo "  - $finding"
            done
            echo ""
            echo "MITRE ATT&CK: T1437 - Protocol Handler"
        } >> "$report"
        
        if [ $score -ge 30 ]; then
            log_threat $((score / 2)) "URI scheme hijacking indicators detected"
            record_ioc "scheme_hijack" "${findings[0]}" "T1437"
        fi
    fi
}

# Mobile Clipboard Hijacking Detection
analyze_clipboard_hijack() {
    set +u
    local content="${1:-}"
    set -u
    local report="${OUTPUT_DIR}/clipboard_hijack_analysis.txt"
    
    log_info "Analyzing for mobile clipboard hijacking..."
    
    local findings=()
    local score=0
    
    # Check for clipboard patterns
    for pattern in "${CLIPBOARD_HIJACK_PATTERNS[@]}"; do
        if echo "$content" | safe_grep_qiE "$pattern"; then
            local matched=$(echo "$content" | safe_grep_oiE "$pattern" 2>/dev/null | head -1)
            findings+=("clipboard:$matched")
            ((score += 25))
        fi
    done
    
    # Check for crypto address replacement patterns
    if echo "$content" | safe_grep_qiE "clipboard.*(bc1|0x[a-f0-9]{40}|[13][a-km-zA-HJ-NP-Z1-9]{25,34})"; then
        findings+=("crypto_clipboard_theft")
        ((score += 55))
        log_critical "Cryptocurrency clipboard hijacking detected"
    fi
    
    # Check for iOS/Android clipboard APIs with exfil
    if echo "$content" | safe_grep_qiE "(UIPasteboard|ClipboardManager).*(http|send|post|upload)"; then
        findings+=("clipboard_exfiltration")
        ((score += 45))
        log_critical "Clipboard data exfiltration pattern"
    fi
    
    if [ ${#findings[@]} -gt 0 ]; then
        {
            echo "═══════════════════════════════════════════════"
            echo "CLIPBOARD HIJACKING ANALYSIS"
            echo "═══════════════════════════════════════════════"
            echo "Timestamp: $(date -Iseconds)"
            echo "Threat Score: $score"
            echo ""
            echo "Findings:"
            for finding in "${findings[@]}"; do
                echo "  - $finding"
            done
            echo ""
            echo "MITRE ATT&CK: T1414 - Clipboard Data"
        } >> "$report"
        
        if [ $score -ge 30 ]; then
            log_threat $((score / 2)) "Clipboard hijacking indicators detected"
            record_ioc "clipboard_hijack" "${findings[0]}" "T1414"
        fi
    fi
}

# Screen Overlay Attack Detection
analyze_overlay_attacks() {
    set +u
    local content="${1:-}"
    set -u
    local report="${OUTPUT_DIR}/overlay_attack_analysis.txt"
    
    log_info "Analyzing for screen overlay attacks..."
    
    local findings=()
    local score=0
    
    # Check for overlay patterns
    for pattern in "${OVERLAY_ATTACK_PATTERNS[@]}"; do
        if echo "$content" | safe_grep_qiE "$pattern"; then
            local matched=$(echo "$content" | safe_grep_oiE "$pattern" 2>/dev/null | head -1)
            findings+=("overlay:$matched")
            ((score += 30))
        fi
    done
    
    # Check for SYSTEM_ALERT_WINDOW permission
    if echo "$content" | safe_grep_qiE "android\.permission\.SYSTEM_ALERT_WINDOW"; then
        findings+=("overlay_permission")
        ((score += 35))
        log_warning "Overlay permission detected"
    fi
    
    # Check for banking overlay attack patterns
    if echo "$content" | safe_grep_qiE "(overlay|transparent).*(bank|credential|login|password)"; then
        findings+=("banking_overlay")
        ((score += 55))
        log_critical "Banking overlay attack pattern detected"
    fi
    
    # Check for tapjacking indicators
    if echo "$content" | safe_grep_qiE "filterTouchesWhenObscured|FLAG_OBSCURED"; then
        findings+=("tapjacking_evasion")
        ((score += 40))
        log_warning "Tapjacking protection bypass attempt"
    fi
    
    if [ ${#findings[@]} -gt 0 ]; then
        {
            echo "═══════════════════════════════════════════════"
            echo "SCREEN OVERLAY ATTACK ANALYSIS"
            echo "═══════════════════════════════════════════════"
            echo "Timestamp: $(date -Iseconds)"
            echo "Threat Score: $score"
            echo ""
            echo "Findings:"
            for finding in "${findings[@]}"; do
                echo "  - $finding"
            done
            echo ""
            echo "MITRE ATT&CK: T1411 - Input Injection"
        } >> "$report"
        
        if [ $score -ge 30 ]; then
            log_threat $((score / 2)) "Screen overlay attack indicators detected"
            record_ioc "overlay_attack" "${findings[0]}" "T1411"
        fi
    fi
}

# Accessibility Service Abuse Detection
analyze_accessibility_abuse() {
    set +u
    local content="${1:-}"
    set -u
    local report="${OUTPUT_DIR}/accessibility_abuse_analysis.txt"
    
    log_info "Analyzing for accessibility service abuse..."
    
    local findings=()
    local score=0
    
    # Check for accessibility abuse patterns
    for pattern in "${ACCESSIBILITY_ABUSE_PATTERNS[@]}"; do
        if echo "$content" | safe_grep_qiE "$pattern"; then
            local matched=$(echo "$content" | safe_grep_oiE "$pattern" 2>/dev/null | head -1)
            findings+=("accessibility:$matched")
            ((score += 25))
        fi
    done
    
    # Check for BIND_ACCESSIBILITY_SERVICE permission
    if echo "$content" | safe_grep_qiE "BIND_ACCESSIBILITY_SERVICE"; then
        findings+=("accessibility_binding")
        ((score += 30))
        log_warning "Accessibility service binding detected"
    fi
    
    # Check for keylogging via accessibility
    if echo "$content" | safe_grep_qiE "AccessibilityEvent.*TYPE_VIEW_TEXT_CHANGED|getText.*EditText"; then
        findings+=("accessibility_keylogger")
        ((score += 55))
        log_critical "Keylogging via accessibility service detected"
    fi
    
    # Check for auto-click fraud
    if echo "$content" | safe_grep_qiE "performAction.*ACTION_CLICK|performGlobalAction"; then
        findings+=("auto_click_fraud")
        ((score += 40))
        log_warning "Auto-click via accessibility detected"
    fi
    
    if [ ${#findings[@]} -gt 0 ]; then
        {
            echo "═══════════════════════════════════════════════"
            echo "ACCESSIBILITY SERVICE ABUSE ANALYSIS"
            echo "═══════════════════════════════════════════════"
            echo "Timestamp: $(date -Iseconds)"
            echo "Threat Score: $score"
            echo ""
            echo "Findings:"
            for finding in "${findings[@]}"; do
                echo "  - $finding"
            done
            echo ""
            echo "MITRE ATT&CK: T1453 - Abuse Accessibility Features"
        } >> "$report"
        
        if [ $score -ge 25 ]; then
            log_threat $((score / 2)) "Accessibility service abuse detected"
            record_ioc "accessibility_abuse" "${findings[0]}" "T1453"
        fi
    fi
}

# MDM Enrollment Attack Detection
analyze_mdm_enrollment() {
    set +u
    local content="${1:-}"
    set -u
    local report="${OUTPUT_DIR}/mdm_enrollment_analysis.txt"
    
    log_info "Analyzing for malicious MDM enrollment..."
    
    local findings=()
    local score=0
    
    # Check for MDM enrollment patterns
    for pattern in "${MDM_ENROLLMENT_PATTERNS[@]}"; do
        if echo "$content" | safe_grep_qiE "$pattern"; then
            local matched=$(echo "$content" | safe_grep_oiE "$pattern" 2>/dev/null | head -1)
            findings+=("mdm:$matched")
            ((score += 30))
        fi
    done
    
    # Check for MDM URL in QR
    if echo "$content" | safe_grep_qiE "https?://.*\.(mobileconfig|plist)($|\?)"; then
        findings+=("mdm_profile_url")
        ((score += 45))
        log_critical "MDM profile download URL detected"
    fi
    
    # Check for PayloadRemovalDisallowed (cannot uninstall)
    if echo "$content" | safe_grep_qiE "PayloadRemovalDisallowed.*true|RemovalPassword"; then
        findings+=("locked_profile")
        ((score += 50))
        log_critical "Locked MDM profile - cannot be removed!"
    fi
    
    # Check for dangerous MDM capabilities
    if echo "$content" | safe_grep_qiE "AllowCamera.*false|AllowScreenShot.*false|AllowPasscodeModification.*false"; then
        findings+=("restrictive_mdm")
        ((score += 40))
        log_warning "Highly restrictive MDM profile"
    fi
    
    # Check for certificate installation
    if echo "$content" | safe_grep_qiE "PayloadContent.*Certificate|com\.apple\.security\.root|com\.apple\.security\.pkcs12"; then
        findings+=("certificate_install")
        ((score += 45))
        log_critical "Root certificate installation in MDM profile"
    fi
    
    if [ ${#findings[@]} -gt 0 ]; then
        {
            echo "═══════════════════════════════════════════════"
            echo "MDM ENROLLMENT ATTACK ANALYSIS"
            echo "═══════════════════════════════════════════════"
            echo "Timestamp: $(date -Iseconds)"
            echo "Threat Score: $score"
            echo ""
            echo "Findings:"
            for finding in "${findings[@]}"; do
                echo "  - $finding"
            done
            echo ""
            echo "MITRE ATT&CK: T1406 - Obfuscated Files or Information"
            echo "                T1444 - Masquerade as Legitimate Application"
        } >> "$report"
        
        if [ $score -ge 30 ]; then
            log_threat $((score / 2)) "Malicious MDM enrollment detected"
            record_ioc "mdm_attack" "${findings[0]}" "T1406"
        fi
    fi
}

# eSIM QR Provisioning Attack Detection
analyze_esim_attacks() {
    set +u
    local content="${1:-}"
    set -u
    local report="${OUTPUT_DIR}/esim_attack_analysis.txt"
    
    log_info "Analyzing for eSIM provisioning attacks..."
    
    local findings=()
    local score=0
    
    # Check for eSIM patterns
    for pattern in "${ESIM_ATTACK_PATTERNS[@]}"; do
        if echo "$content" | safe_grep_qiE "$pattern"; then
            local matched=$(echo "$content" | safe_grep_oiE "$pattern" 2>/dev/null | head -1)
            findings+=("esim:$matched")
            ((score += 25))
        fi
    done
    
    # Check for LPA activation code format
    if echo "$content" | safe_grep_qE "LPA:1\\\$[a-zA-Z0-9.-]+\\\$[A-Z0-9-]+"; then
        findings+=("esim_activation_code")
        ((score += 35))
        log_warning "eSIM activation code detected"
        
        # Extract SM-DP+ address for verification
        local smdp=$(echo "$content" | safe_grep_oE "LPA:1\\\$[a-zA-Z0-9.-]+" | head -1 | cut -d'$' -f2)
        if [ -n "$smdp" ]; then
            findings+=("smdp_address:$smdp")
            
            # Check for known malicious SM-DP+ servers
            if echo "$smdp" | grep -qivE "apple\.com|google\.com|t-mobile\.com|att\.com|verizon\.com"; then
                ((score += 30))
                log_warning "Unknown SM-DP+ server: $smdp"
            fi
        fi
    fi
    
    # Check for SIM swap indicators
    if echo "$content" | safe_grep_qiE "sim.*swap|transfer.*number|port.*number|carrier.*switch"; then
        findings+=("sim_swap_indicator")
        ((score += 50))
        log_critical "Potential SIM swap attack indicator"
    fi
    
    if [ ${#findings[@]} -gt 0 ]; then
        {
            echo "═══════════════════════════════════════════════"
            echo "eSIM PROVISIONING ATTACK ANALYSIS"
            echo "═══════════════════════════════════════════════"
            echo "Timestamp: $(date -Iseconds)"
            echo "Threat Score: $score"
            echo ""
            echo "Findings:"
            for finding in "${findings[@]}"; do
                echo "  - $finding"
            done
            echo ""
            echo "MITRE ATT&CK: T1451 - SIM Card Swap"
        } >> "$report"
        
        if [ $score -ge 25 ]; then
            log_threat $((score / 2)) "eSIM attack indicators detected"
            record_ioc "esim_attack" "${findings[0]}" "T1451"
        fi
    fi
}

################################################################################
# AUTHENTICATION & IDENTITY ATTACK ANALYSIS MODULES
################################################################################

# OAuth Consent Phishing Detection
analyze_oauth_phishing() {
    set +u
    local content="${1:-}"
    set -u
    local report="${OUTPUT_DIR}/oauth_phishing_analysis.txt"
    
    log_info "Analyzing for OAuth consent phishing..."
    
    local findings=()
    local score=0
    
    # OAuth phishing patterns
    local oauth_phishing_patterns=(
        "consent.*screen"
        "grant.*access"
        "authorize.*application"
        "allow.*permission"
        "approve.*request"
        "client_id=.*&scope=.*(&redirect_uri=)?"
        "oauth.*popup"
        "oauth.*iframe"
    )
    
    for pattern in "${oauth_phishing_patterns[@]}"; do
        if echo "$content" | safe_grep_qiE "$pattern"; then
            local matched=$(echo "$content" | safe_grep_oiE "$pattern" 2>/dev/null | head -1)
            findings+=("oauth_phish:$matched")
            ((score += 30))
        fi
    done
    
    # Check for suspicious scopes
    if echo "$content" | safe_grep_qiE "scope=.*(mail|drive|contacts|calendar|admin|all)"; then
        findings+=("broad_scope_request")
        ((score += 40))
        log_warning "OAuth requesting broad permissions"
    fi
    
    # Check for malicious redirect URIs
    if echo "$content" | safe_grep_qiE "redirect_uri=https?://[^/]*@|redirect_uri=.*localhost|redirect_uri=.*127\.0\.0\.1"; then
        findings+=("suspicious_redirect_uri")
        ((score += 45))
        log_critical "Suspicious OAuth redirect URI"
    fi
    
    # Check for illicit consent grant attack
    if echo "$content" | safe_grep_qiE "prompt=consent.*force|response_type=.*token.*&.*state="; then
        findings+=("consent_grant_attack")
        ((score += 50))
        log_critical "Potential illicit consent grant attack"
    fi
    
    if [ ${#findings[@]} -gt 0 ]; then
        {
            echo "═══════════════════════════════════════════════"
            echo "OAUTH CONSENT PHISHING ANALYSIS"
            echo "═══════════════════════════════════════════════"
            echo "Timestamp: $(date -Iseconds)"
            echo "Threat Score: $score"
            echo ""
            echo "Findings:"
            for finding in "${findings[@]}"; do
                echo "  - $finding"
            done
            echo ""
            echo "MITRE ATT&CK: T1550.001 - Application Access Token"
        } >> "$report"
        
        if [ $score -ge 30 ]; then
            log_threat $((score / 2)) "OAuth phishing detected"
            record_ioc "oauth_phishing" "${findings[0]}" "T1550.001"
        fi
    fi
}

# Device Code Flow Phishing Detection
analyze_device_code_phishing() {
    set +u
    local content="${1:-}"
    set -u
    local report="${OUTPUT_DIR}/device_code_phishing_analysis.txt"
    
    log_info "Analyzing for device code flow phishing..."
    
    local findings=()
    local score=0
    
    # Check for device code patterns
    for pattern in "${DEVICE_CODE_PHISHING_PATTERNS[@]}"; do
        if echo "$content" | safe_grep_qiE "$pattern"; then
            local matched=$(echo "$content" | safe_grep_oiE "$pattern" 2>/dev/null | head -1)
            findings+=("device_code:$matched")
            ((score += 30))
        fi
    done
    
    # Check for Microsoft device login URL
    if echo "$content" | safe_grep_qiE "microsoft\.com/devicelogin|aka\.ms/devicelogin"; then
        findings+=("microsoft_device_login")
        ((score += 35))
        log_warning "Microsoft device login URL detected"
        
        # Check if combined with a user code
        if echo "$content" | safe_grep_qiE "[A-Z0-9]{8,9}"; then
            findings+=("user_code_present")
            ((score += 25))
            log_warning "Device code appears to include user code"
        fi
    fi
    
    # Check for device code phishing social engineering
    if echo "$content" | safe_grep_qiE "enter.*code.*microsoft|sign.*in.*device.*code|activate.*your.*device"; then
        findings+=("device_code_social_engineering")
        ((score += 45))
        log_critical "Device code phishing social engineering detected"
    fi
    
    if [ ${#findings[@]} -gt 0 ]; then
        {
            echo "═══════════════════════════════════════════════"
            echo "DEVICE CODE PHISHING ANALYSIS"
            echo "═══════════════════════════════════════════════"
            echo "Timestamp: $(date -Iseconds)"
            echo "Threat Score: $score"
            echo ""
            echo "Findings:"
            for finding in "${findings[@]}"; do
                echo "  - $finding"
            done
            echo ""
            echo "MITRE ATT&CK: T1566.002 - Spearphishing Link"
            echo "              T1078.004 - Cloud Accounts"
        } >> "$report"
        
        if [ $score -ge 30 ]; then
            log_threat $((score / 2)) "Device code phishing detected"
            record_ioc "device_code_phishing" "${findings[0]}" "T1566.002"
        fi
    fi
}

# MFA Fatigue/Bombing Attack Detection
analyze_mfa_fatigue() {
    set +u
    local content="${1:-}"
    set -u
    local report="${OUTPUT_DIR}/mfa_fatigue_analysis.txt"
    
    log_info "Analyzing for MFA fatigue attack indicators..."
    
    local findings=()
    local score=0
    
    # Check for MFA fatigue patterns
    for pattern in "${MFA_FATIGUE_PATTERNS[@]}"; do
        if echo "$content" | safe_grep_qiE "$pattern"; then
            local matched=$(echo "$content" | safe_grep_oiE "$pattern" 2>/dev/null | head -1)
            findings+=("mfa_fatigue:$matched")
            ((score += 25))
        fi
    done
    
    # Check for push approval patterns
    if echo "$content" | safe_grep_qiE "approve.*login|tap.*approve|confirm.*sign.*in"; then
        findings+=("push_approval_prompt")
        ((score += 30))
        log_warning "MFA push approval pattern detected"
    fi
    
    # Check for urgency indicators
    if echo "$content" | safe_grep_qiE "urgent.*approve|security.*alert.*approve|immediate.*action.*verify"; then
        findings+=("urgency_social_engineering")
        ((score += 40))
        log_critical "MFA fatigue with urgency social engineering"
    fi
    
    if [ ${#findings[@]} -gt 0 ]; then
        {
            echo "═══════════════════════════════════════════════"
            echo "MFA FATIGUE ATTACK ANALYSIS"
            echo "═══════════════════════════════════════════════"
            echo "Timestamp: $(date -Iseconds)"
            echo "Threat Score: $score"
            echo ""
            echo "Findings:"
            for finding in "${findings[@]}"; do
                echo "  - $finding"
            done
            echo ""
            echo "MITRE ATT&CK: T1621 - Multi-Factor Authentication Request Generation"
        } >> "$report"
        
        if [ $score -ge 25 ]; then
            log_threat $((score / 2)) "MFA fatigue attack indicators detected"
            record_ioc "mfa_fatigue" "${findings[0]}" "T1621"
        fi
    fi
}

# WebAuthn/Passkey Phishing Detection
analyze_passkey_phishing() {
    set +u
    local content="${1:-}"
    set -u
    local report="${OUTPUT_DIR}/passkey_phishing_analysis.txt"
    
    log_info "Analyzing for WebAuthn/Passkey phishing..."
    
    local findings=()
    local score=0
    
    # Check for passkey phishing patterns
    for pattern in "${PASSKEY_PHISHING_PATTERNS[@]}"; do
        if echo "$content" | safe_grep_qiE "$pattern"; then
            local matched=$(echo "$content" | safe_grep_oiE "$pattern" 2>/dev/null | head -1)
            findings+=("passkey:$matched")
            ((score += 25))
        fi
    done
    
    # Check for WebAuthn credential creation/get
    if echo "$content" | safe_grep_qiE "navigator\.credentials\.(create|get)"; then
        findings+=("webauthn_api")
        ((score += 20))
    fi
    
    # Check for real-time phishing proxies
    if echo "$content" | safe_grep_qiE "evilginx|modlishka|muraena|evilnovnc"; then
        findings+=("realtime_phishing_proxy")
        ((score += 60))
        log_critical "Real-time phishing proxy detected (passkey theft)"
    fi
    
    # Check for FIDO2/CTAP indicators with suspicious context
    if echo "$content" | safe_grep_qiE "fido2.*login|ctap2.*auth|passkey.*verify" && \
       echo "$content" | safe_grep_qiE "urgent|immediately|verify.*now"; then
        findings+=("passkey_phishing_social_eng")
        ((score += 45))
        log_critical "Passkey phishing with social engineering"
    fi
    
    if [ ${#findings[@]} -gt 0 ]; then
        {
            echo "═══════════════════════════════════════════════"
            echo "WEBAUTHN/PASSKEY PHISHING ANALYSIS"
            echo "═══════════════════════════════════════════════"
            echo "Timestamp: $(date -Iseconds)"
            echo "Threat Score: $score"
            echo ""
            echo "Findings:"
            for finding in "${findings[@]}"; do
                echo "  - $finding"
            done
            echo ""
            echo "MITRE ATT&CK: T1556 - Modify Authentication Process"
        } >> "$report"
        
        if [ $score -ge 25 ]; then
            log_threat $((score / 2)) "Passkey phishing detected"
            record_ioc "passkey_phishing" "${findings[0]}" "T1556"
        fi
    fi
}

# Session Fixation Attack Detection
analyze_session_fixation() {
    set +u
    local content="${1:-}"
    set -u
    local report="${OUTPUT_DIR}/session_fixation_analysis.txt"
    
    log_info "Analyzing for session fixation attacks..."
    
    local findings=()
    local score=0
    
    # Check for session fixation patterns
    for pattern in "${SESSION_FIXATION_PATTERNS[@]}"; do
        if echo "$content" | safe_grep_qiE "$pattern"; then
            local matched=$(echo "$content" | safe_grep_oiE "$pattern" 2>/dev/null | head -1)
            findings+=("session:$matched")
            ((score += 25))
        fi
    done
    
    # Check for preset session IDs in URL
    if echo "$content" | safe_grep_qiE "(JSESSIONID|PHPSESSID|session_id|sid)=[a-zA-Z0-9]{20,}"; then
        findings+=("preset_session_id")
        ((score += 45))
        log_critical "Preset session ID in URL - session fixation!"
    fi
    
    # Check for session ID in query string with login
    if echo "$content" | safe_grep_qiE "login.*session|signin.*sid=|auth.*JSESSIONID"; then
        findings+=("session_with_auth")
        ((score += 40))
        log_warning "Session ID combined with authentication URL"
    fi
    
    if [ ${#findings[@]} -gt 0 ]; then
        {
            echo "═══════════════════════════════════════════════"
            echo "SESSION FIXATION ANALYSIS"
            echo "═══════════════════════════════════════════════"
            echo "Timestamp: $(date -Iseconds)"
            echo "Threat Score: $score"
            echo ""
            echo "Findings:"
            for finding in "${findings[@]}"; do
                echo "  - $finding"
            done
            echo ""
            echo "MITRE ATT&CK: T1539 - Steal Web Session Cookie"
        } >> "$report"
        
        if [ $score -ge 25 ]; then
            log_threat $((score / 2)) "Session fixation attack detected"
            record_ioc "session_fixation" "${findings[0]}" "T1539"
        fi
    fi
}

# SSO Token Relay Attack Detection
analyze_sso_relay() {
    set +u
    local content="${1:-}"
    set -u
    local report="${OUTPUT_DIR}/sso_relay_analysis.txt"
    
    log_info "Analyzing for SSO token relay attacks..."
    
    local findings=()
    local score=0
    
    # Check for SSO relay patterns
    for pattern in "${SSO_RELAY_PATTERNS[@]}"; do
        if echo "$content" | safe_grep_qiE "$pattern"; then
            local matched=$(echo "$content" | safe_grep_oiE "$pattern" 2>/dev/null | head -1)
            findings+=("sso_relay:$matched")
            ((score += 30))
        fi
    done
    
    # Check for real-time phishing frameworks
    if echo "$content" | safe_grep_qiE "evilginx|modlishka|gophish|muraena|evilnovnc"; then
        findings+=("phishing_framework")
        ((score += 55))
        log_critical "Real-time phishing framework detected"
    fi
    
    # Check for ADFS/Azure AD endpoints
    if echo "$content" | safe_grep_qiE "adfs/.*token|login\.microsoftonline\.com.*token|login\.windows\.net.*oauth"; then
        findings+=("azure_sso_endpoint")
        ((score += 25))
        
        # Check if combined with suspicious patterns
        if echo "$content" | safe_grep_qiE "proxy|relay|forward|intercept"; then
            findings+=("sso_interception")
            ((score += 40))
            log_critical "SSO token interception pattern"
        fi
    fi
    
    if [ ${#findings[@]} -gt 0 ]; then
        {
            echo "═══════════════════════════════════════════════"
            echo "SSO TOKEN RELAY ANALYSIS"
            echo "═══════════════════════════════════════════════"
            echo "Timestamp: $(date -Iseconds)"
            echo "Threat Score: $score"
            echo ""
            echo "Findings:"
            for finding in "${findings[@]}"; do
                echo "  - $finding"
            done
            echo ""
            echo "MITRE ATT&CK: T1557 - Adversary-in-the-Middle"
        } >> "$report"
        
        if [ $score -ge 30 ]; then
            log_threat $((score / 2)) "SSO relay attack detected"
            record_ioc "sso_relay" "${findings[0]}" "T1557"
        fi
    fi
}

# Kerberos Attack Detection
analyze_kerberos_abuse() {
    set +u
    local content="${1:-}"
    set -u
    local report="${OUTPUT_DIR}/kerberos_abuse_analysis.txt"
    
    log_info "Analyzing for Kerberos attack indicators..."
    
    local findings=()
    local score=0
    
    # Check for Kerberos abuse patterns
    for pattern in "${KERBEROS_ABUSE_PATTERNS[@]}"; do
        if echo "$content" | safe_grep_qiE "$pattern"; then
            local matched=$(echo "$content" | safe_grep_oiE "$pattern" 2>/dev/null | head -1)
            findings+=("kerberos:$matched")
            ((score += 35))
        fi
    done
    
    # Check for Kerberoasting
    if echo "$content" | safe_grep_qiE "kerberoast|GetUserSPNs|servicePrincipalName"; then
        findings+=("kerberoasting")
        ((score += 50))
        log_critical "Kerberoasting indicator detected"
    fi
    
    # Check for Golden/Silver ticket
    if echo "$content" | safe_grep_qiE "golden.*ticket|silver.*ticket|krbtgt"; then
        findings+=("ticket_attack")
        ((score += 60))
        log_critical "Golden/Silver ticket attack indicator"
    fi
    
    # Check for AS-REP roasting
    if echo "$content" | safe_grep_qiE "asreproast|DONT_REQ_PREAUTH|AS-REP"; then
        findings+=("asrep_roasting")
        ((score += 45))
        log_warning "AS-REP roasting indicator"
    fi
    
    if [ ${#findings[@]} -gt 0 ]; then
        {
            echo "═══════════════════════════════════════════════"
            echo "KERBEROS ABUSE ANALYSIS"
            echo "═══════════════════════════════════════════════"
            echo "Timestamp: $(date -Iseconds)"
            echo "Threat Score: $score"
            echo ""
            echo "Findings:"
            for finding in "${findings[@]}"; do
                echo "  - $finding"
            done
            echo ""
            echo "MITRE ATT&CK: T1558 - Steal or Forge Kerberos Tickets"
        } >> "$report"
        
        if [ $score -ge 35 ]; then
            log_threat $((score / 2)) "Kerberos abuse detected"
            record_ioc "kerberos_abuse" "${findings[0]}" "T1558"
        fi
    fi
}

################################################################################
# FORENSIC ANALYSIS MODULES
################################################################################

# Timestamp Anomaly Detection
analyze_timestamp_anomalies() {
    set +u
    local image="${1:-}"
    set -u
    local report="${OUTPUT_DIR}/timestamp_anomaly_analysis.txt"
    
    log_info "Analyzing for timestamp anomalies..."
    
    local findings=()
    local score=0
    
    if ! command -v exiftool &> /dev/null; then
        log_warning "exiftool not available for timestamp analysis"
        return
    fi
    
    # Extract timestamps
    local exif_data=$(exiftool -j "$image" 2>/dev/null)
    
    if [ -n "$exif_data" ]; then
        # Check for suspicious default dates
        for pattern in "${TIMESTAMP_ANOMALY_PATTERNS[@]}"; do
            if echo "$exif_data" | grep -qiE "$pattern"; then
                findings+=("timestamp_pattern:$pattern")
                ((score += 15))
            fi
        done
        
        # Check for 1970/1980/2000 epoch dates
        if echo "$exif_data" | grep -qE "1970:01:01|1980:01:01|2000:01:01"; then
            findings+=("epoch_date_anomaly")
            ((score += 35))
            log_warning "Suspicious epoch date detected"
        fi
        
        # Check for future dates
        local current_year=$(date +%Y)
        if echo "$exif_data" | grep -qE "20[3-9][0-9]:|2[1-9][0-9][0-9]:"; then
            findings+=("future_date")
            ((score += 40))
            log_warning "Future date in metadata"
        fi
        
        # Check for inconsistent dates (CreateDate != ModifyDate significantly)
        local create_date=$(echo "$exif_data" | grep -oE "CreateDate.*[0-9]{4}:[0-9]{2}:[0-9]{2}" | head -1)
        local modify_date=$(echo "$exif_data" | grep -oE "ModifyDate.*[0-9]{4}:[0-9]{2}:[0-9]{2}" | head -1)
        
        if [ -n "$create_date" ] && [ -n "$modify_date" ] && [ "$create_date" != "$modify_date" ]; then
            findings+=("date_inconsistency:$create_date vs $modify_date")
            ((score += 25))
        fi
    fi
    
    if [ ${#findings[@]} -gt 0 ]; then
        {
            echo "═══════════════════════════════════════════════"
            echo "TIMESTAMP ANOMALY ANALYSIS"
            echo "═══════════════════════════════════════════════"
            echo "Timestamp: $(date -Iseconds)"
            echo "Forensic Score: $score"
            echo ""
            echo "Findings:"
            for finding in "${findings[@]}"; do
                echo "  - $finding"
            done
        } >> "$report"
        
        if [ $score -ge 25 ]; then
            log_forensic "Timestamp anomalies detected (score: $score)"
        fi
    fi
}

# Camera Sensor Fingerprinting
analyze_camera_fingerprint() {
    set +u
    local image="${1:-}"
    set -u
    local report="${OUTPUT_DIR}/camera_fingerprint_analysis.txt"
    
    log_info "Analyzing camera sensor fingerprint..."
    
    local findings=()
    local score=0
    
    if ! command -v exiftool &> /dev/null; then
        log_warning "exiftool not available for camera fingerprinting"
        return
    fi
    
    # Extract camera metadata
    local exif_data=$(exiftool -j "$image" 2>/dev/null)
    
    if [ -n "$exif_data" ]; then
        # Check for camera identification
        for pattern in "${CAMERA_FINGERPRINT_PATTERNS[@]}"; do
            if echo "$exif_data" | grep -qiE "\"$pattern\""; then
                local value=$(echo "$exif_data" | grep -oE "\"$pattern\"[^,}]+" | head -1)
                findings+=("camera_meta:$value")
                ((score += 10))
            fi
        done
        
        # Check for serial number exposure
        if echo "$exif_data" | grep -qiE "SerialNumber|ImageUniqueID"; then
            findings+=("device_identifier_exposed")
            ((score += 30))
            log_warning "Device identifier exposed in metadata"
        fi
        
        # Check for GPS data
        if echo "$exif_data" | grep -qiE "GPS.*Latitude|GPS.*Longitude"; then
            findings+=("gps_data_present")
            ((score += 25))
            log_warning "GPS coordinates in image metadata"
        fi
    fi
    
    if [ ${#findings[@]} -gt 0 ]; then
        {
            echo "═══════════════════════════════════════════════"
            echo "CAMERA FINGERPRINT ANALYSIS"
            echo "═══════════════════════════════════════════════"
            echo "Timestamp: $(date -Iseconds)"
            echo ""
            echo "Device Identifiers:"
            for finding in "${findings[@]}"; do
                echo "  - $finding"
            done
        } >> "$report"
    fi
}

# Machine Identification Code (Printer Dots) Detection
analyze_printer_dots() {
    set +u
    local image="${1:-}"
    set -u
    local report="${OUTPUT_DIR}/printer_dots_analysis.txt"
    
    log_info "Analyzing for Machine Identification Codes (printer dots)..."
    
    local findings=()
    local score=0
    
    # Check file type
    local file_type=$(file -b "$image" 2>/dev/null)
    
    # Printer dots typically in scanned documents
    if echo "$file_type" | grep -qiE "PDF|TIFF|JPEG"; then
        findings+=("printable_format:$file_type")
        
        # Check for printer metadata
        if command -v exiftool &> /dev/null; then
            local exif_data=$(exiftool -j "$image" 2>/dev/null)
            
            for pattern in "${PRINTER_DOTS_PATTERNS[@]}"; do
                if echo "$exif_data" | grep -qiE "$pattern"; then
                    findings+=("printer_meta:$pattern")
                    ((score += 20))
                fi
            done
            
            # Check for scanner/printer software
            if echo "$exif_data" | grep -qiE "Scanner|Printer|Xerox|Canon|HP|Epson|Brother"; then
                findings+=("printer_device_identified")
                ((score += 25))
                log_info "Printer/scanner device identified in metadata"
            fi
        fi
    fi
    
    if [ ${#findings[@]} -gt 0 ]; then
        {
            echo "═══════════════════════════════════════════════"
            echo "MACHINE IDENTIFICATION CODE ANALYSIS"
            echo "═══════════════════════════════════════════════"
            echo "Timestamp: $(date -Iseconds)"
            echo ""
            echo "Findings:"
            for finding in "${findings[@]}"; do
                echo "  - $finding"
            done
        } >> "$report"
    fi
}

# Screenshot Artifact Detection
analyze_screenshot_artifacts() {
    set +u
    local image="${1:-}"
    set -u
    local report="${OUTPUT_DIR}/screenshot_artifact_analysis.txt"
    
    log_info "Analyzing for screenshot artifacts..."
    
    local findings=()
    local score=0
    
    if command -v exiftool &> /dev/null; then
        local exif_data=$(exiftool -j "$image" 2>/dev/null)
        
        # Check for screenshot indicators
        for pattern in "${SCREENSHOT_ARTIFACT_PATTERNS[@]}"; do
            if echo "$exif_data" | grep -qiE "$pattern"; then
                findings+=("screenshot_indicator:$pattern")
                ((score += 15))
            fi
        done
        
        # Check for screen capture software
        if echo "$exif_data" | grep -qiE "Snipping|Screenshot|Grab|Capture|ShareX|Greenshot|Lightshot"; then
            findings+=("screenshot_software")
            ((score += 20))
            log_info "Screenshot software identified"
        fi
        
        # Check for system screenshot (no camera info but has dimensions)
        local has_camera=$(echo "$exif_data" | grep -c "Make\|Model\|LensModel")
        local has_dimensions=$(echo "$exif_data" | grep -c "ImageWidth\|ImageHeight")
        
        if [ "$has_camera" -eq 0 ] && [ "$has_dimensions" -gt 0 ]; then
            findings+=("likely_screenshot")
            ((score += 25))
        fi
    fi
    
    # Check for common screen resolutions
    if command -v identify &> /dev/null; then
        local dimensions=$(identify -format "%wx%h" "$image" 2>/dev/null)
        case "$dimensions" in
            "1920x1080"|"2560x1440"|"3840x2160"|"1366x768"|"1440x900"|"2880x1800")
                findings+=("common_screen_resolution:$dimensions")
                ((score += 15))
                ;;
        esac
    fi
    
    if [ ${#findings[@]} -gt 0 ]; then
        {
            echo "═══════════════════════════════════════════════"
            echo "SCREENSHOT ARTIFACT ANALYSIS"
            echo "═══════════════════════════════════════════════"
            echo "Timestamp: $(date -Iseconds)"
            echo ""
            echo "Findings:"
            for finding in "${findings[@]}"; do
                echo "  - $finding"
            done
        } >> "$report"
    fi
}

# Compression Artifact Detection
analyze_compression_artifacts() {
    set +u
    local image="${1:-}"
    set -u
    local report="${OUTPUT_DIR}/compression_artifact_analysis.txt"
    
    log_info "Analyzing for compression/recompression artifacts..."
    
    local findings=()
    local score=0
    
    if command -v exiftool &> /dev/null; then
        local exif_data=$(exiftool -j "$image" 2>/dev/null)
        
        # Check for quality settings
        for pattern in "${COMPRESSION_ARTIFACT_PATTERNS[@]}"; do
            if echo "$exif_data" | grep -qiE "$pattern"; then
                findings+=("compression_indicator:$pattern")
                ((score += 10))
            fi
        done
        
        # Check JPEG quality
        local quality=$(echo "$exif_data" | grep -oE "Quality.*[0-9]+" | head -1)
        if [ -n "$quality" ]; then
            findings+=("jpeg_quality:$quality")
            
            # Low quality might indicate multiple saves
            if echo "$quality" | grep -qE "[0-6][0-9]$"; then
                findings+=("low_quality_indicator")
                ((score += 20))
            fi
        fi
        
        # Check for edit history
        if echo "$exif_data" | grep -qiE "HistoryAction|HistoryParameters|XMPToolkit"; then
            findings+=("edit_history_present")
            ((score += 25))
            log_info "Edit history detected in metadata"
        fi
    fi
    
    if [ ${#findings[@]} -gt 0 ]; then
        {
            echo "═══════════════════════════════════════════════"
            echo "COMPRESSION ARTIFACT ANALYSIS"
            echo "═══════════════════════════════════════════════"
            echo "Timestamp: $(date -Iseconds)"
            echo ""
            echo "Findings:"
            for finding in "${findings[@]}"; do
                echo "  - $finding"
            done
        } >> "$report"
    fi
}

# Image Cropping History Analysis
analyze_crop_history() {
    set +u
    local image="${1:-}"
    set -u
    local report="${OUTPUT_DIR}/crop_history_analysis.txt"
    
    log_info "Analyzing for image cropping history..."
    
    local findings=()
    local score=0
    
    if command -v exiftool &> /dev/null; then
        local exif_data=$(exiftool -j "$image" 2>/dev/null)
        
        # Check for crop-related metadata
        if echo "$exif_data" | grep -qiE "CropLeft|CropTop|CropRight|CropBottom|CroppedAreaImage"; then
            findings+=("crop_metadata_present")
            ((score += 20))
        fi
        
        # Check for original dimensions vs current
        local orig_width=$(echo "$exif_data" | grep -oE "ExifImageWidth.*[0-9]+" | head -1)
        local orig_height=$(echo "$exif_data" | grep -oE "ExifImageHeight.*[0-9]+" | head -1)
        
        if [ -n "$orig_width" ] && [ -n "$orig_height" ]; then
            findings+=("original_dimensions:${orig_width}x${orig_height}")
        fi
        
        # Check for Photoshop/editing software crop history
        if echo "$exif_data" | grep -qiE "Photoshop|GIMP|Lightroom|HistoryAction.*Crop"; then
            findings+=("editing_software_crop")
            ((score += 15))
        fi
    fi
    
    if [ ${#findings[@]} -gt 0 ]; then
        {
            echo "═══════════════════════════════════════════════"
            echo "CROP HISTORY ANALYSIS"
            echo "═══════════════════════════════════════════════"
            echo "Timestamp: $(date -Iseconds)"
            echo ""
            echo "Findings:"
            for finding in "${findings[@]}"; do
                echo "  - $finding"
            done
        } >> "$report"
    fi
}

# AI-Generated Image Detection
analyze_ai_generated_images() {
    set +u
    local image="${1:-}"
    set -u
    local report="${OUTPUT_DIR}/ai_generated_analysis.txt"
    
    log_info "Analyzing for AI-generated image indicators..."
    
    local findings=()
    local score=0
    
    if command -v exiftool &> /dev/null; then
        local exif_data=$(exiftool -j "$image" 2>/dev/null)
        
        # Check for AI generator signatures
        for pattern in "${AI_GENERATED_PATTERNS[@]}"; do
            if echo "$exif_data" | grep -qiE "$pattern"; then
                findings+=("ai_indicator:$pattern")
                ((score += 30))
            fi
        done
        
        # Check for C2PA/Content Credentials
        if echo "$exif_data" | grep -qiE "C2PA|ContentCredentials|Coalition.*Provenance"; then
            findings+=("c2pa_credentials")
            ((score += 20))
            log_info "C2PA content credentials present"
        fi
        
        # Check for AI watermarks
        if echo "$exif_data" | grep -qiE "AI.*Generated|Synthetic|artificial.*intelligence|machine.*learning"; then
            findings+=("ai_watermark")
            ((score += 40))
            log_warning "AI generation watermark detected"
        fi
        
        # Check for missing camera EXIF (common in AI images)
        local has_camera=$(echo "$exif_data" | grep -c "Make\|Model\|LensModel\|FNumber\|ExposureTime")
        if [ "$has_camera" -eq 0 ]; then
            findings+=("no_camera_exif")
            ((score += 15))
        fi
    fi
    
    if [ ${#findings[@]} -gt 0 ]; then
        {
            echo "═══════════════════════════════════════════════"
            echo "AI-GENERATED IMAGE ANALYSIS"
            echo "═══════════════════════════════════════════════"
            echo "Timestamp: $(date -Iseconds)"
            echo "Synthetic Media Score: $score"
            echo ""
            echo "Findings:"
            for finding in "${findings[@]}"; do
                echo "  - $finding"
            done
        } >> "$report"
        
        if [ $score -ge 30 ]; then
            log_warning "AI-generated image indicators detected (score: $score)"
        fi
    fi
}

# Deepfake Indicator Detection
analyze_deepfake_indicators() {
    set +u
    local image="${1:-}"
    set -u
    local report="${OUTPUT_DIR}/deepfake_analysis.txt"
    
    log_info "Analyzing for deepfake indicators..."
    
    local findings=()
    local score=0
    
    if command -v exiftool &> /dev/null; then
        local exif_data=$(exiftool -j "$image" 2>/dev/null)
        
        # Check for deepfake indicators in metadata
        for pattern in "${DEEPFAKE_INDICATOR_PATTERNS[@]}"; do
            if echo "$exif_data" | grep -qiE "$pattern"; then
                findings+=("deepfake_indicator:$pattern")
                ((score += 25))
            fi
        done
        
        # Check for face manipulation software
        if echo "$exif_data" | grep -qiE "FaceApp|DeepFaceLab|FaceSwap|Reface|Wombo"; then
            findings+=("face_manipulation_software")
            ((score += 50))
            log_critical "Face manipulation software detected"
        fi
        
        # Check for video frame extraction
        if echo "$exif_data" | grep -qiE "Frame.*Extract|Video.*Still|FFmpeg"; then
            findings+=("video_frame_extraction")
            ((score += 20))
        fi
    fi
    
    # Check for QR overlay manipulation (deepfake QR replacement)
    # This is relevant because attackers might overlay fake QR codes on legitimate video
    if [ "$score" -gt 0 ]; then
        findings+=("potential_qr_overlay_attack")
        ((score += 15))
    fi
    
    if [ ${#findings[@]} -gt 0 ]; then
        {
            echo "═══════════════════════════════════════════════"
            echo "DEEPFAKE INDICATOR ANALYSIS"
            echo "═══════════════════════════════════════════════"
            echo "Timestamp: $(date -Iseconds)"
            echo "Deepfake Score: $score"
            echo ""
            echo "Findings:"
            for finding in "${findings[@]}"; do
                echo "  - $finding"
            done
            echo ""
            echo "WARNING: High scores indicate potential synthetic media manipulation"
        } >> "$report"
        
        if [ $score -ge 40 ]; then
            log_critical "Deepfake indicators detected (score: $score)"
            record_ioc "deepfake_indicator" "${findings[0]}" "Synthetic Media"
        fi
    fi
}

# Script injection detection
analyze_script_injection() {
    set +u
    local content="${1:-}"
    set -u
    
    log_info "Scanning for script injection..."
    
    local script_patterns=(
        "<script" "</script>" "javascript:" "onerror=" "onload="
        "onclick=" "onmouseover=" "eval\(" "document\.write"
        "innerHTML=" "\.src=" "data:text/html" "vbscript:"
    )
    
    for pattern in "${script_patterns[@]}"; do
        if echo "$content" | safe_grep_qiE "$pattern"; then
            log_threat 45 "Script injection pattern: $pattern"
        fi
    done
    
    if echo "$content" | safe_grep_qE "eval\(|Function\(.*\)"; then
        log_threat 40 "Potentially obfuscated JavaScript"
    fi
    
    if echo "$content" | safe_grep_qE "data:text/html|data:application"; then
        log_threat 35 "Data URI detected (payload embedding)"
    fi
}

# Steghide detection
detect_steghide() {
    local image="$1"
    local base_name="$2"
    
    if ! command -v steghide &> /dev/null; then
        return
    fi
    
    log_info "Running steghide analysis..."
    local steg_report="${EVIDENCE_DIR}/${base_name}_steghide.txt"
    
    steghide extract -sf "$image" -xf "${TEMP_DIR}/${base_name}_extracted.bin" -p "" 2>&1 | tee "$steg_report"
    
    if grep -q "extracted" "$steg_report"; then
        log_threat 60 "STEGANOGRAPHY DETECTED: Hidden data extracted"
    fi
}

# zsteg detection
detect_zsteg() {
    local image="$1"
    local base_name="$2"
    
    if ! command -v zsteg &> /dev/null; then
        return
    fi
    
    log_info "Running zsteg analysis (PNG)..."
    local zsteg_report="${EVIDENCE_DIR}/${base_name}_zsteg.txt"
    
    zsteg "$image" --all 2>/dev/null > "$zsteg_report"
    
    if [ -s "$zsteg_report" ] && grep -q "text" "$zsteg_report"; then
        log_threat 50 "STEGANOGRAPHY DETECTED: zsteg found hidden text"
    fi
}

# stegdetect analysis
detect_stegdetect() {
    local image="$1"
    local base_name="$2"
    
    if ! command -v stegdetect &> /dev/null; then
        return
    fi
    
    log_info "Running stegdetect analysis..."
    local stegdetect_report="${EVIDENCE_DIR}/${base_name}_stegdetect.txt"
    
    stegdetect "$image" 2>/dev/null > "$stegdetect_report"
    
    if [ -s "$stegdetect_report" ] && ! grep -q "negative" "$stegdetect_report"; then
        log_threat 55 "STEGANOGRAPHY DETECTED: stegdetect found indicators"
    fi
}

# Image entropy analysis
analyze_image_entropy() {
    set +u
    local image="${1:-}"
    local base_name="${2:-}"
    set -u
    
    log_info "Analyzing image entropy..."
    
    python3 2>/dev/null << EOF
try:
    import numpy as np
    from PIL import Image
    from collections import Counter
    import math

    img = Image.open(image_path)
    img_array = np.array(img)
    
    if len(img_array.shape) == 3:
        for i, channel in enumerate(['Red', 'Green', 'Blue']):
            channel_data = img_array[:,:,i].flatten()
            counter = Counter(channel_data)
            total = len(channel_data)
            entropy = -sum((count/total) * math.log2(count/total) for count in counter.values())
            print(f"  {channel} channel entropy: {entropy:.2f}")
            
            if entropy > 7.5:
                print(f"  [!] High entropy in {channel} - possible hidden data")
    else:
        flat_data = img_array.flatten()
        counter = Counter(flat_data)
        total = len(flat_data)
        entropy = -sum((count/total) * math.log2(count/total) for count in counter.values())
        print(f"  Grayscale entropy: {entropy:.2f}")
        
        if entropy > 7.5:
            print(f"  [!] High entropy - possible hidden data")
except Exception as e:
    print(f"  Error: {e}")
EOF
}

# Multiple QR code detection
detect_multiple_qr_codes() {
    local image="$1"
    
    log_info "Checking for multiple/split QR codes..."
    
    # AUDIT FIX: Wrap zbarimg with crash protection
    local temp_result=$(create_secure_temp_file "multi_qr") || return 1
    local num_codes=0
    if run_isolated_with_output 30 "$temp_result" zbarimg "$image"; then
        num_codes=$(grep -c "QR-Code" "$temp_result" 2>/dev/null || echo 0)
    fi
    rm -f "$temp_result" 2>/dev/null
    
    if [ "$num_codes" -gt 1 ]; then
        log_threat 35 "Multiple QR codes in image: $num_codes codes"
        log_warning "Possible split-QR evasion technique"
    fi
}

# OCR analysis
analyze_with_ocr() {
    set +u
    local image="${1:-}"
    local base_name="${2:-}"
    set -u
    
    if ! command -v tesseract &> /dev/null; then
        return
    fi
    
    log_info "Running OCR analysis (Tesseract)..."
    local ocr_file="${EVIDENCE_DIR}/${base_name}_ocr.txt"
    
    tesseract "$image" "${ocr_file%.txt}" 2>/dev/null
    
    if [ -s "$ocr_file" ]; then
        log_info "OCR text extracted: $ocr_file"
        log_warning "Text overlay detected via OCR"
    fi
}

# Metadata analysis
analyze_metadata() {
    set +u
    local image="${1:-}"
    local base_name="${2:-}"
    set -u
    
    log_info "Extracting and analyzing metadata..."
    
    if command -v exiftool &> /dev/null; then
        local meta_file="${EVIDENCE_DIR}/${base_name}_metadata.txt"
        exiftool "$image" > "$meta_file" 2>/dev/null
        
        log_success "Metadata extracted: $meta_file"
        
        if grep -qiE "Photoshop|GIMP|edited|modified" "$meta_file"; then
            log_warning "Image appears edited (potential tampering)"
        fi
        
        if grep -qi "GPS Position" "$meta_file"; then
            log_warning "GPS coordinates embedded"
        fi
    fi
}

# Hash computation
compute_hashes() {
    local file="$1"
    local base_name="$2"
    
    log_info "Computing file hashes..."
    
    local hash_file="${EVIDENCE_DIR}/${base_name}_hashes.txt"
    
    {
        echo "=== File Hashes for $file ==="
        echo "MD5:    $(md5sum "$file" 2>/dev/null | awk '{print $1}' || md5 -q "$file" 2>/dev/null)"
        echo "SHA1:   $(sha1sum "$file" 2>/dev/null | awk '{print $1}' || shasum -a 1 "$file" 2>/dev/null | awk '{print $1}')"
        echo "SHA256: $(sha256sum "$file" 2>/dev/null | awk '{print $1}' || shasum -a 256 "$file" 2>/dev/null | awk '{print $1}')"
    } | tee "$hash_file"
}

# VirusTotal file hash check
check_virustotal_file_hash() {
    local hash="$1"
    
    if [ -z "$VT_API_KEY" ]; then
        return
    fi
    
    log_info "Checking VirusTotal file hash: $hash"
    
    local vt_result=$(curl -s --max-time 10 --request GET \
        --url "https://www.virustotal.com/api/v3/files/$hash" \
        --header "x-apikey: $VT_API_KEY" 2>/dev/null)
    
    local malicious=$(echo "$vt_result" | jq -r '.data.attributes.last_analysis_stats.malicious' 2>/dev/null)
    
    if [ "$malicious" != "null" ] && [ "$malicious" != "0" ] && [ -n "$malicious" ]; then
        log_threat 90 "VirusTotal FILE HASH: $malicious engines flagged MALICIOUS"
    fi
}

# URLhaus check
check_urlhaus() {
    local url="$1"
    
    log_info "Checking URLhaus database..."
    
    local urlhaus_response=$(curl -s --max-time 10 -X POST "https://urlhaus-api.abuse.ch/v1/url/" \
        --data "url=$url" 2>/dev/null)
    
    local threat=$(echo "$urlhaus_response" | jq -r '.query_status' 2>/dev/null)
    
    if [ "$threat" = "ok" ]; then
        log_threat 90 "URL found in URLhaus malware database!"
    fi
}

# PhishTank check
check_phishtank() {
    local url="$1"
    
    if [ "$NETWORK_CHECK" = false ] || [ -z "$PHISHTANK_API_KEY" ]; then
        return
    fi
    
    log_info "Checking PhishTank database..."
    
    # AUDIT FIX: Use base64 to safely pass URL to Python
    local encoded_url_input
    encoded_url_input=$(printf '%s' "$url" | base64 2>/dev/null) || return
    local encoded_url=$(python3 - "$encoded_url_input" 2>/dev/null <<'EOF'
import urllib.parse, sys, base64
try:
    url = base64.b64decode(sys.argv[1] if len(sys.argv) > 1 else '').decode('utf-8')
    print(urllib.parse.quote(url))
except:
    pass
EOF
)
    
    local phishtank_response=$(curl -s --max-time 10 -X POST "https://checkurl.phishtank.com/checkurl/" \
        --data "url=${encoded_url}&format=json&app_key=${PHISHTANK_API_KEY}" 2>/dev/null)
    
    local in_database=$(echo "$phishtank_response" | jq -r '.results.in_database' 2>/dev/null)
    local verified=$(echo "$phishtank_response" | jq -r '.results.verified' 2>/dev/null)
    
    if [ "$in_database" = "true" ] && [ "$verified" = "true" ]; then
        log_threat 85 "URL found in PhishTank verified phishing database!"
    fi
}

# OpenPhish direct check
check_openphish_direct() {
    local url="$1"
    
    if [ "$NETWORK_CHECK" = false ]; then
        return
    fi
    
    log_info "Checking OpenPhish feed..."
    
    if curl -sL --max-time 5 "https://openphish.com/feed.txt" 2>/dev/null | grep -qF "$url"; then
        log_threat 85 "URL found in OpenPhish phishing feed!"
    fi
}

# AlienVault OTX domain check
check_alienvault_otx_domain() {
    local domain="$1"
    
    if [ "$NETWORK_CHECK" = false ]; then
        return
    fi
    
    log_info "Checking AlienVault OTX: $domain"
    
    local otx_response=$(curl -s --max-time 10 \
        "https://otx.alienvault.com/api/v1/indicators/domain/${domain}/general" 2>/dev/null)
    
    if [ -n "$otx_response" ]; then
        local pulse_count=$(echo "$otx_response" | jq -r '.pulse_info.count' 2>/dev/null)
        
        if [ "$pulse_count" != "null" ] && [ "$pulse_count" -gt 0 ] 2>/dev/null; then
            log_threat 60 "Domain in $pulse_count AlienVault OTX threat pulses"
        fi
    fi
}

# URL content type analysis
analyze_url_content_type() {
    set +u
    local url="${1:-}"
    set -u
    
    if [ "$NETWORK_CHECK" = false ]; then
        return
    fi
    
    log_info "Checking Content-Type: $url"
    
    local headers=$(curl -sI --max-time 5 "$url" 2>/dev/null)
    local content_type=$(echo "$headers" | grep -i "^Content-Type:" | awk '{print $2}' | tr -d '\r')
    
    if [ -n "$content_type" ]; then
        log_info "  Content-Type: $content_type"
        
        if echo "$content_type" | grep -qiE "application/x-msdownload|application/x-msdos-program|application/exe"; then
            log_threat 70 "CRITICAL: Executable content type"
        fi
        
        if echo "$content_type" | grep -qiE "application/vnd.android.package-archive"; then
            log_threat 65 "CRITICAL: Android APK download"
        fi
        
        if echo "$content_type" | grep -qiE "application/x-apple-aspen-config"; then
            log_threat 60 "CRITICAL: iOS configuration profile"
        fi
    fi
}

# File download and analysis
download_and_analyze_file() {
    local url="$1"
    local content_type="$2"
    
    log_warning "Downloading file for analysis..."
    
    local download_file="${TEMP_DIR}/downloaded_file"
    
    if curl -sL --max-time 15 "$url" -o "$download_file" 2>/dev/null; then
        local file_size=$(stat -c%s "$download_file" 2>/dev/null || stat -f%z "$download_file" 2>/dev/null)
        log_info "Downloaded: $file_size bytes"
        
        local file_type=$(file -b "$download_file")
        log_info "File type: $file_type"
        
        local sha256=$(sha256sum "$download_file" 2>/dev/null | awk '{print $1}' || shasum -a 256 "$download_file" 2>/dev/null | awk '{print $1}')
        log_info "SHA256: $sha256"
        
        if [ "$VT_CHECK" = true ]; then
            check_virustotal_file_hash "$sha256"
        fi
        
        cp "$download_file" "${EVIDENCE_DIR}/downloaded_file_${sha256:0:16}"
    fi
}

# API key detection
analyze_api_keys() {
    set +u
    local content_source="${1:-}"
    set -u
    
    log_info "Scanning for API keys and secrets..."
    
    local content
    if [ -f "$content_source" ]; then
        content=$(cat "$content_source")
    else
        content="$content_source"
    fi
    
    local api_patterns=(
        "AKIA[0-9A-Z]{16}"
        "AIza[0-9A-Za-z\\-_]{35}"
        "sk_live_[0-9a-zA-Z]{24}"
        "sq0atp-[0-9A-Za-z\\-_]{22}"
        "ghp_[0-9a-zA-Z]{36}"
        "glpat-[0-9a-zA-Z\\-]{20}"
    )
    
    for pattern in "${api_patterns[@]}"; do
        local matches=$(echo "$content" | safe_grep_oE "$pattern")
        
        if [ -n "$matches" ]; then
            echo "$matches" | while read -r key; do
                log_threat 50 "POTENTIAL API KEY/SECRET: ${key:0:50}..."
            done
        fi
    done
}

# Calculate entropy
calculate_entropy() {
    local content="$1"
    
    echo "$content" | python3 2>/dev/null <<'EOF'
import math
from collections import Counter
import sys

text = sys.stdin.read()
if not text:
    print(0)
else:
    counter = Counter(text)
    length = len(text)
    entropy = -sum((count/length) * math.log2(count/length) for count in counter.values())
    print(f"{entropy:.2f}")
EOF
}

# Entropy analysis
analyze_entropy() {
    set +u
    local content="${1:-}"
    set -u
    
    local entropy=$(calculate_entropy "$content")
    
    log_info "Content entropy: $entropy bits"
    
    if [ -n "$entropy" ] && (( $(echo "$entropy > 4.5" | bc -l 2>/dev/null || echo "0") )); then
        log_threat 20 "High entropy ($entropy) - possible encrypted/encoded content"
    fi
}

# QR behavior analysis
analyze_qr_behavior() {
    set +u
    local content="${1:-}"
    set -u
    
    log_info "Performing behavioral analysis..."
    
    local behavior_score=0
    
    if echo "$content" | safe_grep_qiE "download.*install|install.*run|run.*execute"; then
        log_threat 30 "Multi-stage attack pattern"
        ((behavior_score += 30))
    fi
    
    if echo "$content" | safe_grep_qiE "login|password|username|credential"; then
        log_threat 25 "Credential harvesting indicators"
        ((behavior_score += 25))
    fi
    
    if echo "$content" | safe_grep_qiE "upload|submit|send|POST"; then
        log_warning "Potential data exfiltration"
        ((behavior_score += 15))
    fi
    
    if echo "$content" | safe_grep_qiE "callback|beacon|checkin|c2|command"; then
        log_threat 40 "C2 communication pattern"
        ((behavior_score += 40))
    fi
    
    if echo "$content" | safe_grep_qiE "startup|autorun|schedule|cron|launchd"; then
        log_threat 35 "Persistence mechanism"
        ((behavior_score += 35))
    fi
    
    if [ $behavior_score -gt 50 ]; then
        log_threat 30 "HIGH behavioral risk: $behavior_score"
    fi
}

# APT indicators check
check_apt_indicators() {
    local content="$1"
    
    log_info "Checking APT indicators..."
    
    if echo "$content" | safe_grep_qiE "pastebin\.com.*raw"; then
        log_threat 40 "Pastebin raw URL (APT C2 staging)"
    fi
    
    if echo "$content" | safe_grep_qiE "github\.com.*\.txt|gitlab\.com.*\.txt"; then
        log_threat 35 "Code repository text file (C2 staging)"
    fi
}

# Obfuscation detection
detect_obfuscation() {
    local content="$1"
    
    log_info "Detecting obfuscation techniques..."
    
    # Base64
    if echo "$content" | safe_grep_qE "^[A-Za-z0-9+/]{40,}={0,2}$"; then
        log_threat 25 "Possible Base64 encoded payload"
        
        local decoded=$(echo "$content" | base64 -d 2>/dev/null)
        if [ -n "$decoded" ]; then
            log_info "Decoded Base64:"
            echo "$decoded" | head -c 200
        fi
    fi
    
    # Hex encoding
    if echo "$content" | safe_grep_qE "^([0-9a-fA-F]{2})+$"; then
        log_threat 25 "Possible hex-encoded payload"
    fi
    
    # URL encoding abuse
    local percent_count=$(echo "$content" | safe_grep_o '%' | wc -l)
    local content_length=${#content}
    
    if [ $content_length -gt 0 ] && [ $(( percent_count * 100 / content_length )) -gt 20 ]; then
        log_threat 20 "Excessive URL encoding (${percent_count} %)"
    fi
    
    detect_xor_encoding "$content"
}

# QR structure analysis
analyze_qr_structure() {
    set +u
    local image="${1:-}"
    local base_name="${2:-}"
    set -u
    
    log_info "Analyzing QR code structure..."
    
    python3 2>/dev/null << EOF
import sys
try:
    from PIL import Image
    from pyzbar.pyzbar import decode, ZBarSymbol

    img = Image.open(image_path)
    codes = decode(img, symbols=[ZBarSymbol.QRCODE])
    
    if not codes:
        print("[!] No QR codes detected")
        sys.exit(0)
    
    for i, code in enumerate(codes):
        print(f"QR Code #{i+1}:")
        print(f"  Type: {code.type}")
        print(f"  Data length: {len(code.data)} bytes")
        print(f"  Position: {code.rect}")
        
        if len(code.data) > 2000:
            print(f"  [!] UNUSUALLY LARGE QR PAYLOAD: {len(code.data)} bytes")
except Exception as e:
    print(f"[ERROR] {e}", file=sys.stderr)
EOF
}

# Comprehensive payload analysis
comprehensive_payload_analysis() {
    local content="$1"
    local image="$2"
    local base_name="$3"
    
    log_info "========================================="
    log_info "COMPREHENSIVE PAYLOAD ANALYSIS"
    log_info "========================================="
    
    log_info "Content length: ${#content} characters"
    
    analyze_charset "$content"
    analyze_entropy "$content"
    analyze_api_keys "$content"
    detect_malware_languages "$content"
    
    if [ "$ML_HEURISTICS" = true ]; then
        ml_style_heuristics "$content"
    fi
    
    analyze_encryption_indicators "$content"
    
    if echo "$content" | safe_grep_qiE "^https?://"; then
        analyze_url_content_type "$content"
    fi
    
    analyze_deep_links "$content"
    analyze_wifi_payload "$content"
    analyze_mobile_config "$content"
    analyze_script_injection "$content"
    analyze_qr_behavior "$content"
    check_apt_indicators "$content"
    detect_obfuscation "$content"
}

# Character set analysis
analyze_charset() {
    set +u
    local content="${1:-}"
    set -u
    
    log_info "Analyzing character set..."
    
    local total=${#content}
    local printable=$(echo "$content" | tr -cd '[:print:]' | wc -c)
    local non_ascii=$(echo "$content" | tr -cd '\200-\377' | wc -c)
    
    if [ $total -gt 0 ]; then
        local printable_pct=$((printable * 100 / total))
        log_info "  Printable: ${printable_pct}%"
        
        if [ $non_ascii -gt 0 ]; then
            log_warning "  Non-ASCII characters: $non_ascii"
        fi
        
        if [ $printable_pct -lt 80 ]; then
            log_threat 20 "Low printable character ratio: ${printable_pct}%"
        fi
    fi
}

# Network indicators analysis
analyze_network_indicators() {
    set +u
    local content="${1:-}"
    set -u
    
    log_forensic "Performing advanced network analysis..."
    
    local ips=$(echo "$content" | safe_grep_oE '\b([0-9]{1,3}\.){3}[0-9]{1,3}\b')
    
    if [ -n "$ips" ]; then
        echo "$ips" | while read -r ip; do
            if [[ "$ip" =~ ^(10\.|172\.(1[6-9]|2[0-9]|3[01])\.|192\.168\.) ]]; then
                log_warning "Private IP address detected: $ip"
            else
                if [ -n "${KNOWN_MALICIOUS_IPS[$ip]}" ]; then
                    log_threat 100 "KNOWN MALICIOUS IP: $ip"
                fi
                check_tor_exit_node "$ip"
                perform_reverse_dns "$ip"
                check_ip_reputation "$ip"
            fi
        done
    fi
    
    local emails=$(echo "$content" | safe_grep_oE '\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b')
    
    if [ -n "$emails" ]; then
        log_info "Email addresses found in payload:"
        echo "$emails" | while read -r email; do
            log_warning "  Email: $email"
            analyze_email_address "$email"
        done
    fi
}

# Tor exit node check
check_tor_exit_node() {
    local ip="$1"
    
    for tor_node in "${TOR_EXIT_INDICATORS[@]}"; do
        if [ "$ip" = "$tor_node" ]; then
            log_threat 60 "TOR EXIT NODE detected: $ip"
            return
        fi
    done
}

# Reverse DNS lookup
perform_reverse_dns() {
    local ip="$1"
    
    if ! command -v dig &> /dev/null || [ "$NETWORK_CHECK" = false ]; then
        return
    fi
    
    log_info "Performing reverse DNS for: $ip"
    
    local hostname=$(dig +short -x "$ip" 2>/dev/null | head -1)
    
    if [ -n "$hostname" ]; then
        log_info "  Hostname: $hostname"
        
        if echo "$hostname" | grep -qiE "malware|phish|spam|bot|c2|hack"; then
            log_threat 40 "Suspicious hostname: $hostname"
        fi
    fi
}

# IP reputation check
check_ip_reputation() {
    local ip="$1"
    
    if [ "$NETWORK_CHECK" = false ]; then
        return
    fi
    
    log_info "Checking IP reputation: $ip"
    
    if [ -n "$ABUSEIPDB_API_KEY" ]; then
        local abuse_response=$(curl -sG --max-time 10 https://api.abuseipdb.com/api/v2/check \
            --data-urlencode "ipAddress=$ip" \
            -H "Key: $ABUSEIPDB_API_KEY" \
            -H "Accept: application/json" 2>/dev/null)
        
        local abuse_score=$(echo "$abuse_response" | jq -r '.data.abuseConfidenceScore' 2>/dev/null)
        
        if [ "$abuse_score" != "null" ] && [ "$abuse_score" -gt 50 ] 2>/dev/null; then
            log_threat 70 "High abuse score for IP $ip: $abuse_score%"
        fi
    fi
}

# Email address analysis
analyze_email_address() {
    set +u
    local email="${1:-}"
    set -u
    local domain=$(echo "$email" | awk -F@ '{print $2}')
    
    log_info "Analyzing email address: $email"
    
    if [ -n "${KNOWN_MALICIOUS_DOMAINS[$domain]}" ]; then
        log_threat 80 "Email from KNOWN MALICIOUS DOMAIN: $domain"
    fi
    
    local disposable_domains=("temp-mail.org" "guerrillamail.com" "10minutemail.com" "mailinator.com")
    
    for disp in "${disposable_domains[@]}"; do
        if [ "$domain" = "$disp" ]; then
            log_warning "Disposable email service detected: $domain"
            break
        fi
    done
}

# Sandbox simulation
simulate_sandbox_analysis() {
    local content="$1"
    
    log_forensic "Simulating sandbox analysis..."
    
    check_sandbox_evasion_techniques "$content"
    check_anti_vm_techniques "$content"
    check_anti_debug_techniques "$content"
    check_time_based_evasion "$content"
}

# Sandbox evasion check
check_sandbox_evasion_techniques() {
    local content="$1"
    
    local evasion_techniques=(
        "Sleep\("
        "GetTickCount"
        "QueryPerformanceCounter"
        "IsDebuggerPresent"
        "NtQueryInformationProcess"
        "GetSystemMetrics"
    )
    
    for technique in "${evasion_techniques[@]}"; do
        if echo "$content" | safe_grep_qiE "$technique"; then
            log_threat 55 "Sandbox evasion technique detected: $technique"
        fi
    done
}

# Anti-VM check
check_anti_vm_techniques() {
    local content="$1"
    
    local vm_indicators=(
        "VMware" "VirtualBox" "VBOX" "QEMU" "Xen" "Hyper-V" "Parallels"
    )
    
    for indicator in "${vm_indicators[@]}"; do
        if echo "$content" | safe_grep_qiE "$indicator"; then
            log_threat 45 "Anti-VM technique detected: $indicator"
        fi
    done
}

# Anti-debug check
check_anti_debug_techniques() {
    local content="$1"
    
    local debug_checks=(
        "IsDebuggerPresent" "CheckRemoteDebuggerPresent" "OutputDebugString"
        "FindWindow.*OLLYDBG" "ptrace"
    )
    
    for check in "${debug_checks[@]}"; do
        if echo "$content" | safe_grep_qiE "$check"; then
            log_threat 50 "Anti-debug technique detected: $check"
        fi
    done
}

# Time-based evasion check
check_time_based_evasion() {
    local content="$1"
    
    if echo "$content" | safe_grep_qiE "sleep.*[0-9]{4,}|timeout.*[0-9]{4,}|delay.*[0-9]{4,}"; then
        log_threat 40 "Time-based evasion detected (long sleep/delay)"
    fi
}

# Mobile config download and analysis
download_and_analyze_mobileconfig() {
    local url="$1"
    local profile_file="${TEMP_DIR}/suspicious_profile.mobileconfig"
    
    log_warning "Downloading mobile config profile..."
    
    if curl -sL --max-time 10 "$url" -o "$profile_file" 2>/dev/null; then
        log_success "Profile downloaded: $profile_file"
        
        if command -v plutil &> /dev/null; then
            plutil -p "$profile_file" > "${profile_file}.txt" 2>/dev/null
            
            if grep -qi "VPN\|Root.*Certificate\|MDM\|SCEP" "${profile_file}.txt"; then
                log_threat 80 "CRITICAL: Dangerous payload (VPN/Root Cert/MDM)"
            fi
        fi
        
        cp "$profile_file" "$EVIDENCE_DIR/"
    fi
}

# Threat feed loaders
load_openphish_feed() {
    if [ "$NETWORK_CHECK" = false ]; then
        return
    fi
    
    log_info "Loading OpenPhish threat feed..."
    local openphish_file="${TEMP_DIR}/openphish_feed.txt"
    
    if curl -sL --max-time 10 "https://openphish.com/feed.txt" -o "$openphish_file" 2>/dev/null; then
        while IFS= read -r url; do
            local domain=$(echo "$url" | awk -F/ '{print $3}')
            [[ -n "$domain" ]] && KNOWN_MALICIOUS_DOMAINS["$domain"]=1
        done < "$openphish_file"
        log_success "OpenPhish feed loaded: $(wc -l < "$openphish_file") entries"
    fi
}

load_abuse_ch_feeds() {
    if [ "$NETWORK_CHECK" = false ]; then
        return
    fi
    
    log_info "Loading Abuse.ch threat feeds..."
    
    local urlhaus_file="${TEMP_DIR}/urlhaus_feed.txt"
    if curl -sL --max-time 10 "https://urlhaus.abuse.ch/downloads/text/" -o "$urlhaus_file" 2>/dev/null; then
        while IFS= read -r line; do
            [[ "$line" =~ ^# ]] && continue
            local domain=$(echo "$line" | awk -F/ '{print $3}')
            [[ -n "$domain" ]] && KNOWN_MALICIOUS_DOMAINS["$domain"]=1
        done < "$urlhaus_file"
        log_success "URLhaus feed loaded"
    fi
}

load_alienvault_otx() {
    if [ "$NETWORK_CHECK" = false ]; then
        return
    fi
    
    log_info "Loading AlienVault OTX indicators..."
    log_warning "AlienVault OTX integration requires API key (use OTX_API_KEY env var)"
}

load_misp_feeds() {
    log_info "Loading MISP feeds..."
    log_warning "MISP integration pending API configuration"
}

load_talos_intelligence() {
    if [ "$NETWORK_CHECK" = false ]; then
        return
    fi
    
    log_info "Loading Cisco Talos Intelligence..."
    log_warning "Talos Intelligence integration pending"
}

# Generate threat assessment
generate_threat_assessment() {
    log_info "Generating threat assessment..."
    
    echo ""
    echo "═══════════════════════════════════════════════════════════════"
    echo "                    THREAT ASSESSMENT SUMMARY"
    echo "═══════════════════════════════════════════════════════════════"
    echo ""
    echo "Total Threat Score: ${THREAT_SCORE}"
    echo ""
    
    if [ $THREAT_SCORE -ge 200 ]; then
        echo -e "${RED}[CRITICAL]${NC} Extremely high threat level - Immediate action required"
    elif [ $THREAT_SCORE -ge 100 ]; then
        echo -e "${RED}[HIGH]${NC} High threat level - Investigation recommended"
    elif [ $THREAT_SCORE -ge 50 ]; then
        echo -e "${YELLOW}[MEDIUM]${NC} Medium threat level - Review findings"
    elif [ $THREAT_SCORE -ge 20 ]; then
        echo -e "${BLUE}[LOW]${NC} Low threat level - Monitor"
    else
        echo -e "${GREEN}[MINIMAL]${NC} Minimal threat indicators detected"
    fi
}

# Generate threat correlation
generate_threat_correlation() {
    log_info "Generating threat correlation report..."
    
    {
        echo "═══════════════════════════════════════════════════════════════"
        echo "                 THREAT CORRELATION ANALYSIS"
        echo "═══════════════════════════════════════════════════════════════"
        echo ""
        echo "Timestamp: $(date -Iseconds)"
        echo "Total IOCs: $(wc -l < "$IOC_REPORT" 2>/dev/null || echo 0)"
        echo ""
    } >> "$REPORT_FILE"
}

# Generate threat hunting queries
generate_threat_hunting_queries() {
    log_info "Generating threat hunting queries..."
    
    local queries_file="${OUTPUT_DIR}/threat_hunting_queries.txt"
    
    {
        echo "═══════════════════════════════════════════════════════════════"
        echo "                  THREAT HUNTING QUERIES"
        echo "═══════════════════════════════════════════════════════════════"
        echo ""
        echo "Splunk Queries:"
        echo "  index=proxy_logs url=*$(grep -oE 'https?://[^/]+' "$IOC_REPORT" 2>/dev/null | head -1 || echo "suspicious.domain")*"
        echo ""
        echo "Elastic/ELK Queries:"
        echo "  url.domain: \"suspicious.domain\""
        echo ""
    } > "$queries_file"
    
    log_success "Threat hunting queries saved: $queries_file"
}

# Generate YARA rules file
generate_yara_rules_file() {
    log_info "Generating YARA rules..."
    
    local yara_file="${OUTPUT_DIR}/generated_rules.yara"
    
    {
        echo "// Auto-generated YARA rules from QR analysis"
        echo "// Generated: $(date -Iseconds)"
        echo ""
        echo "rule QR_Malicious_URL {"
        echo "    meta:"
        echo "        description = \"Detects malicious URLs from QR code analysis\""
        echo "        generated = \"$(date -Iseconds)\""
        echo "    strings:"
        echo "        \$url1 = \"http\" nocase"
        echo "        \$suspicious = \"malware\" nocase"
        echo "    condition:"
        echo "        any of them"
        echo "}"
    } > "$yara_file"
    
    log_success "YARA rules saved: $yara_file"
}

# Generate individual report for each image
generate_individual_report() {
    local image="$1"
    local content="$2"
    local base_name="$3"
    
    local report="${EVIDENCE_DIR}/${base_name}_report.txt"
    
    {
        echo "========================================="
        echo "QR CODE ANALYSIS REPORT"
        echo "========================================="
        echo "Generated: $(date)"
        echo "Scanner Version: $VERSION"
        echo "Image: $image"
        echo "Threat Score: $THREAT_SCORE / $MAX_THREAT_SCORE"
        echo ""
        echo "DECODED CONTENT:"
        echo "----------------------------------------"
        echo "$content"
        echo ""
        echo "========================================="
    } > "$report"
    
    log_success "Individual report saved: $report"
}

# Generate summary report
generate_summary_report() {
    log_info ""
    log_info "========================================="
    log_info "GENERATING SUMMARY REPORT"
    log_info "========================================="
    
    {
        echo "╔══════════════════════════════════════════════════════════════╗"
        echo "║   QR CODE MALWARE DETECTION - ULTIMATE EDITION SUMMARY       ║"
        echo "╠══════════════════════════════════════════════════════════════╣"
        echo "║ Scan Date: $(date)                                           "
        echo "║ Scanner Version: $VERSION                                    "
        echo "║ Output Directory: $OUTPUT_DIR                                "
        echo "╚══════════════════════════════════════════════════════════════╝"
        echo ""
        echo "SCAN STATISTICS:"
        echo "  - Total images analyzed: $(find "$OUTPUT_DIR" -name "*_report.txt" 2>/dev/null | wc -l)"
        echo "  - Evidence files collected: $(find "$EVIDENCE_DIR" -type f 2>/dev/null | wc -l)"
        echo "  - IOCs detected: $(wc -l < "$IOC_REPORT" 2>/dev/null || echo 0)"
        echo "  - Threat intelligence sources: ${#KNOWN_MALICIOUS_DOMAINS[@]} domains, ${#KNOWN_MALICIOUS_IPS[@]} IPs"
        echo ""
        echo "OUTPUT FILES:"
        echo "  - Main report: $REPORT_FILE"
        echo "  - JSON report: $JSON_REPORT"
        echo "  - IOC report: $IOC_REPORT"
        echo "  - Log file: $LOG_FILE"
        echo "  - Evidence directory: $EVIDENCE_DIR"
        echo ""
        echo "DETECTION CAPABILITIES:"
        echo "  - QR Decoders: zbar, pyzbar, quirc, zxing, qrdecode, opencv, qreader, pyzxing"
        echo "  - Steganography: steghide, zsteg, stegdetect, LSB analysis"
        echo "  - Language Detection: PowerShell, Python, JS, Bash, VBS, Perl, Ruby"
        echo "  - Threat Intel: OpenPhish, URLhaus, SSL BL, Feodo, PhishTank, OTX"
        echo "  - Heuristics: ML-style, XOR detection, entropy analysis"
        echo "  - IOC Database: $(( ${#KNOWN_MALICIOUS_DOMAINS[@]:-0} + ${#KNOWN_MALICIOUS_IPS[@]:-0} + ${#KNOWN_CRYPTO_SCAM_ADDRESSES[@]:-0} )) indicators"
        echo ""
        echo "========================================="
    } | tee -a "$REPORT_FILE"
    
    log_success "Summary report generation complete"
}

################################################################################
# MAIN FUNCTION
################################################################################

main() {
    local start_time=$SECONDS
    
    # Parse command line arguments
    parse_arguments "$@"
    
    # AUDIT: Check for root user warning
    if [[ "$(id -u)" == "0" ]]; then
        echo -e "${YELLOW}[WARNING] Running as root is not recommended unless absolutely necessary${NC}"
        echo -e "${YELLOW}[WARNING] Consider running as a non-privileged user${NC}"
        sleep 2
    fi
    
    # Initialize
    initialize
    
    # NEW: Configuration & hardening checks
    check_script_integrity
    verify_dependency_hashes
    check_sandbox_environment
    validate_api_key_formats
    rotate_api_keys
    check_rate_limits
    check_disk_space
    validate_network_connectivity
    check_dns_resolver
    
    # Check dependencies
    check_dependencies
    
    # Initialize YARA rules
    init_yara_rules
    init_extended_yara_rules
    
    # Load threat intelligence
    load_threat_intelligence
    
    # Determine target path
    local target_path="${TARGET_PATH:-.}"
    
    # AUDIT: Validate target path
    target_path=$(sanitize_path "$target_path") || {
        log_error "Invalid target path"
        exit 1
    }
    
    if [ ! -e "$target_path" ]; then
        log_error "Path does not exist: $target_path"
        exit 1
    fi
    
    # Collect images to analyze
    local images=()
    
    if [ -f "$target_path" ]; then
        # Single file
        images=("$target_path")
    elif [ -d "$target_path" ]; then
        # Directory - find all image files
        while IFS= read -r -d '' file; do
            images+=("$file")
        done < <(find "$target_path" -type f \( \
            -iname "*.png" -o \
            -iname "*.jpg" -o \
            -iname "*.jpeg" -o \
            -iname "*.gif" -o \
            -iname "*.bmp" -o \
            -iname "*.webp" -o \
            -iname "*.tiff" -o \
            -iname "*.tif" \
        \) -print0 2>/dev/null)
    fi
    
    if [ ${#images[@]} -eq 0 ]; then
        log_error "No images found to analyze"
        exit 1
    fi
    
    log_info "Found ${#images[@]} image(s) to analyze"
    echo ""
    
    # Analyze each image
    for image in "${images[@]}"; do
        analyze_qr_image "$image"
        
        # Adversarial QR analysis on image
        if [ "$ADVERSARIAL_QR_CHECK" = true ]; then
            analyze_adversarial_qr "$image"
        fi
        echo ""
    done
    
    # Generate reports
    generate_ioc_summary
    generate_forensic_timeline
    generate_comprehensive_report
    generate_json_report
    generate_stix_report
    
    # SIEM Integration Export
    if [ "$SIEM_INTEGRATION" = true ]; then
        generate_siem_export
        log_info "SIEM export generated: $SIEM_EXPORT_FILE"
    fi
    
    # AUDIT: Finalize chain of custody
    record_custody_action "SCAN_COMPLETED" "Analysis completed with threat score: $THREAT_SCORE"
    
    # Calculate duration
    local duration=$((SECONDS - start_time))
    
    # Count IOCs detected
    local ioc_count=$(wc -l < "$IOC_REPORT" 2>/dev/null | tr -d ' ' || echo "0")
    ((ioc_count--)) # Subtract header line
    [ $ioc_count -lt 0 ] && ioc_count=0
    
    # Print final summary
    echo ""
    log_success "════════════════════════════════════════════════════════════"
    log_success "ANALYSIS COMPLETE!"
    log_success "════════════════════════════════════════════════════════════"
    echo ""
    
    # Forensics Summary
    echo -e "${CYAN}┌─────────────────────────────────────────────────────────────┐${NC}"
    echo -e "${CYAN}│                    FORENSIC SUMMARY                          │${NC}"
    echo -e "${CYAN}├─────────────────────────────────────────────────────────────┤${NC}"
    echo -e "${CYAN}│${NC} Analysis Duration:    ${WHITE}${duration} seconds${NC}"
    echo -e "${CYAN}│${NC} Threat Score:         ${WHITE}${THREAT_SCORE}/${MAX_THREAT_SCORE}${NC}"
    echo -e "${CYAN}│${NC} IOCs Detected:        ${WHITE}${ioc_count}${NC}"
    echo -e "${CYAN}│${NC} Images Analyzed:      ${WHITE}${#images[@]}${NC}"
    echo -e "${CYAN}│${NC} IOC Sources Loaded:   ${WHITE}${#LOADED_IOC_SOURCES[@]}${NC}"
    echo -e "${CYAN}│${NC} Additional IOCs:      ${WHITE}${IOC_LOAD_COUNT}${NC}"
    echo -e "${CYAN}│${NC} Script Hash:          ${WHITE}${SCRIPT_HASH:0:16}...${NC}"
    echo -e "${CYAN}└─────────────────────────────────────────────────────────────┘${NC}"
    echo ""
    
    # Threat Level Indicator
    echo -e "${WHITE}THREAT ASSESSMENT:${NC}"
    if [ $THREAT_SCORE -ge $CRITICAL_THRESHOLD ]; then
        # GRANULAR OUTPUT RESTORED: Classic Paste A critical threat format
        log_critical "⚠️  CRITICAL THREAT LEVEL - Immediate action required!"
        echo -e "${RED}╔═════════════════════════════════════════════════════════════╗${NC}"
        echo -e "${RED}║  ████  CRITICAL THREAT LEVEL  ████                          ║${NC}"
        echo -e "${RED}║  Score: $THREAT_SCORE - IMMEDIATE ACTION REQUIRED             ${NC}"
        echo -e "${RED}╚═════════════════════════════════════════════════════════════╝${NC}"
        echo ""
        echo -e "${RED}RECOMMENDED ACTIONS:${NC}"
        echo "  1. DO NOT open any URLs from this QR code"
        echo "  2. Report to security team immediately"
        echo "  3. Preserve all evidence in the output directory"
        echo "  4. Check IOC report for indicators to block"
        echo "  5. Consider forensic investigation of the QR source"
    elif [ $THREAT_SCORE -ge $HIGH_THRESHOLD ]; then
        # GRANULAR OUTPUT RESTORED: Classic Paste A format for high threat level
        log_warning "▲▲▲  HIGH THREAT LEVEL - Exercise extreme caution!"
        echo -e "${RED}╔═════════════════════════════════════════════════════════════╗${NC}"
        echo -e "${RED}║  ▲▲▲  HIGH THREAT LEVEL  ▲▲▲                                ║${NC}"
        echo -e "${RED}║  Score: $THREAT_SCORE - EXERCISE EXTREME CAUTION               ${NC}"
        echo -e "${RED}╚═════════════════════════════════════════════════════════════╝${NC}"
        echo ""
        echo -e "${YELLOW}RECOMMENDED ACTIONS:${NC}"
        echo "  1. Avoid interacting with the decoded content"
        echo "  2. Review the detailed analysis report"
        echo "  3. Cross-reference IOCs with threat intelligence"
    elif [ $THREAT_SCORE -ge $MEDIUM_THRESHOLD ]; then
        echo -e "${YELLOW}╔═════════════════════════════════════════════════════════════╗${NC}"
        echo -e "${YELLOW}║  ⚡ MEDIUM THREAT LEVEL                                     ║${NC}"
        echo -e "${YELLOW}║  Score: $THREAT_SCORE - REVIEW FINDINGS CAREFULLY              ${NC}"
        echo -e "${YELLOW}╚═════════════════════════════════════════════════════════════╝${NC}"
    elif [ $THREAT_SCORE -ge $LOW_THRESHOLD ]; then
        echo -e "${BLUE}╔═════════════════════════════════════════════════════════════╗${NC}"
        echo -e "${BLUE}║  ℹ️  LOW THREAT LEVEL                                        ║${NC}"
        echo -e "${BLUE}║  Score: $THREAT_SCORE - Minor concerns detected                 ${NC}"
        echo -e "${BLUE}╚═════════════════════════════════════════════════════════════╝${NC}"
    else
        echo -e "${GREEN}╔═════════════════════════════════════════════════════════════╗${NC}"
        echo -e "${GREEN}║  ✓ MINIMAL THREAT LEVEL                                     ║${NC}"
        echo -e "${GREEN}║  Score: $THREAT_SCORE - No significant threats detected        ${NC}"
        echo -e "${GREEN}╚═════════════════════════════════════════════════════════════╝${NC}"
    fi
    echo ""
    
    # Output Files
    echo -e "${WHITE}OUTPUT FILES:${NC}"
    echo "  ├─ Main Report:     $REPORT_FILE"
    echo "  ├─ JSON Report:     $JSON_REPORT"
    echo "  ├─ IOC Report:      $IOC_REPORT (${ioc_count} indicators)"
    echo "  ├─ Timeline:        $TIMELINE_FILE"
    echo "  ├─ STIX Report:     $STIX_REPORT"
    echo "  ├─ Chain of Custody: $CHAIN_OF_CUSTODY_FILE"
    if [ -f "${OUTPUT_DIR}/offensive_tools_analysis.txt" ]; then
        echo "  ├─ Offensive Tools: ${OUTPUT_DIR}/offensive_tools_analysis.txt"
    fi
    if [ -f "${OUTPUT_DIR}/service_abuse_analysis.txt" ]; then
        echo "  ├─ Service Abuse:   ${OUTPUT_DIR}/service_abuse_analysis.txt"
    fi
    echo "  └─ Evidence:        $EVIDENCE_DIR"
    
    if [ "$SIEM_INTEGRATION" = true ]; then
        echo "  └─ SIEM Export:     $SIEM_EXPORT_FILE"
    fi
    echo ""
    
    # AUDIT: Display IOC database information in report
    if [ ${#LOADED_IOC_SOURCES[@]} -gt 0 ]; then
        echo -e "${WHITE}IOC DATABASES LOADED:${NC}"
        for src in "${LOADED_IOC_SOURCES[@]}"; do
            echo "  ├─ $src"
        done
        echo "  └─ Total patterns: $IOC_LOAD_COUNT"
        echo ""
    fi
}

# Run main function
# AUDIT: Enable strict undefined variable checking now that all declarations are done
set -u

main "$@"
